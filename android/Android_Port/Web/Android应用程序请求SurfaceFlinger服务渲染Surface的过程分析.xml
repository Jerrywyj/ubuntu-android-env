<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" title="XSL Formatting" href="/rss.xsl" media="all" ?>
<rss version="2.0">
<channel>
    <title>老罗的Android之旅</title>
    <image>
    <link>http://blog.csdn.net</link>
    <url>http://static.blog.csdn.net/images/logo.gif</url>
    </image>
    <description>爱生活，爱Android</description>
	<link>http://blog.csdn.net/luoshengyang</link>
	<language>zh-cn</language>
	<generator>http://blog.csdn.net</generator>
	<ttl>5</ttl>
	<copyright><![CDATA[Copyright &copy; Luoshengyang]]></copyright> 
	<pubDate>2013-2-4 16:01:01</pubDate>
    <item>
        <title><![CDATA[[原]Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/7932268</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/7932268</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-9-17 0:56:30</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面一篇文章中，我们分析了</span><span style="color:black;">Android</span><span style="color:black;">应用程序请求</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务创建</span><span style="color:black;">Surface</span><span style="color:black;">的过程。有了</span><span style="color:black;">Surface</span><span style="color:black;">之后，</span><span style="color:black;">Android</span><span style="color:black;">应用程序就可以在上面绘制自己的</span><span style="color:black;">UI</span><span style="color:black;">了，接着再请求</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务将这个已经绘制好了</span><span style="color:black;">UI</span><span style="color:black;">的</span><span style="color:black;">Surface</span><span style="color:black;">渲染到设备显示屏上去。在本文中，我们就将详细分析</span><span style="color:black;">Android</span><span style="color:black;">应用程序请求</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务渲染</span><span style="color:black;">Surface</span><span style="color:black;">的过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black; ">Android应用程序在请求<span style="color: black; ">SurfaceFlinger</span><span style="color: black; ">服务渲染一个</span><span style="color: black; ">Surface之前，首先要</span></span></span>将该Surface作为当前活动的绘图上下文，以便可以使用OpengGL库或者其它库的API来在上面绘制UI，我们以Android系统的开机动画应用程序bootanim为例，来说明这个问题。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文可以知道，Android系统的开机动画应用程序bootanim是在BootAnimation类的成员函数readyToRun中请求SurfaceFlinger服务创建Surface的。这个Surface创建完成之后，就会被设置为当前活动的绘图上下文，如下所示：</p><p></p><pre name="code" class="cpp">status_t BootAnimation::readyToRun() {
    ......

    // create the native surface
    sp&lt;SurfaceControl&gt; control = session()-&gt;createSurface(
            getpid(), 0, dinfo.w, dinfo.h, PIXEL_FORMAT_RGB_565);
    ......

    sp&lt;Surface&gt; s = control-&gt;getSurface();
    ......

    // initialize opengl and egl
    const EGLint attribs[] = {
            EGL_DEPTH_SIZE, 0,
            EGL_NONE
    };
    ......

    EGLConfig config;
    EGLSurface surface;
    EGLContext context;

    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);

    eglInitialize(display, 0, 0);
    EGLUtils::selectConfigForNativeWindow(display, attribs, s.get(), &amp;config);
    surface = eglCreateWindowSurface(display, config, s.get(), NULL);
    context = eglCreateContext(display, config, NULL, NULL);
    ......

    if (eglMakeCurrent(display, surface, surface, context) == EGL_FALSE)
        return NO_INIT;

    ......
}</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; BootAnimation类的成员函数readyToRun首先调用eglGetDisplay和eglInitialize函数来获得和初始化OpengGL库的默认显示屏，接着再调用EGLUtils::selectConfigForNativeWindow函数来获得前面所创建的一个Surface（由sp&lt;Surface&gt;指针s来描述）的配置信息。有了这些信息之后，接下来就分别调用eglCreateWindowSurface和eglCreateContext函数来创建一个适用于OpenGL库使用的绘图表面surface以及绘图上下文context，最后就可以调用eglMakeCurrent函数来将绘图表面surface和绘图上下文context设置为当前活动的绘图表面和绘图上下文，这就相当于是将前面请求SurfaceFlinger服务创建的一个Surface设置为当前活动的缓图上下文了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 完成了上述操作之后，Android系统的开机动画应用程序bootanim就可以继续使用OpengGL库的其它API来在当前活动的Surface上绘制UI了，不过，通过前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文的学习，我们知道，此时SurfaceFlinger服务为Android应用程序创建的Surface只有UI元数据缓冲区，而没有UI数据缓冲区，即还没有图形缓冲区，换句来说，就是还没有可以用来绘制UI的载体。那么，这些用来绘制UI的图形缓冲区是什么时候创建的呢？</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>一文可以知道，每一个Surface都有一个对应的UI元数据缓冲区堆栈，这个UI元数据缓冲区堆栈是使用一个SharedBufferStack来描述的，如图1所示。</p><p></p><p style="text-align: center;">&nbsp;<img src="http://my.csdn.net/uploads/201208/11/1344640651_6649.jpg" alt="" /></p><p style="text-align: center;">图1 SharedBufferStack的结构示意图</p><br /><p>&nbsp;&nbsp; &nbsp; &nbsp; 从图1就可以看出，每一个UI元数据缓冲区都可能对应有一个UI数据缓冲区，这个UI数据缓冲区又可以称为图形缓冲区，它使用一个GraphicBuffer对象来描述。注意，一个UI元数据缓冲区只有第一次被使用时，Android应用程序才会为它创建一个图形缓冲区，因此，我们才说每一个UI元数据缓冲区都可能对应有一个UI数据缓冲区。例如，在图1中，目前只使到了编号为1和2的UI元数据缓冲区，因此，只有它们才有对应的图形缓冲区，而编号为3、4和5的UI元数据缓冲区没有。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Android应用程序渲染一个Surface的过程大致如下所示：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. 从UI元数据缓冲区堆栈中得到一个空闲的UI元数据缓冲区；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. 请求SurfaceFlinger服务为这个空闲的UI元数据缓冲区分配一个图形缓冲区；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 3. 在图形缓冲区上面绘制好UI之后，即填充好UI数据之后，就将前面得到的空闲UI元数据缓冲区添加到UI元数据缓冲区堆栈中的待渲染队列中去；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 4. 请求SurfaceFlinger服务渲染前面已经准备好了图形缓冲区的Surface；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 5. SurfaceFlinger服务从即将要渲染的Surface的UI元数据缓冲区堆栈的待渲染队列中找到待渲染的UI元数据缓冲区；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 6.&nbsp;SurfaceFlinger服务得到了待渲染的UI元数据缓冲区之后，接着再找到在前面第2步为它所分配的图形缓冲区，最后就可以将这个图形缓冲区渲染到设备显示屏上去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个过程的第1步、第3步和第5步涉到UI元数据缓冲区堆栈的一些出入栈操作，为了方便后面描述Android应用程序请求SurfaceFlinger服务渲染Surface的过程，我们首先介绍一下UI元数据缓冲区堆栈的一些出入栈操作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文中，我们分析了用来描述UI元数据缓冲区堆栈的SharedBufferServer和SharedBufferClient类的父类SharedBufferBase，它有一个成员函数waitForCondition，用来等待一个条件得到满足，它定义在文件frameworks/base/include/private/surfaceflinger/SharedBufferStack.h中，如下所示：</p><p></p><pre name="code" class="cpp">class SharedBufferBase
{
    ......

protected:
    ......

    struct ConditionBase {
        SharedBufferStack&amp; stack;
        inline ConditionBase(SharedBufferBase* sbc)
            : stack(*sbc-&gt;mSharedStack) { }
        virtual ~ConditionBase() { };
        virtual bool operator()() const = 0;
        virtual const char* name() const = 0;
    };
    status_t waitForCondition(const ConditionBase&amp; condition);

    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp;SharedBufferBase类的成员函数waitForCondition只有一个参数condition，它的类型为ConditionBase，用来描述一个需要等待满足的条件。ConditionBase类是一个抽象类，我们需要以它来为父类，来实现一个自定义的条件，并且重写操作符号()和成员函数name。接下来，我们分析SharedBufferBase类的成员函数waitForCondition的实现，接着再分析ConditionBase类的一个子类的实现。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;SharedBufferBase类的成员函数waitForCondition实现在文件frameworks/base/libs/surfaceflinger_client/SharedBufferStack.cpp文件中，如下所示：</p><p></p><pre name="code" class="cpp">status_t SharedBufferBase::waitForCondition(const ConditionBase&amp; condition)
{
    const SharedBufferStack&amp; stack( *mSharedStack );
    SharedClient&amp; client( *mSharedClient );
    const nsecs_t TIMEOUT = s2ns(1);
    const int identity = mIdentity;

    Mutex::Autolock _l(client.lock);
    while ((condition()==false) &amp;&amp;
            (stack.identity == identity) &amp;&amp;
            (stack.status == NO_ERROR))
    {
        status_t err = client.cv.waitRelative(client.lock, TIMEOUT);
        // handle errors and timeouts
        if (CC_UNLIKELY(err != NO_ERROR)) {
            if (err == TIMED_OUT) {
                if (condition()) {
                    LOGE(&quot;waitForCondition(%s) timed out (identity=%d), &quot;
                        &quot;but condition is true! We recovered but it &quot;
                        &quot;shouldn't happen.&quot; , condition.name(), stack.identity);
                    break;
                } else {
                    LOGW(&quot;waitForCondition(%s) timed out &quot;
                        &quot;(identity=%d, status=%d). &quot;
                        &quot;CPU may be pegged. trying again.&quot;, condition.name(),
                        stack.identity, stack.status);
                }
            } else {
                LOGE(&quot;waitForCondition(%s) error (%s) &quot;,
                        condition.name(), strerror(-err));
                return err;
            }
        }
    }
    return (stack.identity != mIdentity) ? status_t(BAD_INDEX) : stack.status;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;SharedBufferBase类的成员变量mSharedStack指向了一个SharedBufferStack对象，即一个UI元数据缓冲区堆栈，另外一个成员变量mSharedClient指向了当前应用程序进程的一个SharedClient单例。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;SharedClient类有一个类型为Condition的成员变量cv，用来描述一个条件变量，同时，SharedClient类还有一个类型为Mutex的成员变量lock，用来描述一个互斥锁。通过调用一个Condition对象的成员函数waitRelative，就可以在指定的时间内等待一个互斥锁变为可用。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;SharedBufferBase类的成员函数waitForCondition中的while循环的作用是循环等待一个UI元数据缓冲区堆栈满足某一个条件，这个条件是通过参数condition来描述的。当调用参数condition所描述的一个CondtitionBase对象的重载操作符号()的返回值等于true的时候，就表示所要等待的条件得到满足了，这时候函数就会停止执行中间的while循环语句。另一方面，当调用参数condition所描述的一个CondtitionBase对象的重载操作符号()的返回值等于flase的时候，就表示所要等待的条件还没有得到满足，这时候函数就会继续执中间的while循环，直到所要等待的条件得到满足为止。等待的操作是通过调用下面这个语句来完成的：</p><p></p><pre name="code" class="cpp">status_t err = client.cv.waitRelative(client.lock, TIMEOUT);</pre>&nbsp;&nbsp; &nbsp; &nbsp;即调用当前应用程序进程的SharedClient单例client的成员变量cv所描述的一个条件变量的成员函数waitRelative来完成，并且指定要等待的互斥锁为当前应用程序进程的SharedClient单例client的成员变量lock所描述的一个互斥锁，以及指定等待的时间为TIMEOUT，即1秒。如果在1秒内，当前应用程序进程的SharedClient单例client的成员变量lock所描述的一个互斥锁还是不可用，那么上述等待操作就会超时，然后导致重新执行外层的while循环，否则的话，等待操作就完成了。<p></p><p>&nbsp;&nbsp; &nbsp; 在SharedBufferClient类中，定义了一个ConditionBase子类DequeueCondition，用来描述一个UI元数据缓冲区堆栈是否有空闲的缓冲区可以出栈，它定义在文件frameworks/base/include/private/surfaceflinger/SharedBufferStack.h中，如下所示：</p><p></p><pre name="code" class="cpp">class SharedBufferClient : public SharedBufferBase
{
    ......

private:
    ......

    struct DequeueCondition : public ConditionBase {
        inline DequeueCondition(SharedBufferClient* sbc);
        inline bool operator()() const;
        inline const char* name() const { return &quot;DequeueCondition&quot;; }
    };
 
    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;一个UI元数据缓冲区堆栈是否有空闲的缓冲区可以出栈是由DequeueCondition类的重载操作符号()来决定的，它实现在文件frameworks/base/libs/surfaceflinger_client/SharedBufferStack.cpp文件中，如下所示：<p></p><p></p><pre name="code" class="cpp">bool SharedBufferClient::DequeueCondition::operator()() const {
    return stack.available &gt; 0;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DequeueCondition类的成员变量stack是从父类ConditionBase继承下来的，它指向了一个SharedBufferStack对象，即用来描述一个UI元数据缓冲区堆栈。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>一文可以知道，当一个SharedBufferStack对象的成员变量available的值大于0的时候，就说明它所描述的UI元数据缓冲区堆栈有空闲的缓冲区可以使用，因此，这时候DequeueCondition类的重载操作符号()的返回值就等于true，表示一个UI元数据缓冲区堆栈有空闲的缓冲区可以出栈。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SharedBufferBase类还有一个成员函数updateCondition，用来操作一个UI元数据缓冲区堆栈，例如，执行一个UI元数据缓冲区的出入栈操作。这个成员函数定义和实现在文件rameworks/base/include/private/surfaceflinger/SharedBufferStack.h中，如下所示：</p><p></p><pre name="code" class="cpp">class SharedBufferBase
{
    ......

protected:
    ......

    struct UpdateBase {
        SharedBufferStack&amp; stack;
        inline UpdateBase(SharedBufferBase* sbb)
            : stack(*sbb-&gt;mSharedStack) { }
    };
    template &lt;typename T&gt;
    status_t updateCondition(T update);
};

template &lt;typename T&gt;
status_t SharedBufferBase::updateCondition(T update) {
    SharedClient&amp; client( *mSharedClient );
    Mutex::Autolock _l(client.lock);
    ssize_t result = update();
    client.cv.broadcast();
    return result;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SharedBufferBase类的成员函数updateCondition是一个模板函数，它过调用参数T的重载操作符号()来实现一个具体的UI元数据缓冲区堆栈操作。这个参数T必须要从基类UpdateBase继承下来，并且重载操作符号()。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SharedBufferBase类的成员函数updateCondition执行完成一个UI元数据缓冲区堆栈操作之后，还会调用当前应用进程的SharedClient单例client的成员变量cv所描述的一个条件变量的成员函数broadcast，用来唤醒那些在当前应用进程的SharedClient单例client的成员变量lock所描述的一个互斥锁上等待的其它线程，以便它们可以继续执行自己的操作，这样，SharedBufferBase类的成员函数updateCondition就可以和前面介绍的成员函数waitCondition对应起来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就分别分析UpdateBase的三个子类QueueUpdate、DequeueUpdate和RetireUpdate。QueueUpdate和DequeueUpdate两个子类是Android应用程序这一侧使用的，前者用来向一个UI元数据缓冲区堆栈的待渲染队列增加一个缓冲区，而后者用来从一个UI元数据缓冲区堆栈出栈一个空闲的缓冲区。RetireUpdate类是在SurfaceFlinger服务这一侧使用的，用来从一个UI元数据缓冲区堆栈的待渲染队列出栈一个缓冲区，以便可以将与它所对应的图形缓冲区渲染到设备显示屏去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;QueueUpdate类定义在文件frameworks/base/include/private/surfaceflinger/SharedBufferStack.h中，如下所示：<br /></p><pre name="code" class="cpp">class SharedBufferClient : public SharedBufferBase
{
    ......

private:
    ......

    struct QueueUpdate : public UpdateBase {
        inline QueueUpdate(SharedBufferBase* sbb);
        inline ssize_t operator()();
    };

    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;它的重载操作符号()实现在文件frameworks/base/libs/surfaceflinger_client/SharedBufferStack.cpp文件中，如下所示：<p></p><p></p><pre name="code" class="cpp">ssize_t SharedBufferClient::QueueUpdate::operator()() {
    android_atomic_inc(&amp;stack.queued);
    return NO_ERROR;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;QueueUpdate类的成员变量stack是从父类UpdateBase继承下来的，它指向了一个SharedBufferStack对象，用来描述当前要操作的UI元数据缓冲区堆栈。从前面的图1可以知道，当我们将一个SharedBufferStack对象的成员变量queued的值增加1的时候，就表示这个SharedBufferStack对象所描述的UI元数据缓冲区堆栈的待渲染队列的大小增加了1。不过，在执行这个操作之前，我们还需要将用来这个待渲染队列头queue_head往前移动一个位置。后面在分析Surface的渲染过程时，我们再详细分析。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DequeueUpdate类定义在文件frameworks/base/include/private/surfaceflinger/SharedBufferStack.h中，如下所示：</p><p></p><pre name="code" class="cpp">class SharedBufferClient : public SharedBufferBase
{
    ......

private:
    ......

    struct DequeueUpdate : public UpdateBase {
        inline DequeueUpdate(SharedBufferBase* sbb);
        inline ssize_t operator()();
    };

    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;它的重载操作符号()实现在文件frameworks/base/libs/surfaceflinger_client/SharedBufferStack.cpp文件中，如下所示：<p></p><p></p><pre name="code" class="cpp">ssize_t SharedBufferClient::DequeueUpdate::operator()() {
    if (android_atomic_dec(&amp;stack.available) == 0) {
        LOGW(&quot;dequeue probably called from multiple threads!&quot;);
    }
    return NO_ERROR;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; DequeueUpdate类的成员变量stack是从父类UpdateBase继承下来的，它指向了一个SharedBufferStack对象，用来描述当前要操作的UI元数据缓冲区堆栈。从前面的图1可以知道，当我们将一个SharedBufferStack对象的成员变量available的值减少1的时候，就表示这个SharedBufferStack对象所描述的UI元数据缓冲区堆栈的空闲缓冲区的大小就减少了1。不过，在执行这个操作之前，我们还需要将用来这个UI元数据缓冲区堆栈尾tail往前移动一个位置。后面在分析Surface的渲染过程时，我们再详细分析。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; RetireUpdate类定义在文件frameworks/base/include/private/surfaceflinger/SharedBufferStack.h中，如下所示：<br /></p><pre name="code" class="cpp">class SharedBufferServer
    : public SharedBufferBase,
      public LightRefBase&lt;SharedBufferServer&gt;
{
    ......

private:
    ......

    struct RetireUpdate : public UpdateBase {
        const int numBuffers;
        inline RetireUpdate(SharedBufferBase* sbb, int numBuffers);
        inline ssize_t operator()();
    };

    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;RetireUpdate类的成员变量numBuffers用来描述一个UI元数据缓冲区堆栈的大小，它的重载操作符号()实现在文件frameworks/base/libs/surfaceflinger_client/SharedBufferStack.cpp文件中，如下所示：<p></p><p></p><pre name="code" class="cpp">ssize_t SharedBufferServer::RetireUpdate::operator()() {
    int32_t head = stack.head;
    if (uint32_t(head) &gt;= SharedBufferStack::NUM_BUFFER_MAX)
        return BAD_VALUE;

    // Decrement the number of queued buffers 
    int32_t queued;
    do {
        queued = stack.queued;
        if (queued == 0) {
            return NOT_ENOUGH_DATA;
        }
    } while (android_atomic_cmpxchg(queued, queued-1, &amp;stack.queued));

    // lock the buffer before advancing head, which automatically unlocks
    // the buffer we preventively locked upon entering this function

    head = (head + 1) % numBuffers;
    const int8_t headBuf = stack.index[head];
    stack.headBuf = headBuf;

    // head is only modified here, so we don't need to use cmpxchg
    android_atomic_write(head, &amp;stack.head);

    // now that head has moved, we can increment the number of available buffers
    android_atomic_inc(&amp;stack.available);
    return head;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>一文中提到，在图1所描述的UI元数据缓冲区堆栈中，位于(head, queue_head]里面的缓冲区组成了一个待渲染队列，而SurfaceFlinger服务就是按照head到queue_head的顺序来渲染这个队列中的缓冲区的。理解了这一点之后，RetireUpdate类的重载操作符号()的实现就好理解了。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 首先，函数使用一个do...while循环来将queued的值减少1，即将待渲染队列的大小减少1。当然，如果这个待渲染队列的大小本来就等于0，那么函数就什么也不做就返回了。接着，函数将待渲染队列的头部head向前移一个位置。移动后的得到的位置所对应的缓冲区就是接下来要渲染的，因此，函数最后要将它返回给调用者。函数在将要渲染的缓冲区的位置返回给调用者之前，还会将当前正在操作的UI元数据缓冲区的空闲缓冲区的个数available增加1。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，DequeueCondition、QueueUpdate、DequeueUpdate和RetireUpdate这四个辅助类就介绍完成了，接下来，我们就可以继续分析Android应用程序请求SurfaceFlinger服务渲染Surface的过程了。在分析的过程中，我们还会继续看到这四个辅助类的使用方法。<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文的Step 16中，我们将在Android应用程序这一侧所创建的一个Surface的父类ANativeWindow的OpenGL回调函数dequeueBuffer和queueBuffer分别设置为Surface类的静态成员函数dequeueBuffer和queueBuffer。OpenGL在绘图之前，就首先会调用Surface类的静态成员函数dequeueBuffer来获得一个空闲的UI元数据缓冲区，接着请求SurfaceFlinger服务为这个UI元数据缓冲区分配一个图形缓冲区。有了图形缓冲区之后，OpengGL库就可以往里面填入UI数据。在往图形缓冲区填入UI数据的同时，OpenGL库也会往前面获得的UI元数据缓冲区填入当前正在操作的Surface的裁剪区域、纹理坐标和旋转方向等信息。再接下来，OpenGL库就会调用Surface类的静态成员函数queueBuffer来将前面已经填好了数据的UI元数据缓冲区添加到当前正在操作的Surface的UI元数缓冲区堆栈的待渲染队列中。最后，Android应用程序就会请求SurfaceFlinger服务将当前正在操作的Surface的UI数据渲染到设备显示屏去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就首先分析Surface类的静态成员函数dequeueBuffer的实现，接着再分析Surface类的静态成员函数queueBuffer的实现，最后分析SurfaceFlinger服务渲染Surface的图形缓冲区的过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Surface类的静态成员函数dequeueBuffer获得空闲UI元数据缓冲区，以及请求SurfaceFlinger服务为这个空闲UI元数据缓冲区分配图形缓冲区的过程如图2所示：</p><p style="text-align: center;"><img width="708" src="http://img.my.csdn.net/uploads/201209/04/1346696909_2192.jpg" alt="" /><br /></p><p style="text-align: center;">图2 分配空闲UI元数据缓冲区及其图形缓冲区的过程</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;这个过程一共分为12个步骤，接下来我们就详细分析每一个步骤。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;Step 1. Surface.dequeueBuffer</p><p style="text-align: left;"></p><pre name="code" class="cpp">int Surface::dequeueBuffer(ANativeWindow* window,
        android_native_buffer_t** buffer) {
    Surface* self = getSelf(window);
    return self-&gt;dequeueBuffer(buffer);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<br />&nbsp;&nbsp; &nbsp; &nbsp; 参数window虽然是一个ANativeWindow指针，但是它实际上指向的是一个Surface对象，因此，函数首先调用另外一个静态成员函数getSelf来将它转换为一个Surface对象self，接着再调用这个Surface对象self的成员函数dequeueBuffer来分配一个空闲UI元数据缓冲区和一个图形缓冲区，其中，分配的图形缓冲区就保存在输出参数buffer中。<p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; Surface类的非静态成员函数dequeueBuffer的实现如下所示：</p><p style="text-align: left;"></p><pre name="code" class="cpp">int Surface::dequeueBuffer(android_native_buffer_t** buffer)
{
    status_t err = validate();
    if (err != NO_ERROR)
        return err;
    ......

    ssize_t bufIdx = mSharedBufferClient-&gt;dequeue();
    ......    

    if (bufIdx &lt; 0) {
        ......
        return bufIdx;
    }

    // grow the buffer array if needed
    const size_t size = mBuffers.size();
    const size_t needed = bufIdx+1;
    if (size &lt; needed) {
        mBuffers.insertAt(size, needed-size);
    }

    uint32_t w, h, format, usage;
    if (needNewBuffer(bufIdx, &amp;w, &amp;h, &amp;format, &amp;usage)) {
        err = getBufferLocked(bufIdx, w, h, format, usage);
        ......
        if (err == NO_ERROR) {
            // reset the width/height with the what we get from the buffer
            const sp&lt;GraphicBuffer&gt;&amp; backBuffer(mBuffers[bufIdx]);
            mWidth  = uint32_t(backBuffer-&gt;width);
            mHeight = uint32_t(backBuffer-&gt;height);
        }
    }

    // if we still don't have a buffer here, we probably ran out of memory
    const sp&lt;GraphicBuffer&gt;&amp; backBuffer(mBuffers[bufIdx]);
    if (!err &amp;&amp; backBuffer==0) {
        err = NO_MEMORY;
    }

    if (err == NO_ERROR) {
        mDirtyRegion.set(backBuffer-&gt;width, backBuffer-&gt;height);
        *buffer = backBuffer.get();
    } else {
        mSharedBufferClient-&gt;undoDequeue(bufIdx);
    }

    return err;
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数首先调用Surface类的成员变量mSharedBufferClient所指向的一个SharedBufferClient对象的成员函数dequeue来从UI元数据缓冲区堆栈中获得一个空闲的缓冲区。获得的空闲缓冲区使用一个编号来描述，这个编号保存在变量bufIdx中。后面我们再分析SharedBufferClient类的成员函数dequeue的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;获最一个空闲UI元数据缓冲区之后，函数接下来判断该缓冲区的编号是否大于Surface类的成员变量mBuffers所描述的一个GraphicBuffer向量的大小。如果大于，那么就需要扩充这个向量的大小，以便后面可以用来保存与该缓冲区对应的一个GraphicBuffer，即一个图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;函数再接下来调用Surface类的另外一个成员函数needNewBuffer来判断之前是否已经为编号为bufIdx的UI元数据缓冲区分配过图形缓冲区了，它的实现如下所示：</p><p></p><pre name="code" class="cpp">bool Surface::needNewBuffer(int bufIdx,
        uint32_t *pWidth, uint32_t *pHeight,
        uint32_t *pFormat, uint32_t *pUsage) const
{
    Mutex::Autolock _l(mSurfaceLock);

    // Always call needNewBuffer(), since it clears the needed buffers flags
    bool needNewBuffer = mSharedBufferClient-&gt;needNewBuffer(bufIdx);
    bool validBuffer = mBufferInfo.validateBuffer(mBuffers[bufIdx]);
    bool newNeewBuffer = needNewBuffer || !validBuffer;
    if (newNeewBuffer) {
        mBufferInfo.get(pWidth, pHeight, pFormat, pUsage);
    }
    return newNeewBuffer;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;由于UI元数据缓冲区堆栈中的缓冲区是循环使用的。当一个UI元数据缓冲区第一次被使用的时候，应用程序就会请求SurfaceFlinger服务为它分配一个图形缓冲区。这个图形缓冲区使用完成之后，就会被应用程序缓存起来，以便后面可以继续使用。但是这个图形缓冲区可能会被得无效，例如，与它对应的Surface的大小和用途等信息发生改变之后，该图形缓冲区就会变得无效了，因为它在分配的时候，是按照既定的大小和用途来分配的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数首先调用Surface类的成员变量mSharedBufferClient所指向的一个SharedBufferClient对象的成员函数needBuffer来验证编号为bufIdx的UI元数据缓冲区所对应的图形缓冲区信息是否发生了变化。如果发生了变化，那么变量needNewBuffer的值就会等于true，表示要重新为编号为bufIdx的UI元数据缓冲区分配新的图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SharedBufferClient类的成员函数needBuffer的实现如下所示：</p><p></p><pre name="code" class="cpp">bool SharedBufferClient::needNewBuffer(int buf) const
{
    SharedBufferStack&amp; stack( *mSharedStack );
    const uint32_t mask = 1&lt;&lt;(31-buf);
    return (android_atomic_and(~mask, &amp;stack.reallocMask) &amp; mask) != 0;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/libs/surfaceflinger_client/SharedBufferStack.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SharedBufferClient类的成员变量mSharedStack的类型为SharedBufferStack，它是从父类SharedBufferBase继承下来的，用来描述一个UI元数据缓冲区堆栈。SharedBufferStack类的成员变量reallocMask是一个掩码，如果它的某一位的值等于1，那么这一位所描述的一个UI元数据缓冲区所对应的图形缓冲区就是无效的。这一般是由SurfaceFlinger服务来设备的。当SurfaceFlinger服务发现一个Surface的元信息发生变化时，就会通过一个SharedBufferServer对象来设置这个Surface的UI元数据缓冲区堆栈的成员变量reallocMask的相应位等于1，以便应用程序在使用到该位所描述的UI元数据缓冲区时，请求分配一个新的图形缓冲区。例如，假设SharedBufferStack类的成员变量reallocMask的值等于01000000 00000000 00000000 00000000，那么就表示编号为1的UI元数据缓冲区对应的图形缓冲区需要重新分配。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;回到Surface类的成员函数needNewBuffer中，接下来该函数继续验证编号为bufIdx对应的UI元数据缓冲区在成员变量mBuffers中所对应的图形缓冲区是否还有效，即图形缓冲区mBuffers[bufIdx]是否还有效，这是通过调用Surface类的成员变量mBufferInfo所描述的一个BufferInfo对象的成员函数validateBuffer来验证的。如果没有效，那么变量validBuffer的值就会等于false，表示要重新为编号为bufIdx的UI元数据缓冲区分配新的图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;BufferInfo类的成员函数validateBuffer的实现如下所示：</p><p></p><pre name="code" class="cpp">bool Surface::BufferInfo::validateBuffer(const sp&lt;GraphicBuffer&gt;&amp; buffer) const {
    // make sure we AT LEAST have the usage flags we want
    if (mDirty || buffer==0 ||
            ((buffer-&gt;usage &amp; mUsage) != mUsage)) {
        mDirty = 0;
        return false;
    }
    return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;BufferInfo类的成员变量mDirty用来描述一个Surface的元数据是否发了变化，例如，它的大小、像素格式等是发生了变化。如果发生了变化，那么它的值就会不等于0。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;参数buffer是一个类型为GraphicBuffer的强指针，如果它的值等于null，那么就说明它所描述的图形缓冲是无效的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;如果参数buffer所指向的图形缓冲区是有效的，但是它的用途发生了变化，即它的用途与它所对应的Surface的用途已经不一致了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;上述三种情况都说明需要为编号为bufIdx的UI元数据缓冲分配新的图形缓冲区，因此，这个函数的返回值就会等于false。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;回到Surface类的成员函数needNewBuffer中，接下来该函数通过变量needNewBuffer和变量validBuffer的值就可以知道是否需要为编号为bufIdx的UI元数据缓冲分配新的图形缓冲区了。假设应用程序是第一次使用编号为bufIdx的UI元数据缓冲，那么变量validBuffer的值就一定会等于false，因此，Surface类的成员函数needNewBuffer的返回值就会等于true，表示要为编号为bufIdx的UI元数据缓冲分配新的图形缓冲区。该函数在返回之前，还会通过Surface类的成员变量mBufferInfo所描述的一个BufferInfo对象来得到当前正在绘制的Surface的宽度、高度、像素格式以及用途，分别保存在输出参数pWidth、pHeight、pFormat和pUsage，以便应用程序接下来可以使用这些信息来请求SurfaceFlinger服务分配一个新的图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 回到Surface类的非静态成员函数dequeueBuffer中，该函数接下来就会调用Surface类的另外一个成员函数getBufferLocked来请求SurfaceFlinger服务为编号为bufIdx的UI元数据缓冲区分配一个图形缓冲区。分配完成之后，这个图形缓冲区就会保存在mBuffers[bufIdx]中。后面我们就详细分析Surface类的成员函数getBufferLocked的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Surface类的非静态成员函数dequeueBuffer获得了编号为bufIdx的图形缓冲区之后，接下来就会得到这个图形缓冲区的宽度和高度，并且保存Surface类的成员变量mWidth和mHeight中，以便可以表示当前下在绘制的Surface的宽度和高度。同时，这个图形缓冲区的宽度和高度还会被更新到用来描述当前正在绘制的Surface的裁剪区域去，因为SurfaceFlinger服务在渲染该Surface时，需要用到这个信息。当前正在绘制的Surface的裁剪区域是由Surface类的成员变量mDirtyRegion来描述的，只要调用它的成员函数set，就可以重新设置它的宽度和高度。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;最后，Surface类的非静态成员函数dequeueBuffer就将得到的图形缓冲区的地址保存输出参数buffer中，以便OpenGL库可以在上面填入UI数据。另一方面，如果分配图形缓冲区失败，那么Surface类的非静态成员函数dequeueBuffer会将前面得到的一个UI元数据缓冲区返回给成员变量mSharedBufferClient所描述的一个UI元数据缓冲区堆栈去，这是通过调用成员变量mSharedBufferClient的成员函数undoDequeue来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就继续分析SharedBufferClient类的成员函数dequeue的实现，以便了解它是如何从UI元数据缓冲区堆栈中获得一个空闲的缓冲区的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 2.&nbsp;SharedBufferClient.dequeue</p><p></p><pre name="code" class="cpp">ssize_t SharedBufferClient::dequeue()
{
    SharedBufferStack&amp; stack( *mSharedStack );

    if (stack.head == tail &amp;&amp; stack.available == mNumBuffers) {
        LOGW(&quot;dequeue: tail=%d, head=%d, avail=%d, queued=%d&quot;,
                tail, stack.head, stack.available, stack.queued);
    }

    RWLock::AutoRLock _rd(mLock);

    const nsecs_t dequeueTime = systemTime(SYSTEM_TIME_THREAD);

    //LOGD(&quot;[%d] about to dequeue a buffer&quot;,
    //        mSharedStack-&gt;identity);
    DequeueCondition condition(this);
    status_t err = waitForCondition(condition);
    if (err != NO_ERROR)
        return ssize_t(err);

    DequeueUpdate update(this);
    updateCondition( update );

    int dequeued = stack.index[tail];
    tail = ((tail+1 &gt;= mNumBuffers) ? 0 : tail+1);
    LOGD_IF(DEBUG_ATOMICS, &quot;dequeued=%d, tail++=%d, %s&quot;,
            dequeued, tail, dump(&quot;&quot;).string());

    mDequeueTime[dequeued] = dequeueTime;

    return dequeued;
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/libs/surfaceflinger_client/SharedBufferStack.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>一文可以知道，SharedBufferClient类的成员变量tail指向了一个UI元数据缓冲区堆栈的空闲缓冲区列表的尾部。当这个UI元数据缓冲区堆栈的可用空闲缓冲区的数量available的值大于0的时候，应用程序就可以从它的空闲缓冲区列表的尾部分配一个绘冲区出来使用。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数首先创建了一个DequeueCondition对象condition，然后再调用SharedBufferClient从SharedBufferBase类继承下来的成员函数waitForCondition来判断当前正在使用的UI元数据缓冲区堆栈是否有空闲的缓冲区可以分配。如果没有，那么当前线程就会一直等待，直到可以得到一个空闲缓冲区为止。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数接着创建了一个DequeueUpdate对象update，然后再调用SharedBufferClient从SharedBufferBase类继承下来的成员函数updateCondition来减少当前正在使用的UI元数据缓冲区堆栈的空闲缓冲区的数量，因为接下来要将空闲缓冲区列表尾部的缓冲区分配出来使用。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数最后就通过SharedBufferClient类的成员变量tail来获得了一个编号为dequeued的空闲UI元数据缓冲区，并且将这个编号返回给调用者。不过，在返回之前，函数还会将SharedBufferClient类的成员变量tail向前移一个位置，以便它可以指向下一个可以用来分配的空闲UI元数据缓冲区。由于UI元数据缓冲区堆栈是循环使用的，因此，当SharedBufferClient类的成员变量tail向前移一个位置，即加1之后，它的值大于等于UI元数据缓冲区堆栈的大小mNumBuffers时，就需要绕回到堆栈的开头去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，就返回到Step 1中，即Surface类的成员函数dequeueBuffer中，这时候应用程序就为当前正在绘制的Surface获得了一个空闲UI元数据缓冲区，接下来就会继续调用Surface类的成员函数getBufferLocked来为该空闲UI元数据缓冲区分配图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 3. &nbsp;Surface.getBufferLocked</p><p></p><pre name="code" class="cpp">status_t Surface::getBufferLocked(int index,
        uint32_t w, uint32_t h, uint32_t format, uint32_t usage)
{
    sp&lt;ISurface&gt; s(mSurface);
    if (s == 0) return NO_INIT;

    status_t err = NO_MEMORY;

    // free the current buffer
    sp&lt;GraphicBuffer&gt;&amp; currentBuffer(mBuffers.editItemAt(index));
    if (currentBuffer != 0) {
        getBufferMapper().unregisterBuffer(currentBuffer-&gt;handle);
        currentBuffer.clear();
    }

    sp&lt;GraphicBuffer&gt; buffer = s-&gt;requestBuffer(index, w, h, format, usage);
    ......

    if (buffer != 0) { // this should never happen by construction
        ......

        err = mSharedBufferClient-&gt;getStatus();
        ......
        if (!err &amp;&amp; buffer-&gt;handle != NULL) {
            err = getBufferMapper().registerBuffer(buffer-&gt;handle);
            ......

            if (err == NO_ERROR) {
                currentBuffer = buffer;
                currentBuffer-&gt;setIndex(index);
            }
        } else {
            err = err&lt;0 ? err : status_t(NO_MEMORY);
        }
    }
    return err;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文可以知道，&nbsp;&nbsp;Surface类的成员变量mSurface指向了一个类型为BpSurface的Binder代理对象，这个Binder代理对象引用了运行在SurfaceFlinger服务一侧的一个类型为SurfaceLayer的Binder本地对象。函数首先将这个成员变量保存在变量s中，后面会通过它来向SurfaceFlinger服务为编号为index的空闲UI元数据缓冲区分配一个图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在请求SurfaceFlinger服务为编号为index的空闲UI元数据缓冲区分配图形缓冲区之前，函数还会检查在Surface类的成员变量mBuffers中是否存在一个与编号为index的空闲UI元数据缓冲区对应的图形缓冲区。如果存在的话，就需要将这个图形缓冲区从应用程序进程的地址空间注销掉，因为这个图形缓冲区已经变成无效了。Surface类的成员函数getBufferMapper的返回值是一个GraphicBufferMapper对象，通过调用这个GraphicBufferMapper对象的成员函数unregisterBuffer就可以注销一个指定的图形缓冲区。GraphicBufferMapper类的成员函数unregisterBuffer最终也是通过HAL层中的Gralloc模块提供的接口gralloc_unregister_buffer来注销一个指定的图形缓冲区，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数接下来就请求变量s所指向的一个BpSurface对象的成员函数requestBuffer请求SurfaceFlinger服务为编号为index的空闲UI元数据缓冲区分配一个图形缓冲区，这个缓冲区保存在变量buffer中。应用程序得到图形缓冲区buffer之后，还需要将它注册到本进程的地址空间之后，才能使用，这是通过调用GraphicBufferMapper类的成员函数registerBuffer来实现的，后面我们再详细分析这个注册的过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，函数就将图形缓冲区buffer保存在一个GraphicBuffer引用currentBuffer中。由于currentBuffer引用的是Surface类的成员变量mBuffers的第index个图形缓冲区，因此，前面相当于将图形缓冲区buffer保存在Surface类的成员变量mBuffers的第index个位置中，以便以后可以重复利用。最后，函数还调用GraphicBuffer引用currentBuffer的成员函数setIndex来将前面分配到的图形缓冲区的编号设置为index，这样就可以将它与编号为index的UI元数据缓冲区关联起来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;由于变量s引用的是一个类型为SurfaceLayer的Binder本地对象，因此，接下来我们就继续分析SurfaceLayer类的成员函数requestBuffer的实现，以便可以了解SurfaceFlinger服务是如何为应用程序的一个Surface分配一个图形缓冲区的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 4. SurfaceLayer.requestBuffer</p><p></p><pre name="code" class="cpp">sp&lt;GraphicBuffer&gt; Layer::SurfaceLayer::requestBuffer(int index,
        uint32_t w, uint32_t h, uint32_t format, uint32_t usage)
{
    sp&lt;GraphicBuffer&gt; buffer;
    sp&lt;Layer&gt; owner(getOwner());
    if (owner != 0) {
        /*
         * requestBuffer() cannot be called from the main thread
         * as it could cause a dead-lock, since it may have to wait
         * on conditions updated my the main thread.
         */
        buffer = owner-&gt;requestBuffer(index, w, h, format, usage);
    }
    return buffer;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/Layer.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数首先调用SurfaceLayer类的成员函数getOwner来获得当前正在处理的一个SurfaceLayer对象的宿主Layer对象，接着再调用这个Layer对象的成员函数requestBuffer来执行分配图形缓冲区的操作。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文可以知道，SurfaceFlinger服务在为Android应用程序创建一个Surface的时候，会相应地创建一个Layer对象和一个SurfaceLayer对象来描述这个Surface。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析Layer类的成员函数requestBuffer的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 5. Layer.requestBuffer</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在frameworks/base/services/surfaceflinger/Layer.cpp文件中，我们分段来阅读：</p><p></p><pre name="code" class="cpp">sp&lt;GraphicBuffer&gt; Layer::requestBuffer(int index,
        uint32_t reqWidth, uint32_t reqHeight, uint32_t reqFormat,
        uint32_t usage)
{
    sp&lt;GraphicBuffer&gt; buffer;

    if (int32_t(reqWidth | reqHeight | reqFormat) &lt; 0)
        return buffer;

    if ((!reqWidth &amp;&amp; reqHeight) || (reqWidth &amp;&amp; !reqHeight))
        return buffer;

    // this ensures our client doesn't go away while we're accessing
    // the shared area.
    ClientRef::Access sharedClient(mUserClientRef);
    SharedBufferServer* lcblk(sharedClient.get());
    if (!lcblk) {
        // oops, the client is already gone
        return buffer;
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; 我们首先明确一下各个函数参数的含义。参数index用来描述一个UI元数据缓冲区的编号，参数reqWidth、reqHeight、reqFormat和usage分别表示要分配的图形缓冲区的宽度、高度、像素格式和用途。函数首先检查各个参数的合法性，即参数reqWidth、reqHeight和reqFormat不能为负数，并且参数reqWidth和reqHeight不能同时等于0。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文可以知道，Layer类的成员变量mUserClientRef指向了一个ClientRef对象，通过这个ClientRef对象可以获得一个SharedBufferServer对象lcblk。得到的SharedBufferServer对象lcblk就是用来描述正在请求SurfaceFlinger服务分配图形缓冲区的Surface的UI元数据缓冲区堆栈的，接下来我们就会看到它的用法。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们继续往下看：</p><p></p><pre name="code" class="cpp">    /*
     * This is called from the client's Surface::dequeue(). This can happen
     * at any time, especially while we're in the middle of using the
     * buffer 'index' as our front buffer.
     */

    uint32_t w, h, f, bypass;
    { // scope for the lock
        Mutex::Autolock _l(mLock);

        bypass = mBypassState;

        // zero means default
        mFixedSize = reqWidth &amp;&amp; reqHeight;
        if (!reqFormat) reqFormat = mFormat;
        if (!reqWidth)  reqWidth = mWidth;
        if (!reqHeight) reqHeight = mHeight;

        w = reqWidth;
        h = reqHeight;
        f = reqFormat;

        if ((reqWidth != mReqWidth) || (reqHeight != mReqHeight) ||
                (reqFormat != mReqFormat)) {
            mReqWidth  = reqWidth;
            mReqHeight = reqHeight;
            mReqFormat = reqFormat;
            mNeedsScaling = mWidth != mReqWidth || mHeight != mReqHeight;

            lcblk-&gt;reallocateAllExcept(index);
        }
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一段代码主要就是用来判断要分配图形缓冲区的Surface的宽度、高度和像素格式是否发生变化。当请求分配的图形缓冲区的宽度、高度和像素格式与这个图形缓冲区所描述的Surface原来的宽度、高度和像素格式不一样时，SurfaceFlinger服务就会认为这个Surface的元信息发生了变化，这时候函数就会将请求分配的图形缓冲区的宽度、高度和像素格式设置为当前Surface的宽度、高度和像素格式，并且调用前面所获得的一个SharedBufferServer对象lcblk的成员函数reallocateAllExcept来将之前已经分配给当前Surface的图形缓冲区设置为无效，因为之前已经分配给当前Surface的图形缓冲区已经不适合于当前Surface使用了。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在这一段代码中，还有一个需要注意的地方，即Layer类的成员变量mBypassState。这个成员变量表示当前正在处理的一个Layer对象所描述的一个Surface在SurfaceFlinger服务渲染UI时，是否需要参与合成。当它的值等于true的时候，就表示不需要参与合成，否则就要参考合成。一般当一个Layer对象所描述的Surface的图形缓冲区是直接在硬件帧缓冲区fb上分配时，对应的Surface就不需要参与SurfaceFlinger服务的合成操作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们继续向下看：</p><p></p><pre name="code" class="cpp">    // here we have to reallocate a new buffer because the buffer could be
    // used as the front buffer, or by a client in our process
    // (eg: status bar), and we can't release the handle under its feet.
    uint32_t effectiveUsage = getEffectiveUsage(usage);

    status_t err = NO_MEMORY;

#ifdef USE_COMPOSITION_BYPASS
    if (!mSecure &amp;&amp; bypass &amp;&amp; (effectiveUsage &amp; GRALLOC_USAGE_HW_RENDER)) {
        // always allocate a buffer matching the screen size. the size
        // may be different from (w,h) if the buffer is rotated.
        const DisplayHardware&amp; hw(graphicPlane(0).displayHardware());
        int32_t w = hw.getWidth();
        int32_t h = hw.getHeight();
        int32_t f = hw.getFormat();

        buffer = new GraphicBuffer(w, h, f, effectiveUsage | GRALLOC_USAGE_HW_FB);
        err = buffer-&gt;initCheck();
        buffer-&gt;transform = uint8_t(getOrientation());

        if (err != NO_ERROR) {
            // allocation didn't succeed, probably because an older bypass
            // window hasn't released all its resources yet.
            ClientRef::Access sharedClient(mUserClientRef);
            SharedBufferServer* lcblk(sharedClient.get());
            if (lcblk) {
                // all buffers need reallocation
                lcblk-&gt;reallocateAll();
            }
        }
    }
#endif</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码用来判断是否需要直接在硬件帧缓冲区fb上分配一个图形缓冲区。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 当满足以下四个条件时，一个图形缓冲区就可以在硬件帧缓冲区fb分配：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. SurfaceFlinger服务在编译时，定义了USE_COMPOSITION_BYPASS宏；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. 当前正在处理的Layer对象的成员变量mSecure的值等于false，即这个Layer对象的所描述的一个Surface是非进程间传输安全的，这种类型的Surface一般用来保存屏幕UI数据或者用来传输远程桌面UI数据；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 3.&nbsp;当前正在处理的Layer对象的成员变量mBypassState的值等于true，即这个Layer对象的所描述的一个Surface是不需要参与到SurfaceFlinger服务渲染合成操作的；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 4. 请求分配的图形缓冲区的有效用途effectiveUsage的第GRALLOC_USAGE_HW_RENDER位等于1，即请求分配的图形缓冲区要在直接在硬件帧缓冲区上渲染。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 当满足上述四个条件，函数就会创建一个类型为GRALLOC_USAGE_HW_FB的图形缓冲区buffer，并且将它返回给应用程序。如果创建失败，函数会调用前面所获得的一个SharedBufferServer对象lcblk的成员函数reallocateAll来将之前已经分配给当前Surface的图形缓冲区都设置为无效，因为这些图形缓冲区有可能不是在硬件帧缓冲区fb上分配的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;请求分配的图形缓冲区的有效用途effectiveUsage是通过调用Surface类的成员函数getEffectiveUsage来获得的，如下所示：</p><p></p><pre name="code" class="cpp">uint32_t Layer::getEffectiveUsage(uint32_t usage) const
{
    /*
     *  buffers used for software rendering, but h/w composition
     *  are allocated with SW_READ_OFTEN | SW_WRITE_OFTEN | HW_TEXTURE
     *
     *  buffers used for h/w rendering and h/w composition
     *  are allocated with  HW_RENDER | HW_TEXTURE
     *
     *  buffers used with h/w rendering and either NPOT or no egl_image_ext
     *  are allocated with SW_READ_RARELY | HW_RENDER
     *
     */

    if (mSecure) {
        // secure buffer, don't store it into the GPU
        usage = GraphicBuffer::USAGE_SW_READ_OFTEN |
                GraphicBuffer::USAGE_SW_WRITE_OFTEN;
    } else {
        // it's allowed to modify the usage flags here, but generally
        // the requested flags should be honored.
        // request EGLImage for all buffers
        usage |= GraphicBuffer::USAGE_HW_TEXTURE;
    }
    return usage;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 参数usage用来描述请求分配的图形缓冲区的原始用途。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 如果当前正在处理的Layer对象所描述的一个Surface是可以在进程间安全传输的，那么函数就会将参数usage的值修改为(GraphicBuffer::USAGE_SW_READ_OFTEN |&nbsp;GraphicBuffer::USAGE_SW_WRITE_OFTEN)，目的是防止该Surface的图形缓冲区直接在硬件帧缓冲区上分配。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;如果当前正在处理的Layer对象所描述的一个Surface是不可以在进程间安全传输的，那么函数除了会保留参数usage的原值之外，还会将它的第GraphicBuffer::USAGE_HW_TEXTURE位设置为1，用来表示分配的图形缓冲区可以用来作为OpenGL库的纹理缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 最后，函数就将修改后的参数usage的值返回给调用者。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 回到Layer类的成员函数requestBuffer中。对于一般应用程序创建的Surface来说，它们都是不可以在进程间安全传输的，即与它对应的Layer对象的成员变量mSecure的值等于false，因此，这时候Layer类的成员函数requestBuffer得到即将要分配的图形缓冲区的有效用途effectiveUsage的GraphicBuffer::USAGE_HW_TEXTURE位就被设置为1。我们记住这个值，以便接下来可以了解图形缓冲区的分配过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;我们假设SurfaceFlinger服务在编译时，没有定义USE_COMPOSITION_BYPASS宏，或者当前正在处理的Layer对象所描述的一个Surface是需要由SurfaceFlinger服务执行渲染合成操作的，即前面第1个或者第3个条件不满足，于是，我们就继续向下分析Layer类的成员函数requestBuffer的实现：</p><p></p><pre name="code" class="cpp">    if (err != NO_ERROR) {
        buffer = new GraphicBuffer(w, h, f, effectiveUsage);
        err = buffer-&gt;initCheck();
    }

    .....

    if (err == NO_ERROR &amp;&amp; buffer-&gt;handle != 0) {
        Mutex::Autolock _l(mLock);
        mBufferManager.attachBuffer(index, buffer);
    }
    return buffer;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码首先使用参数w、h、f和effectiveUsage来创建了一个GraphicBuffer对象buffer，用来描述即将要分配的图形缓冲区，接着再调用Layer类的成员变量mBufferManager所描述的一个BufferManager对象的成员函数attachBuffer来将GraphicBuffer对象buffer的编号设置为index，以便可以表示这个GraphicBuffer对象buffer是为编号为index的UI元数据缓冲区创建的。<p>&nbsp;&nbsp; &nbsp; &nbsp; 最后，Layer类的成员函数requestBuffer就将分配好的图形缓冲区，即GraphicBuffer对象buffer返回给应用程序。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们首先分析一个GraphicBuffer对象的创建过程，即GraphicBuffer类的构造函数的实现，以便可以了解它所描述的图形缓冲区是如何分配的，接着再分析BufferManager类的成员函数attachBuffer的实现，以便可以了解SurfaceFlinger服务是如何将一个UI元数据缓冲区与一个图形缓冲区关联起来的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 6. new GraphicBuffer</p><p></p><pre name="code" class="cpp">GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,
        PixelFormat reqFormat, uint32_t reqUsage)
    : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),
      mInitCheck(NO_ERROR), mIndex(-1)
{
    width  =
    height =
    stride =
    format =
    usage  =
    transform = 0;
    handle = NULL;
    mInitCheck = initSize(w, h, reqFormat, reqUsage);
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/libs/ui/GraphicBuffer.cpp文件中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; GraphicBuffer类的构造函数最重要的是调用另外一个成员函数initSize来初始化即将要分配的图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 7. GraphicBuffer.initSize</p><p></p><pre name="code" class="cpp">status_t GraphicBuffer::initSize(uint32_t w, uint32_t h, PixelFormat format,
        uint32_t reqUsage)
{
    GraphicBufferAllocator&amp; allocator = GraphicBufferAllocator::get();
    status_t err = allocator.alloc(w, h, format, reqUsage, &amp;handle, &amp;stride);
    if (err == NO_ERROR) {
        this-&gt;width  = w;
        this-&gt;height = h;
        this-&gt;format = format;
        this-&gt;usage  = reqUsage;
    }
    return err;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/libs/ui/GraphicBuffer.cpp文件中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数首先获得一个GraphicBufferAllocator对象，然后再调用这个GraphicBufferAllocator对象的成员函数alloc来分配一块指定大小、像素格式以及用用途的图形缓冲区。分配好的图形缓冲的句柄值最终就保存在GraphicBuffer类的成员变量handle中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; GraphicBufferAllocator类是用来分配图形缓冲区的，接下来我们就继续分析它的成员函数alloc的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 8.&nbsp;GraphicBufferAllocator.alloc</p><p></p><pre name="code" class="cpp">status_t GraphicBufferAllocator::alloc(uint32_t w, uint32_t h, PixelFormat format,
        int usage, buffer_handle_t* handle, int32_t* stride)
{
    // make sure to not allocate a N x 0 or 0 x N buffer, since this is
    // allowed from an API stand-point allocate a 1x1 buffer instead.
    if (!w || !h)
        w = h = 1;

    // we have a h/w allocator and h/w buffer is requested
    status_t err;

    if (usage &amp; GRALLOC_USAGE_HW_MASK) {
        err = mAllocDev-&gt;alloc(mAllocDev, w, h, format, usage, handle, stride);
    } else {
        err = sw_gralloc_handle_t::alloc(w, h, format, usage, handle, stride);
    }

    ......

    return err;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/ui/GraphicBufferAllocator.cpp中。<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数usage是从前面的Step 5中传进来的，前面我们假设它的第GraphicBuffer::USAGE_HW_TEXTURE位的值等于1。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;GraphicBuffer::USAGE_HW_TEXTURE是一个枚举值，定义在文件frameworks/base/include/ui/GraphicBuffer.h中，如下所示：</p><p></p><pre name="code" class="cpp">class GraphicBuffer
    : public EGLNativeBase&lt;
        android_native_buffer_t,
        GraphicBuffer,
        LightRefBase&lt;GraphicBuffer&gt; &gt;, public Flattenable
{
public:

    enum {
        ......

        USAGE_HW_TEXTURE        = GRALLOC_USAGE_HW_TEXTURE,
        ......
 
    };

    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp; 它的值等于GRALLOC_USAGE_HW_TEXTURE。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;GRALLOC_USAGE_HW_TEXTURE和GRALLOC_USAGE_HW_MASK也是两个枚举值，它们定义在文件hardware/libhardware/include/hardware/gralloc.h中，如下所示：</p><p></p><pre name="code" class="cpp">enum {
    ......

    /* buffer will be used as an OpenGL ES texture */
    GRALLOC_USAGE_HW_TEXTURE      = 0x00000100,
    ......

    /* mask for the software usage bit-mask */
    GRALLOC_USAGE_HW_MASK         = 0x00001F00,
    ......

};</pre>&nbsp;&nbsp; &nbsp; &nbsp; 从GRALLOC_USAGE_HW_TEXTURE和GRALLOC_USAGE_HW_MASK这两个枚举值的定义可以知道，GraphicBufferAllocator类的成员函数alloc最终会调用其成员变量mAllocDev的成员函数alloc来分配一个图形缓冲区。<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;GraphicBufferAllocator类的成员变量mAllocDev指向了一个alloc_device_t结构体，用来描述HAL层的Gralloc模块中的一个gralloc设备，这个gralloc设备是在GraphicBufferAllocator类的构造函数中创建的，如下所示：</p><p></p><pre name="code" class="cpp">GraphicBufferAllocator::GraphicBufferAllocator()
    : mAllocDev(0)
{
    hw_module_t const* module;
    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module);
    LOGE_IF(err, &quot;FATAL: can't find the %s module&quot;, GRALLOC_HARDWARE_MODULE_ID);
    if (err == 0) {
        gralloc_open(module, &amp;mAllocDev);
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; GraphicBufferAllocator类的构造函数首先调用函数hw_get_module来加载ID值等于GRALLOC_HARDWARE_MODULE_ID的HAL模块，即加载HAL层中的Gralloc模块，目的是为了接下来调用函数gralloc_open来打开里面的gralloc设备，并且将这个打开的gralloc设备保存在GraphicBufferAllocator类的成员变量mAllocDev中，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析alloc_device_t结构体的成员函数alloc的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 9.&nbsp;alloc_device_t.alloc</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文可以知道，Gralloc模块中的gralloc设备的成员函数alloc被设置为Gralloc模块中的函数gralloc_alloc。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Gralloc模块模块中的函数gralloc_alloc有一个参数usage，当它的GRALLOC_USAGE_HW_FB位等于1的时候，函数gralloc_alloc就会直接在硬件帧缓冲区上分配一个图形缓冲区，否则的话，就会在匿名共享内存中分配一个图形缓冲区。从前面的调用过程可以知道，这个参数的值最开始是从前面的Step 1传过来的，即是从应用程序进程这一侧传递过来的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 由于整个系统在硬件上就只有一个帧缓冲区，它是由SurfaceFlinger服务来统一管理的，即只有SurfaceFlinger服务使用的图形缓冲区才可以在上面分配，否则的话，随便一个应用程序进程都可以在上面分配图形缓冲区来使用，这个帧缓冲区的管理就乱套了。应用程序进程使用的图形缓冲区一般都是在匿名共享内存里面分配的，这个图形缓区填好数据之后，就会再交给SurfaceFlinger服务来合成到硬件帧缓冲区上去渲染。因此，从前面Step 1传过来给函数gralloc_alloc的参数usage的GRALLOC_USAGE_HW_FB位会被设置为0，以便可以在匿名共享内存中分配一个图形缓冲区。这个分配的过程可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文，这里就不再复述了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，应用程序所请求的图形缓冲区就分配完成了，回到前面的Step 5中，即Layer类的成员函数requestBuffer中，接下来就会调用BufferManager类的成员函数attachBuffer来设置这个图形缓冲区的编号，以便它可以与一个UI元数据缓冲区关联起来的。关联好之后，应用程序在请求SurfaceFlinger服务渲染一个Surface时，只需要指定一个UI元数据缓冲区的编号，SurfaceFlinger服务就可以根据这个编号来找到对应的图形缓冲区，进而把这个图形缓冲区的内容渲染到硬件帧缓冲区上去，即渲染到设备显示屏上去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就继续分BufferManager类的成员函数attachBuffer的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 10.&nbsp;BufferManager.attachBuffer</p><p></p><pre name="code" class="cpp">status_t Layer::BufferManager::attachBuffer(size_t index,
        const sp&lt;GraphicBuffer&gt;&amp; buffer)
{
    BufferData* const buffers = mBufferData;
    Mutex::Autolock _l(mLock);
    buffers[index].buffer = buffer;
    buffers[index].texture.dirty = true;
    return NO_ERROR;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在frameworks/base/services/surfaceflinger/Layer.cpp文件中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面的调用过程可以知道，参数index用来描述一个UI元数据缓冲区的编号，而参数buffer用来描述一个图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;BufferManager类的成员变量mBufferData是一个类型为BufferData的数组，这个数组就是用来关联当前正在处理的一个Layer对象所描述的一个Surface的UI元数据缓冲区和图形缓冲区的。例如，编号为i的UI元数据缓冲区在数组mBufferData的第i个位置有一个对应的BufferData结构体，而这个BufferData结构体的成员变量buffer就指向为编号为i的UI元数据缓冲区所分配的一个图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 理解了这一点之后，我们就不难理解BufferManager类的成员函数attachBuffer的实现了，它就是将编号为index的UI元数据缓冲区与参数buffer所描述的图形缓冲区关联起来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，回到前面的Step 5中，即Layer类的成员函数requestBuffer中，接下来就会将分配好的图形缓冲区返回给应用程序，即返回到前面的Step 3中去，这时候应用程序就继续调用GraphicBufferMapper类的成员函数registerBuffer来将获得的图形缓冲区注册到当前进程的地址空间去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 11.&nbsp;GraphicBufferMapper.registerBuffer</p><p></p><pre name="code" class="cpp">status_t GraphicBufferMapper::registerBuffer(buffer_handle_t handle)
{
    status_t err;
    if (sw_gralloc_handle_t::validate(handle) &lt; 0) {
        err = mAllocMod-&gt;registerBuffer(mAllocMod, handle);
    } else {
        err = sw_gralloc_handle_t::registerBuffer((sw_gralloc_handle_t*)handle);
    }
    LOGW_IF(err, &quot;registerBuffer(%p) failed %d (%s)&quot;,
            handle, err, strerror(-err));
    return err;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/ui/GraphicBufferMapper.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数handle的类型为buffer_handle_t，它描述的便是前面在匿名共享内存中分配的一个图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面的Step 8可以知道，当GraphicBufferAllocator类的成员函数alloc的参数usage的第GraphicBuffer::USAGE_HW_TEXTURE位的值等于1的时候，SurfaceFlinger服务就会通过HAL层的Gralloc模块来分配一个图形缓冲区，否则的话，就会在sw_gralloc_handle_t模块中分配一个图形缓冲区。sw_gralloc_handle_t模块中分配的图形缓冲区是使用一个sw_gralloc_handle_t对象来描述的，而从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文可以知道，Gralloc模块分配的图形缓冲区是使用一个private_handle_t对象来描述的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;sw_gralloc_handle_t类的静态成员函数validate就是用来验证参数handle所描述的一个图形缓冲区是否是在sw_gralloc_handle_t模块中分配的。如果是的话，那么它的返回值就会等于0，否则的话，就会小于0。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 由于参数handle所描述的一个图形缓冲区是在Gralloc模块中分配的，因此，这个函数接下来就会调用GraphicBufferMapper类的成员变量mAllocMod的成员函数registerBuffer来执行注册图形缓冲区的操作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;GraphicBufferMapper类的成员变量mAllocMod指向了HAL层中的Gralloc模块，它是在GraphicBufferMapper类的构造函数中初始化的，如下所示：</p><p></p><pre name="code" class="cpp">GraphicBufferMapper::GraphicBufferMapper()
    : mAllocMod(0)
{
    hw_module_t const* module;
    int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module);
    LOGE_IF(err, &quot;FATAL: can't find the %s module&quot;, GRALLOC_HARDWARE_MODULE_ID);
    if (err == 0) {
        mAllocMod = (gralloc_module_t const *)module;
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; GraphicBufferMapper类的构造函数首先调用函数hw_get_module来加载ID值等于GRALLOC_HARDWARE_MODULE_ID的模块，就可以将Gralloc模块加载到应用程序进程中来。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文可以知道，Gralloc模块是使用一个gralloc_module_t结构体来描述的，因此，GraphicBufferMapper类的构造函数最终就可以将加载得到的模块module转换为一个gralloc_module_t结构体，并且保存在GraphicBufferMapper类的成员变量mAllocMod中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析gralloc_module_t结构体的成员函数registerBuffer的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 12.&nbsp;gralloc_module_t.registerBuffer</p><p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文可以知道，Gralloc模块的成员函数registerBuffer被设置为Gralloc模块中的函数gralloc_register_buffer。Gralloc模块模块中的函数gralloc_register_buffer主要就是将一块指定的图形缓冲区映射到当前进程的地址空间来。在我们这个情景中，就是映射到应用程序进程的地址空间来。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，应用程序请求SurfaceFlinger服务为一个空闲的UI元数据缓冲区分配一个图形缓冲区的过程就分析完成了。从分析的过程可以知道，这个图形缓冲区指向的是一块匿名共享内存，最初是在SurfaceFlinger服务这一侧分配的，然后再返回给应用程序进程这一侧，并且会被映射到应用程序进程的地址空间来。这样，SurfaceFlinger服务和应用程序就可以在各自的地址空间中访问这个图形缓冲区，其中，应用程序访问这个图形缓冲区的目的是往里面写入UI数据，而SurfaceFlinger服务访问这个图形缓冲区的目的是将里面的UI数据读取出来渲染。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们继续再分析Surface类的静态成员函数queueBuffer的实现，以便可以了解应用程序是如何将一块已经填好了数据的UI元数据缓冲区添加到当前正在绘制的Surface的UI元数缓冲区堆栈的待渲染队列中去，这个过程如图3所示：</p><p style="text-align: center;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "><img src="http://img.my.csdn.net/uploads/201209/14/1347559050_3870.jpg" alt="" /><br /></p><div style="text-align: center;">图3 准备就绪的UI元数据缓冲区进入待渲染队列的过程</div><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp;这个过程一共分为4个步骤，接下来我们就详细分析每一个步骤。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp;Step 1. Surface.queueBuffer</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; "></p><pre name="code" class="cpp">int Surface::queueBuffer(ANativeWindow* window,
        android_native_buffer_t* buffer) {
    Surface* self = getSelf(window);
    return self-&gt;queueBuffer(buffer);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;这个函数定义文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<br /><p>&nbsp;&nbsp; &nbsp; &nbsp;参数window虽然是一个ANativeWindow指针，但是它实际上指向的是一个Surface对象，因此，函数首先调用另外一个静态成员函数getSelf来将它转换为一个Surface对象self，接着再调用这个Surface对象self的成员函数queueBuffer将一个UI元数据缓冲区加入到待渲染队列中去，其中，要加入到待渲染队列中去的UI元数据缓冲区就是使用参数buffer来描述的。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; Surface类的非静态成员函数queueBuffer的实现如下所示：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; "></p><pre name="code" class="cpp">int Surface::queueBuffer(android_native_buffer_t* buffer)
{
    status_t err = validate();
    if (err != NO_ERROR)
        return err;

    if (mSwapRectangle.isValid()) {
        mDirtyRegion.set(mSwapRectangle);
    }

    int32_t bufIdx = getBufferIndex(GraphicBuffer::getSelf(buffer));

    GraphicLog::getInstance().log(GraphicLog::SF_APP_QUEUE, mIdentity, bufIdx);

    mSharedBufferClient-&gt;setTransform(bufIdx, mNextBufferTransform);
    mSharedBufferClient-&gt;setCrop(bufIdx, mNextBufferCrop);
    mSharedBufferClient-&gt;setDirtyRegion(bufIdx, mDirtyRegion);
    err = mSharedBufferClient-&gt;queue(bufIdx);
    LOGE_IF(err, &quot;error queuing buffer %d (%s)&quot;, bufIdx, strerror(-err));

    if (err == NO_ERROR) {
        // TODO: can we avoid this IPC if we know there is one pending?
        mClient.signalServer();
    }
    return err;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; Surface类的成员变量mSwapRectangle用来指定要绘制的Surface的区域。如果它的值是正确的，那么函数就会将它的值设置到Surface类的另外一个成员变量mDirtyRegion中去，以便接下来可以用来作为裁剪区域传递给SurfaceFlinger服务。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 如前所述，参数buffer描述的是一个图形缓冲区，它的实际类型为GraphicBuffer，因此，函数就可以调用GraphicBuffer的静态成员函数getSelf来将它转换为一个GraphicBuffer对象，接着函数还调用Sufrace类的成员函数getBufferIndex来获得参数buffer所描述的一个图形缓冲区的编号bufIdx。这个编号是用来关联一个UI元数据缓冲区。在前面分析空闲UI元数据缓冲区及其图形缓冲区的分配过程的Step 3中提到，应用程序请求SurfaceFlinger服务为一个UI元数据缓冲区分配了一个图形缓冲区时，就会将这个UI元数据缓冲区的编号设置到这个图形缓冲区里面去。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; Surface类的成员变量mSharedBufferClient指向了一个SharedBufferClient对象，用来描述当前正在绘制的Surface的UI元数据缓冲区堆栈，接下来函数就会调用它的成员函数queue来将前面获得的一个编号为bufIdx的UI元数据缓冲区加入到它的待渲染队列中去。不过，在加入这个编号为bufIdx的UI元数据缓冲区之前，函数还会分别调用成员变量mSharedBufferClient的成员函数setTransform、setCrop和setDirtyRegion来设置它的旋转方向、纹理坐标和裁剪区域等信息。这些信息分别保存在Surface类的成员变量mNextBufferTransform、mNextBufferCrop和mDirtyRegion中。注意，Surface类的成员变量mNextBufferTransform和mNextBufferCrop是由OpenGL库通过调用Surface类的成员函数perform来设置。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文可以知道，应用程序在请求SurfaceFlinger服务创建一个绘图表面的时候，会将用来描述这个绘图表面的一个Surface对象的成员函数perform设置为OpenGL库在画图的过程需要调用到的一个回调接口peform，这样做的目的就是为了可以设置绘图表面的元信息。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 将编号为bufIdx的UI元数据缓冲区加入到正在绘制的Surface的UI元数据缓冲区堆栈的待渲染队列之后，函数最后就会调用Surface类的成员变量mClient所描述的一个SurfaceClient对象的成员函数signalServer来通知SurfaceFlinger服务来相应的图形缓冲区渲染到设备显示屏上去。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们首先分析SharedBufferClient类的成员函数queue的实现，以便可以了解一个UI元数缓冲区是如何进入到一个UI元数据缓冲区堆栈的待渲染队列中去的，接着分析SurfaceClient类的成员函数signalServer的实现，以便可以了解应用程序是如何请求SurfaceFlinger服务渲染一个Surface的图形缓冲区的。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 2.&nbsp;SharedBufferClient.queue</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; "></p><pre name="code" class="cpp">status_t SharedBufferClient::queue(int buf)
{
    RWLock::AutoRLock _rd(mLock);

    SharedBufferStack&amp; stack( *mSharedStack );

    queued_head = (queued_head + 1) % mNumBuffers;
    stack.index[queued_head] = buf;

    QueueUpdate update(this);
    status_t err = updateCondition( update );
    LOGD_IF(DEBUG_ATOMICS, &quot;queued=%d, %s&quot;, buf, dump(&quot;&quot;).string());

    const nsecs_t now = systemTime(SYSTEM_TIME_THREAD);
    stack.stats.totalTime = ns2us(now - mDequeueTime[buf]);
    return err;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/surfaceflinger_client/SharedBufferStack.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SharedBufferClient类的成员变量mSharedStack是从父类SharedBufferBase继承下来的，它的成员变量index是一个类型为int8_t的数组，而这个数组就是用来描述一个UI元数据缓冲区堆栈的，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7867340">Android应用程序与SurfaceFlinger服务之间的共享UI元数据（SharedClient）的创建过程分析</a>一文。<br /></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>一文可以知道，SharedBufferClient类的成员变量queue_head指向了一个UI元数据缓冲区堆栈的待渲染队列的尾部，所有需要加入到这个待渲染队列的UI元数据缓冲都保存在queue_head的下一个位置上。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 参数buf描述的是要加入到当前正在绘制的Surface的UI元数据缓冲区堆栈的待渲染队列的缓冲区的编号，在将这个缓冲区加入到待渲染队列之后，还需要将这个待渲染队列的大小增加1，以便SurfaceFlinger服务可以知道一个Surface当前有多少个图形缓冲区是正在等待被渲染的。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>一文可以知道，一个UI元数据缓冲区堆栈的待渲染队列的大小保存在一个SharedBufferStack对象的成员变量queued中，而将这个待渲染队列的大小增加1的操作是通过调用用SharedBufferClient类从SharedBufferBase类继承下来的成员函数updateCondition来实现的。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数首先创建了一个QueueUpdate对象update，然后再以这个QueueUpdate对象update为参数，来调用SharedBufferClient从SharedBufferBase类继承下来的成员函数updateCondition，就可以将当前正在处理的一个UI元数据缓冲区堆栈的待渲染队列的大小增加1了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，就返回到Step 1中，即Surface类的成员函数queueBuffer中，这时候与需要渲染的图形缓冲区所对应的UI元数据缓冲区就加入到当前正在绘制的Surface的UI元数据缓冲区的待渲染队列中去了，接下来，应用程序就会调用SurfaceClient类的成员函数signalServer来请求SurfaceFlinger服务渲染这个Surface。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 3.&nbsp;SurfaceClient.signalServer</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">class SurfaceClient : public Singleton&lt;SurfaceClient&gt;
{
    // all these attributes are constants
    sp&lt;ISurfaceComposer&gt; mComposerService;
    ......

public:
    ......

    void signalServer() const {
        mComposerService-&gt;signal();
    }
};</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7867340">Android应用程序与SurfaceFlinger服务之间的共享UI元数据（SharedClient）的创建过程分析</a>一文可以知道，SurfaceClient类的成员变量mComposerService指向了一个实现了ISurfaceComposer接口的Binder代理对象，而这个Binder代理对象引用了系统中的SurfaceFlinger服务，因此，SurfaceClient类的成员函数signalServer实际上就是通过成员变量mComposerService的成员函数signal来通知SurfaceFlinger服务执行渲染Surface的操作。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;这一步执行完成之后，就会导致SurfaceFlinger类的成员函数signal被调用，接下来我们继续分析这个成员函数的实现。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;Step 4.&nbsp;SurfaceFlinger.signal</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void SurfaceFlinger::signal() const {
    // this is the IPC call
    const_cast&lt;SurfaceFlinger*&gt;(this)-&gt;signalEvent();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp文件中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;SurfaceFlinger服务是运行在System进程中的一个单独的线程中的。当SurfaceFlinger服务什么也不需要做的时候，它就会在这个线程中睡眠。由于现在有应用程序请求SurfaceFlinger服务执行渲染Surface的操作了，因此，就需要将这个线程唤醒起来了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;唤醒SurfaceFlinger服务所运行在的线程的操作是通过调用SurfaceFlinger类的成员函数signalEvent来实现的。当这个线程被唤醒之后，它就会继续执行SurfaceFlinger类的成员函数threadLoop来执行渲染Surface的操作。在后面的文章中，我们再详细分析SurfaceFlinger服务的实现，到时候就可以知道SurfaceFlinger服务的运行原理了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就从SurfaceFlinger类的成员函数threadLoop开始，分析SurfaceFlinger服务渲染Surface的图形缓冲区的过程。这里我们并不打算详细分析这个过程，而是粗略地分析，目的是为了理清一下思路，为后面从正面分析SurfaceFlinger服务的实现打下基础。这个过程如图4所示。</p><p style="text-align: center;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "><img src="http://img.my.csdn.net/uploads/201209/15/1347686845_7506.jpg" alt="" /><br /></p><p style="text-align: center;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">图 4 SurfaceFlinger服务渲染Surface的过程</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 这个过程一共分为6个步骤，接下来我们就详细分析每一个步骤。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 1. SurfaceFlinger.threadLoop</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">bool SurfaceFlinger::threadLoop()
{
    waitForEvent();

    ......

    // post surfaces (if needed)
    handlePageFlip();

    const DisplayHardware&amp; hw(graphicPlane(0).displayHardware());
    if (LIKELY(hw.canDraw() &amp;&amp; !isFrozen())) {

        ......

        // repaint the framebuffer (if needed)
        const int index = hw.getCurrentBufferIndex();
        GraphicLog&amp; logger(GraphicLog::getInstance());

        logger.log(GraphicLog::SF_REPAINT, index);
        handleRepaint();

        // inform the h/w that we're done compositing
        logger.log(GraphicLog::SF_COMPOSITION_COMPLETE, index);
        hw.compositionComplete();

        logger.log(GraphicLog::SF_SWAP_BUFFERS, index);
        postFramebuffer();

        logger.log(GraphicLog::SF_REPAINT_DONE, index);
    } else {
        // pretend we did the post
        hw.compositionComplete();
        usleep(16667); // 60 fps period
    }
    return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp文件中。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 在SurfaceFlinger服务中，每一个Surface，或者说每一个Layer，都有自己的一系列图形缓冲区。而对于每一个Surface来说，它们各自需要渲染的图形缓冲区都保存在内部的一个UI元数据缓冲区堆栈的待渲染队列中。当SurfaceFlinger服务需要渲染系统的UI时，首先就会将各个Surface的UI元数据缓冲区堆栈的待渲染队列的缓冲区逐个取出来，并且找到对应的图形缓冲区，接着再将这些图形缓冲区合成在一起渲染到硬件帧缓冲区fb上，最后我们就可以在设备显示屏上看到系统的UI了。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;了解了这个背景知识之后，接下来我们就简要描述SurfaceFlinger类的成员函数threadLoop的工作过程：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;1. 在SurfaceFlinger类的成员函数waitForEvent中等待。一旦SurfaceFlinger类的成员函数signalEvent被调用，那么SurfaceFlinger服务所运行的线程就会被唤醒。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;2. 调用SurfaceFlinger类的成员函数handlePageFlip将各个Surface的UI元数据缓冲区堆栈的待渲染队列头部的缓冲区取出来，并且找到对应的图形缓冲区。这些图缓冲区就是接下来要被合成和渲染的。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;3. 调用SurfaceFlinger类的成员函数handleRepaint来合成第2步得到的图形缓冲区。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;4. SurfaceFlinger服务使用一个DisplayHardware对象hw来描述系统当前所使用的显示屏，这个DisplayHardware对象hw实际就是用来封装对硬件帧缓冲区fb的访问的，第3步就是将各个图形缓冲区的内容合成到这个DisplayHardware对象hw中去。合成完成之后，就会调用这个DisplayHardware对象hw的成员函数compositionComplete来通知HAL层Gralloc模块中的fb设备。这一步是可选的，即HAL层Gralloc模块中的fb设备可以忽略掉这个合成完成通知。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;5. 调用SurfaceFlinger类的成员函数postFramebuffer来将产须合成好的图形缓冲区渲染到硬件帧缓冲区fb上去。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;这里我们只关注第2步的实现，以后分析SurfaceFlinger服务的实现时，再分析其它步骤的实现。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;Step 2.&nbsp;SurfaceFlinger.handlePageFlip</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void SurfaceFlinger::handlePageFlip()
{
    bool visibleRegions = mVisibleRegionsDirty;
    LayerVector&amp; currentLayers = const_cast&lt;LayerVector&amp;&gt;(
            mDrawingState.layersSortedByZ);
    visibleRegions |= lockPageFlip(currentLayers);

        const DisplayHardware&amp; hw = graphicPlane(0).displayHardware();
        const Region screenRegion(hw.bounds());
        if (visibleRegions) {
            Region opaqueRegion;
            computeVisibleRegions(currentLayers, mDirtyRegion, opaqueRegion);

            /*
             *  rebuild the visible layer list
             */
            mVisibleLayersSortedByZ.clear();
            const LayerVector&amp; currentLayers(mDrawingState.layersSortedByZ);
            size_t count = currentLayers.size();
            mVisibleLayersSortedByZ.setCapacity(count);
            for (size_t i=0 ; i&lt;count ; i++) {
                if (!currentLayers[i]-&gt;visibleRegionScreen.isEmpty())
                    mVisibleLayersSortedByZ.add(currentLayers[i]);
            }

         ......

         mWormholeRegion = screenRegion.subtract(opaqueRegion);
            mVisibleRegionsDirty = false;
        }

    unlockPageFlip(currentLayers);
    mDirtyRegion.andSelf(screenRegion);
}</pre><p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp文件中。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger服务将系统中的各个Surface按照其Z轴大小排列在SurfaceFlinger类的成员变量mDrawingState内部的一个layersSortedByZ列表中。函数首先将这个Surface列表layersSortedByZ取出来，并且调用SurfaceFlinger类的另外一个成员函数lockPageFlip来将各个Surface当前需要渲染的图形缓冲区取出来。<br /></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 如果SurfaceFlinger服务确实需要执行渲染图形缓冲区的操作，那么SurfaceFlinger类的成员函数lockPageFlip的返回值就会等于true。在这种情况下，函数接下来主要就是调用SurfaceFlinger类的成员函数computeVisibleRegions来计算需要渲染的各个Surface的可见区域，以便后面可以正确地将它们的UI绘制出来。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们只关注SurfaceFlinger类的成员函数lockPageFlip的实现，以便可以了解SurfaceFlinger服务是如何将各个Surface当前需要渲染的图形缓冲区取出来的。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 3.&nbsp;SurfaceFlinger.lockPageFlip</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">bool SurfaceFlinger::lockPageFlip(const LayerVector&amp; currentLayers)
{
    bool recomputeVisibleRegions = false;
    size_t count = currentLayers.size();
    sp&lt;LayerBase&gt; const* layers = currentLayers.array();
    for (size_t i=0 ; i&lt;count ; i++) {
        const sp&lt;LayerBase&gt;&amp; layer(layers[i]);
        layer-&gt;lockPageFlip(recomputeVisibleRegions);
    }
    return recomputeVisibleRegions;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp文件中。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 保存在Surface列表currentLayers中的Surface有可能是一个Layer对象，也有可能一个是LayerBlur对象或者一个LayerDim对象等。这里我们只关心类型为Layer的Surface的图形缓冲区是如何取出来渲染的，这是通过调用Layer类的成员函数lockPageFlip来实现的。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 4. Layer.lockPageFlip</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void Layer::lockPageFlip(bool&amp; recomputeVisibleRegions)
{
    ClientRef::Access sharedClient(mUserClientRef);
    SharedBufferServer* lcblk(sharedClient.get());
    ......

    ssize_t buf = lcblk-&gt;retireAndLock();
    ......

    // we retired a buffer, which becomes the new front buffer
    if (mBufferManager.setActiveBufferIndex(buf) &lt; NO_ERROR) {
        ......
        return;
    }

    sp&lt;GraphicBuffer&gt; newFrontBuffer(getBuffer(buf));
    if (newFrontBuffer != NULL) {
        // get the dirty region
        // compute the posted region
        const Region dirty(lcblk-&gt;getDirtyRegion(buf));
        mPostedDirtyRegion = dirty.intersect( newFrontBuffer-&gt;getBounds() );
 
        ......

        // get the crop region
        setBufferCrop( lcblk-&gt;getCrop(buf) );

        // get the transformation
        setBufferTransform( lcblk-&gt;getTransform(buf) );

    } 
    ......

    if (lcblk-&gt;getQueuedCount()) {
        // signal an event if we have more buffers waiting
        mFlinger-&gt;signalEvent();
    }

    ......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/Layer.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文可以知道，Layer类的成员变量mUserClientRef指向了一个ClientRef对象，通过这个ClientRef对象可以获得一个SharedBufferServer对象lcblk。有了SharedBufferServer对象lcblk之后，函数就可以调用它的成员函数retireAndLock来从它所描述的UI元数据缓冲区堆栈的待渲染队列中取出一个缓冲区来，以便接下来可以找到对应的图形缓冲区来渲染。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 注意，调用SharedBufferServer对象lcblk的成员函数retireAndLock得到的是一个UI元数据缓冲区的编号，这个编号保存在变量buf中。函数接下来就会调用Layer类的成员变量mBufferManager所描述的一个BufferManager对象的成员函数setActiveBufferIndex来将这个编号为buf的图形缓冲区设置当前激活的图形缓冲区，即接下来要被SurfaceFlinger服务渲染的图形缓冲区。前面在分析空闲UI元数据缓冲区及其图形缓冲区的分配过程的Step 10时提到，每一个分配的图形缓冲区都关联有一个编号，而这个编号正好就是一个对应的UI元数据缓冲区的编号。因此，知道了一个UI元数据缓冲区的编号之后，就可以找到对应的图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数接下来还会通过SharedBufferServer对象lcblk的成员函数getDirtyRegion、getCrop和getTransform来获得当前激活的图形缓冲区的元信息，即裁剪区域、纹理坐标和旋转方向。这些元信息是在前面分析UI元数据缓冲区进入待渲染队列的过程的Step 1中提供的，因此，这里就可以将它们获取回来。后面在渲染当前激活的图形缓冲区时，就需要使用到这些元信息。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 最后，函数调用SharedBufferServer对象lcblk的成员函数getQueueCount来检查待渲染待队列中的缓冲区的个数是否大于0。如果大于0，那么就说明还有图形缓冲区在等待被渲染。在这种情况下，函数就就会继续调用Layer类的成员变量mFlinger的成员函数signalEvent来通知SurfaceFlinger服务在执行完成当前这次的Surface渲染操作之后，接着要马上进行下一次的Surface渲染操作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们首先分析SharedBufferServer类的成员函数retireAndLock的实现，以便可以了解SurfaceFlinger服务是如何从一个Surface的UI元数据缓冲区堆栈的待渲染队列中取出一个缓冲区编号的，接着再分析BufferManager类的成员函数setActiveBufferIndex的实现，以便可以了解一个图形缓冲区是如何被设置为一个Surface的当前激活的图形缓冲区的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 5.&nbsp;SharedBufferServer.retireAndLock</p><p></p><pre name="code" class="cpp">ssize_t SharedBufferServer::retireAndLock()
{
    RWLock::AutoRLock _l(mLock);

    RetireUpdate update(this, mNumBuffers);
    ssize_t buf = updateCondition( update );
    if (buf &gt;= 0) {
        if (uint32_t(buf) &gt;= SharedBufferStack::NUM_BUFFER_MAX)
            return BAD_VALUE;
        SharedBufferStack&amp; stack( *mSharedStack );
        buf = stack.index[buf];
        LOGD_IF(DEBUG_ATOMICS &amp;&amp; buf&gt;=0, &quot;retire=%d, %s&quot;,
                int(buf), dump(&quot;&quot;).string());
    }
    return buf;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/libs/surfaceflinger_client/SharedBufferStack.cpp中。<p></p><p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数首先创建了一个RetireUpdate对象update，然后再调用SharedBufferServer从SharedBufferBase类继承下来的成员函数updateCondition来获得当前正在使用的UI元数据缓冲区堆栈的待渲染队列头部的缓冲区在堆栈中的位置值buf。有了这个位置值buf之后，函数再接下来就可以从用来描述当前正在使用的UI元数据缓冲区堆栈的一个index数组中获得一个对应的缓冲区的编号。这个编号即为待渲染队列头部的UI元数据缓冲区的编号，因此，函数最后就可以将它返回给调用者。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，就返回到Step 4中，即Layer类的成员函数lockPageFlip中，这时候SurfaceFlinger服务就可以就为当前正在处理的Surface设置当前激活的图形缓冲区了，这是通过调用BufferManager类的成员函数setActiveBufferIndex来实现的。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 6.&nbsp;BufferManager.setActiveBufferIndex</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">status_t Layer::BufferManager::setActiveBufferIndex(size_t index) {
    mActiveBuffer = index;
    return NO_ERROR;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/Layer.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;BufferManager类的成员变量mActiveBuffer用来描述一个Surface的当前激活的图形缓冲区的编号。由于参数index正好就是描述一个Surface的当前激活的图形缓冲区的编号，因此，函数就可以将它保存在BufferManager类的成员变量mActiveBuffer中。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 前面在分析空闲UI元数据缓冲区及其图形缓冲区的分配过程的Step 10时提到，BufferManager类有一个类型BufferData数组的成员变量mBufferData，它里面保存了SurfaceFlinger服务为一个Surface所分配的图形缓冲区，这样，后面SurfaceFlinger服务在渲染一个Surface时，就可以通过与它所关联的一个BufferManager对象的成员变量mActiveBuffer来在另外一个成员变量mBufferData中找到当前激活的图形缓冲区。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，SurfaceFlinger服务渲染Surface的图形缓冲区的过程就分析完成了。这个过程虽然只是一个粗略的过程，但是已经足够我们理解Android应用程序请求SurfaceFlinger服务渲染Surface的过程了，同时也为后面我们从正面分析SurfaceFlinger服务的实现原理理清了思路，以及打下了良好的基础。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 至此，Android应用程序和SurfaceFlinger服务的关系我们就学习完成了。要重新学习，请参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>一文。接下来，我们还会继续分析SurfaceFlinger服务的实现原理，敬请关注！</p><p style="text-align: center; margin: 4px 0px; padding: 2px 0px;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-9-17 0:56:30 <a href="http://blog.csdn.net/luoshengyang/article/details/7932268">原文链接</a>
            </div>
            <div>
            阅读：20701 评论：27 <a href="http://blog.csdn.net/luoshengyang/article/details/7932268#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8010977</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8010977</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-9-26 0:55:32</pubDate>
        <description><![CDATA[
            <p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面我们从Android应用程序与SurfaceFlinger服务的关系出发，从侧面简单学习了SurfaceFlinger服务。有了这些预备知识之后，我们就可以从正面来分析SurfaceFlinger服务的实现原理了。SurfaceFlinger服务负责管理系统的帧缓冲区设备，并且负责渲染系统的UI，即各个应用程序的UI。在本文中，我们就简要介绍SurfaceFlinger服务，并且制定学习计划。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>一系列的文章中提到，SurfaceFlinger服务运行在System进程中，用来统一管理系统的帧缓冲区设备。由于SurfaceFlinger服务运行在System进程中，因此，Android应用程序就需要通过Binder进程间通信机制来请求它来渲染自己的UI。Android应用程序请求SurfaceFlinger服务渲染自己的UI可以分为三步曲：首先是创建一个到SurfaceFlinger服务的连接，接着再通过这个连接来创建一个Surface，最后请求SurfaceFlinger服务渲染该Surface。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 由于SurfaceFlinger服务需要与Android应用程序执行Binder进程间通信，因此，它本身就是一个Binder本地对象，如图1所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201209/23/1348412121_8769.jpg" alt="" /><br /></p><p style="text-align: center;">图1 SurfaceFlinger服务的类关系图</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;理解这个图需要学习Binder进程间通信机制，具体可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/6618363">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>这一系列的文章。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger服务实现的接口为ISurfaceComposer，后者定义在文件frameworks/base/include/surfaceflinger/ISurfaceComposer.h中，如下所示：<br /></p><p style="text-align: left;"></p><pre name="code" class="cpp">class ISurfaceComposer : public IInterface
{
public:
    DECLARE_META_INTERFACE(SurfaceComposer);
    ......

    /* create connection with surface flinger, requires
     * ACCESS_SURFACE_FLINGER permission
     */
    virtual sp&lt;ISurfaceComposerClient&gt; createConnection() = 0;

    /* create a client connection with surface flinger
     */
    virtual sp&lt;ISurfaceComposerClient&gt; createClientConnection() = 0;

    /* retrieve the control block */
    virtual sp&lt;IMemoryHeap&gt; getCblk() const = 0;

    /* open/close transactions. requires ACCESS_SURFACE_FLINGER permission */
    virtual void openGlobalTransaction() = 0;
    virtual void closeGlobalTransaction() = 0;

    /* [un]freeze display. requires ACCESS_SURFACE_FLINGER permission */
    virtual status_t freezeDisplay(DisplayID dpy, uint32_t flags) = 0;
    virtual status_t unfreezeDisplay(DisplayID dpy, uint32_t flags) = 0;

    /* Set display orientation. requires ACCESS_SURFACE_FLINGER permission */
    virtual int setOrientation(DisplayID dpy, int orientation, uint32_t flags) = 0;

    /* signal that we're done booting.
     * Requires ACCESS_SURFACE_FLINGER permission
     */
    virtual void bootFinished() = 0;

    /* Capture the specified screen. requires READ_FRAME_BUFFER permission
     * This function will fail if there is a secure window on screen.
     */
    virtual status_t captureScreen(DisplayID dpy,
            sp&lt;IMemoryHeap&gt;* heap,
            uint32_t* width, uint32_t* height, PixelFormat* format,
            uint32_t reqWidth, uint32_t reqHeight) = 0;

    virtual status_t turnElectronBeamOff(int32_t mode) = 0;
    virtual status_t turnElectronBeamOn(int32_t mode) = 0;

    /* Signal surfaceflinger that there might be some work to do
     * This is an ASYNCHRONOUS call.
     */
    virtual void signal() const = 0;
};</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ISurfaceComposer接口有13个成员函数，下面我们就简单介绍一下：<p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; <strong>&nbsp;--createConnection</strong>：Android应用程序通过它来请求SurfaceFlinger服务建立一个连接，具体可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/7857163">Android应用程序与SurfaceFlinger服务的连接过程分析</a>一文。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--createClientConnection</strong>：Android应用程序通过它来请求SurfaceFlinger服务创建一块共享UI元数据缓冲区，具体可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/7867340">Android应用程序与SurfaceFlinger服务之间的共享UI元数据（SharedClient）的创建过程分析</a>一文。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--getCblk</strong>：Android应用程序通过它来请求SurfaceFlinger服务返回一块匿名共享内存，返回的匿名共享内存包含了设备显示屏的信息，例如，宽度和高度信息。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--openGlobalTransaction</strong>：Android应用程序通过它请求SurfaceFlinger服务来增加一个全局Transaction计数，用来批量修改UI属性信息。注意，这些被修改的UI属性信息会被缓存起来，不会马上生效。要使得这些被修改的UI属性信息生效，需要调用另外一个成员函数closeGlobalTransaction，如下所述。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; <strong>&nbsp;--closeGlobalTransaction</strong>：Android应用程序通过它请求SurfaceFlinger服务来减少一个全局Transaction计数。当这个全局Transaction计数减少至0的时候，前面通过openGlobalTransaction来请求修改的UI属性信息就会马上生效。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--freezeDisplay</strong>：Android应用程序通过它来请求SurfaceFlinger服务来冻结屏幕。屏幕在被冻结期间，所有UI渲染操作都会被缓存起来，等待被执行。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--unfreezeDisplay</strong>：Android应用程序通过它来请求SurfaceFlinger服务来解冻屏幕。屏幕被解冻之后，SurfaceFlinger服务就可以执行UI渲染操作了。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--setOrientation</strong>：Android应用程序通过它来请求SurfaceFlinger服务设备屏幕的旋转方向。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--bootFinished</strong>：WindowManagerService通过它来告诉SurfaceFlinger服务，系统启动完成了，这时候SurfaceFlinger服务就会停止执行开机动画，具体可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/7691321">Android系统的开机画面显示过程分析</a>一文。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--captureScreen</strong>：Android应用程序通过它来请求SurfaceFlinger服务截取屏幕图像。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; <strong>&nbsp;--turnElectronBeamOff</strong>：Android应用程序通过它来请求SurfaceFlinger服务关闭屏幕。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--turnElectronBeamOn</strong>：Android应用程序通过它来请求SurfaceFlinger服务点亮屏幕。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--signal</strong>：Android应用程序通过它来请求SurfaceFlinger服务渲染UI，具体可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;理解了ISurfaceComposer接口的定义之后，我们再来看SurfaceFlinger服务的Binder代理对象BpSurfaceComposer的实现，如图2所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201209/23/1348414268_2639.jpg" alt="" /><br /></p><p style="text-align: center;">图2 SurfaceFlinger服务的Binder代理对象的类关系图</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;理解这个图同样需要学习Binder进程间通信机制，具体可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/6618363">Android进程间通信（IPC）机制Binder简要介绍和学习计划</a>这一系列的文章。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Android应用程序获得了SurfaceFlinger服务的一个Binder代理对象，即一个BpSurfaceComposer对象之后，就可以请求SurfaceFlinger服务来创建以及渲染自己的UI了。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们再简单介绍一下SurfaceFlinger类的定义，如图3所示：</p><p style="text-align: center;"><img width="708" src="http://img.my.csdn.net/uploads/201209/24/1348416965_5567.jpg" alt="" /><br /></p><p style="text-align: center;">图3 SurfaceFlinger类的定义</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类有两个类型为State的成员变量mCurrentState和mDrawingState。其中，成员变量mCurrentState用来描述系统下一次要渲染的UI的状态；而mDrawingState用来描述当前正要渲染的UI的状态。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;State类用来描述一个UI状态，它有四个重要的成员变量layersSortedByZ、orientation、orientationType和freezeDisplay。其中，成员变量layersSortedByZ是一个类型为LayerVector的向量，里面保存的系统所包含的Surface，每一个Surface使用一个LayerBase对象来描述，并且它们按照 Z轴顺序来排列；成员变量orientation和orientationType的类型均为uint8_t，它们用来描述屏幕的方向； 成员变量freezeDisplay的类型也是uint8_t，用来描述屏幕是否处于被冻结状态。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员变量mVisibleLayerSortedByZ是一个类型为sp&lt;LayerBase&gt;的Vector，它是用来保存SurfaceFlinger服务下一次要渲染的、处于可见状态的Surface的，它们是来自SurfaceFlinger类的成员变量mDrawingState所描述的一个State对象的成员变量layersSortedByZ的。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员变量mGraphicPlanes是一个类型为GraphicPlane的数组，它是用来描述系统所有的显示设备的。从这个数组的大小等于1可以知道，当前Android系统只支持一个显示设备。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;GraphicPlane类有四个重要的成员变量mHw、mOrientation、mWidth和mHeight。其中，成员变量mHw指向一个DisplayHardware对象，用来描述一个硬件显示设备；成员变量mOrientation、mWidth和mHeight的类型均为int，分别用来描述一个硬件显示设备的旋转方向、宽度和高度。我们可以通过调用GraphicPlane类的成员函数setDisplayHardware和displayHardware来设备和获取一个GraphicPlane对象内部所包含的一个硬件显示设备。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DisplayHardware类有一个重要的成员变量mNativeWindow，它是一个类型为FramebufferNativeWindow的强指针。FramebufferNativeWindow类是用来描述一个Android系统本地窗口，而这个窗口代表的是系统的硬件帧缓冲区。DisplayHardware类的成员函数flip是用来渲染系统UI的，即将后端的图形缓冲区翻转为前端的图形缓冲区，并且渲染在硬件帧缓冲区去。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;FramebufferNativeWindow类与在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文中所介绍的Surface类的作用是一样的，即它是OpenGL库和Android的UI系统之间的一个桥梁。OpenGL库正是通过它的成员函数dequeueBuffer来获得一个用来填充UI数据的图形缓冲区，而通过它的成员函数queueBuffer来将一个已经填充好UI数据的图形缓冲区渲染到系统的帧缓冲区中去。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;FramebufferNativeWindow类有三个重要的成员变量fbDev、grDev和buffers。其中，成员变量fbDev和grDev分别指向一个framebuffer_device_t设备和一个alloc_device_t设备。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文可以知道，framebuffer_device_t设备和一个alloc_device_t设备是由HAL模块Gralloc来提供的，它们分别用来分配图形缓冲区和渲染图形缓冲区；成员变量buffers是一个类型为NativeBuffer的数组，这个数组用来描述一个图形缓冲区堆栈，堆栈的大小为NUM_FRAME_BUFFERS，这些图形缓冲区是直接在硬件帧缓冲区中分配的，有别于Surface类所使用的图形缓冲区，因为后者所使用的图形缓冲区是在匿名共享内存分配的。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;了解了SurfaceFlinger类的重要成员变量之后，我们再来了解它的几个重要成员函数threadLoop、waitForEvent、signalEvent、handleConsoleEvents、handleTransaction、handlePageFlip、handleRepaint和postFramebuffer。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceFlinger服务虽然是在System进程中启动的，但是它在启动的时候创建一个线程来专门负责渲染UI。为了方便描述，我们将这个线程称为UI渲染线程。UI渲染线程的执行函数就为SurfaceFlinger类的成员函数threadLoop，同时它有一个消息队列。当UI渲染线程不需要渲染UI时，它就会在SurfaceFlinger类的成员函数waitForEvent中睡眠等待，直到SurfaceFlinger服务需要执行新的UI渲染操作为止。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceFlinger服务什么时候会需要执行新的UI渲染操作呢？当系统显示屏属性发生变化，或者应用程序窗口发生变化时，它就需要重新渲染系统的UI。这时候SurfaceFlinger服务就会从SurfaceFlinger类的成员函数waitEvent中唤醒，并且依次执行SurfaceFlinger类的成员函数handleConsoleEvents、handleTransaction、handlePageFlip、handleRepaint和postFramebuffer来具体执行渲染UI的操作。其中，成员函数handleConsoleEvents用来处理控制台事件；成员函数handleTransaction用来处理系统显示屏属性变化以及应用程序窗口属性变化；成员函数handlePageFlip用来获得应用程序窗口下一次要渲染的图形缓冲区，即设置应用程序窗口的活动图形缓冲区；成员函数handleRepaint用来重绘应用程序窗口；成员函数postFramebuffer用来将系统UI渲染到硬件帧缓冲区中去。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 我们知道，应用程序是运行在与SurfaceFlinger服务不同的进程中的，而从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文又可以知道，每当应用程序需要更新自己的UI时，它们就会通过Binder进程间通信机制来通知SurfaceFlinger服务。SurfaceFlinger服务接到这个通知之后，就会调用SurfaceFlinger类的成员函数signalEvent来唤醒UI渲染线程，以便它可以执行渲染UI的操作。注意，SurfaceFlinger服务是通过Binder线程来获得应用程序的请求的，因此，这时候SurfaceFlinger服务的UI渲染线程实际上是被Binder线程唤醒的。SurfaceFlinger类的成员函数signalEvent实际上是通过向UI渲染线程的消息队列发送一个类型为INVALIDATE的消息来唤醒UI渲染线程的。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 前面提到，&nbsp;SurfaceFlinger服务在在执行UI渲染操作时，需要调用SurfaceFlinger类的成员函数handleConsoleEvents来处理控制台事件。这怎么理解呢？原来，SurfaceFlinger服务在启动的时候，还会创建另外一个线程来监控由内核发出的帧缓冲区硬件事件。为了方便描述，我们将这个线程称为控制台事件监控线程。每当帧缓冲区要进入睡眠状态时，内核就会发出一个睡眠事件，这时候SurfaceFlinger服务就会执行一个释放屏幕的操作；而当帧缓冲区从睡眠状态唤醒时，内核就会发出一个唤醒事件，这时候SurfaceFlinger服务就会执行一个获取屏幕的操作。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 这样，我们就简要介绍完了SurfaceFlinger类的定义。从这些介绍可以知道：</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 1. SurfaceFlinger服务通过一个GraphicPlane对象来管理系统的显示设备；</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 2.&nbsp;SurfaceFlinger服务有三种类型的线程，它们分别是Binder线程、控制台事件监控线程和UI渲染线程；</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 3.&nbsp;SurfaceFlinger服务是在UI渲染线程中执行渲染系统UI的操作的。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 围绕上述三个内容，再结合SurfaceFlinger服务的启动过程，接下来我们再通过以下四篇文章来系统地学习SurfaceFlinger服务的实现原理：</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 1. &nbsp;<a href="http://blog.csdn.net/luoshengyang/article/details/8022957">SurfaceFlinger服务是如何启动的？</a></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 2. &nbsp;<a href="http://blog.csdn.net/luoshengyang/article/details/8046659">SurfaceFlinger服务是如何通过GraphicPlane、DisplayHardware和FramebufferNativeWindow三个类来管理系统的显示设备的</a>？</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;3. &nbsp;<a href="http://blog.csdn.net/luoshengyang/article/details/8062945">SurfaceFlinger服务的三个线程的协作模型是如何的</a>？</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 4. &nbsp;<a href="http://blog.csdn.net/luoshengyang/article/details/8079456">SurfaceFlinger服务是如何在UI渲染线程中执行UI渲染操作的</a>？</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 结合前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>的一系列文章，以及上述四篇文章，相信我们就可以对SurfaceFlinger服务有一个清晰的认识了，敬请关注！</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-9-26 0:55:32 <a href="http://blog.csdn.net/luoshengyang/article/details/8010977">原文链接</a>
            </div>
            <div>
            阅读：8558 评论：9 <a href="http://blog.csdn.net/luoshengyang/article/details/8010977#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android系统Surface机制的SurfaceFlinger服务的启动过程分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8022957</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8022957</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-9-29 14:48:05</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面一篇文章中，我们简要介绍了</span><span style="color:black;">Android</span><span style="color:black;">系统</span><span style="color:black;">Surface</span><span style="color:black;">机制中的</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务。</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务是在</span><span style="color:black;">System</span><span style="color:black;">进程中启动的，并且负责统一管理设备的帧缓冲区。</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务在启动的过程中，会创建两个线程，其中一个线程用来监控控制台事件，而另外一个线程用来渲染系统的</span><span style="color:black;">UI</span><span style="color:black;">。在本文中，我们就将详细分析</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务的启动过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6768304">Android系统进程Zygote启动过程的源代码分析</a>一文可以知道，<span style="color: black; ">System</span><span style="color: black; ">进程是由Zygote进程启动的，并且是以Java层的SystemServer类的静态成员函数main为入口函数的。因此，接下来我们就从SystemServer类的静态成员函数main开始，分析<span style="color: black; ">SurfaceFlinger</span><span style="color: black; ">服务的启动过程，如图1所示。</span></span></span></p><p style="text-align: center;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><img src="http://img.my.csdn.net/uploads/201209/27/1348676798_2147.jpg" alt="" /><br /></span></span></span></p><p style="text-align: center;"><span style="color:black;"><span style="color: black; "><span style="color: black; ">图1 SurfaceFlinger服务的启动过程</span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<span style="color: black; ">SurfaceFlinger</span><span style="color: black; ">服务的启动过程可以划分为8个步骤，接下来我们就详细分析每一个步骤。</span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 1. SystemServer.main</span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "></span></span></span></span></p><pre name="code" class="java">public class SystemServer
{
    ......

    native public static void init1(String[] args);

    public static void main(String[] args) {
        ......

        System.loadLibrary(&quot;android_servers&quot;);
        init1(args);
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/SystemServer.java中。<p></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SystemServer类的静态成员函数main首先将android_servers库加载到System进程中来，接着调用另外一个静态成员函数init1来启动那些使用C++语言来实现的系统服务。</span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SystemServer类的静态成员函数init1是一个JNI方法，它是由C++层的函数android_server_SystemServer_init1来实现的，接下来我们就继续分析它的实现。</span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2.&nbsp;SystemServer.init1</span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "></span></span></span></span></p><pre name="code" class="cpp">static void android_server_SystemServer_init1(JNIEnv* env, jobject clazz)
{
    system_init();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/jni/com_android_server_SystemServer.cpp&nbsp;中。<p></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SystemServer类的静态成员函数init1调用另外一个函数system_init来启动那些使用C++语言来实现的系统服务，它的实现在文件frameworks/base/cmds/system_server/library/system_init.cpp中，如下所示：</span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "></span></span></span></span></p><pre name="code" class="cpp">extern &quot;C&quot; status_t system_init()
{
    LOGI(&quot;Entered system_init()&quot;);

    sp&lt;ProcessState&gt; proc(ProcessState::self());
    ......

    char propBuf[PROPERTY_VALUE_MAX];
    property_get(&quot;system_init.startsurfaceflinger&quot;, propBuf, &quot;1&quot;);
    if (strcmp(propBuf, &quot;1&quot;) == 0) {
        // Start the SurfaceFlinger
        SurfaceFlinger::instantiate();
    }

    ......

    if (proc-&gt;supportsProcesses()) {
        LOGI(&quot;System server: entering thread pool.\n&quot;);
        ProcessState::self()-&gt;startThreadPool();
        IPCThreadState::self()-&gt;joinThreadPool();
        LOGI(&quot;System server: exiting thread pool.\n&quot;);
    }
    return NO_ERROR;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 函数首先获得System进程中的一个ProcessState单例，并且保存在变量proc中，后面会通过调用它的成员函数supportsProcesses来判断系统是否支持Binder进程间通信机制。我们知道，在Android系统中，每一个需要使用Binder进程间通信机制的进程内部都有一个ProcessState单例，它是用来和Binder驱动程序建立连接的，具体可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/6627260">Android系统进程间通信（IPC）机制Binder中的Server启动过程源代码分析</a>一文。<p></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数接下来就检查系统中是否存在一个名称为“system_init.startsurfaceflinger”的属性。如果存在的话，就将它的值获取回来，并且保存在缓冲区proBuf中。如果不存在的话，那么函数property_get就会将缓冲区proBuf的值设置为“1”。当缓冲区proBuf的值等于“1”的时候，就表示需要在System进程中将SurfaceFlinger服务启动起来，这是通过调用SurfaceFlinger类的静态成员函数instantiate来实现的。</span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数最后检查系统是否支持Binder进程间通信机制。如果支持的话，那么接下来就会调用当前进程中的ProcessState单例的成员函数startThreadPool来启动一个Binder线程池，并且调用当前线程中的IPCThreadState单例来将当前线程加入到前面所启动的Binder线程池中去。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6768304">Android系统进程Zygote启动过程的源代码分析</a>和<a href="http://blog.csdn.net/luoshengyang/article/details/6747696">Android应用程序进程启动过程的源代码分析</a>两篇文章可以知道，System进程前面在初始化运行时库的过程中，已经调用过当前进程中的ProcessState单例的成员函数startThreadPool来启动Binder线程池了，因此，这里其实只是将当前线程加入到这个Binder线程池中去。有了这个Binder线程池之后，SurfaceFlinger服务在启动完成之后，就可以为系统中的其他组件或者进程提供服务了。</span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 假设系统存在一个名称为“system_init.startsurfaceflinger”的属性，并且它的值等于“1”，接下来我们就继续分析SurfaceFlinger类的静态成员函数instantiate的实现，以便可以了解SurfaceFlinger服务的启动过程。</span></span></span></span>由于SurfaceFlinger类的静态成员函数instantiate是从父类BinderService继承下来的，因此，接下来我们要分析的实际上是BinderService类的静态成员函数instantiate的实现。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; Step 3.&nbsp;BinderService.instantiate</p><p style="text-align: left;"></p><pre name="code" class="cpp">template&lt;typename SERVICE&gt;
class BinderService
{
public:
    ......

    static void instantiate() { publish(); }

    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/include/binder/BinderService.h中。<p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;BinderService类的静态成员函数instantiate的实现很简单，它只是调用BinderService类的另外一个静态成员函数publish来继续执行启动SurfaceFlinger服务的操作。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; Step 4.&nbsp;BinderService.publish</p><p style="text-align: left;"></p><pre name="code" class="cpp">template&lt;typename SERVICE&gt;
class BinderService
{
public:
    static status_t publish() {
        sp&lt;IServiceManager&gt; sm(defaultServiceManager());
        return sm-&gt;addService(String16(SERVICE::getServiceName()), new SERVICE());
    }

    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/include/binder/BinderService.h中。<p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;BinderService是一个模板类，它有一个模板参数SERVICE。当BinderService类被SurfaceFlinger类继承时，模板参数SERVICE的值就等于SurfaceFlinger。因此，BinderService类的静态成员函数publish所执行的操作就是创建一个SurfaceFlinger实例，用来作为系统的SurfaceFlinger服务，并且将这个服务注册到Service Manager中去，这样系统中的其它组件或者进程就可以通过Service Manager来获得SurfaceFlinger服务的Binder代理对象，进而使用它所提供的服务。Binder进程间通信机制中的服务对象的注册过程可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/6629298">Android系统进程间通信（IPC）机制Binder中的Server启动过程源代码分析</a>一文。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析SurfaceFlinger服务的创建过程。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; Step 5. new&nbsp;SurfaceFlinger<br /></p><pre name="code" class="cpp">SurfaceFlinger::SurfaceFlinger()
    :   BnSurfaceComposer(), Thread(false),
        ......
{
    init();
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8010977">Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划</a>一文可以知道，SurfaceFlinger类继承了BnSurfaceComposer类，而后者是一个实现了ISurfaceComposer接口的Binder本地对象类。此外，SurfaceFlinger类还继承了Thread类，后者是用来创建一个线程的，这个线程就是我们在<a href="http://blog.csdn.net/luoshengyang/article/details/8010977">Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划</a>一文中提到的UI渲染线程，它的线程执行体函数为SurfaceFlinger类的成员函数threadLoop。后面在分析SurfaceFlinger服务渲染UI的过程时，我们再分析SurfaceFlinger类的成员函数threadLoop的实现。注意，在初始化SurfaceFlinger的父类Thread时，传进去的参数为false，表示先不要将SurfaceFlinger服务的UI渲染线程启动起来，等到后面再启动。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceFlinger服务在创建的过程中，会调用SurfaceFlinger类的成员函数init来执行初始化的操作，接下来，我们就继续分析它的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 6.&nbsp;SurfaceFlinger.init</p><p></p><pre name="code" class="cpp">void SurfaceFlinger::init()
{
    LOGI(&quot;SurfaceFlinger is starting&quot;);

    // debugging stuff...
    char value[PROPERTY_VALUE_MAX];
    property_get(&quot;debug.sf.showupdates&quot;, value, &quot;0&quot;);
    mDebugRegion = atoi(value);
    property_get(&quot;debug.sf.showbackground&quot;, value, &quot;0&quot;);
    mDebugBackground = atoi(value);

    LOGI_IF(mDebugRegion,       &quot;showupdates enabled&quot;);
    LOGI_IF(mDebugBackground,   &quot;showbackground enabled&quot;);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数init的实现很简单，它分别获得系统中两个名称为“debug.sf.showupdates”和“debug.sf.showbackground”的属性的值，并且分别保存在SurfaceFlinger类的成员变量mDebugRegion和mDebugBackground中。这两个成员变量是与调试相关的，我们不关心。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步执行完成之后，返回到前面的Step 4中，即BinderService类的静态成员函数publish中，这时候在前面的Step 5中所创建的一个SurfaceFlinger实例就会被注册到Service Manager中，这是通过调用Service Manager的Binder代理对象的成员函数addService来实现的。由于Service Manager的Binder代理对象的成员函数addService的第二个参数是一个类型为IBinder的强指针引用。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6786239">Android系统的智能指针（轻量级指针、强指针和弱指针）的实现原理分析</a>一文可以知道，当一个对象第一次被一个强指针引用时，那么这个对象的成员函数onFirstRef就会被调用。因此，接下来前面所创建的SurfaceFlinger实例的成员函数onFirstRef就会被调用，以便可以继续执行初始化操作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 7.&nbsp;SurfaceFlinger.onFirstRef</p><p></p><pre name="code" class="cpp">void SurfaceFlinger::onFirstRef()
{
    run(&quot;SurfaceFlinger&quot;, PRIORITY_URGENT_DISPLAY);

    // Wait for the main thread to be done with its initialization
    mReadyToRunBarrier.wait();
}<span style="font-family:Arial, Helvetica, sans-serif;"><span style="white-space: normal;">
</span></span></pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数首先调用从父类继承下来的成员函数run来启动一个名秒为“SurfaceFlinger”的线程，用来执行UI渲染操作。这就是前面我们所说的UI渲染线程了。这个UI渲染线程创建完成之后，首先会调用SurfaceFlinger类的成员函数readyToRun来执行一些初始化操作，接着再循环调用SurfaceFlinger类的成员函数threadLoop来作为线程的执行体。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;mReadyToRunBarrier是SurfaceFlinger类的一个成员变量，它的类型是Barrier，用来描述一个屏障，是通过条件变量来实现的。我们可以把它看作是一个线程同步工具，即阻塞当前线程，直到SurfaceFlinger服务的UI渲染线程执行完成初始化操作为止。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析SurfaceFlinger类的成员函数readyToRun的实现，以便可以了解SurfaceFlinger服务的UI渲染线程的初始化过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 8.&nbsp;SurfaceFlinger.oreadyToRun</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp文件中，用来初始化SurfaceFlinger服务的UI渲染线程，我们分段来阅读：</p><p></p><pre name="code" class="cpp">status_t SurfaceFlinger::readyToRun()
{
    LOGI(   &quot;SurfaceFlinger's main thread ready to run. &quot;
            &quot;Initializing graphics H/W...&quot;);

    // we only support one display currently
    int dpy = 0;

    {
        // initialize the main display
        GraphicPlane&amp; plane(graphicPlane(dpy));
        DisplayHardware* const hw = new DisplayHardware(this, dpy);
        plane.setDisplayHardware(hw);
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先创建了一个DisplayHardware对象hw，用来描述设备的显示屏，并且用这个DisplayHardware对象来初始化SurfaceFlinger类的成员变量mGraphicPlanes所描述的一个GraphicPlane数组的第一个元素。在DisplayHardware对象hw的创建过程中，会创建另外一个线程，用来监控控制台事件，即监控硬件帧缓冲区的睡眠和唤醒事件。在后面一篇文章中介绍SurfaceFlinger服务是如何管理硬件帧缓冲区时，我们就会看到这个控制台事件监控线程的创建过程。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们接着往下阅读代码：</p><p></p><pre name="code" class="cpp">    // create the shared control-block
    mServerHeap = new MemoryHeapBase(4096,
            MemoryHeapBase::READ_ONLY, &quot;SurfaceFlinger read-only heap&quot;);
    LOGE_IF(mServerHeap==0, &quot;can't create shared memory dealer&quot;);

    mServerCblk = static_cast&lt;surface_flinger_cblk_t*&gt;(mServerHeap-&gt;getBase());
    LOGE_IF(mServerCblk==0, &quot;can't get to shared control block's address&quot;);

    new(mServerCblk) surface_flinger_cblk_t;</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码首先创建了一块大小为4096，即4KB的匿名共享内存，接着将这块匿名共享内存结构化为一个surface_flinger_cblk_t对象来访问。这个surface_flinger_cblk_t对象就保存在SurfaceFlinger类的成员变量mServerCblk中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这块匿名共享内存用来保存设备显示屏的属性信息，例如，宽度、高度、密度和每秒多少帧等信息，后面我们就会看到这块匿名共享内存的初始化过程。为什么会使用匿名共享内存来保存设备显示屏的属性信息呢？这是为了方便将这些信息传递给系统中的其它进程访问的。系统中的其它进程可以通过调用调用SurfaceFlinger服务的代理对象的成员函数getCblk来获得这块匿名共享内存的内容。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;我们再接着往下阅读代码：<br /></p><pre name="code" class="cpp">    // initialize primary screen
    // (other display should be initialized in the same manner, but
    // asynchronously, as they could come and go. None of this is supported
    // yet).
    const GraphicPlane&amp; plane(graphicPlane(dpy));
    const DisplayHardware&amp; hw = plane.displayHardware();
    const uint32_t w = hw.getWidth();
    const uint32_t h = hw.getHeight();
    const uint32_t f = hw.getFormat();
    hw.makeCurrent();</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先获得SurfaceFlinger类的成员变量mGraphicPlanes所描述的一个GraphicPlane数组的第一个元素plane，接着再设置它的宽度、长度和像素格式等作息，最后再调用它里面的一个DisplayHardware对象hw的成员函数makeCurrent来将它作为系统的主显示屏。这个DisplayHardware对象hw是在前面第一段代码中创建的，在创建的过程中，它会执行一些初始化操作，这里将它设置为系统主显示屏之后，后面就可以将系统的UI渲染在它上面了。在后面一篇文章中介绍SurfaceFlinger服务是如何管理硬件帧缓冲区时，我们再分析DisplayHardware类的成员函数makeCurrent的实现。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;我们继续往下阅读代码：</p><p></p><pre name="code" class="cpp">    // initialize the shared control block
    mServerCblk-&gt;connected |= 1&lt;&lt;dpy;
    display_cblk_t* dcblk = mServerCblk-&gt;displays + dpy;
    memset(dcblk, 0, sizeof(display_cblk_t));
    dcblk-&gt;w            = plane.getWidth();
    dcblk-&gt;h            = plane.getHeight();
    dcblk-&gt;format       = f;
    dcblk-&gt;orientation  = ISurfaceComposer::eOrientationDefault;
    dcblk-&gt;xdpi         = hw.getDpiX();
    dcblk-&gt;ydpi         = hw.getDpiY();
    dcblk-&gt;fps          = hw.getRefreshRate();
    dcblk-&gt;density      = hw.getDensity();</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码将系统主显示屏的属性信息保存在前面所创建的一块匿名共享内存中，以便可以将系统主显示屏的属性信息返回给系统中的其它进程访问。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;我们再继续往下阅读代码：<br /></p><pre name="code" class="cpp">    // Initialize OpenGL|ES
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    glPixelStorei(GL_PACK_ALIGNMENT, 4);
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnable(GL_SCISSOR_TEST);
    glShadeModel(GL_FLAT);
    glDisable(GL_DITHER);
    glDisable(GL_CULL_FACE);

    const uint16_t g0 = pack565(0x0F,0x1F,0x0F);
    const uint16_t g1 = pack565(0x17,0x2f,0x17);
    const uint16_t textureData[4] = { g0, g1, g1, g0 };
    glGenTextures(1, &amp;mWormholeTexName);
    glBindTexture(GL_TEXTURE_2D, mWormholeTexName);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterx(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 2, 2, 0,
            GL_RGB, GL_UNSIGNED_SHORT_5_6_5, textureData);

    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrthof(0, w, h, 0, 0, 1);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来初始化OpenGL库，因为SurfaceFlinger服务是通过OpenGL库提供的API来渲染系统的UI的。这里我们就不详细分析OpenGL库的初始化过程中，有兴趣的读者可以参考官方网站：<a href="http://cn.khronos.org/">http://cn.khronos.org/</a>。<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们再继续往下阅读最后一段代码：</p><p></p><pre name="code" class="cpp">    LayerDim::initDimmer(this, w, h);

    mReadyToRunBarrier.open();

    /*
     *  We're now ready to accept clients...
     */

    // start boot animation
    property_set(&quot;ctl.start&quot;, &quot;bootanim&quot;);

    return NO_ERROR;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码做了三件事情。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第一件事情是调用LayerDim类的静态成员函数initDimmer来初始化LayerDim类。LayerDim类是用来描述一个具有颜色渐变功能的Surface的，这种类型的Surface与普通的Surface不一样，前者是在后者的基础上创建和渲染的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第二件事情是调用SurfaceFlinger类的成员变量mReadyToRunBarrier所描述的一个屏障的成员函数open来告诉System进程的主线程，即在前面的Step 7中正在等待的线程，SurfaceFlinger服务的UI渲染线程已经创建并且初始化完成了，这时候System进程的主线程就可以继续向前执行其它操作了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第三件事情是调用函数property_set来设置系统中名称为“ctl.start”的属性，即将它的值设置为“bootanim”。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7691321">Android系统的开机画面显示过程分析</a>一文可以知道，ctl.start是Android系统的一个控制属性，当它的值等于““bootanim”的时候，就表示要启动Android系统的开机动画。从这里就可以看出，当我们看到Android系统的开机动画时，就说明Android系统的SurfaceFlinger服务已经启动起来了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成SurfaceFlinger服务的启动过程中了。在分析过程中，有两个比较重要的知识点：第一个知识点是系统主显示屏的创建和初始化过程，第二个知识点是UI渲染线程的执行过程。在接下来的第一篇文章中，我们将详细分析第一个知识点。在分析第一个知识点的过程中，会涉及到SurfaceFlinger服务的控制台事件监控线程的创建过程，因此，结合Step 2提到的Binder线程，以及Step 7提到的UI渲染线程，我们将在接下来的第二篇文章中，综合描述SurfaceFlinger服务的线程协作模型。有了前面的基础知识之后，在接下来的第三篇文章中，我们就将详细分析第二个知识点。敬请关注！</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p><p></p>
            <div>
                作者：Luoshengyang 发表于2012-9-29 14:48:05 <a href="http://blog.csdn.net/luoshengyang/article/details/8022957">原文链接</a>
            </div>
            <div>
            阅读：6773 评论：1 <a href="http://blog.csdn.net/luoshengyang/article/details/8022957#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8046659</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8046659</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-10-15 0:56:03</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前文中，我们分析了</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务的启动过程。</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务在启动的过程中，会对系统的硬件帧缓冲区进行初始化。由于系统的硬件帧缓冲区一般只有一个，并且不是谁都可以随便访问的，因此，它就需要由一个服务来统一管理。在</span><span style="color:black;">Android</span><span style="color:black;">系统中，这个服务便是</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">。在本文中，我们就详细分析</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务是如何管理系统的硬件帧缓冲区的。</span></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<span style="color:#000000;"><a href="http://blog.csdn.net/luoshengyang/article/details/8010977">Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划</a></span>一文可以知道，SurfaceFlinger服务通过一个GraphicPlane对象来描述系统的显示屏，即系统的硬件帧缓冲区。GraphicPlane类内部聚合了一个DisplayHardware对象，通过这个DisplayHardware对象就可以访问系统的硬件帧缓冲区。DisplayHardware类内部又包含了一个FramebufferNativeWindow对象，这个FramebufferNativeWindow对象才是真正用来描述系统的硬件帧缓冲区的。FramebufferNativeWindow类的作用类似于在前面<span style="color:#000000;"><a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a></span>一文中所介绍的Surface类，它是连接OpenGL库和Android的UI系统的一个桥梁，OpenGL库就是通过这个桥梁来将Android系统的UI渲染到硬件帧缓冲区中去的。GraphicPlane、DisplayHardware和FramebufferNativeWindow这三个类的关系如图1所示。</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/09/1349716410_5733.jpg" alt="" /><br /></p><p style="text-align: center;">图1 GraphicPlane、DisplayHardware和FramebufferNativeWindow的类关系图</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就分别介绍GraphicPlane、DisplayHardware和FramebufferNativeWindow这三个类的实现，以便可以理解SurfaceFlinger服务是如何通过它们来管理系统的硬件帧缓冲区的。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8022957">Android系统Surface制的SurfaceFlinger服务的启动过程分析</a>一文可以知道，<span style="color: black; ">SurfaceFlinger</span><span style="color: black; ">服务在启动的过程中，会对系统的硬件帧缓冲区进行初始化，如下所示：</span></p><p style="text-align: left;"><span style="color: black; "></span></p><pre name="code" class="cpp">status_t SurfaceFlinger::readyToRun()  
{
    ......

    // we only support one display currently  
    int dpy = 0;  
  
    {  
        // initialize the main display  
        GraphicPlane&amp; plane(graphicPlane(dpy));  
        DisplayHardware* const hw = new DisplayHardware(this, dpy);  
        plane.setDisplayHardware(hw);  
    }  

    ......

    // initialize primary screen  
    // (other display should be initialized in the same manner, but  
    // asynchronously, as they could come and go. None of this is supported  
    // yet).  
    const GraphicPlane&amp; plane(graphicPlane(dpy));  
    const DisplayHardware&amp; hw = plane.displayHardware();  
    ......
    hw.makeCurrent();

    ......  
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp文件中。<p></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 这个代码段首先创建了一个DisplayHardware对象，用来初始化编号为0的GraphicPlane对象，接着再将这个DisplayHardware对象设置为系统当前活动的DisplayHardware对象，这就相当于是将编号为0的GraphicPlane对象所描述的显示屏设置为系统当前活动的显示屏。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就首先分析编号为0的GraphicPlane对象的初始化过程，接着再分析DisplayHardware对象的创建过程。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;编号为0的GraphicPlane对象的初始化过程主要是调用GraphicPlane类的成员函数setDisplayHardware来实现的，如下所示：</span></p><p style="text-align: left;"><span style="color: black; "></span></p><pre name="code" class="cpp">void GraphicPlane::setDisplayHardware(DisplayHardware *hw)
{
    mHw = hw;

    // initialize the display orientation transform.
    // it's a constant that should come from the display driver.
    int displayOrientation = ISurfaceComposer::eOrientationDefault;
    char property[PROPERTY_VALUE_MAX];
    if (property_get(&quot;ro.sf.hwrotation&quot;, property, NULL) &gt; 0) {
        //displayOrientation
        switch (atoi(property)) {
        case 90:
            displayOrientation = ISurfaceComposer::eOrientation90;
            break;
        case 270:
            displayOrientation = ISurfaceComposer::eOrientation270;
            break;
        }
    }

    const float w = hw-&gt;getWidth();
    const float h = hw-&gt;getHeight();
    GraphicPlane::orientationToTransfrom(displayOrientation, w, h,
            &amp;mDisplayTransform);
    if (displayOrientation &amp; ISurfaceComposer::eOrientationSwapMask) {
        mDisplayWidth = h;
        mDisplayHeight = w;
    } else {
        mDisplayWidth = w;
        mDisplayHeight = h;
    }

    setOrientation(ISurfaceComposer::eOrientationDefault);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp文件中。<p></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数首先设置显示屏的初始大小和旋转方向。GraphicPlane类有三个成员变量mDisplayWidth、mDisplayHeight和mDisplayTransform，前两者的类型为float，分别用描述显示屏的初始宽度和高度，而后者的类型为Transform，用来描述显示屏的初始旋转矩阵。Transform类的作用是来描述<a href="http://zh.wikipedia.org/wiki/%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5">变换矩阵</a>，以便后面在渲染UI时可以用来动态地计算显示屏的大小和旋转方向等。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 显示屏的初始化宽度和高度是由参数hw所描述的一个DisplayHardware对象来描述的，而显示屏的初始旋转方向则是由名称为“ro.sf.hwrotation”的系统属性来决定的。如果没有设置名称为“ro.sf.hwrotation”的系统属性，那么显示屏的旋转方向就为默认方向，即ISurfaceComposer::eOrientationDefault。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 获得了显示屏的初始化宽度w、高度h和旋转方向displayOrientation之后，函数接着就调用GraphicPlane类的静态成员函数orientationToTransfrom来将它们构造成一个变换矩阵，并且保存在GraphicPlane类的成员变量mDisplayTransform中。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数接下来继续判断显示屏的初始化旋转方向是否将初始化宽度和高度值翻转了。如果翻转了，那么就需要相互调换GraphicPlane类的成员变量mDisplayWidth和mDisplayHeight的值，以便可以正确地反映显示屏的初始化宽度和高度。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 注意，显示屏的初始宽度、高度和旋转方向一经初始化之后，就会保持不变，以后显示屏的实际旋转方向计算都是要在此基础上进行计算的，即要在变换矩阵mDisplayTransform的基础上进行计算。从这里还可以看出，通过设置名称为“ro.sf.hwrotation”的系统属性的值，就可以设置系统显示屏的初始化旋转方向，以便匹配实际的硬件帧缓冲区的旋转方向。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数最后调用GraphicPlane类的成员函数setOrientation来设备显示屏的实际度度、高度以及旋转方向，如下所示：</span></p><p style="text-align: left;"><span style="color: black; "></span></p><pre name="code" class="cpp">status_t GraphicPlane::setOrientation(int orientation)
{
    // If the rotation can be handled in hardware, this is where
    // the magic should happen.

    const DisplayHardware&amp; hw(displayHardware());
    const float w = mDisplayWidth;
    const float h = mDisplayHeight;
    mWidth = int(w);
    mHeight = int(h);

    Transform orientationTransform;
    GraphicPlane::orientationToTransfrom(orientation, w, h,
            &amp;orientationTransform);
    if (orientation &amp; ISurfaceComposer::eOrientationSwapMask) {
        mWidth = int(h);
        mHeight = int(w);
    }

    mOrientation = orientation;
    mGlobalTransform = mDisplayTransform * orientationTransform;
    return NO_ERROR;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp文件中。<p></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数orientation的值等于ISurfaceComposer::eOrientationDefault，即SurfaceFlinger服务在初始化系统显示屏时，会将它的旋转方向设置为默认值，以后再根据实际情况来做调整。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; GraphicPlane类有三个成员变量mWidth、mHeight和mOrientation，它们的类型均为int，分别用来描述显示屏的实际宽度、高度和旋转方向。与成员变量mDisplayWidth、mDisplayHeight和mDisplayTransform所描述的显示屏初始化宽度、高度和旋转矩阵一经初始化后就保持不变不同，mWidth、mHeight和mOrientation这三个成员变量是会动态变化的。例如，当显示屏由LANDSCAPE变为PORTRAIT模式时，mWidth、mHeight和mOrientation这三个成员变量就会相应地发生改变。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数首先将显示屏的实际宽度mWidth、高度mHeight和旋转方向mOrientation设置为显示屏的初始宽度mDisplayWidth、高度mDisplayHeight以及参数orientation所描述的旋转方向，接着再调用GraphicPlane类的静态成员函数orientationToTransfrom来将它们构造成一个变换矩阵orientationTransform。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数接着判断显示屏的实际旋转方向orientation是否将原来的实际宽度和高度值翻转了。如果翻转了，那么就需要相互调换GraphicPlane类的成员变量mWidth和mHeight的值，以便可以正确地反映显示屏的实际宽度和高度。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数最后将用来描述显示屏的初始化旋转方向的变换矩阵mDisplayTransform和用来描述显示屏的实际旋转方向的变换矩阵orientationTransform相乘，就可以得到一个全局变换矩阵，并且保存在GraphicPlane类的成员变量mGlobalTransform中。这样以后渲染UI时，对于一个任意的点向量，只要将它乘以全局变换矩阵mGlobalTransform，那么就可以得到它所描述的实际位置。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 至此，编号为0的GraphicPlane对象的初始化过程就完成了，以后SurfaceFlinger服务就可以调用它的成员函数displayHardware来获得它内部的一个DisplayHardware对象，如下所示：</span></p><p style="text-align: left;"><span style="color: black; "></span></p><pre name="code" class="cpp">const DisplayHardware&amp; GraphicPlane::displayHardware() const {
    return *mHw;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp文件中。<p></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;接下来，回到前面SurfaceFlinger类的成员函数readyToRun中，我们通过DisplayHardware对象的创建过程来分析DisplayHardware类的实现。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;在创建DisplayHardware对象的过程中，会调用DisplayHardware类的构造函数，如下所示：</span></p><p style="text-align: left;"><span style="color: black; "></span></p><pre name="code" class="cpp">DisplayHardware::DisplayHardware(
        const sp&lt;SurfaceFlinger&gt;&amp; flinger,
        uint32_t dpy)
    : DisplayHardwareBase(flinger, dpy),
      mFlags(0)
{
    init(dpy);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp中。<p></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 从这里可以看出，DisplayHardware类是从DisplayHardwareBase类继承下来的。接下来，我们首先继续分析一个DisplayHardware对象的初始化过程，接着再分析这个DisplayHardware对象的父对象DisplayHardwareBase的初始化过程，以便可以了解DisplayHardwareBase类的实现。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;一个DisplayHardware对象的初始化过程是通过调用DisplayHardware类的成员函数init来实现的。DisplayHardware类的成员函数init的实现比较长，我们分段来阅读：</span></p><p style="text-align: left;"><span style="color: black; "></span></p><pre name="code" class="cpp">void DisplayHardware::init(uint32_t dpy)
{
    mNativeWindow = new FramebufferNativeWindow();
    framebuffer_device_t const * fbDev = mNativeWindow-&gt;getDevice();
    mDpiX = mNativeWindow-&gt;xdpi;
    mDpiY = mNativeWindow-&gt;ydpi;
    mRefreshRate = fbDev-&gt;fps;

    mOverlayEngine = NULL;
    hw_module_t const* module;
    if (hw_get_module(OVERLAY_HARDWARE_MODULE_ID, &amp;module) == 0) {
        overlay_control_open(module, &amp;mOverlayEngine);
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先是创建了一个FramebufferNativeWindow对象，并且保存在DisplayHardware类的成员变量mNativeWindow中，用来管理硬件帧缓冲区。有了这个FramebufferNativeWindow对象之后，就可以通过它里面的一个fb设备来获得硬件帧缓冲区的点密度以及刷新频率等信息。后面我们再详细分析FramebufferNativeWindow类的实现。<p></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码接着再加载HAL层中的overlay模块，目的是要打开系统的overlay设备。在Android系统中，我们可以将overlay看作是一种特殊的Surface，一般用来显示视频。在这一系列文章中，我们暂时不关心overlay设备的实现。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</span></p><p style="text-align: left;"><span style="color: black; "></span></p><pre name="code" class="cpp">    EGLint w, h, dummy;
    EGLint numConfigs=0;
    EGLSurface surface;
    EGLContext context;

    // initialize EGL
    EGLint attribs[] = {
            EGL_SURFACE_TYPE,   EGL_WINDOW_BIT,
            EGL_NONE,           0,
            EGL_NONE
    };

    // debug: disable h/w rendering
    char property[PROPERTY_VALUE_MAX];
    if (property_get(&quot;debug.sf.hw&quot;, property, NULL) &gt; 0) {
        if (atoi(property) == 0) {
            LOGW(&quot;H/W composition disabled&quot;);
            attribs[2] = EGL_CONFIG_CAVEAT;
            attribs[3] = EGL_SLOW_CONFIG;
        }
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码主要用来设置一个EGL属性数组attribs，以便接下来可以根据这个属性数组的值来正确的初始化EGL库。<p></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</span></p><p style="text-align: left;"><span style="color: black; "></span></p><pre name="code" class="cpp">    // TODO: all the extensions below should be queried through
    // eglGetProcAddress().

    EGLDisplay display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
    eglInitialize(display, NULL, NULL);
    eglGetConfigs(display, NULL, 0, &amp;numConfigs);

    EGLConfig config;
    status_t err = EGLUtils::selectConfigForNativeWindow(
            display, attribs, mNativeWindow.get(), &amp;config);
    LOGE_IF(err, &quot;couldn't find an EGLConfig matching the screen format&quot;);</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先调用eglGetDisplay和eglInitialize函数来获得和初始化OpengGL库的默认显示屏，接着再调用EGLUtils::selectConfigForNativeWindow函数来获得前面所创建的一个FramebufferNativeWindow对象所描述的系统主绘图表面的配置信息，并且保存在EGLConfig对象config。有了这些配置信息之后，接下来就可以在硬件帧缓冲区上面创建系统的主绘图表面。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</p><p></p><pre name="code" class="cpp">    EGLint r,g,b,a;
    eglGetConfigAttrib(display, config, EGL_RED_SIZE,   &amp;r);
    eglGetConfigAttrib(display, config, EGL_GREEN_SIZE, &amp;g);
    eglGetConfigAttrib(display, config, EGL_BLUE_SIZE,  &amp;b);
    eglGetConfigAttrib(display, config, EGL_ALPHA_SIZE, &amp;a);

    if (mNativeWindow-&gt;isUpdateOnDemand()) {
        mFlags |= PARTIAL_UPDATES;
    }

    if (eglGetConfigAttrib(display, config, EGL_CONFIG_CAVEAT, &amp;dummy) == EGL_TRUE) {
        if (dummy == EGL_SLOW_CONFIG)
            mFlags |= SLOW_CONFIG;
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码主要是用来获得系统主绘图表面的一些属性，例如，四个颜色分量R、G、B和A的大小，以及是否支持部分更新、是否使用慢渲染方式等。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</p><p></p><pre name="code" class="cpp">    /*
     * Create our main surface
     */

    surface = eglCreateWindowSurface(display, config, mNativeWindow.get(), NULL);
    eglQuerySurface(display, surface, EGL_WIDTH,  &amp;mWidth);
    eglQuerySurface(display, surface, EGL_HEIGHT, &amp;mHeight);

    if (mFlags &amp; PARTIAL_UPDATES) {
        // if we have partial updates, we definitely don't need to
        // preserve the backbuffer, which may be costly.
        eglSurfaceAttrib(display, surface,
                EGL_SWAP_BEHAVIOR, EGL_BUFFER_DESTROYED);
    }

    if (eglQuerySurface(display, surface, EGL_SWAP_BEHAVIOR, &amp;dummy) == EGL_TRUE) {
        if (dummy == EGL_BUFFER_PRESERVED) {
            mFlags |= BUFFER_PRESERVED;
        }
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先调用函数eglCreateWindowSurface来创建系统的主绘图表面。系统的主绘图表面是直接在硬件帧缓冲区上创建的，用来渲染系统的UI，即负责合成和渲染所有应用程序的UI。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码接着还获得系统的主绘图表面的宽度和高度，分别保存在并且保存在DisplayHardware类的成员变量mWidth和mHeight中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码最后还判断硬件帧缓冲区是否支持部分更新。如果支持的话，就会在调用函数eglSwapBuffers来渲染系统的UI时，不保留后端图形缓冲区的内容，因为保留是有代价的。如果不支持的话，那么就会就会调用函数eglQuerySurface来检查在调用函数eglSwapBuffers来渲染系统的UI时是否需要保留后端图形缓冲区的内容。如果需要的话，那么就会将DisplayHardware类的成员变量mFlags的BUFFER_PRESERVED位设置为1。在保留后端图形缓冲区的内容的情况下，系统就可以支持仅仅渲染那些需要更新的脏区域，这些区域可以是不规则的。然而，实现不规则区域部分更新功能是有代价的，因为每次在渲染UI时，都要将后端图形缓冲区的内容拷贝回那些不在那些需要更新的区域中去，这会导致性能低下。因此，系统一般都不支持不规则区域部分更新功能。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</p><p></p><pre name="code" class="cpp">    /* Read density from build-specific ro.sf.lcd_density property
     * except if it is overridden by qemu.sf.lcd_density.
     */
    if (property_get(&quot;qemu.sf.lcd_density&quot;, property, NULL) &lt;= 0) {
        if (property_get(&quot;ro.sf.lcd_density&quot;, property, NULL) &lt;= 0) {
            LOGW(&quot;ro.sf.lcd_density not defined, using 160 dpi by default.&quot;);
            strcpy(property, &quot;160&quot;);
        }
    } else {
        /* for the emulator case, reset the dpi values too */
        mDpiX = mDpiY = atoi(property);
    }
    mDensity = atoi(property) * (1.0f/160.0f);</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来设备系统的主绘图表面的点密度信息。系统的主绘图表面的点密度信息可以通过名称为“qemu.sf.lcd_density”或者“ro.sf.lcd_density”的系统属性来配置。如果没有配置，那么默认值就为160dpi。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</p><p></p><pre name="code" class="cpp">    /*
     * Create our OpenGL ES context
     */


    EGLint contextAttributes[] = {
#ifdef EGL_IMG_context_priority
#ifdef HAS_CONTEXT_PRIORITY
#warning &quot;using EGL_IMG_context_priority&quot;
        EGL_CONTEXT_PRIORITY_LEVEL_IMG, EGL_CONTEXT_PRIORITY_HIGH_IMG,
#endif
#endif
        EGL_NONE, EGL_NONE
    };
    context = eglCreateContext(display, config, NULL, contextAttributes);

    mDisplay = display;
    mConfig  = config;
    mSurface = surface;
    mContext = context;
    mFormat  = fbDev-&gt;format;
    mPageFlipCount = 0;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码主要是调用函数eglCreateContext来创建系统的主绘图表面的上下文。有了这个上下文之后，OpenGL库就能够在前面所创建的系统主绘图表面上渲染系统的UI了。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</p><p></p><pre name="code" class="cpp">    /*
     * Gather OpenGL ES extensions
     */

    eglMakeCurrent(display, surface, surface, context);

    GLExtensions&amp; extensions(GLExtensions::getInstance());
    extensions.initWithGLStrings(
            glGetString(GL_VENDOR),
            glGetString(GL_RENDERER),
            glGetString(GL_VERSION),
            glGetString(GL_EXTENSIONS),
            eglQueryString(display, EGL_VENDOR),
            eglQueryString(display, EGL_VERSION),
            eglQueryString(display, EGL_EXTENSIONS));

    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &amp;mMaxTextureSize);
    glGetIntegerv(GL_MAX_VIEWPORT_DIMS, &amp;mMaxViewportDims);


#ifdef EGL_ANDROID_swap_rectangle
    if (extensions.hasExtension(&quot;EGL_ANDROID_swap_rectangle&quot;)) {
        if (eglSetSwapRectangleANDROID(display, surface,
                0, 0, mWidth, mHeight) == EGL_TRUE) {
            // This could fail if this extension is not supported by this
            // specific surface (of config)
            mFlags |= SWAP_RECTANGLE;
        }
    }
    // when we have the choice between PARTIAL_UPDATES and SWAP_RECTANGLE
    // choose PARTIAL_UPDATES, which should be more efficient
    if (mFlags &amp; PARTIAL_UPDATES)
        mFlags &amp;= ~SWAP_RECTANGLE;
#endif</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码主要用来检查系统的主绘图表面是否支持EGL_ANDROID_swap_rectangle扩展属性。如果支持的话，那么每次在调用函数eglSwapBuffers来渲染UI时，都会使用软件的方式来支持部分更新区域功能，即：先得到不在新脏区域里面的那部分旧脏区域的内容，然后再将得到的这部分旧脏区域的内容拷贝回到要渲染的新图形缓冲区中去，这要求每次在渲染UI时，都要将被渲染的图形缓冲区以及对应的脏区域保存下来。注意，如果系统的主绘图表面同时支持EGL_ANDROID_swap_rectangle扩展属性以及部分更新属性，那么将会优先使用部分更新属性，因为后者是直接在硬件上支持部分更新，因而性能会更好。</p><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读最后一段代码：</p><p></p><pre name="code" class="cpp">    LOGI(&quot;EGL informations:&quot;);
    LOGI(&quot;# of configs : %d&quot;, numConfigs);
    LOGI(&quot;vendor    : %s&quot;, extensions.getEglVendor());
    LOGI(&quot;version   : %s&quot;, extensions.getEglVersion());
    LOGI(&quot;extensions: %s&quot;, extensions.getEglExtension());
    LOGI(&quot;Client API: %s&quot;, eglQueryString(display, EGL_CLIENT_APIS)?:&quot;Not Supported&quot;);
    LOGI(&quot;EGLSurface: %d-%d-%d-%d, config=%p&quot;, r, g, b, a, config);

    LOGI(&quot;OpenGL informations:&quot;);
    LOGI(&quot;vendor    : %s&quot;, extensions.getVendor());
    LOGI(&quot;renderer  : %s&quot;, extensions.getRenderer());
    LOGI(&quot;version   : %s&quot;, extensions.getVersion());
    LOGI(&quot;extensions: %s&quot;, extensions.getExtension());
    LOGI(&quot;GL_MAX_TEXTURE_SIZE = %d&quot;, mMaxTextureSize);
    LOGI(&quot;GL_MAX_VIEWPORT_DIMS = %d&quot;, mMaxViewportDims);
    LOGI(&quot;flags = %08x&quot;, mFlags);

    // Unbind the context from this thread
    eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码首先调用日志接口LOGI来显示系统的主绘图表面的属性信息，接着最调用函数eglMakeCurrent来取消 设置OpenGL库在当前线程的绘图表面以及绘图上下文。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从这里就可以看出，一个DisplayHardware对象在初始化完成之后，它还不能直接用来渲染系统的UI，因为它所初始化的的绘图表面以及绘图上下文并没有作为当前线程的绘图表面以及绘图上下文。这是由于SurfaceFlinger服务可以同时支持多个DisplayHardware对象，即同时支持多个显示屏造成的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面SurfaceFlinger类的成员函数readyToRun可以知道，当前正在初始化的DisplayHardware对象的编号为0，并且它是在SurfaceFlinger服务的UI渲染线程中创建的，为了可以将它设置系统的主显示屏，即主绘图表面，SurfaceFlinger类的成员函数readyToRun接下来还会调用它的成员函数makeCurrent来将它所里面的绘图表面以及绘图上下文设置为SurfaceFlinger服务的UI渲染线程的绘图表面以及绘图上下文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayHardware类的成员函数makeCurrent的实现如下所示：</p><p></p><pre name="code" class="cpp">void DisplayHardware::makeCurrent() const
{
    eglMakeCurrent(mDisplay, mSurface, mSurface, mContext);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayHardware类的成员函数makeCurrent的实现很简单，它只是通过调用函数eglMakeCurrent来将前面已经创建好的绘图表面以及绘图上下文设置为当前线程的绘图表面以及绘图上下文，即设置为SurfaceFlinger服务的UI渲染线程的绘图表面以及绘图上下文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 系统的硬件帧缓冲区在初始化完成之后，SurfaceFlinger服务以后就可以调用用来描述它的一个DisplayHardware对象的成员函数flip来在它上面渲染系统的UI了，这个成员函数的实现如下所示：</p><p></p><pre name="code" class="cpp">void DisplayHardware::flip(const Region&amp; dirty) const
{
    checkGLErrors();

    EGLDisplay dpy = mDisplay;
    EGLSurface surface = mSurface;

#ifdef EGL_ANDROID_swap_rectangle    
    if (mFlags &amp; SWAP_RECTANGLE) {
        const Region newDirty(dirty.intersect(bounds()));
        const Rect b(newDirty.getBounds());
        eglSetSwapRectangleANDROID(dpy, surface,
                b.left, b.top, b.width(), b.height());
    }
#endif

    if (mFlags &amp; PARTIAL_UPDATES) {
        mNativeWindow-&gt;setUpdateRectangle(dirty.getBounds());
    }

    mPageFlipCount++;
    eglSwapBuffers(dpy, surface);
    checkEGLErrors(&quot;eglSwapBuffers&quot;);

    // for debugging
    //glClearColor(1,0,0,0);
    //glClear(GL_COLOR_BUFFER_BIT);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数主要就是调用OpenGL库中的函数eglSwapBuffers来将系统的UI渲染到系统的主绘图表面上去的，即渲染到系统的硬件帧缓冲区上去的。在渲染之前，函数会首先判断系统的主绘图表面是否支持EGL_ANDROID_swap_rectangle扩展属性和部分更新属性。如果支持EGL_ANDROID_swap_rectangle扩展属性，即DisplayHardware类的成员变量mFlags的SWAP_RECTANGLE位等于1，那么就需要调用函数eglSetSwapRectangleANDROID来设置要渲染的区域，以便在渲染UI时，可以通过软件的方式来支持部分更新。如果硬件帧缓冲区直接支持部分更新属性，即DisplayHardware类的成员变量mFlags的PARTIAL_UPDATES位等于1，那么就需要调用DisplayHardware类的成员变量mNativeWindow所描述的一个本地窗口的成员函数setUpdateRectangle来设置要更新的那一部分区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DisplayHardware类的成员函数flip在调用函数eglSwapBuffers来渲染UI之前，实际上需要通过其成员变量mNativeWindow所描述的一个本地窗口（FramebufferNativeWindow）来获得一个空闲的图形缓冲区，然后才可以将UI数据写入到这个空闲的图形缓冲区中去，最后再渲染到硬件帧缓冲区中去。前面提到，FramebufferNativeWindow类的作用类似于在前面<span style="color: rgb(0, 0, 0); "><a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a></span>一文中所介绍的Surface类，不过它里面所维护的图形缓冲区是直接在硬件帧缓冲区上创建的，后面我们在分析FramebufferNativeWindow类的实现时，再详细分析。<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;至此，我们就分析完成DisplayHardware类的实现了，接下来我们还需要继续介绍它的父类DisplayHardwareBase的实现，以便可以了解DisplayHardware类的另外一个作用，即它还会创建一个线程来监控硬件帧缓冲区的睡眠和唤醒事件。分析完成DisplayHardwareBase类的实现之后，我们最后再分析FramebufferNativeWindow类的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面在分析DisplayHardware类的实现时提到，DisplayHardware对象在创建的过程中，会对其父类对象DisplayHardwareBase进行初始化，因此，接下来我们就从DisplayHardwareBase对象的初始化过程入手，来分析DisplayHardwareBase类的实现。不过，在分析DisplayHardwareBase类的实现之前，我们首先看看它的类关系图，如图2所示。</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/11/1349890354_8357.jpg" alt="" /><br /></p><p style="text-align: center;">图2 DisplayHardwareBase类关系图</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DisplayHardwareBase类一方面用来控制SurfaceFlinger服务当前是否能够访问显示屏。当显示屏处于唤醒状态时，DisplayHardwareBase类的成员变量mScreenAcquired的值就会等于1，表示SurfaceFlinger服务就可以访问显示屏；而当显示屏处于睡眠状态时，DisplayHardwareBase类的成员变量mScreenAcquired的值就会等于0，表示SurfaceFlinger服务不可以访问显示屏。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;显示屏的唤醒/睡眠状态切换是由内核来通知DisplayHardwareBase类的，因此，DisplayHardwareBase类会通过一个线程来监控显示屏的唤醒/睡眠状态切换。这个线程是通过DisplayHardwareBase类的成员变量mDisplayEventThread来描述的。DisplayHardwareBase类的成员变量mDisplayEventThread所描述的线程的类型要么是DisplayEventThread，要么是ConsoleManagerThread，这两者均是从DisplayEventThreadBase类继续下来的，而后者又是从Thread类继承下来的。当硬件帧缓冲区的控制台被打开时，DisplayHardwareBase类的成员变量mDisplayEventThread所描述的线程的类型就是DisplayEventThread；当硬件帧缓冲区的控制台没有被打开时，DisplayHardwareBase类的成员变量mDisplayEventThread所描述的线程的类型就是ConsoleManagerThread。这里我们只考虑硬件帧缓冲区的控制台被打开的情况。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;用来监控显示屏唤醒/睡眠状态切换的线程是在DisplayHardwareBase对象的初始化过程中创建的，它运行起来之后，就会在一个无限循环中不断地监控显示屏唤醒/睡眠状态切换事件。为了方便描述，我们将这个线程称为控制台事件监控线程。DisplayEventThreadBase类的成员变量mFlinger指向了SurfaceFlinger服务，一旦控制台事件监控线程监控到显示屏发生唤醒/睡眠状态切换，那么就会通过它来通知SurfaceFlinger服务。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;控制台事件监控线程的运行过程大概上这样的。在每一次循环中，控制台事件监控线程首先监控显示屏是否要进入睡眠状态了。如果是的话，那么该线程就会通过DisplayEventThreadBase类的成员变量mFlinger来通知SurfaceFlinger服务，并且等待SurfaceFlinger服务处理完成这个通知。SurfaceFlinger服务一旦处理完成显示屏进入睡眠状态的事件，它就会调用DisplayHardwareBase类的成员函数releaseScreen来将其成员变量mScreenAcquired的值设置为0，表示它目前不可以访问显示屏。控制台事件监控线程接下来就会等待显示屏被唤醒过来。一旦显示屏被唤醒过来，那么该线程就会通过DisplayEventThreadBase类的成员变量mFlinger来通知SurfaceFlinger服务。SurfaceFlinger服务得到这个通知之后，就会调用DisplayHardwareBase类的成员函数acquireScreen来将其成员变量mScreenAcquired的值设置为1，表示它目前可以访问显示屏。在下一篇文章分析SurfaceFlinger服务的线程模型时，我们再详细分析这个过程。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DisplayHardwareBase类另一方面用来控制SurfaceFlinger服务当前是否能够在显示屏上渲染UI。当系统的其它组件请求SurfaceFlinger服务关闭显示屏时，SurfaceFlinger服务就会调用DisplayHardwareBase类的成员函数setCanDraw来将其成员变量mCanDraw的值设置为0；而当系统的其它组件请求SurfaceFlinger服务打开显示屏时，SurfaceFlinger服务就会调用DisplayHardwareBase类的成员函数setCanDraw来将其成员变量mCanDraw的值设置为1。只有当DisplayHardwareBase类的成员变量mScreenAcquired和mCanDraw的值均等于1时，SurfaceFlinger服务才可以在显示屏上渲染系统的UI。为了方便SurfaceFlinger服务判断它当前是否可以在显示屏上渲染系统的UI，DisplayHardwareBase类提供了另外一个成员函数canDraw。当DisplayHardwareBase类的成员函数canDraw的返回值等于true时，就表示SurfaceFlinger服务可以在显示屏上渲染系统的UI，否则就不可以。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 了解了DisplayHardwareBase类的作用之后，接下来我们就从它的构造函数开始分析它的初始化过程。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DisplayHardwareBase类的构造函数的实现如下所示：</p><p style="text-align: left;"></p><pre name="code" class="cpp">DisplayHardwareBase::DisplayHardwareBase(const sp&lt;SurfaceFlinger&gt;&amp; flinger,
        uint32_t displayIndex)
    : mCanDraw(true), mScreenAcquired(true)
{
    mDisplayEventThread = new DisplayEventThread(flinger);
    if (mDisplayEventThread-&gt;initCheck() != NO_ERROR) {
        // fall-back on the console
        mDisplayEventThread = new ConsoleManagerThread(flinger);
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp中。<br /><p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数首先创建一个类型为DisplayEventThread的线程。如果这个线程能够通过初始化检查，即DisplayEventThread类的成员函数initCheck的返回值等于NO_ERROR，那么SurfaceFlinger服务就会使用这个类型为DisplayEventThread的线程来监控显示屏的睡眠/唤醒状态切换事件，否则的话，函数接下来就会创建另外一个类型为ConsoleManagerThread的线程来监控显示屏的睡眠/唤醒状态切换事件。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DisplayEventThread类的成员函数initCheck的实现如下所示：</p><p style="text-align: left;"></p><pre name="code" class="cpp">status_t DisplayHardwareBase::DisplayEventThread::initCheck() const
{
    return (((access(kSleepFileName, R_OK) == 0 &amp;&amp;
            access(kWakeFileName, R_OK) == 0) ||
            (access(kOldSleepFileName, R_OK) == 0 &amp;&amp;
            access(kOldWakeFileName, R_OK) == 0)) &amp;&amp;
            access(kFbconSysDir, F_OK) != 0) ? NO_ERROR : NO_INIT;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp中。<br /><p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;kSleepFileName、kWakeFileName、kOldSleepFileName、kOldWakeFileName和kFbconSysDir是五个字符串常量，它们的定义如下所示：</p><p style="text-align: left;"></p><pre name="code" class="cpp">static char const * kSleepFileName = &quot;/sys/power/wait_for_fb_sleep&quot;;
static char const * kWakeFileName = &quot;/sys/power/wait_for_fb_wake&quot;;
static char const * const kOldSleepFileName = &quot;/sys/android_power/wait_for_fb_sleep&quot;;
static char const * const kOldWakeFileName = &quot;/sys/android_power/wait_for_fb_wake&quot;;

// This dir exists if the framebuffer console is present, either built into
// the kernel or loaded as a module.
static char const * const kFbconSysDir = &quot;/sys/class/graphics/fbcon&quot;;</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;当硬件帧缓冲区的控制台被打开时，帧缓冲区驱动程序就创建一个/sys/class/graphics/fbcon目录，以及创建/sys/power/wait_for_fb_sleep和/sys/power/wait_for_fb_wake或者/sys/android_power/wait_for_fb_sleep和/sys/android_power/wait_for_fb_wake文件，用来通知用户空间显示屏即将要进入睡眠/唤醒状态了。<br /><p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 回到DisplayHardwareBase类的构造函数中，最终创建出来的线程对象保存在其成员变量mDisplayEventThread中。DisplayHardwareBase类的mDisplayEventThread是一个类型为DisplayEventThreadBase的强指针，从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6786239">Android系统的智能指针（轻量级指针、强指针和弱指针）的实现原理分析</a>一文可以知道，当一个强指针第一次引用一个对象的时候，这个对象的成员函数onFirstRef就会被调用，因此，接下来我们就继续分析DisplayEventThreadBase类的成员函数onFirstRef的实现，看看它在里面做了一件什么事情。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayEventThreadBase类的成员函数onFirstRef的实现如下所示：</p><p style="text-align: left;"></p><pre name="code" class="cpp">class DisplayHardwareBase
{
    ......

private:
    class DisplayEventThreadBase : public Thread {
        ......

    public:
        ......

        virtual void onFirstRef() {
            run(&quot;DisplayEventThread&quot;, PRIORITY_URGENT_DISPLAY);
        }
        
        ......
    };

    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.h中。<p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayEventThreadBase类的成员函数onFirstRef主要就调用父类Thread的成员函数run来创建一个名称为“DisplayEventThread”的线程，用来监控显示屏的睡眠/唤醒状态切换事件。这个线程在创建完成之后，首先会调用DisplayEventThread类的成员函数readyToRun来执行一些初始化操作，接下来不断地循环调用DisplayEventThread类的成员函数threadLoop来监控显示屏的睡眠/唤醒状态切换事件。接下来，我们就主要分析这个线程的初始化操作，即DisplayEventThread类的成员函数readyToRun的实现，在接下来的一篇文章中分析SurfaceFlinger服务的线程模型时，再详细分析这个线程监控显示屏的睡眠/唤醒状态切换事件的过程，即DisplayEventThread类的成员函数threadLoop的实现。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;DisplayEventThread类的成员函数readyToRun的实现如下所示：</p><p style="text-align: left;"></p><pre name="code" class="cpp">status_t DisplayHardwareBase::DisplayEventThread::readyToRun()
{
    if (access(kSleepFileName, R_OK) || access(kWakeFileName, R_OK)) {
        if (access(kOldSleepFileName, R_OK) || access(kOldWakeFileName, R_OK)) {
            LOGE(&quot;Couldn't open %s or %s&quot;, kSleepFileName, kWakeFileName);
            return NO_INIT;
        }
        kSleepFileName = kOldSleepFileName;
        kWakeFileName = kOldWakeFileName;
    }
    return NO_ERROR;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp中。<br /><p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayEventThread类的成员函数readyToRun的实现很简单，它首先判断/sys/power/wait_for_fb_sleep和/sys/power/wait_for_fb_wake文件是否存在。如果存在的话，那么就通过它们来监控显示屏的睡眠/唤醒状态切换事件，否则的话，就通过/sys/android_power/wait_for_fb_sleep和/sys/android_power/wait_for_fb_wake文件来监控显示屏的睡眠/唤醒状态切换事件。如果这四个文件都不存在，那么就说明硬件帧缓冲区的控制台没有被打开了，这时候就不能使用类型为DisplayEventThread的线程来监控显示屏的睡眠/唤醒状态切换事件。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成DisplayHardwareBase类的实现了，接下来我们继续分析FramebufferNativeWindow类的实现，以便可以了解它是如何管理硬件帧缓冲区的。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;在分析FramebufferNativeWindow类的实现之前，我们首先看看它的类关系图，如图3所示。</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/11/1349969220_4139.jpg" alt="" /></p><p style="text-align: center;">图3&nbsp;FramebufferNativeWindow类关系</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面提到，FramebufferNativeWindow类与在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文中提到的Surface类的作用是类似的。FramebufferNativeWindow类一方面用来在OpenGL库和Android本地窗口系统之间建立连接，这样，我们就可以使用它的成员函数dequeueBuffer来为OpenGL库分配空闲图形缓冲区，以及使用它的成员函数queueBuffer来将OpenGL已经填充好UI数据的图形缓冲区渲染到硬件帧缓冲区中去。FramebufferNativeWindow类另一方面还继承了LightRefBase类，因此，从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6786239">Android系统的智能指针（轻量级指针、强指针和弱指针）的实现原理分析</a>一文可以知道，FramebufferNativeWindow类对象可以结合Android系统的轻量级指针sp来使用，以便可以自动维护生命周期。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FramebufferNativeWindow类与Surface类又有不同的地方。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文可以知道，Surface类使用的图形缓冲区一般是在匿名共享内存中分配的，并且是由SurfaceFlinger服务来负责分配，然后再传递给应用程序进程使用的，而FramebufferNativeWindow类使用的图形缓冲区是直接在硬件帧缓冲区分配的，并且它可以直接将这些图形缓冲区渲染到硬件帧缓冲区中去。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文可以知道，要从硬件帧缓冲区中分配和渲染图形缓冲区，就必须要将HAL层中的Gralloc模块加载到当前的进程空间来，并且打开里面的gralloc设备和fb设备，其中，gralloc设备用来分配图形缓冲区，而fb设备用来渲染图形缓冲区。因此，FramebufferNativeWindow类包含了一个类型的alloc_device_t*的成员变量grDev和一个类型为framebuffer_device_t*的成员变量fbDev，它们分别指向HAL层中的Gralloc模块的gralloc设备和fb设备。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;FramebufferNativeWindow类在内部还包含了一个类型为sp&lt;NativeBuffer&gt;的数组buffers，用来描述OpenGL库可以使用的图形缓冲区，数组的大小等于NUM_FRAME_BUFFERS，即等于硬件帧缓冲区能够提供的图形缓冲区的个数。例如，在Android 2.3系统中，硬件帧缓冲区能够提供的图形缓冲区的个数等于2，这意味着Android系统可以使用双缓冲区技术来渲染系统的UI。由于OpenGL库所使用的图形缓冲区必须要实现android_native_buffer_t接口，因此，NativeBuffer类继承了android_native_buffer_t类。此外，NativeBuffer类还继承了LightRefBase类，因此，它的对象就和FramebufferNativeWindow类对象一样，可以结合Android系统的轻量级指针sp来使用，以便可以自动维护生命周期。<br /></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;了解了FramebufferNativeWindow类的作用之后，接下来我们就从它的构造函数开始分析它的实现，即分析它的类对象的创建过程。从前面DisplayHardware类的成员函数init的实现可以知道，FramebufferNativeWindow对象是在DisplayHardware对象初始化的过程中创建的，并且包含在DisplayHardware对象内部中，用来管理硬件帧缓冲区。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FramebufferNativeWindow类的构造函数定义在文件frameworks/base/libs/ui/FramebufferNativeWindow.cpp中，它的实现比较长，我们分段来阅读：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; "></p><pre name="code" class="cpp">FramebufferNativeWindow::FramebufferNativeWindow()
    : BASE(), fbDev(0), grDev(0), mUpdateOnDemand(false)
{
    hw_module_t const* module;
    if (hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &amp;module) == 0) {
        int stride;
        int err;
        int i;
        err = framebuffer_open(module, &amp;fbDev);
        LOGE_IF(err, &quot;couldn't open framebuffer HAL (%s)&quot;, strerror(-err));

        err = gralloc_open(module, &amp;grDev);
        LOGE_IF(err, &quot;couldn't open gralloc HAL (%s)&quot;, strerror(-err));

        // bail out if we can't initialize the modules
        if (!fbDev || !grDev)
            return;

        mUpdateOnDemand = (fbDev-&gt;setUpdateRect != 0);

        // initialize the buffer FIFO
        mNumBuffers = NUM_FRAME_BUFFERS;
        mNumFreeBuffers = NUM_FRAME_BUFFERS;
        mBufferHead = mNumBuffers-1;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先调用函数hw_get_module来将HAL层中的Gralloc模块加载到当前进程来，并且调用函数framebuffer_open和gralloc_open分别打开Gralloc模块中的fb设备和gralloc设备。这三个过程的实现可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文。Gralloc模块中的fb设备和gralloc设备打开之后，就分别保存在FramebufferNativeWindow类的成员变量fbDev和grDev中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码接着判断硬件帧缓冲区是否支持部区更新UI。如果支持的话，那么从Gralloc模块中打开的fb设备的成员函数setUpdateRect就不等于0。这时候这段代码就会FramebufferNativeWindow类的成员变量mUpdateOnDemand的值设置为true。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码最后还会将FramebufferNativeWindow类的成员变量mNumBuffers和mNumFreeBuffers的值均设置为NUM_FRAME_BUFFERS，它们分别用来描述硬件帧缓冲区可以提供的图形缓冲区的个数，以及当前可用的空闲图形缓冲区的个数。此外，FramebufferNativeWindow类的成员变量mBufferHead的值还会被设置为（NUM_FRAME_BUFFERS - 1），表示下一个可用的空闲图形缓冲区在FramebufferNativeWindow类的成员变量buffers所描述的一个图形缓冲区数组的位置。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 我们接着往下阅读代码：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; "></p><pre name="code" class="cpp">        for (i = 0; i &lt; mNumBuffers; i++)
        {
                buffers[i] = new NativeBuffer(
                        fbDev-&gt;width, fbDev-&gt;height, fbDev-&gt;format, GRALLOC_USAGE_HW_FB);
        }

        for (i = 0; i &lt; mNumBuffers; i++)
        {
                err = grDev-&gt;alloc(grDev,
                        fbDev-&gt;width, fbDev-&gt;height, fbDev-&gt;format,
                        GRALLOC_USAGE_HW_FB, &amp;buffers[i]-&gt;handle, &amp;buffers[i]-&gt;stride);

                LOGE_IF(err, &quot;fb buffer %d allocation failed w=%d, h=%d, err=%s&quot;,
                        i, fbDev-&gt;width, fbDev-&gt;height, strerror(-err));

                if (err)
                {
                        mNumBuffers = i;
                        mNumFreeBuffers = i;
                        mBufferHead = mNumBuffers-1;
                        break;
                }
        }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来创建FramebufferNativeWindow类的成员变量buffers所描述的一个图形缓冲区数组。每一个图形缓冲区都使用一个NativeBuffer对象来描述，并且这些图形缓冲区都是通过调用HAL层中的Gralloc模块的gralloc设备的成员函数alloc来分配的。注意，在分配图形缓冲区时，指定的标志，即第5个参数的值为GRALLOC_USAGE_HW_FB。这意味着FramebufferNativeWindow类所管理的图形缓冲区都是直接在硬件帧缓冲区上分配的，而不是在匿名共享内存中分配的。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; "></p><pre name="code" class="cpp">        const_cast&lt;uint32_t&amp;&gt;(ANativeWindow::flags) = fbDev-&gt;flags;
        const_cast&lt;float&amp;&gt;(ANativeWindow::xdpi) = fbDev-&gt;xdpi;
        const_cast&lt;float&amp;&gt;(ANativeWindow::ydpi) = fbDev-&gt;ydpi;
        const_cast&lt;int&amp;&gt;(ANativeWindow::minSwapInterval) =
            fbDev-&gt;minSwapInterval;
        const_cast&lt;int&amp;&gt;(ANativeWindow::maxSwapInterval) =
            fbDev-&gt;maxSwapInterval;
    } else {
        LOGE(&quot;Couldn't get gralloc module&quot;);
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码主要就是用来设置FramebufferNativeWindow的父类ANativeWindow的成员变量flags、xdpi、ydpi、minSwapInternal和maxSwapInterval的值，以便OpenGL库可以知道系统当前所使用的硬件帧缓冲区的一些属性，例如，点密度、缓冲区数据交换时间间隔等信息。这些成员变量的具体含义可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文所提到的Surface类的初始化过程。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; "></p><pre name="code" class="cpp">    ANativeWindow::setSwapInterval = setSwapInterval;
    ANativeWindow::dequeueBuffer = dequeueBuffer;
    ANativeWindow::lockBuffer = lockBuffer;
    ANativeWindow::queueBuffer = queueBuffer;
    ANativeWindow::query = query;
    ANativeWindow::perform = perform;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来设置FramebufferNativeWindow的父类ANativeWindow的成员函数setSwapInterval、dequeueBuffer、lockBuffer、queueBuffer、query和perform，它们都是OpenGL的回调接口，分别指向FramebufferNativeWindow类的静态成员函数setSwapInterval、dequeueBuffer、lockBuffer、queueBuffer、query和perform。与前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文所提到的Surface类一样，我们只关注FramebufferNativeWindow类的静态成员函数dequeueBuffer和queueBuffer的实现，因为它们负责用来为OpenGL库分配和渲染图形缓冲区。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FramebufferNativeWindow类的成员函数dequeueBuffer的实现如下所示：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; "></p><pre name="code" class="cpp">int FramebufferNativeWindow::dequeueBuffer(ANativeWindow* window,
        android_native_buffer_t** buffer)
{
    FramebufferNativeWindow* self = getSelf(window);
    Mutex::Autolock _l(self-&gt;mutex);
    framebuffer_device_t* fb = self-&gt;fbDev;

    int index = self-&gt;mBufferHead++;
    if (self-&gt;mBufferHead &gt;= self-&gt;mNumBuffers)
        self-&gt;mBufferHead = 0;

    GraphicLog&amp; logger(GraphicLog::getInstance());
    logger.log(GraphicLog::SF_FB_DEQUEUE_BEFORE, index);

    // wait for a free buffer
    while (!self-&gt;mNumFreeBuffers) {
        self-&gt;mCondition.wait(self-&gt;mutex);
    }
    // get this buffer
    self-&gt;mNumFreeBuffers--;
    self-&gt;mCurrentBufferIndex = index;

    *buffer = self-&gt;buffers[index].get();

    logger.log(GraphicLog::SF_FB_DEQUEUE_AFTER, index);
    return 0;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/libs/ui/FramebufferNativeWindow.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 参数window虽然是一个类型为ANativeWindow的指针，但是它指向的实际上是一个FramebufferNativeWindow对象，这个FramebufferNativeWindow对象是在DisplayHardware类的成员函数init中创建的，因此，函数在开始的地方就可以将它转换一个FramebufferNativeWindow对象self。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 有了FramebufferNativeWindow对象self之后，我们就可以在它内部的图形缓冲区数组buffers中获取下一个空闲图形缓冲区。前面提到，下一个空闲图形缓冲区的在数组buffer中的位置就保存在FramebufferNativeWindow对象self的成员变量mBufferHead中。因此，函数就可以将FramebufferNativeWindow对象self的成员变量mBufferHead的值取出来保存在变量index中，以便接下来可以从FramebufferNativeWindow对象self内部的图形缓冲区数组buffers中取出一个图形缓冲区。此外，函数还需要将FramebufferNativeWindow对象self的成员变量mBufferHead增加1，以便它可以指向下一个空闲的图形缓冲区。注意，FramebufferNativeWindow对象self内部的图形缓冲区数组buffers是循环使用的，因此，在将它的成员变量mBufferHead增加1之后，要判断它的值是否已经大于等于数组的大小，如果大于等于的话，就需要将它的值设置为0，即绕回到前面去。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 从前面的分析可以知道，FramebufferNativeWindow对象self内部可用的空闲图形缓冲区的个数保存在其成员变量mNumFreeBuffers中，因此，当这个成员变量的值等于0的时候，就表示FramebufferNativeWindow对象self没有空闲的空闲图形缓冲区可用，这时候当前线程就会通过FramebufferNativeWindow对象self的成员变量mCondition所描述的一个条件变量进入到睡眠等待状态，直到有可用的空闲图形缓冲区为止。什么时候FramebufferNativeWindow对象self内部才会有可用的空闲图形缓冲区呢？当OpenGL库请求FramebufferNativeWindow对象self将一个图形缓冲区的内容渲染到硬件帧缓冲区之后，FramebufferNativeWindow对象self就会获得一个可用的空闲图形缓冲区了，后面我们分析FramebufferNativeWindow类的成员函数queueBuffer的实现时就会看到这个逻辑。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 一旦FramebufferNativeWindow对象self内部有可用的空闲图形缓冲区，那么函数就会将这个空闲图形缓冲区就会返回给OpenGL库，即保存在输出参数buffer，并且将FramebufferNativeWindow对象self内部可用的空闲图形缓冲区的个数减1，以及将OpenGL库当前正前正在使用的图形缓冲区在数组buffers中的位置保存在FramebufferNativeWindow对象self的成员变量mCurrentBufferIndex中。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成FramebufferNativeWindow类的成员函数dequeueBuffer的实现了，接下来我们继续分析FramebufferNativeWindow类的成员函数queueBuffer的实现，如下所示：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; "></p><pre name="code" class="cpp">int FramebufferNativeWindow::queueBuffer(ANativeWindow* window,
        android_native_buffer_t* buffer)
{
    FramebufferNativeWindow* self = getSelf(window);
    Mutex::Autolock _l(self-&gt;mutex);
    framebuffer_device_t* fb = self-&gt;fbDev;
    buffer_handle_t handle = static_cast&lt;NativeBuffer*&gt;(buffer)-&gt;handle;

    const int index = self-&gt;mCurrentBufferIndex;
    GraphicLog&amp; logger(GraphicLog::getInstance());
    logger.log(GraphicLog::SF_FB_POST_BEFORE, index);

    int res = fb-&gt;post(fb, handle);

    logger.log(GraphicLog::SF_FB_POST_AFTER, index);

    self-&gt;front = static_cast&lt;NativeBuffer*&gt;(buffer);
    self-&gt;mNumFreeBuffers++;
    self-&gt;mCondition.broadcast();
    return res;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/ui/FramebufferNativeWindow.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数window指向的实际上也是一个FramebufferNativeWindow对象，这个FramebufferNativeWindow对象是在DisplayHardware类的成员函数init中创建的，因此，函数在开始的地方同样是先将它转换一个FramebufferNativeWindow对象self。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数buffer指向的是一个实际类型为NativeBuffer的图形缓冲区，这个图形缓冲区是在FramebufferNativeWindow类的成员函数dequeueBuffer中分配的，如前所述。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FramebufferNativeWindow类的成员函数queueBuffer目标就是要将参数buffer所描述的图形缓冲区渲染到硬件帧缓冲区中去，因此，我们就需要获得FramebufferNativeWindow对象self的成员变量fbDev所描述的一个fb设备。有了这个fb设备之后， 我们就可以调用它的成员函数post来将参数buffer所描述的图形缓冲区渲染到硬件帧缓冲区中去，这个过程可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 参数buffer所描述的图形缓冲区被渲染到硬件帧缓冲区中去之后，它就变成一个空闲的图形缓冲区了，因此，我们就需要将它返回给FramebufferNativeWindow对象self内部的图形缓冲区数组buffers中去，并且将可用的空闲图形缓冲区的个数增加1，最后通过FramebufferNativeWindow对象self的成员变量mCondition所描述的一个条件变量将前面正在等待从FramebufferNativeWindow对象self内部分配空闲图形缓的线程唤醒。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 至此，FramebufferNativeWindow类的成员函数queueBuffer的实现就分析完成了，FramebufferNativeWindow类的实现也分析完成了。通过GraphicPlane、DisplayHardware和FramebufferNativeWindow这三个类的实现，我们就可以知道SurfaceFlinger服务是如何管理系统的显示屏，即系统的硬件帧缓冲区的了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: left; ">&nbsp;&nbsp; &nbsp; &nbsp; 从SurfaceFlinger服务创建一个DisplayHardwareBase对象来管理系统的显示屏的过程可以知道，这个DisplayHardwareBase对象会创建一个控制台事件监控线程来监控硬件帧缓冲区的睡眠/唤醒状态切换事件，而从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8022957">Android系统Surface制的SurfaceFlinger服务的启动过程分析</a>一文又可以知道，System进程在启动SurfaceFlinger服务过程中，又会创建一个Binder线程池，以及为SurfaceFlinger服务创建一个UI渲染线程，这样在SurfaceFlinger服务中，就存在三种不同类型的线程，在接下来的一篇文章中，我们就将分析详细SurfaceFlinger服务的线程模型，以便最后我们就可以更好地分析SurfaceFlinger服务的实现，敬请关注！</p><p style="text-align: center; margin: 4px 0px; padding: 2px 0px;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-10-15 0:56:03 <a href="http://blog.csdn.net/luoshengyang/article/details/8046659">原文链接</a>
            </div>
            <div>
            阅读：10138 评论：30 <a href="http://blog.csdn.net/luoshengyang/article/details/8046659#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android系统Surface机制的SurfaceFlinger服务的线程模型分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8062945</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8062945</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-10-22 0:55:49</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面两篇文章中，我们分析了</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务的启动过程以及</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务初始化硬件帧缓冲区的过程。从这两个过程可以知道，</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务在启动的过程中，一共涉及到了三种类型的线程，它们分别是</span><span style="color:black;">Binder</span><span style="color:black;">线程、</span><span style="color:black;">UI</span><span style="color:black;">渲染线程和控制台事件监控线程。在本文中，我们就将详细分</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务的线程模型，即上述三种类型的线程是如何运行和交互的。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从<a href="http://blog.csdn.net/luoshengyang/article/details/8022957">Android系统Surface制的SurfaceFlinger服务的启动过程分析</a>一文可以知道，<span style="color: black; ">SurfaceFlinger</span><span style="color: black; ">服务是在System进程的主线程中启动的。System进程的主线程在启动系统的关键<span style="color: black; ">服务之前，会先启动一个Binder线程池。这样运行在System进程中的系统关系服务就可以与其它进程执行Binder进程间通信了。<span style="color: black; ">SurfaceFlinger</span><span style="color: black; ">服务虽然是由System进程的主线程来负责启动的，但是最终它会运行在一个独立的线程中。我们将这个独立的线程称为UI渲染线程，因为它负责渲染系统的UI。</span></span></span></span></p><p><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从<a href="http://blog.csdn.net/luoshengyang/article/details/8046659">Android系统Surface制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析</a>一文可以知道，<span style="color: black; ">SurfaceFlinger</span><span style="color: black; ">服务的UI渲染线程的启动的时候，会对系统的硬件帧缓冲区进行初始化。在初始化的过程，又会创建另外一个线程来监控硬件帧缓冲区的睡眠/唤醒状态切换事件。为了方便描述，我们这个线程称称为控制台事件监控线程。</span></span></span></span></span></p><p><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;上述的三种类型的线程的启动顺序，可以通过图1来描述，如下所示：</span></span></span></span></span></p><p style="text-align: center;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; "><img src="http://img.my.csdn.net/uploads/201210/13/1350062766_5445.jpg" alt="" /><br /></span></span></span></span></span></p><p style="text-align: center;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">图1 SurfaceFlinger服务的线程模型</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 从图1就可以清楚地看到，System进程的主线程负责启动Binder线程池，以及UI渲染线程，而UI渲染线程又负责启动控制台事件监控线程。在这三种类型的线程中，UI渲染线程是主角，Binder线程和控制台事件监控线程是配角。Binder线程池是为了让其它进程，例如Android应用程序进程，可以与SurfaceFlinger服务进行Binder进程间通信的，有一部分通信所执行的操作便是让UI渲染线程更新系统的UI。控制台事件监控线程是为了监控硬件帧缓冲区的睡眠/唤醒状态切换事件的。一旦硬件帧缓冲区要进入睡眠或者唤醒状态，控制台事件监控线程都需要通知UI渲染线程，以便UI渲染线程可以执行关闭或者启动显示屏的操作。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 接下来，为了弄清楚SurfaceFlinger服务的线程模型，我们就首先简要分析UI渲染线程的运行模型，接着再分析Binder线程与UI渲染线程的交互过程，最后分析控制台事件监控线程与UI渲染线程的交互过程。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 1.&nbsp;UI渲染线程的运行模型</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8010977">Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划</a>一文中提到，SurfaceFlinger服务的UI渲染线程有一个消息队列。当消息队列为空时，SurfaceFlinger服务的UI渲染线程就会进入睡眠等待状态。一旦SurfaceFlinger服务的Binder线程接收到其它进程发送过来的渲染UI的请求时，它就会往SurfaceFlinger服务的UI渲染线程的消息队列中发送一个消息，以便可以将SurfaceFlinger服务的UI渲染线程唤醒起来执行渲染的操作。同样，一旦SurfaceFlinger服务的控制台事件监控线程发现硬件帧缓冲区即将要进入睡眠或者唤醒状态时，它就会往SurfaceFlinger服务的UI渲染线程的消息队列中发送一个消息，以便SurfaceFlinger服务的UI渲染线程可以执行冻结或者解冻显示屏的操作。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8022957">Android系统Surface制的SurfaceFlinger服务的启动过程分析</a>一文又可以知道，SurfaceFlinger服务的UI渲染线程是以SurfaceFlinger类的成员函数threadLoop为线程执行体的，即SurfaceFlinger服务的UI渲染线程会不断地循环执行SurfaceFlinger类的成员函数threadLoop。接下来，我们就通过SurfaceFlinger类的成员函数threadLoop的实现来分析SurfaceFlinger服务的UI渲染线程的运行模型，如下所示：</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; "></span></span></span></span></span></p><pre name="code" class="cpp">bool SurfaceFlinger::threadLoop()
{
    waitForEvent();

    // check for transactions
    if (UNLIKELY(mConsoleSignals)) {
        handleConsoleEvents();
    }

    if (LIKELY(mTransactionCount == 0)) {
        // if we're in a global transaction, don't do anything.
        const uint32_t mask = eTransactionNeeded | eTraversalNeeded;
        uint32_t transactionFlags = getTransactionFlags(mask);
        if (LIKELY(transactionFlags)) {
            handleTransaction(transactionFlags);
        }
    }

    // post surfaces (if needed)
    handlePageFlip();

    const DisplayHardware&amp; hw(graphicPlane(0).displayHardware());
    if (LIKELY(hw.canDraw() &amp;&amp; !isFrozen())) {

#ifdef USE_COMPOSITION_BYPASS
        if (handleBypassLayer()) {
            unlockClients();
            return true;
        }
#endif

        // repaint the framebuffer (if needed)
        const int index = hw.getCurrentBufferIndex();
        GraphicLog&amp; logger(GraphicLog::getInstance());

        logger.log(GraphicLog::SF_REPAINT, index);
        handleRepaint();

        // inform the h/w that we're done compositing
        logger.log(GraphicLog::SF_COMPOSITION_COMPLETE, index);
        hw.compositionComplete();

        logger.log(GraphicLog::SF_SWAP_BUFFERS, index);
        postFramebuffer();

        logger.log(GraphicLog::SF_REPAINT_DONE, index);
    } else {
        // pretend we did the post
        hw.compositionComplete();
        usleep(16667); // 60 fps period
    }
    return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文可以知道，SurfaceFlinger类的成员函数threadLoop的工作过程如下所示：</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 调用SurfaceFlinger类的成员函数waitForEvent中检查SurfaceFlinger服务的UI渲染线程的消息队列是否为空。如果不为空，那么就会马上返回来执行其它的操作，否则的话，SurfaceFlinger服务的UI渲染线程就会进入睡眠等状态，直到被SurfaceFlinger服务的Binder线程或者控制台事件监控线程唤醒为止。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 当SurfaceFlinger服务的UI渲染线程被控制台事件监控线程唤醒时，SurfaceFlinger类的成员变量mConsoleSignals的值就会不等于0。在这种情况下，SurfaceFlinger类的成员函数threadLoop就会调用另外一个成员函数handleConsoleEvents来处理控制台事件。后面在分析SurfaceFlinger服务的UI渲染线程和控制台事件监控线程的交互过程时，我们再分析这个成员函数的实现。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3.&nbsp;SurfaceFlinger类的成员变量mTransactionCount用来描述SurfaceFlinger服务是否正在执行事务。如果SurfaceFlinger服务正在执行事务，那么SurfaceFlinger类的成员变量mTransactionCount的值就会大于0。怎么理解SurfaceFlinger服务所执行的事务是什么呢？这些事务是用来处理系统的显示属性的。这些属性划分为两种类型。一种类型是与整个显示屏属性相关的，例如屏幕旋转方向发生了变化，另一外类型是与某一个应用程序的Surface相关的，例如某一个Surface的大小或者Z轴位置发生了变化。一般来说，每当系统的显示属性发生了变化的时候，SurfaceFlinger服务的UI渲染线程都需要马上刷新系统UI，以便可以反映真实情况。但是，为了减少屏幕的闪烁，有时候可以将多个属性变化组合成一个事务来刷新系统UI。例如，我们可以在修改了一个Surface的大小和Z轴位置之后，才要求SurfaceFlinger服务的UI渲染线程去刷新系统UI，这样就可以减少一个刷新系统UI的操作。因此，只有当SurfaceFlinger类的成员变量mTransactionCount的值的等于0的时候，，SurfaceFlinger类的成员函数threadLoop才会判断系统的显示属性是否发生了变化。如果发生了变化，那么就会调用另外一个成员函数handleTransaction来进一步处理。在接下来的一篇文章中分析SurfaceFlinger服务的UI渲染过程时，我们就详细分析这个成员函数的实现。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;4.&nbsp;&nbsp;SurfaceFlinger服务的UI渲染线程接下来调用SurfaceFlinger类的成员函数handlePageFlip来通知各个应用程序的Surface将接下来要渲染的图形缓冲区设置为当前激活的图形缓冲区，以便接下来可以渲染到硬件帧缓冲区中去。我们同样会在接下来的一篇文章中分析SurfaceFlinger服务的UI渲染过程时，详细分析这个成员函数的实现。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;5. 如果SurfaceFlinger服务的UI渲染线程目前只有一个Surface需要渲染，并且SurfaceFlinger类在编译时，指定了USE_COMPOSITION_BYPASS宏，那么SurfaceFlinger类的成员函数threadLoop就会直接调用另外一个成员函数handleBypassLayer来将这个Surface直接渲染到硬件帧缓冲区中去。这是一个优化操作，避免执行接下来的Surface合成操作。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;6.&nbsp;如果SurfaceFlinger服务的UI渲染线程目前有多个Surface需要渲染，或者SurfaceFlinger类在编译时没指定USE_COMPOSITION_BYPASS宏，那么SurfaceFlinger类的成员函数threadLoop接下来就会调用另外一个成员函数handleRepaint来将各个Surface的图形缓冲区合成起来，以便接下来可以渲染到硬件帧缓冲区中去。Surface的合成操作比较复杂，因为它涉及到可见性计算等。我们同样会在接下来的一篇文章中分析SurfaceFlinger服务的UI渲染过程时，详细分析这个成员函数的实现。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 7. 要渲染的各个Surface的图形缓冲区被合成之后，SurfaceFlinger类的成员函数threadLoop接下来前面获得的用来描述系统主显示屏的DisplayHardware对象hw的成员函数compositionComplete来通知HAL层Gralloc模块中的fb设备，以便这个fb设备可以在Surface合成操作完成时执行一些逻辑。这一步是可选的，取决于HAL层Gralloc模块中的fb设备是否需要接收这个Surface合成完成通知。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 8. 上述步骤都执行完成之后，SurfaceFlinger类的成员函数threadLoop最后就可以调用SurfaceFlinger类的成员函数postFramebuffer来将合成后得到的图形缓冲区渲染到硬件帧缓冲区去了，这样就可以将系统的最新UI渲染出来，或者说刷新了系统的UI。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 在本小节中，我们只关注第1步的处理过程，即SurfaceFlinger类的成员函数waitForEvent的实现，以便可以了解SurfaceFlinger服务的UI渲染线程是如何围绕它的消息队列来运行的。</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceFlinger类的成员函数waitForEvent的实现如下所示：</span></span></span></span></span></p><p style="text-align: left;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; "><span style="color: black; "></span></span></span></span></span></p><pre name="code" class="cpp">void SurfaceFlinger::waitForEvent()
{
    while (true) {
        nsecs_t timeout = -1;
        const nsecs_t freezeDisplayTimeout = ms2ns(5000);
        if (UNLIKELY(isFrozen())) {
            // wait 5 seconds
            const nsecs_t now = systemTime();
            if (mFreezeDisplayTime == 0) {
                mFreezeDisplayTime = now;
            }
            nsecs_t waitTime = freezeDisplayTimeout - (now - mFreezeDisplayTime);
            timeout = waitTime&gt;0 ? waitTime : 0;
        }

        sp&lt;MessageBase&gt; msg = mEventQueue.waitMessage(timeout);

        // see if we timed out
        if (isFrozen()) {
            const nsecs_t now = systemTime();
            nsecs_t frozenTime = (now - mFreezeDisplayTime);
            if (frozenTime &gt;= freezeDisplayTimeout) {
                // we timed out and are still frozen
                LOGW(&quot;timeout expired mFreezeDisplay=%d, mFreezeCount=%d&quot;,
                        mFreezeDisplay, mFreezeCount);
                mFreezeDisplayTime = 0;
                mFreezeCount = 0;
                mFreezeDisplay = false;
            }
        }

        if (msg != 0) {
            switch (msg-&gt;what) {
                case MessageQueue::INVALIDATE:
                    // invalidate message, just return to the main loop
                    return;
            }
        }
    }
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在分析这个函数的实现之前，我们首先了解一下SurfaceFlinger类的三个成员变量mFreezeDisplay、mFreezeDisplayTime和mFreezeCount的含义。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 外部进程，例如，应用程序进程，可以请求SurfaceFlinger服务将显示屏冻结，这时候SurfaceFlinger类的成员变量mFreezeDisplay的值就会等于true。当显示屏被冻结时，SurfaceFlinger服务同时也会记录被冻结的起始时间，记录在SurfaceFlinger类的成员变量mFreezeDisplayTime中。另一方面，SurfaceFlinger服务在修改某一个Surface的显示属性时，例如，修改它的大小时，如果发现显示屏此时正处于被冻结的状态，这时候就会将SurfaceFlinger类的成员变量mFreezeCount的值增加1，表示这个Surface也需要冻结显示屏。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从SurfaceFlinger类的成员函数threadLoop的实现可以知道，SurfaceFlinger服务都会调用SurfaceFlinger类的另外一个成员函数isFrozen来判断显示屏是否处于冻结状态。如果是的话，那么SurfaceFlinger服务是不可以执行渲染UI的操作的。SurfaceFlinger类的成员函数isFrozen的实现如下所示：</p><p></p><pre name="code" class="cpp">class SurfaceFlinger :
        public BinderService&lt;SurfaceFlinger&gt;,
        public BnSurfaceComposer,
        protected Thread
{
    ......

private:
    ......

            inline bool isFrozen() const {
                return (mFreezeDisplay || mFreezeCount&gt;0) &amp;&amp; mBootFinished;
            }

    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.h中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的另外一个成员变量mBootFinished用来表示系统是否已经启动完成的。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7691321">Android系统的开机画面显示过程分析</a>一文可以知道，当系统启动完成时，第三个开机画面，即开动动画，就会被停止，同时SurfaceFlinger类的成员变量mBootFinished的值会被设置为true。从SurfaceFlinger类的成员函数isFrozen的实现也可以看出，只有当系统启动完成之后，显示屏才会有冻结的概念。由于在系统启动的过程中，显示屏都是依次被三个开机画面独占的，而在独占的期间，不会出现同时去修改显示属性的问题，因此就不需要去冻结显示屏。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;由于将显示屏冻结的目的一般是为了修改显示屏的显示属性，例如修改某一个Surface的大小或者修改显示并的旋转方向等，因此，通过SurfaceFlinger类的两个成员变量mFreezeDisplay和mFreezeCount，SurfaceFlinger服务就可以将多个显示属性变化合并在一起去渲染UI，避免单独为每一个显示属性变化执行一次UI渲染操作。单独为每一个显示属性变化执行一次UI渲染操作会出现什么情况呢？假如有两个显示属性是同时发生变化的，那么执行两次UI渲染操作就会可能导致冲突，从而造成一些画面上的误差。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 理解了SurfaceFlinger类的三个成员变量mFreezeDisplay、mFreezeDisplayTime和mFreezeCount的含义之后，接下来我们就可以分析SurfaceFlinger类的成员函数waitForEvent的实现了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 当消息队列为空时，SurfaceFlinger服务的UI渲染线程每一次进行睡眠等待状态的默认时间被设置为5000毫秒，保存在变量freezeDisplayTimeout中。但是如果显示屏当前正处于冻结状态，那么这个等待的时间就会从默认值减去已经被冻结的时间。这样做的目的是避免显示屏长时间被冻结而导致UI不能被渲染，即相当于是将显示屏的最长冻结时间设置为5000毫秒。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 最终得到的等待时间就保存在变量timeout中，接下来SurfaceFlinger类的成员函数waitForEvent就会调用成员变量mEventQueue所描述的一个消息队列的成员函数waitMessage来检查是否有新的消息需要处理。如果没有，那么SurfaceFlinger服务的UI渲染线程就会进入到睡眠等待状态中去，直到消息队列有新的消息需要处理或者等待超时为止。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceFlinger服务的UI渲染线程从SurfaceFlinger类的成员变量mEventQueue所描述的一个消息队列的成员函数waitMessage返回来时，如果有新的消息需要处理，那么变量msg就指向这个需要处理的新消息，即变量msg的值不等于0。目前SurfaceFlinger服务的UI渲染线程只处理一种类型为MessageQueue::INVALIDATE的消息，因此，变量msg所指向的消息的类型为MessageQueue::INVALIDATE时，SurfaceFlinger服务的UI渲染线程就会从SurfaceFlinger类的成员函数waitForEvent中返回到调用它的成员函数threadLoop中去，以便可以处理控制台事件或者渲染UI的操作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 注意，当SurfaceFlinger服务的UI渲染线程从SurfaceFlinger类的成员变量mEventQueue所描述的一个消息队列的成员函数waitMessage返回来时，如果这时候显示屏仍然处于冻结状态，那么SurfaceFlinger类的成员函数waitForEvent就需要检查显示屏的冻结时间是否已经大于等于5000毫秒。如果大于等于的话，那么就会自动对显示屏执行解冻操作，即分别将SurfaceFlinger类的成员变量mFreezeDisplayTime、mFreezeCount和mFreezeDisplay的值重置为0、0和false。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员变量mEventQueue所描述的一个消息队列的类型为MessageQueue，实现在文件frameworks/base/services/surfaceflinger/MessageQueue.cpp，它与<a href="http://blog.csdn.net/luoshengyang/article/details/6817933">Android应用程序线程的消息队列</a>的实现思路是类似的，不过会更简单一些。简单来说，这个消息队列就是由一个消息列表以及一个条件变量组成。当消息列表为空时，调用MessageQueue类的成员函数waitMessage的线程就会在MessageQueue类内部的条件变量上进入睡眠等状态。而当其它线程向这个消息队列添加一个新消息的时候，就会通过MessageQueue类内部的条件变量来将前面正在等待的线程唤醒起来，以它可以将前面加入到它的消息队列中的新消息取出来处理。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;至此，我们就分析完成SurfaceFlinger服务的UI渲染线程的运行模型了，在下一篇文章中我们还会继续详细分析这个线程是如何执行UI渲染操作的，接下来我们接着分析Binder线程与UI渲染线程的交互过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp;Binder线程与UI渲染线程的交互过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面提到，System进程在启动SurfaceFlinger服务之前，首先会启动一个Binder线程池。Binder线程池的启动过程可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/6629298">Android系统进程间通信（IPC）机制Binder中的Server启动过程源代码分析</a>一文。System进程中的Binder线程池启动起来之后，其它进程，例如Android应用程序进程，就可以请求SurfaceFlinger服务来渲染系统的UI了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;以<a href="http://blog.csdn.net/luoshengyang/article/details/7691321">Android系统的开机动画应用程序bootanim</a>为例，当它需要刷新自己的UI时，就会通过它所运行在的进程的SurfaceClient单例的成员函数signalServer来向SurfaceFlinger服务发送一个Binder进程间通信请求，这一点可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文。接下来，我们就从SurfaceClient类的成员函数signalServer来分析SurfaceFlinger服务的Binder线程与UI渲染线程的交互过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceClient类的成员函数signalServer的实现如下所示：</p><p></p><pre name="code" class="cpp">class SurfaceClient : public Singleton&lt;SurfaceClient&gt;  
{  
    // all these attributes are constants  
    sp&lt;ISurfaceComposer&gt; mComposerService;  
    ......  
  
public:  
    ......  
  
    void signalServer() const {  
        mComposerService-&gt;signal();  
    }  
};  </pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceClient类的成员变量mComposerService指向的是一个类型为BpSurfaceComposer的Binder代理对象，这个Binder代理对象引用了SurfaceFlinger服务，因此，SurfaceClient类的成员函数signalServer实际上就是通过BpSurfaceComposer类的成员函数signal来向SurfaceFlinger服务发送一个进程间通信请求。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;BpSurfaceComposer类的成员函数signal的实现如下所示：</p><p></p><pre name="code" class="cpp">class BpSurfaceComposer : public BpInterface&lt;ISurfaceComposer&gt;
{
public:
    ......

    virtual void signal() const
    {
        Parcel data, reply;
        data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
        remote()-&gt;transact(BnSurfaceComposer::SIGNAL, data, &amp;reply, IBinder::FLAG_ONEWAY);
    }
};</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/surfaceflinger_client/ISurfaceComposer.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从这里就可以看出，BpSurfaceComposer类的成员函数signal所执行的操作就是向SurfaceFlinger服务发送一个类型为BnSurfaceComposer::SIGNAL的进程间通信请求，而SurfaceFlinger服务是在SurfaceFlinger类的成员函数signal中处理类型为BnSurfaceComposer::SIGNAL的进程间通信请求的，如下所示：</p><p></p><pre name="code" class="cpp">void SurfaceFlinger::signal() const {
    // this is the IPC call
    const_cast&lt;SurfaceFlinger*&gt;(this)-&gt;signalEvent();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数signal调用了另外一个成员函数signalEvent来进一步处理类型为BnSurfaceComposer::SIGNAL的进程间通信请求的，如下所示：</p><p></p><pre name="code" class="cpp">void SurfaceFlinger::signalEvent() {
    mEventQueue.invalidate();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 前面提到，SurfaceFlinger类的成员变量mEventQueue指向的是SurfaceFlinger服务的UI渲染线程的消息队列，这个消息队列的类型为MessageQueue。SurfaceFlinger类的成员函数signalEvent要执行的操作便是向SurfaceFlinger服务的UI渲染线程的消息队列发送一个类型为MessageQueue::INVALIDATE的消息，这是通过调用MessageQueue类的成员函数invalidate来实现的，如下所示：</p><p></p><pre name="code" class="cpp">status_t MessageQueue::invalidate() {
    Mutex::Autolock _l(mLock);
    mInvalidate = true;
    mCondition.signal();
    return NO_ERROR;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/MessageQueue.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;MessageQueue类的成员函数invalidate并不是真的向SurfaceFlinger服务的UI渲染线程的消息队列发送一个消息，而是将MessageQueue的类成员变量mInvalidate的值设置为true，并且通过MessageQueue类的成员变量mCondition所描述的一个条件变量来将SurfaceFlinger服务的UI渲染线程唤醒。当SurfaceFlinger服务的UI渲染线程被唤醒时，就会检查MessageQueue的类成员变量mInvalidate是否为true。如果是的话，那么就会获得一个类型为MessageQueue::INVALIDATE的消息，这个消息最终是在SurfaceFlinger类的成员函数threadLoop中处理的，如前面第1部分的内容所示。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;至此，我们就分析完成SurfaceFlinger服务的Binder线程与UI渲染线程的交互过程了，接下来我们再分析SurfaceFlinger服务的控制台事件监控线程与UI渲染线程的交互过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 3.&nbsp;控制台事件监控线程与UI渲染线程的交互过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8046659">Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析</a>一文可以知道，SurfaceFlinger服务的控制台事件监控线程是以DisplayEventThread类的成员函数threadLoop为执行体的，即SurfaceFlinger服务的控制台事件监控线程会不断地循环调用DisplayEventThread类的成员函数threadLoop，以便可以监控硬件帧缓冲区的睡眠/唤醒状态切换事件。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayEventThread类的成员函数threadLoop的实现如下所示：</p><p></p><pre name="code" class="cpp">bool DisplayHardwareBase::DisplayEventThread::threadLoop()
{
    int err = 0;
    char buf;
    int fd;

    fd = open(kSleepFileName, O_RDONLY, 0);
    do {
      err = read(fd, &amp;buf, 1);
    } while (err &lt; 0 &amp;&amp; errno == EINTR);
    close(fd);
    LOGW_IF(err&lt;0, &quot;ANDROID_WAIT_FOR_FB_SLEEP failed (%s)&quot;, strerror(errno));
    if (err &gt;= 0) {
        sp&lt;SurfaceFlinger&gt; flinger = mFlinger.promote();
        LOGD(&quot;About to give-up screen, flinger = %p&quot;, flinger.get());
        if (flinger != 0) {
            mBarrier.close();
            flinger-&gt;screenReleased(0);
            mBarrier.wait();
        }
    }
    fd = open(kWakeFileName, O_RDONLY, 0);
    do {
      err = read(fd, &amp;buf, 1);
    } while (err &lt; 0 &amp;&amp; errno == EINTR);
    close(fd);
    LOGW_IF(err&lt;0, &quot;ANDROID_WAIT_FOR_FB_WAKE failed (%s)&quot;, strerror(errno));
    if (err &gt;= 0) {
        sp&lt;SurfaceFlinger&gt; flinger = mFlinger.promote();
        LOGD(&quot;Screen about to return, flinger = %p&quot;, flinger.get());
        if (flinger != 0)
            flinger-&gt;screenAcquired(0);
    }
    return true;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8046659">Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析</a>一文可以知道，DisplayEventThread类的成员变量kSleepFileName要么指向文件/sys/power/wait_for_fb_sleep，要么是指向文件/sys/android_power/wait_for_fb_sleep，而DisplayEventThread类的成员变量kWakeFileName要么指向文件/sys/power/wait_for_fb_wake，要么指向文件/sys/android_power/wait_for_fb_wake。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;文件/sys/power/wait_for_fb_sleep和文件/sys/android_power/wait_for_fb_sleep是用来监控硬件帧缓冲区的睡眠事件的，而文件/sys/power/wait_for_fb_wake和文件/sys/android_power/wait_for_fb_wake是用来监控硬件帧缓冲区的唤醒事件的。文件/sys/power/wait_for_fb_sleep和文件/sys/power/wait_for_fb_wake是硬件帧缓冲区控制台提供的新式接口，而文件/sys/android_power/wait_for_fb_sleep和文件/sys/android_power/wait_for_fb_wake是件帧缓冲区控制台提供的旧式接口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DisplayEventThread类的成员函数threadLoop首先是监控硬件帧缓冲区的睡眠事件，这是通过监控文件kSleepFileName的内容来实现的，即首先调用函数open来打开文件kSleepFileName，然后再调用函数read来检查这个文件是否有内容可读。当文件kSleepFileName有新的内容可读时，那么就说明硬件帧缓冲区要进入睡眠状态了，这时候SurfaceFlinger服务的控制台事件监控线程就需要通知UI渲染线程来释放系统的显示屏。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DisplayEventThread类的成员变量mFlinger指向了系统中的SurfaceFlinger服务，因此，DisplayEventThread类的成员函数threadLoop就可以调用它的成员函数screenReleased来通知SurfaceFlinger服务的UI渲染线程来释放系统的显示屏。由于DisplayEventThread类的成员变量mFlinger是一个类型为SurfaceFlinger的弱指针，因此，在使用它之前，首先要调用它的成员函数promote来将它升级为一个强指针flinger。如果升级成功，那么才说明它所指向的SurfaceFlinger服务还活着。弱指针升级为强指针的原理可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/6786239">Android系统的智能指针（轻量级指针、强指针和弱指针）的实现原理分析</a>一文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger服务的控制台事件监控线程调用SurfaceFlinger类的成员函数screenReleased来通知UI渲染线程来释放系统的显示屏之后，就会通过DisplayEventThread类的成员变量mBarrier所描述的一个屏障的成员函数wait来进入到睡眠等待状态，直到被SurfaceFlinger服务的UI渲染线程唤醒为止。接下来，我们就通过SurfaceFlinger类的成员函数screenReleased来分析SurfaceFlinger服务的UI渲染线程是如何释放系统的显示屏以及唤醒控制台事件监控线程的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数screenReleased的实现如下所示：</p><p></p><pre name="code" class="cpp">void SurfaceFlinger::screenReleased(int dpy)
{
    // this may be called by a signal handler, we can't do too much in here
    android_atomic_or(eConsoleReleased, &amp;mConsoleSignals);
    signalEvent();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数screenReleased的实现很简单，它首先将SurfaceFlinger类的成员变量mConsoleSignals的eConsoleReleased位设置为1，接着再通过SurfaceFlinger类的成员函数signalEvent来唤醒UI渲染线程。从前面第1部分的内容可知道，UI渲染线程被唤醒之后，就会调用SurfaceFlinger类的成员函数handleConsoleEvents来处理硬件帧缓冲区的睡眠事件。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handleConsoleEvents处理硬件帧缓冲区的睡眠事件的代码如下所示：</p><p></p><pre name="code" class="cpp">void SurfaceFlinger::handleConsoleEvents()
{
    // something to do with the console
    const DisplayHardware&amp; hw = graphicPlane(0).displayHardware();

    int what = android_atomic_and(0, &amp;mConsoleSignals);
    ......

    if (mDeferReleaseConsole &amp;&amp; hw.isScreenAcquired()) {
        // We got the release signal before the acquire signal
        mDeferReleaseConsole = false;
        hw.releaseScreen();
    }

    if (what &amp; eConsoleReleased) {
        if (hw.isScreenAcquired()) {
            hw.releaseScreen();
        } else {
            mDeferReleaseConsole = true;
        }
    }

    mDirtyRegion.set(hw.bounds());
}</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handleConsoleEvents处理硬件帧缓冲区睡眠事件的过程如下所示：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 首先检查SurfaceFlinger类的成员变量mDeferReleaseConsole的值是否等于true，并且系统显示屏当前是否处于可访问的状态。如果均是的话，那么就说明有一个延迟执行的释放系统显示屏的操作在等待执行，因此，这时候就会调用用来描述系统显示屏的一个DisplayHardware对象的成员函数releaseScreen来释放系统显示屏，并且将SurfaceFlinger类的成员变量mDeferReleaseConsole的值设置为false，表示这个延迟执行的释放系统显示屏的操作已经被执行了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2 &nbsp;接着检查系统显示屏当前是否处于可访问的状态。如果是的话，那么就直接调用用来描述系统显示屏的一个DisplayHardware对象的成员函数releaseScreen来释放系统显示屏，否则的话，就会将SurfaceFlinger类的成员变量mDeferReleaseConsole的值设置为true，表示要延迟执行一个释放系统显示屏的操作，因为系统显示屏当前是处于释放的状态的。&nbsp;</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. 最后将系统显示屏的脏区域mDirtyRegion设置为整个显示屏的大小，表示接下来要刷新整个显示屏的UI，这是因为硬件帧缓冲区的状态发生了变化，即要从唤醒状态进入睡眠状态了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;判断系统显示屏是否处于可访问状态是通过调用DisplayHardware类的成员函数isScreenAcquired来实现的，而DisplayHardware类的成员函数isScreenAcquired是从父类DisplayHardwareBase类继承下来的，因此，接下来我们就继续分析DisplayHardwareBase类的成员函数isScreenAcquired的实现，如下所示：</p><p></p><pre name="code" class="cpp">bool DisplayHardwareBase::isScreenAcquired() const
{
    return mScreenAcquired;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp中。<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 当硬件帧缓冲区处于唤醒状态时，SurfaceFlinger服务就可以访问系统显示屏，而硬件帧缓冲区处于是否处于唤醒状态是记录在DisplayHardwareBase类的成员变量mScreenAcquired中的，因此，当DisplayHardwareBase类的成员变量mScreenAcquired中的值等于true时，就表示SurfaceFlinger服务可以访问系统显示屏。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;释放系统显示屏的操作是通过调用DisplayHardware类的成员函数releaseScreen来实现的，而DisplayHardware类的成员函数releaseScreen是从父类DisplayHardwareBase类继承下来的，因此，接下来我们就继续分析DisplayHardwareBase类的成员函数releaseScreen的实现，如下所示：</p><p></p><pre name="code" class="cpp">void DisplayHardwareBase::releaseScreen() const
{
    status_t err = mDisplayEventThread-&gt;releaseScreen();
    if (err &gt;= 0) {
        mScreenAcquired = false;
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayHardwareBase类的成员函数releaseScreen首先调用其成员变量mDisplayEventThread所描述的一个控制台事件监控线程的成员函数releaseScreen来执行释放系统显示屏的操作。如果释放成功，那么接下来就会继续将DisplayHardwareBase类的成员变量mScreenAcquired的值设置为false，以表示系统显示屏处于不可访问状态。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayHardwareBase类的成员变量mDisplayEventThread的类型为DisplayEventThread，因此，接下来我们就继续分析DisplayEventThread的成员函数releaseScreen的实现，看看它是如何执行释放系统显示屏的操作的，如下所示：</p><p></p><pre name="code" class="cpp">status_t DisplayHardwareBase::DisplayEventThread::releaseScreen() const
{
    mBarrier.open();
    return NO_ERROR;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayEventThread类的成员函数releaseScreen的实现很简单，它只是将睡眠其成员变量mBarrier所描述的一个屏障的线程唤醒。从前面的描述可以知道，当前正在执行的DisplayEventThread类的成员函数releaseScreen的线程为SurfaceFlinger服务的UI渲染线程，而正在DisplayEventThread类成员变量mBarrier所描述的一个屏障的线程为SurfaceFlinger服务的控制台事件监控线程。因此，经过这一步之后，SurfaceFlinger服务的控制台事件监控线程就被唤醒了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceFlinger服务的控制台事件监控线程被唤醒之后，回到DisplayEventThread类的成员函数threadLoop中，我们继续分析它是如何监控硬件帧缓冲区的唤醒事件的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayEventThread类的成员函数threadLoop是通过监控文件kWakeFileName的内容来监控硬件帧缓冲区的唤醒事件的，即首先调用函数open来打开文件kWakeFileName，然后再调用函数read来检查这个文件是否有内容可读。当文件kWakeFileName有新的内容可读时，那么就说明硬件帧缓冲区要进入唤醒状态了，这时候SurfaceFlinger服务的控制台事件监控线程就需要通知UI渲染线程来获取系统的显示屏，即将系统的显示屏的状态设置为可访问。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 前面提到，DisplayEventThread类的成员变量mFlinger指向了系统中的SurfaceFlinger服务，因此，DisplayEventThread类的成员函数threadLoop就可以调用它的成员函数screenAcquired来通知SurfaceFlinger服务的UI渲染线程来将获取系统的显示屏。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceFlinger类的成员函数screenAcquired的实现如下所示：</p><p></p><pre name="code" class="cpp">void SurfaceFlinger::screenAcquired(int dpy)
{
    // this may be called by a signal handler, we can't do too much in here
    android_atomic_or(eConsoleAcquired, &amp;mConsoleSignals);
    signalEvent();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数screenAcquired的实现很简单，它首先将SurfaceFlinger类的成员变量mConsoleSignals的eConsoleAcquired位设置为1，接着再通过SurfaceFlinger类的成员函数signalEvent来唤醒UI渲染线程。从前面第1部分的内容可知道，UI渲染线程被唤醒之后，就会调用SurfaceFlinger类的成员函数handleConsoleEvents来处理硬件帧缓冲区的唤醒事件。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handleConsoleEvents处理硬件帧缓冲区的唤醒事件的代码如下所示：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void SurfaceFlinger::handleConsoleEvents()
{
    // something to do with the console
    const DisplayHardware&amp; hw = graphicPlane(0).displayHardware();

    int what = android_atomic_and(0, &amp;mConsoleSignals);
    if (what &amp; eConsoleAcquired) {
        hw.acquireScreen();
        // this is a temporary work-around, eventually this should be called
        // by the power-manager
        SurfaceFlinger::turnElectronBeamOn(mElectronBeamAnimationMode);
    }

    ......

    mDirtyRegion.set(hw.bounds());
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handleConsoleEvents处理硬件帧缓冲区唤醒事件的过程如下所示：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. &nbsp;首先调用用来描述系统显示屏的一个DisplayHardware对象的成员函数acquireScreen来将系统显示屏的状态设置为可访问。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 接着再调用SurfaceFlinger类的静态成员函数turnElectronBeamOn来点亮屏幕。在点亮屏幕的时候，通过参数mElectronBeamAnimationMode来表示要显示一个屏幕点亮动画。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. 最后将系统显示屏的脏区域mDirtyRegion设置为整个显示屏的大小，表示接下来要刷新整个显示屏的UI，这是因为硬件帧缓冲区的状态发生了变化，即要从睡眠状态进入唤醒状态了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;将系统显示屏的状态设置为可访问是通过调用DisplayHardware类的成员函数acquireScreen来实现的，而DisplayHardware类的成员函数acquireScreen是从父类DisplayHardwareBase类继承下来的，因此，接下来我们就继续分析DisplayHardwareBase类的成员函数acquireScreen的实现，如下所示：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void DisplayHardwareBase::acquireScreen() const
{
    status_t err = mDisplayEventThread-&gt;acquireScreen();
    if (err &gt;= 0) {
        mScreenAcquired = true;
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayHardwareBase类的成员函数acquireScreen首先调用其成员变量mDisplayEventThread所描述的一个控制台事件监控线程的成员函数acquireScreen来执行获取系统显示屏的操作。如果获取成功，那么接下来就会继续将DisplayHardwareBase类的成员变量mScreenAcquired的值设置为true，以表示系统显示屏处于可访问状态。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DisplayHardwareBase类的成员变量mDisplayEventThread的类型为DisplayEventThread，它的成员函数acquireScreen是从父类DisplayEventThreadBase继承下来的，因此，接下来我们就继续分析DisplayEventThreadBase的成员函数acquireScreen的实现，看看它是如何执行获取系统显示屏的操作的，如下所示：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">class DisplayHardwareBase
{
    ......

private:
    class DisplayEventThreadBase : public Thread {
        ......
    public:
        ......

        virtual status_t acquireScreen() const { return NO_ERROR; };
        ......
    };

    ......
};</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardwareBase.h中。<br /><p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;从前面的描述可以知道，当前正在执行的DisplayEventThreadBase类的成员函数acquireScreen的线程为SurfaceFlinger服务的UI渲染线程，由于硬件帧缓冲区唤醒之后，它就可以自动地获得系统的显示屏了，并且它不需要与SurfaceFlinger服务的控制台事件监控线程进行交互，因此，DisplayEventThreadBase类的成员函数acquireScreen什么也不用做，直接返回一个成功码NO_ERROR给调用者就可以了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成SurfaceFlinger服务的控制台事件监控线程与UI渲染线程的交互过程了，整个SurfaceFlinger服务的线程模型也分析完成了。理解了SurfaceFlinger服务的线程模型之后，在接下来的一篇文章中，我们就可以集中火力来分析SurfaceFlinger服务的UI渲染线程是如何将系统UI渲染到硬件帧缓冲区中去的了，敬请关注！</p><p style="text-align: center; margin: 4px 0px; padding: 2px 0px;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-10-22 0:55:49 <a href="http://blog.csdn.net/luoshengyang/article/details/8062945">原文链接</a>
            </div>
            <div>
            阅读：7605 评论：17 <a href="http://blog.csdn.net/luoshengyang/article/details/8062945#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8079456</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8079456</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-11-5 0:59:47</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面的一系列文章中，我们学习了</span><span style="color:black;">Android</span><span style="color:black;">应用程序与</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务的关系，以及</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务的启动过程、初始化硬件帧缓冲区的过程、线程模型。</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务所做的一切都是为了给</span><span style="color:black;">Android</span><span style="color:black;">应用程序提服务的，即为</span><span style="color:black;">Android</span><span style="color:black;">应用程序渲染它们的</span><span style="color:black;">UI</span><span style="color:black;">。在本文中，我们就详细分析</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务渲染</span><span style="color:black;">Android</span><span style="color:black;">应用程序</span><span style="color:black;">UI</span><span style="color:black;">的过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8062945">Android系统Surface制的SurfaceFlinger服务的线程模型分析</a>一文可以知道，<span style="color: black; ">SurfaceFlinger</span><span style="color: black; ">服务是通过它的UI渲染线程来将应用程序的UI渲染到硬件帧缓冲区中去的，因此，接下来我们就通过分析<span style="color: black; ">SurfaceFlinger</span><span style="color: black; ">服务的UI渲染线程的执行过程来分应用程序UI的渲染过程，这个过程如图1所示。</span></span></span></p><p style="text-align: center;"><span style="color:black;"><span style="color: black; "><span style="color: black; "><img src="http://img.my.csdn.net/uploads/201210/18/1350489913_5651.jpg" alt="" /><br /></span></span></span></p><p style="text-align: center;"><span style="color:black;"><span style="color: black; "><span style="color: black; ">图1 SurfaceFlinger服务渲染应用程序UI的示意图</span></span></span></p><p><span style="color:black;"><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从图1就可以看出，<span style="color: black; ">SurfaceFlinger</span><span style="color: black; ">服务的UI渲染线程的执行过程如下所示：</span></span></span></span></p><p><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 调用SurfaceFlinger类的成员函数handleConsoleEvents来处理控制台事件。</span></span></span></span></p><p><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp;调用SurfaceFlinger类的成员函数handleTransaction来处理系统显示屏以及应用程序窗口的属性变化，例如大小、旋转方向变化等。</span></span></span></span></p><p><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3.&nbsp;调用SurfaceFlinger类的成员函数handlePageFlip来让各个应用程序窗口设置它们当前所要渲染的图形缓冲区。</span></span></span></span></p><p><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;4. 如果SurfaceFlinger服务在编译的时候指定了USE_COMPOSITION_BYPASS宏，并且当前需要渲染的应用程序窗口只有一个，那么就会调用SurfaceFlinger类的成员函数handleBypassLayer来直接将这个应用程序窗口的图形缓冲区渲染到硬件帧缓冲区中去，否则的话，就要调用SurfaceFlinger类的成员函数handleRepaint来合成所有的应用程序窗口的图形缓冲区到一个主图形缓冲区中去。</span></span></span></span></p><p><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;5.&nbsp;调用SurfaceFlinger类的成员函数postFramebuffer将前面得到的主图形缓冲区渲染到硬件帧缓冲区中去。</span></span></span></span></p><p><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面<a href="http://blog.csdn.net/luoshengyang/article/details/8062945">Android系统Surface制的SurfaceFlinger服务的线程模型分析</a>一文中，我们已经分析过第1步的实现了，而通过前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>这一系列文章的学习，我们也已经了解了应用程序窗口的图形缓冲区的创建过程，因此，接下来我们就在这些知识的基础上来详细分析第2步到第5的实现，即分别分析SurfaceFlinger类的成员函数handleTransaction、handlePageFlip、handleBypassLayer和postFramebuffer的实现。</span></span></span></span></p><p><span style="color:black;"><span style="color: black; "><span style="color: black; "><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 1.&nbsp;handleTransaction</span></span></span></span></p><p>&nbsp;&nbsp; &nbsp; &nbsp; SurfaceFlinger类的成员函数handleTransaction是用来处理系统显示屏以及应用程序窗口的属性变化的，这个过程如图2所示。</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/18/1350491987_1022.jpg" alt="" /><br /></p><p style="text-align: center;">图2&nbsp;系统显示屏以及应用程序窗口的属性变化处理过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个过程可以分为6个步骤，接下来我们就详细分析每一个步骤。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 1.&nbsp;SurfaceFlinger.handleTransaction</p><p></p><pre name="code" class="cpp">void SurfaceFlinger::handleTransaction(uint32_t transactionFlags)
{
    Vector&lt; sp&lt;LayerBase&gt; &gt; ditchedLayers;

    /*
     * Perform and commit the transaction
     */

    { // scope for the lock
        Mutex::Autolock _l(mStateLock);
        const nsecs_t now = systemTime();
        mDebugInTransaction = now;
        handleTransactionLocked(transactionFlags, ditchedLayers);
        mLastTransactionTime = systemTime() - now;
        mDebugInTransaction = 0;
        // here the transaction has been committed
    }

    /*
     * Clean-up all layers that went away
     * (do this without the lock held)
     */
    const size_t count = ditchedLayers.size();
    for (size_t i=0 ; i&lt;count ; i++) {
        if (ditchedLayers[i] != 0) {
            //LOGD(&quot;ditching layer %p&quot;, ditchedLayers[i].get());
            ditchedLayers[i]-&gt;ditch();
        }
    }
} </pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handleTransaction是通过调用另外一个成员函数handleTransactionLocked来处理系统显示屏以及应用程序窗口的属性变化的，而SurfaceFlinger类的成员函数handleTransactionLocked在处理完成系统显示屏以及应用程序窗口的属性变化之后，会返回系统中那些已经销毁了的应用程序窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>这一系列文章可以知道，在SurfaceFlinger服务这一侧，应用程序窗口一般是使用一个Layer对象来描述的，又由于Layer类是从LayerBase类继承下来的，因此，我们可以那些已经销毁了的应用程序窗口保存在一个类型为sp&lt;LayerBase&gt;的向量ditchedLayers中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handleTransaction最后就调用保存在向量ditchedLayers中的每一个LayerBase对象的成员函数dtich来执行被销毁的应用程序窗口的清理操作，接下来我们就继续分析SurfaceFlinger类的成员函数handleTransactionLocked，看看它是如何处理系统显示屏以及应用程序窗口的属性变化的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2.&nbsp;SurfaceFlinger.handleTransactionLocked</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handleTransactionLocked定义在文件rameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中，我们分三段来阅读：</p><p></p><pre name="code" class="cpp">void SurfaceFlinger::handleTransactionLocked(
        uint32_t transactionFlags, Vector&lt; sp&lt;LayerBase&gt; &gt;&amp; ditchedLayers)
{
    const LayerVector&amp; currentLayers(mCurrentState.layersSortedByZ);
    const size_t count = currentLayers.size();

    /*
     * Traversal of the children
     * (perform the transaction for each of them if needed)
     */

    const bool layersNeedTransaction = transactionFlags &amp; eTraversalNeeded;
    if (layersNeedTransaction) {
        for (size_t i=0 ; i&lt;count ; i++) {
            const sp&lt;LayerBase&gt;&amp; layer = currentLayers[i];
            uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);
            if (!trFlags) continue;

            const uint32_t flags = layer-&gt;doTransaction(0);
            if (flags &amp; Layer::eVisibleRegion)
                mVisibleRegionsDirty = true;
        }
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来处理应用程序窗口的属性变化。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数transactionFlags最开始是从SurfaceFlinger类的成员函数threadLoop传进来的。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8062945">Android系统Surface制的SurfaceFlinger服务的线程模型分析</a>一文可以知道，SurfaceFlinger类的成员函数threadLoop在调用另外一个成员函数handleTransaction来处理系统显示屏以及应用程序窗口的属性变化之前，首先会调用成员函数getTransactionFlags来检查系统显示屏或者应用程序窗口的属性是否发生了变化。如果系统显示屏的属性发生了变化，那么传到这里的参数transactionFlags的eTransactionNeeded位就会等于1，而如果有应用程序窗口的属性发生了变化，那么传到这里的参数transactionFlags的eTraversalNeeded位就会等于1。为了方便描述，我们假设系统显示屏以及应用程序窗口的属性都发生了变化。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; SurfaceFlinger类的成员变量mCurrentState指向了一个State对象，用来描述SufaceFlinger服务的当前状态，其中，这个State对象的成员变量layersSortedByZ是一个类型为LayerVector的向量，它里面保存了SufaceFlinger服务当前所需要渲染的应用程序窗口，而这些应用程序窗口都是使用一个LayerBase对象来描述的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这段代码首先获得SufaceFlinger服务当前所需要渲染的应用程序窗口，接着再通过一个for循环来依次检查每一个应用程序窗口的属性是否发生了变化。如果某一个应用程序窗口的属性被修改过，那么调用用来描述这个应用程序窗口的一个LayerBase对象的成员函数getTransactionFlags得到的返回值trFlags就不会等于0，在这种情况下，这段代码就会调用这个LayerBase对象的成员函数doTransaction来处理对应的应用程序窗口的属性变化。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在LayerBase类中，有一个类型为int32_t的成员变量mTransactionFlags，每当SurfaceFlinger服务修改某一个应用程序窗口的属性时，都会将与其对应的LayerBase的成员变量mTransactionFlags的相应的位设置为1，这样LayerBase类的成员函数getTransactionFlags就可以通过这个成员变量来判断一个应用程序窗口的属性是否发生变化了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 如果一个应用程序窗口发生的属性变化是可见区域发生了改变，那么对应的LayerBase对象的成员函数doTransaction的返回值flags的Layer::eVisibleRegion位就会等于1。在这种情况下，这段代码就会将&nbsp;SurfaceFlinger类的成员变量mVisibleRegionsDirty的值设置为true，表示后面要重新计算各个应用程序窗口的可见区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;为了方便描述，我们假设发生了属性变化的应用程序窗口是一个普通类型的Surface，即用来描述它的实际是一个从LayerBase类继承下来的Layer对象。在这种情况下，前面实际上调用了Layer类的成员函数doTransaction来处理一个应用程序窗口的属性变化。在接下来的Step 3中，我们再详细分析Layer类的成员函数doTransaction的实现，现在我们接着往下阅读SurfaceFlinger类的成员函数handleTransactionLocked的代码：</p><p></p><pre name="code" class="cpp">    /*
     * Perform our own transaction if needed
     */

    if (transactionFlags &amp; eTransactionNeeded) {
        if (mCurrentState.orientation != mDrawingState.orientation) {
            // the orientation has changed, recompute all visible regions
            // and invalidate everything.

            const int dpy = 0;
            const int orientation = mCurrentState.orientation;
            const uint32_t type = mCurrentState.orientationType;
            GraphicPlane&amp; plane(graphicPlane(dpy));
            plane.setOrientation(orientation);

            // update the shared control block
            const DisplayHardware&amp; hw(plane.displayHardware());
            volatile display_cblk_t* dcblk = mServerCblk-&gt;displays + dpy;
            dcblk-&gt;orientation = orientation;
            dcblk-&gt;w = plane.getWidth();
            dcblk-&gt;h = plane.getHeight();

            mVisibleRegionsDirty = true;
            mDirtyRegion.set(hw.bounds());
        }

        if (mCurrentState.freezeDisplay != mDrawingState.freezeDisplay) {
            // freezing or unfreezing the display -&gt; trigger animation if needed
            mFreezeDisplay = mCurrentState.freezeDisplay;
            if (mFreezeDisplay)
                 mFreezeDisplayTime = 0;
        }

        if (currentLayers.size() &gt; mDrawingState.layersSortedByZ.size()) {
            // layers have been added
            mVisibleRegionsDirty = true;
        }

        // some layers might have been removed, so
        // we need to update the regions they're exposing.
        if (mLayersRemoved) {
            mLayersRemoved = false;
            mVisibleRegionsDirty = true;
            const LayerVector&amp; previousLayers(mDrawingState.layersSortedByZ);
            const size_t count = previousLayers.size();
            for (size_t i=0 ; i&lt;count ; i++) {
                const sp&lt;LayerBase&gt;&amp; layer(previousLayers[i]);
                if (currentLayers.indexOf( layer ) &lt; 0) {
                    // this layer is not visible anymore
                    ditchedLayers.add(layer);
                    mDirtyRegionRemovedLayer.orSelf(layer-&gt;visibleRegionScreen);
                }
            }
        }
    }</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来处理系统显示屏的属性变化。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在分析这段代码之前，我们首先了解SurfaceFlinger类的另外一个成员变量mDrawingState的含义。SurfaceFlinger类的成员变量mDrawingState与前面所介绍的成员变量mCurrentState类似，它的类型也为State，不过它是用来描述SufaceFlinger服务的上一次渲染状态的。通过这两个成员变量的比较，我们就可以知道系统显示屏的哪一个属性发生了变化。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面提到，当系统显示屏的属性发生了变化，那么参数transactionFlags的eTransactionNeeded位就会等于1，在这种情况，这段代码就需要完成四件事情。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第一件事情是判断系统显示屏的旋转方向是否发生变化。State类的成员变量orientation用来描述显示屏的方向，因此，当SurfaceFlinger类的成员变量mCurrentState所描述的一个State对象的成员变量orientation的值不等于SurfaceFlinger类的成员变量mDrawingState所描述的一个State对象的成员变量orientation的值时，就说明系统显示屏的旋转方向发生了变化。在这种情况下，我们就需要将系统显示屏的旋转方向设置为SurfaceFlinger类的成员变量mCurrentState所描述的一个State对象的成员变量orientation的值，这是通过调用编号为0的一个GraphicPlane对象的成员函数setOrientation来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; SurfaceFlinger服务的UI渲染线程在初始化的过程中，除了会初始化硬件帧缓冲区之外，还会创建一个类型为surface_flinger_cblk_t的对象，用来描述系统显示屏的信息，例如大小和旋转方向等，以便其它进程可以通过这个surface_flinger_cblk_t对象来获得系统显示屏的信息。这个surface_flinger_cblk_t对象就保存在SurfaceFlinger类的成员变量mServerCblk中。因此，当系统显示屏的旋转方向发生了变化时，我们还需要将变化后的旋转方向保存在SurfaceFlinger类的成员变量mServerCblk所描述的一个surface_flinger_cblk_t对象中。由于系统显示屏的旋转方向变化一般意味着宽度和高度也会发生变化，因此，我们还需要将旋转发生变化后得到的系统显示屏的宽度和高度值保存在SurfaceFlinger类的成员变量mServerCblk所描述的一个surface_flinger_cblk_t对象中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;系统显示屏的旋转方向同时也意味着我们需要重新计算各个应用程序窗口的可见区域以及重新绘制整个显示屏，因此，在这种情况下，我们还需要将SurfaceFlinger类的成员变量mVisibleRegionsDirty的值设置为true，以及将SurfaceFlinger类的成员变量mDirtyRegion的大小设置为整个显示屏的大小，即将系统UI的脏区域设置为整个显示屏的大小。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第二件事情是判断系统显示屏的冻结状态是否发生变化。State类的成员变量freezeDisplay用来描述显示屏的冻结状态，因此，当SurfaceFlinger类的成员变量mCurrentState所描述的一个State对象的成员变量freezeDisplay的值不等于SurfaceFlinger类的成员变量mDrawingState所描述的一个State对象的成员变量freezeDisplay的值时，就说明系统显示屏的冻结状态发生了变化。在这种情况下，我们就需要将SurfaceFlinger类的成员变量mFreezeDisplay的值设置为SurfaceFlinger类的成员变量mCurrentState所描述的一个State对象的成员变量freezeDisplay的值。如果显示屏的是由解冻状态变化为冻结状态的，那么还需要将显示屏的冻结时间设置为0，即将SurfaceFlinger类的成员变量mFreezeDisplayTime的值设置为0，以便可以将显示屏进入到冻结状态的最长时间设置为一个默认值，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8062945">Android系统Surface制的SurfaceFlinger服务的线程模型分析</a>一文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第三件事情是判断是否新增了应用程序窗口。State类的成员变量layersSortedByZ是一个类型LayerVector的向量，里面保存的是SurfaceFlinger服务在某一个状态下所拥有的应用程序窗口，因此，当SurfaceFlinger类的成员变量mCurrentState所描述的一个State对象的成员变量layersSortedByZ所指向的一个向量的大小值大于SurfaceFlinger类的成员变量mDrawingState所描述的一个State对象的成员变量layersSortedByZ所指向的一个向量的大小值时，就说明系统新增了应用程序窗口。在这种情况下，我们就需要将SurfaceFlinger类的成员变量mVisibleRegionsDirty的值设置为true，以表示我们需要重新计算各个应用程序窗口的可见区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第四件事情是判断是否移除了某些应用程序窗口。SurfaceFlinger类的成员变量mLayersRemoved用来描述是否有应用程序窗口被移除了。如果有有应用程序窗口被移除的话，那么这个成员变量的值就会等于true。在这种情况下，我们就需要是哪些应用程序窗口被移除了。计算的方法很简单，如果一个应用程序窗口存在于SurfaceFlinger类的成员变量mDrawingState所描述的一个State对象的成员变量layersSortedByZ所指向的一个向量中，但是不存在于SurfaceFlinger类的成员变量mCurrentState所描述的一个State对象的成员变量layersSortedByZ所指向的一个向量中，那么就说明这个应用程序窗口被移除了，因此，就需要将它保存输出参数ditchedLayers所描述的一个向量中，以便可以返回给上一步来处理。SurfaceFlinger类的成员变量mDirtyRegionRemovedLayer用来描述那些被移除了的应用程序窗口所占用的区域，因此，每当我们移除一个应用程序窗口的时候，都需要将它所占用的区域增加到SurfaceFlinger类的成员变量mDirtyRegionRemovedLayer所描述的一个区域去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;当处理完成那些被移除的应用程序窗口之后，我们就需要将SurfaceFlinger类的成员变量mLayersRemoved的值设置为false，并且将SurfaceFlinger类的成员变量mVisibleRegionsDirty的值设置为true，以表示我们需要重新计算现存的各个应用程序窗口的可见区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;处理完成系统显示屏的属性变化之后，我们接着向下阅读SurfaceFlinger类的成员函数handleTransactionLocked的最后一行代码：</p><p><span style="font-family: monospace; white-space: pre; "></span></p><pre name="code" class="cpp">    commitTransaction();
} </pre><p></p>&nbsp;&nbsp; &nbsp; &nbsp;这段代码只有一行，即调用SurfaceFlinger类的成员函数commitTransaction来告诉SurfaceFlinger服务，系统显示屏以及各个应用程序窗口的属性变化已经处理完毕，这时候SurfaceFlinger服务就可以切换状态了。在后面的Step 6中，我们再详细分析SurfaceFlinger类的成员函数commitTransaction的实现。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就继续分析Layer类的成员函数doTransaction的实现，以便可以了解应用程序窗口的属性变化的处理过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 3.&nbsp;Layer.doTransaction</p><p></p><pre name="code" class="cpp">uint32_t Layer::doTransaction(uint32_t flags)
{
    const Layer::State&amp; front(drawingState());
    const Layer::State&amp; temp(currentState());

    const bool sizeChanged = (front.requested_w != temp.requested_w) ||
            (front.requested_h != temp.requested_h);

    if (sizeChanged) {
        ......

        if (!isFixedSize()) {
            // we're being resized and there is a freeze display request,
            // acquire a freeze lock, so that the screen stays put
            // until we've redrawn at the new size; this is to avoid
            // glitches upon orientation changes.
            if (mFlinger-&gt;hasFreezeRequest()) {
                // if the surface is hidden, don't try to acquire the
                // freeze lock, since hidden surfaces may never redraw
                if (!(front.flags &amp; ISurfaceComposer::eLayerHidden)) {
                    mFreezeLock = mFlinger-&gt;getFreezeLock();
                }
            }

            // this will make sure LayerBase::doTransaction doesn't update
            // the drawing state's size
            Layer::State&amp; editDraw(mDrawingState);
            editDraw.requested_w = temp.requested_w;
            editDraw.requested_h = temp.requested_h;

            // record the new size, form this point on, when the client request
            // a buffer, it'll get the new size.
            setBufferSize(temp.requested_w, temp.requested_h);

            ClientRef::Access sharedClient(mUserClientRef);
            SharedBufferServer* lcblk(sharedClient.get());
            if (lcblk) {
                // all buffers need reallocation
                lcblk-&gt;reallocateAll();
            }
        } else {
            // record the new size
            setBufferSize(temp.requested_w, temp.requested_h);
        }
    }

    if (temp.sequence != front.sequence) {
        if (temp.flags &amp; ISurfaceComposer::eLayerHidden || temp.alpha == 0) {
            // this surface is now hidden, so it shouldn't hold a freeze lock
            // (it may never redraw, which is fine if it is hidden)
            mFreezeLock.clear();
        }
    }

    return LayerBase::doTransaction(flags);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/Layer.cpp中。&nbsp;<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 和SurfaceFlinger服务类似，每一个应用程序窗口在内部也分别使用两个类型为State的成员变量mDrawingState和mCurrentState来描述上一次的渲染状态和下一次的渲染状态。这两个成员变量是从LayerBase类继承下来的，用来描述应用程序窗口的Layer类可以分别通过从父类LayerBase继承下来的成员函数drawingState和currentState来访问它们。注意，这里所说的State类是定义在LayerBase类内部的，而SurfaceFlinger服务使用的State类是定义在SurfaceFlinger类内部的，它们是不一样的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;Layer类的成员函数doTransaction首先调用从父类LayerBase继承下来的成员函数drawingState和currentState来获得当前正在处理的应用程序窗口的上一次的渲染状态和下一次的渲染状态，并且分别保存在两个类型为State的变量front和temp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; State类的成员变量requested_w和requested_h分别用来描述应用程序窗口的宽度和高度，因此，当State变量front的成员变量requested_w和requested_h不等于State变量temp的成员变量requested_w和requested_h时，我们就会得到变量sizeChanged的值等于true，表示当前正在处理的应用程序窗口的大小发生了变化。在分析Layer类的成员函数doTransaction处理应用程序窗口的大小变化时，我们先介绍Layer类的成员变量mFixedSize的含义。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;Layer类的成员变量mFixedSize是一个布尔变量，它的值可以通过Layer类的成员函数isFixedSize来获得。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文可以知道，当Android应用程序请求SurfaceFlinger服务分配一块图形缓冲区时，&nbsp;Layer类的成员函数requestBuffer就会被调用。这时候Android应用程序会传递两个参数reqWidth和reqHeight过来，表示请求分配的图形缓冲区的宽度和高度。这两个参数是可以同时等于0的，表示使用默认的宽度和高度值来创建所请求的图形缓冲区。这两个默认的宽度和高度值即等于当前所处理的应用程序窗口的宽度和高度值，而后者的宽度和高度值是在其创建的时候指定的，这一点可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Layer类的成员函数requestBuffer的参数reqWidth和reqHeight的值等于0意味着什么呢？从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文还可以知道，Android应用程序在请求SurfaceFlinger服务分配一块图形缓冲区之前，会通过在Surface类内部定义的BufferInfo类的成员函数validateBuffer来检查当前所处理的应用程序窗口的大小是否发生了变化。如果发生了变化，那么Android应用程序就会忽略掉缓存自己一侧的图形缓冲区，而去SurfaceFlinger服务请求新的图形缓冲区，因为那些缓存的图形缓冲区由于与它们所关联的应用程序窗口大小发生了变化而变为无效了。但是有一种特殊情况，在Android应用程序这一侧，用来描述应用程序窗口的Surface类可以不维护应用程序窗口的大小值。在这种情况下，Surface类就会将与它所关联的应用程序窗口的大小值设置为0，这意味着Android应用程序每次为这个应用程序窗口向SurfaceFlinger服务请求分配图形缓冲区之前，都认为这个应用程序窗口的大小值没有发生变化，同时传递给Layer类的成员函数requestBuffer的参数reqWidth和reqHeight的值会等于0。事实上，一个应用程序窗口的大小是随时都可以发生变化的，比如，我们可以通过调用用来在Android应用程序和SurfaceFlinger服务建立连接的一个类型为Client的Binder对象的成员函数setState来改变一个应用程序窗口的大小，而一旦一个应用程序窗口的大小发生了变化，我们正在分析Layer类的成员函数doTransaction就会被调用。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;从上面的分析就可以得出一个结论，Layer类的成员函数doTransaction在处理应用程序窗口大小变化时，需要考虑Android应用程序每次在为该应用程序窗口向SurfaceFlinger服务请求分配图形缓冲区之前，是否有能力去判断之前为该应用程序窗口缓存的图形缓冲区的有效性。如果没有的话，那么Layer类的成员函数doTransaction就需要将为该应用程序窗口缓存的图形缓冲区设置为无效，以便以后Android应用程序可以请求SurfaceFlinger服务分配新的、大小正确的图形缓冲区。从前面的分析还可以知道，当Android应用程序没有能力去判断之前为一个应用程序窗口所缓存的图形缓冲区的有效性时，那么之前在请求分配这些图形缓冲区时，传递给Layer类的成员函数requestBuffer的参数reqWidth和reqHeight的值就会等于0，这时候Layer类的成员函数requestBuffer就会将Layer类的成员变量mFixedSize的值设置为false。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就分别根据Layer类的成员变量mFixedSize是等于true还是false来分析Layer类的成员函数doTransaction处理一个应用程序窗口大小发生变化的过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;当Layer类的成员变量mFixedSize的值等于true时，Layer类的成员函数doTransaction的处理很简单，它只是调用另外一个成员函数setBufferSize来将新的应用程序窗口大小记录下来，即保存在Layer类的成员变量mWidth和mHeight中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;当Layer类的成员变量mFixedSize的值等于false时，由于Android应用程序没有能力去判断之前为一个应用程序窗口所缓存的图形缓冲区的有效性，因此，Layer类的成员函数doTransaction除了会调用外一个成员函数setBufferSize来将新的应用程序窗口大小记录下来之外，还会通过一个SharedBufferServer对象的成员函数reallocateAll来将为当前正在处理的应用程序窗口所缓存的图形缓冲区设置为无效。在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文中，我们已经分析过SharedBufferServer类的作用了，它是用来维护Android应用程序与SurfaceFlinger服务之间的共享UI元数据的，通过它可以将对应的图形缓冲区设置为无效。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;当Layer类的成员变量mFixedSize的值等于false时，Layer类的成员函数doTransaction还会提前将成员变量mCurrentState所描述的一个State对象的成员变量requested_w和requested_h的值保存到成员变量mDrawingState所描述的一个State对象的成员变量requested_w和requested_h中去，这是为了避免后面调用父类LayerBase的成员函数doTransaction时，会返回一个Layer::eVisibleRegion位不等于0的标志值给前面的Step 2，而这将会导致SurfaceFlinger服务马上重新计算各个应用程序窗口的可见区域。现在不返回一个Layer::eVisibleRegion位不等于0的标志值给前面的Step 2，就会等到下次渲染当前正在处理的应用程序窗口时再重新计算各个应用程序窗口的可见区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;此外，当Layer类的成员变量mFixedSize的值等于false时，Layer类的成员函数doTransaction还会检查系统显示屏是否正处于冻结的状态，这是通过调用Layer类的成员变量mFlinger所指向的SurfaceFlinger服务的成员函数hasFreezeRequest来实现的。如果系统显示屏处于冻结的状态中，并且当前正在处理的应用程序窗口处于可见状态，即变量front所描述的State对象的成员变量flags的ISurfaceComposer::eLayerHidden位等于0，那么Layer类的成员函数doTransaction还会请求获得一个用来冻结系统显示屏的类型为FreezeLock的锁，并且将这个锁保存在Layer类的成员变量mFreezeLock中。这样就可以等到下次渲染当前正在处理的应用程序窗口时，再来刷新系统的UI。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;State类的另外一个成员变量sequence用来描述一个应用程序窗口的其它属性是否发生过变化，例如，X、Y和Z轴位置、透明度等除了大小之外的属性。每当这些属性发生了变化，那么State类的成员变量sequence的值就会比原来增加1。Layer类的成员函数doTransaction再接下来就通过比较变量temp和front所描述的State对象的成员变量sequence的值是否相等来判断当前正在处理的应用程序窗口的其它属性是否发生变化。如果发生过变化，并且当前正在处理的应用程序窗口处于不可见状态或者处于完全透明的状态，那么Layer类的成员函数doTransaction就会释放之前所持有的用来冻结系统显示屏的一个类型为FreezeLock的锁，这是通过调用Layer类的成员变量mFreezeLock所指向的一个FreezeLock对象的成员函数clear来实现的，这样就可以避免阻止SurfaceFlinger服务更新系统UI。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;最后，Layer类的成员函数doTransaction调用父类LayerBase的成员函数doTransaction来继续处理应用程序窗口的属性变化。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 4.&nbsp;LayerBase.doTransaction</p><p></p><pre name="code" class="cpp">uint32_t LayerBase::doTransaction(uint32_t flags)
{
    const Layer::State&amp; front(drawingState());
    const Layer::State&amp; temp(currentState());

    if ((front.requested_w != temp.requested_w) ||
        (front.requested_h != temp.requested_h))  {
        // resize the layer, set the physical size to the requested size
        Layer::State&amp; editTemp(currentState());
        editTemp.w = temp.requested_w;
        editTemp.h = temp.requested_h;
    }

    if ((front.w != temp.w) || (front.h != temp.h)) {
        // invalidate and recompute the visible regions if needed
        flags |= Layer::eVisibleRegion;
    }

    if (temp.sequence != front.sequence) {
        // invalidate and recompute the visible regions if needed
        flags |= eVisibleRegion;
        this-&gt;contentDirty = true;

        // we may use linear filtering, if the matrix scales us
        const uint8_t type = temp.transform.getType();
        mNeedsFiltering = (!temp.transform.preserveRects() ||
                (type &gt;= Transform::SCALE));
    }

    // Commit the transaction
    commitTransaction();
    return flags;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/LayerBase.cpp中。&nbsp;<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 与前面的Step 3一样，LayerBase类的成员函数doTransaction首先通过成员函数drawingState和currentState来获得用来描述当前正在处理的应用程序窗口的当前渲染状态的一个State对象front和下一次渲染状态的一个State对象temp，接下来就可以通过这两个State对象的成员变量requested_w和requested_h来判断当前正在处理的应用程序窗口的大小是否发生了变化。如果发生了变化，那么就将新的应用程序窗口大小值保存在用来描述下一次渲染状态的State对象editTemp的成员变量w和h中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; State类的成员变量requested_w、requested_h和w、h的区别在于，前两者用来描述应用程序窗口的大小，后两者虽然也是用来描述应用程序窗口的大小，不过它们的作用是用来判断是否需要重新计算系统中的各个应用程序窗口的可见区域的。一旦用来描述应用程序窗口的当前渲染状态的State对象front和下一次渲染状态的State对象temp的成员变量w和h不相等，那么就说明需要系统中的各个应用程序窗口的可见区域，这是通过将将返回值flags的Layer::eVisibleRegion位设置为1来实现的。&nbsp;</p><p>&nbsp;&nbsp; &nbsp; &nbsp; LayerBase类的成员函数doTransaction接下来还会继续判断State对象front和temp的成员变量sequence的值是否相等。如果不相等，那么就说明当前正在处理的应用程序窗口的其它属性，例如位置和透明度等发生了变化。在这种情况下，SurfaceFlinger服务也是需要重新计算系统中的各个应用程序窗口的可见区域的。因此，这时候&nbsp;LayerBase类的成员函数doTransaction就会将它的返回值flags的Layer::eVisibleRegion位设置为1，并且将Layer类的成员变量contentDirty的值设置为true，表示当前正在处理的应用程序窗口的内容是脏的，需要重新渲染。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;LayerBase类的成员函数doTransaction最后还会继续调用另外一个成员函数commitTransaction来结束对当前正在处理的应用程序窗口的属性变化处理，以及将返回值flags返回给前面的Step 2，即SurfaceFlinger类的成员函数handleTransactionLocked。SurfaceFlinger类的成员函数handleTransactionLocked一旦发现这个返回值的Layer::eVisibleRegion位的值为1，那么就会将SurfaceFlinger类的成员变量mVisibleRegionsDirty的值设置为true，以便接下来可以重新计算系统中的各个应用程序窗口的可见区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析LayerBase类的成员函数commitTransaction的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 5.&nbsp;LayerBase.commitTransaction</p><p></p><pre name="code" class="cpp">void LayerBase::commitTransaction() {
    mDrawingState = mCurrentState;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/LayerBase.cpp中。&nbsp;<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;由于此时当前正在处理的应用程序窗口的属性变化已经处理完成了，因此，LayerBase类的成员函数commitTransaction就将用来描述下一次渲染状态的成员变量mCurrentState所描述的一个State对象保存在另外一个用来描述当前渲染状态的成员变量mDrawingState中去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;这一步执行完成之后，返回到前面的Step 2中，即SurfaceFlinger类的成员函数handleTransactionLocked中，这时候系统显示屏的属性变化以及各个应用程序的属性变化就都已经处理完成了，SurfaceFlinger类的成员函数handleTransactionLocked最后就会调用另外一个成员函数commitTransaction来结束整个属性变化处理过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 6.&nbsp;SurfaceFlinger.commitTransaction</p><p></p><pre name="code" class="cpp">void SurfaceFlinger::commitTransaction()
{
    mDrawingState = mCurrentState;
    mResizeTransationPending = false;
    mTransactionCV.broadcast();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。&nbsp;<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;前面提到，SurfaceFlinger类的成员变量mDrawingState用来描述SufaceFlinger服务的当前状态，而成员变量mCurrentState用来描述SufaceFlinger服务的下一个状态，由于这时候SufaceFlinger服务的状态变化已经处理完成了，因此，SurfaceFlinger类的commitTransaction就将成员变量mCurrentState所指向的一个State对象保存在成员变量mDrawingState中，接着又将成员变量mResizeTransationPending的值设置为false，表示SufaceFlinger服务已经处理过系统显示屏或者应用程序窗口的大小变化了，最后调用成员变量mTransactionCV所描述的一个条件变量的成员函数broadcast来通知其它线程，例如Binder线程，SufaceFlinger服务已经处理完成一次属性变化了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;至此，我们就分析完成系统显示屏以及应用程序窗口的属性变化的处理过程，接下来我们继续分析各个应用程序窗口是如何设置它们当前所要渲染的图形缓冲区的，即SurfaceFlinger类的成员函数handlePageFlip的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;2.&nbsp;handlePageFlip<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handlePageFlip是用来让各个应用程序窗口设置它们当前所要渲染的图形缓冲区的，在这个过程中，SurfaceFlinger服务还会计算各个应用程序窗口的可见区域，如图3所示。</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/23/1350923670_1694.jpg" alt="" /><br /></p><p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; text-align: center; ">图3 应用程序窗口设置当前所要渲染的图形缓冲区的过程</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程可以分为7个步骤，接下来我们就详细分析每一个步骤。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. SurfaceFlinger.handlePageFlip</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void SurfaceFlinger::handlePageFlip()
{
    bool visibleRegions = mVisibleRegionsDirty;
    LayerVector&amp; currentLayers = const_cast&lt;LayerVector&amp;&gt;(
            mDrawingState.layersSortedByZ);
    visibleRegions |= lockPageFlip(currentLayers);

        const DisplayHardware&amp; hw = graphicPlane(0).displayHardware();
        const Region screenRegion(hw.bounds());
        if (visibleRegions) {
            Region opaqueRegion;
            computeVisibleRegions(currentLayers, mDirtyRegion, opaqueRegion);

            /*
             *  rebuild the visible layer list
             */
            mVisibleLayersSortedByZ.clear();
            const LayerVector&amp; currentLayers(mDrawingState.layersSortedByZ);
            size_t count = currentLayers.size();
            mVisibleLayersSortedByZ.setCapacity(count);
            for (size_t i=0 ; i&lt;count ; i++) {
                if (!currentLayers[i]-&gt;visibleRegionScreen.isEmpty())
                    mVisibleLayersSortedByZ.add(currentLayers[i]);
            }

#ifdef USE_COMPOSITION_BYPASS
            sp&lt;LayerBase&gt; bypassLayer;
            const size_t numVisibleLayers = mVisibleLayersSortedByZ.size();
            if (numVisibleLayers == 1) {
                const sp&lt;LayerBase&gt;&amp; candidate(mVisibleLayersSortedByZ[0]);
                const Region&amp; visibleRegion(candidate-&gt;visibleRegionScreen);
                const Region reminder(screenRegion.subtract(visibleRegion));
                if (reminder.isEmpty()) {
                    // fullscreen candidate!
                    bypassLayer = candidate;
                }
            }
            setBypassLayer(bypassLayer);
#endif

            mWormholeRegion = screenRegion.subtract(opaqueRegion);
            mVisibleRegionsDirty = false;
        }

    unlockPageFlip(currentLayers);
    mDirtyRegion.andSelf(screenRegion);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数首先将SurfaceFlinger类的成员变量mVisibleRegionsDirty的值保存在变量visibleRegions中。从前面第1部分的内容可以知道，当SurfaceFlinger服务在处理系统显示屏以及各个应用程序窗口的属性变化时，如果发现需要重新计算各个应用程序窗口的可见区域，那么就会将SurfaceFlinger类的成员变量mVisibleRegionsDirty的值设置为true。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数接下来通过SurfaceFlinger类的成员变量mDrawingState所描述的一个State对象的成员变量layersSortedByZ来获得系统当前所有的应用程序窗口，并且保存在一个类型为LayerVector的向量currentLayers中。有了系统当前所有的应用程序窗口之后，就可以通过调用SurfaceFlinger类的成员函数lockPageFlip来让它们设置自己当前所要渲染<br />的图形缓冲区。在后面的Step 2中，我们再详细分析SurfaceFlinger类的成员函数lockPageFlip的实现。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;系统中的各个应用程序窗口在设置自己当前所要渲染的图形缓冲区的过程中，有可能会改变自己的大小。在这种情况下，它们就会通过SurfaceFlinger类的成员函数lockPageFlip来返回一个true值来给SurfaceFlinger类的成员函数handlePageFlip，这时候得到的变量visibleRegions的值就会等于true，表示需要重新计算各个应用程序窗口的可见区域。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;综合上述情况，无论变量visibleRegions的值是由于什么原因等于true，都说明SurfaceFlinger服务需要重新计算各个应用程序窗口的可见区域，这个计算的工作是通过调用SurfaceFlinger类的另外一个成员函数computeVisibleRegions来完成的。在后面的Step 5中，我们再详细分析SurfaceFlinger类的成员函数computeVisibleRegions的实现。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数computeVisibleRegions在计算完成各个应用程序窗口的可见区域之后，会得到一个全局不透明区域，保存在输出参数opaqueRegion中。这个全局不透明区域就是接下来需要渲染的，一般情况下，它的大小就应该等于显示屏的大小，即变量screenRegion所描述的区域。在异常情况下，可能会导致显示屏区域screenRegion大于全局不透明区域opaqueRegion，这时候前者减去后者就可以得到一些称为“虫洞”的区域，它们保存在SurfaceFlinger类的成员变量mWormholeRegion中。由于这些虫洞区域不会被各个应用程序窗口覆盖，因此，SurfaceFlinger服务需要对它们进行特殊处理，即以一种特殊的方式来渲染它们。在后面的第4部分内容中，我们就会看到SurfaceFlinger服务是通过调用SurfaceFlinger类的成员函数drawWormhole来渲染这些虫洞的。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数computeVisibleRegions在计算完成各个应用程序窗口的可见区域之后，各个应用程序窗口的可见区域就会保存在用来描述它们的一个LayerBase对象的成员变量visibleRegionScreen中，因此，SurfaceFlinger类的成员函数handlePageFlip就会通过这个成员变量来排除掉那些可见区域为空的应用程序窗口，并且将所有可见区域不为空的应用程序窗口按照它们的Z轴大小保存在SurfaceFlinger类的成员变量mVisibleLayersSortedByZ所描述的一个向量中。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;经过前面的操作之后，SurfaceFlinger类的成员函数handlePageFlip就可以将成员变量mVisibleRegionsDirty的值设置为false了，因为这时候系统中各个应用程序窗口的可见区域都已经重新计算过了。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handlePageFlip最后就调用另外一个成员函数unlockPageFlip来让各个应用程序窗口执行一些善后的工作，例如，让各个应用程序窗口检查自己的可见区域是否等于空，如果等于空的话，那么就需要将它们之前所获得的用来冻结显示屏的锁释放掉，以避免阻止SurfaceFlinger服务渲染系统UI。在后面的Step 6中，我们再详细分析SurfaceFlinger类的成员函数unlockPageFlip的实现。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handlePageFlip最后还需要做的另外一件事情是将设置系统的脏区域，这个脏区域保存在SurfaceFlinger类的成员变量mDirtyRegion中，它同样是作为一个输出参数来传递给SurfaceFlinger类的成员函数computeVisibleRegions的，以便后者在计算各个应用程序窗口的可见区域时，可以将获得的系统脏区域保存在它里面。我们同样是在后面的Step 5中分析SurfaceFlinger类的成员函数computeVisibleRegions的实现时，再看看系统的脏区域是如何计算的。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;有一种特殊情况，即SurfaceFlinger类的成员函数handlePageFlip在重新计算完成各个应用程序窗口的可见区域后，如果满足以下三个条件：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; 1.&nbsp;SurfaceFlinger服务在编译时指定了宏USE_COMPOSITION_BYPASS；</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; 2.&nbsp;当前要渲染的应用程序窗口只有一个，即SurfaceFlinger类的成员变量mVisibleLayersSortedByZ所描述的一个向量的大小等于1；</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; 3.&nbsp;当前要渲染的一个唯一的应用程序窗口的可见区域的大小不为空。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; 那么SurfaceFlinger服务就会直接将这个唯一需要渲染的应用程序窗口的图形缓冲区渲染到硬件帧缓冲区中去，以跳过后面的合成各个应用程序窗口的图形缓冲区的操作。在这种情况下，这个唯一需要渲染的应用程序窗口会通过SurfaceFlinger类的成员函数setBypassLayer记录起来。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数setBypassLayer的实现如下所示：</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void SurfaceFlinger::setBypassLayer(const sp&lt;LayerBase&gt;&amp; layer)
{
    // if this layer is already the bypass layer, do nothing
    sp&lt;Layer&gt; cur(mBypassLayer.promote());
    if (mBypassLayer == layer) {
        if (cur != NULL) {
            cur-&gt;updateBuffersOrientation();
        }
        return;
    }

    // clear the current bypass layer
    mBypassLayer.clear();
    if (cur != 0) {
        cur-&gt;setBypass(false);
        cur.clear();
    }

    // set new bypass layer
    if (layer != 0) {
        if (layer-&gt;setBypass(true)) {
            mBypassLayer = static_cast&lt;Layer*&gt;(layer.get());
        }
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 从这里就可以看出，在指定了编译宏USE_COMPOSITION_BYPASS的情况下，SurfaceFlinger服务唯一需要渲染的应用程序窗口就保存在SurfaceFlinger类的一个类型为Layer的成员变量mBypassLayer中，并且会调用用来这个Layer对象的成员函数setBypass来将它里面的一个成员变量mBypassState的值设置为true。在后面的第3部分内容中，我们再详细分析这个唯一需要渲染的应用程序窗口的图形缓冲区是如何直接渲染到硬件帧缓冲区中去的。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就继续分析SurfaceFlinger类的成员函数lockPageFlip、computeVisibleRegions和unlockPageFlip的实现，以便可以分别了解各个应用程序窗口是如何设置自己当前需要渲染的图形缓冲区的、SurfaceFlinger服务是如何计算各个应用程序窗口的可见区域的，以及各个应用程序窗口的可见区域计算完成之后的善后工作是什么。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;Step 2.&nbsp;SurfaceFlinger.lockPageFlip</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">bool SurfaceFlinger::lockPageFlip(const LayerVector&amp; currentLayers)
{
    bool recomputeVisibleRegions = false;
    size_t count = currentLayers.size();
    sp&lt;LayerBase&gt; const* layers = currentLayers.array();
    for (size_t i=0 ; i&lt;count ; i++) {
        const sp&lt;LayerBase&gt;&amp; layer(layers[i]);
        layer-&gt;lockPageFlip(recomputeVisibleRegions);
    }
    return recomputeVisibleRegions;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>的一系列文章中，我们假设在SurfaceFlinger服务这一侧，每一个应用程序窗口都是使用一个Layer对象来描述，这些Layer对象都是从LayerBase继承下来的，因此它们可以保存在一个类型为LayerBase的向量中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面的调用过程可以知道，参数currentLayers里面保存的一系列LayerBase对象正是用来描述系统当前的各个应用程序窗口的，SurfaceFlinger类的成员函数lockPageFlip依次调用这些LayerBase对象的成员函数lockPageFlip来让它们设置当前需要渲染的图形缓冲区。由于前面我们假设这些LayerBase对象的实际类型为Layer，因此，前面调用的实际上就是Layer类的成员函数lockPageFlip。接下来，我们就继续分析Layer类的成员函数lockPageFlip的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 3.&nbsp;Layer.lockPageFlip</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/Layer.cpp中。在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文中，我们已经分析过这个函数的实现了，不过当时分析得不是太完整，现在我们再重新来阅读一下。这个函数比较长，我们分段来阅读：</p><p></p><pre name="code" class="cpp">void Layer::lockPageFlip(bool&amp; recomputeVisibleRegions)
{
    ClientRef::Access sharedClient(mUserClientRef);
    SharedBufferServer* lcblk(sharedClient.get());
    if (!lcblk) {
        // client died
        recomputeVisibleRegions = true;
        return;
    }

    ssize_t buf = lcblk-&gt;retireAndLock();
    if (buf == NOT_ENOUGH_DATA) {
        // NOTE: This is not an error, it simply means there is nothing to
        // retire. The buffer is locked because we will use it
        // for composition later in the loop
        return;
    }

    if (buf &lt; NO_ERROR) {
        LOGE(&quot;retireAndLock() buffer index (%d) out of range&quot;, int(buf));
        mPostedDirtyRegion.clear();
        return;
    }

    // we retired a buffer, which becomes the new front buffer
    if (mBufferManager.setActiveBufferIndex(buf) &lt; NO_ERROR) {
        LOGE(&quot;retireAndLock() buffer index (%d) out of range&quot;, int(buf));
        mPostedDirtyRegion.clear();
        return;
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码首先通过Layer类的成员变量mUserClientRef来获得一个SharedBufferServer对象lcblk。这个SharedBufferServer对象lcblk是用来描述Android应用程序与SurfaceFlinger服务之间的共享UI元数据，通过调用它的成员函数retireAndLock，Layer类的成员函数lockPageFlip就可以知道当前需要渲染的图形缓冲区的编号。有了这个编号之后，Layer类的成员函数lockPageFlip就可以在成员变量mBufferManager所描述的一个BufferManager中找到一个对应的图形缓冲区。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码接着将当前需要渲染的图形缓冲区的编号保存在Layer类的成员变量mBufferManager所描述的一个BufferManager中，这是通过调用这个BufferManager的成员函数setActiveBufferIndex来实现的。在接下来的Step 4中，我们就可以通过这个BufferManager的成员函数getActiveBufferIndex来重新获得这个编号，以便可以找到对应的图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们接着往下阅读代码：</p><p></p><pre name="code" class="cpp">    sp&lt;GraphicBuffer&gt; newFrontBuffer(getBuffer(buf));
    if (newFrontBuffer != NULL) {
        // get the dirty region
        // compute the posted region
        const Region dirty(lcblk-&gt;getDirtyRegion(buf));
        mPostedDirtyRegion = dirty.intersect( newFrontBuffer-&gt;getBounds() );

        // update the layer size and release freeze-lock
        const Layer::State&amp; front(drawingState());
        if (newFrontBuffer-&gt;getWidth()  == front.requested_w &amp;&amp;
            newFrontBuffer-&gt;getHeight() == front.requested_h)
        {
            if ((front.w != front.requested_w) ||
                (front.h != front.requested_h))
            {
                // Here we pretend the transaction happened by updating the
                // current and drawing states. Drawing state is only accessed
                // in this thread, no need to have it locked
                Layer::State&amp; editDraw(mDrawingState);
                editDraw.w = editDraw.requested_w;
                editDraw.h = editDraw.requested_h;

                // We also need to update the current state so that we don't
                // end-up doing too much work during the next transaction.
                // NOTE: We actually don't need hold the transaction lock here
                // because State::w and State::h are only accessed from
                // this thread
                Layer::State&amp; editTemp(currentState());
                editTemp.w = editDraw.w;
                editTemp.h = editDraw.h;

                // recompute visible region
                recomputeVisibleRegions = true;
            }

            // we now have the correct size, unfreeze the screen
            mFreezeLock.clear();
        }

        // get the crop region
        setBufferCrop( lcblk-&gt;getCrop(buf) );

        // get the transformation
        setBufferTransform( lcblk-&gt;getTransform(buf) );

    } else {
        // this should not happen unless we ran out of memory while
        // allocating the buffer. we're hoping that things will get back
        // to normal the next time the app tries to draw into this buffer.
        // meanwhile, pretend the screen didn't update.
        mPostedDirtyRegion.clear();
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先是用来设置当前正在处理的应用程序窗口的脏区域、纹理坐标和旋转方向的。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;一个应用程序窗口当前的脏区域、纹理坐标，以及旋转方向是保存在一块匿名共享内存中的，用来在Android应用程序和SurfaceFlinger服务之间共享UI元数据。这块匿名共享内存就是使用前面所获得的SharedBufferServer对象lcblk来描述的，即我们可以通过调用SharedBufferServer对象lcblk的成员函数getDirtyRegion、getCrop以及getTransform来获得当前正在处理的应用程序窗口的脏区域、纹理坐标以及旋转方向。其中，脏区域保存在Layer类的成员变量mPostedDirtyRegion中，纹理坐标通过调用父类LayerBase的成员函数setBufferCrop保存在其成员变量mBufferCrop中，而旋转方向通过调用父类LayerBase的成员函数setBufferTransform保存在其成员变量mBufferTransform中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面的执行过程可以知道，变量buf保存的是当前需要渲染的图形缓冲区的编号。当我们以这个编号为参数来调用Layer类的成员函数getBuffer时，就可以得到一个对应的图形缓冲区。这个图形缓冲区使用一个GraphicBuffer对象来描述，并且保存在变量newFrontBuffer中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当前需要渲染的图形缓冲区newFrontBuffer的大小可以通过调用它的成员函数getBounds来获得。我们把当前需要渲染的图形缓冲区的大小与当前正在处理的应用程序窗口的脏区域执行一个相交操作之后，才可以得到最终需要渲染的脏区域。这个最终需要渲染的脏区域就保存在前面提到的Layer类的成员变量mPostedDirtyRegion中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码接下来还会检查是否需要修改当前正在处理的应用程序窗口的大小。本来修改应用程序窗口的大小是在处理应用程序窗口的属性变化时进行的，如前面第1部分的内容所示。但是在前面第1部分的内容的Step 3中提到，有一种特殊情况，即Android应用程序在请求SurfaceFlinger服务分配图形缓冲区时，传递过来的图形缓冲区的宽度和高度值等于0。在这种情况下，Layer类的成员函数doTransaction会暂时忽略掉应用程序窗口当前所发生的大小变化，而是等到该应用程序窗口大小发生了变化后所申请分配的新图形缓冲区需要渲染时，再来修改它的大小。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面第1部分的内容的Step 3可以知道，调用Layer类的成员函数drawingState所获得的一个State对象是用来描述一个应用程序窗口的当前渲染状态的，而这个State对象的成员变量requested_w和requested_h描述的就正好是该应用程序窗口的最新宽度和高度值。如果一个应用程序窗口的最新宽度和高度值正好等于它当前所要渲染的图形缓冲区newFrontBuffer的宽度和高度值，那么就说明它当前所要渲染的图形缓冲区newFrontBuffer就正好是在它的大小发生变化之后所申请分配的，因此，这时候Layer类的成员函数lockPageFlip就需要继续检查它之前是否有被忽略掉的大小变化未被处理。如果有的话，现在就是时候对它的大小变化进行处理了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面第1部分的内容的Step 4可以知道，如果用来描述一个应用程序窗口的当前渲染状态的一个State对象的两个成员变量w和h，与另外两个成员变量requested_w和requested_h不相等的话，那么就说明该应用程序窗口有被忽略掉的大小变化未被处理，因此，在这种情况下，Layer类的成员函数lockPageFlip就会分别将该State对象的成员变量requested_w和requested_h的值分别保存在成员变量w和h中，同时还会保存用来描述该应用程序窗口的下一次渲染状态的一个State对象的成员变量w和h中，以表示前面被忽略掉的窗口大小变化已经得到处理了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 由于每当有应用程序窗口的大小发生变化之后，SurfaceFlinger服务都需要重新计算各个应用程序窗口的可见区域，因此，Layer类的成员函数lockPageFlip在处理了当前正在处理的应用程序窗口上一次被忽略掉的大小变化之后，需要将输出参数recomputeVisibleRegions的值设置为true，以便可以用来通知SurfaceFlinger服务更新各个应用程序窗口的可见区域，如前面的Step 1所示。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 此外，Layer类的成员函数lockPageFlip在处理了当前正在处理的应用程序窗口上一次被忽略掉的大小变化之后，如果之前获取过用来冻结系统显示屏的锁，那么现在也是时间释放这个锁了，以避免阻止SurfaceFlinger服务接下来重新渲染系统的UI。这个用来冻结系统显示屏的锁是保存在Layer类的成员变量mFreezeLock中的，通过调用它的成员函数clear就可以释放它所描述的用来冻结系统显示屏的锁。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们接着往下阅读代码：</p><p></p><pre name="code" class="cpp">    if (lcblk-&gt;getQueuedCount()) {
        // signal an event if we have more buffers waiting
        mFlinger-&gt;signalEvent();
    }

    /* a buffer was posted, so we need to call reloadTexture(), which
     * will update our internal data structures (eg: EGLImageKHR or
     * texture names). we need to do this even if mPostedDirtyRegion is
     * empty -- it's orthogonal to the fact that a new buffer was posted,
     * for instance, a degenerate case could be that the user did an empty
     * update but repainted the buffer with appropriate content (after a
     * resize for instance).
     */
    reloadTexture( mPostedDirtyRegion );
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先检查当前正在处理的应用程序窗口是否还有其它图形缓冲区在等待被渲染。如果有的话，那么就会通过Layer类的成员变量mFlinger的成员函数signalEvent来向SurfaceFlinger服务的UI渲染线程的消息队列发送另外一个类型为MessageQueue::INVALIDATE的消息，以便SurfaceFlinger服务的UI渲染线程在刷新了当前的系统UI之后，可以马上再次刷新系统的UI。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;执行完成以上操作之后，Layer类的成员函数lockPageFlip就调用另外一个成员函数reloadTexture来为当前正在处理的应用程序窗口加载新的纹理，以便接下来可以将这个新的纹理渲染合成和渲染到硬件帧缓冲区中去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来， 我们就继续分析Layer类的成员函数reloadTexture是如何获得应用程序窗口即将要合成和渲染的纹理的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 4.&nbsp;Layer.reloadTexture</p><p></p><pre name="code" class="cpp">void Layer::reloadTexture(const Region&amp; dirty)
{
    sp&lt;GraphicBuffer&gt; buffer(mBufferManager.getActiveBuffer());
    if (buffer == NULL) {
        // this situation can happen if we ran out of memory for instance.
        // not much we can do. continue to use whatever texture was bound
        // to this context.
        return;
    }

    if (mGLExtensions.haveDirectTexture()) {
        EGLDisplay dpy(mFlinger-&gt;graphicPlane(0).getEGLDisplay());
        if (mBufferManager.initEglImage(dpy, buffer) != NO_ERROR) {
            // not sure what we can do here...
            goto slowpath;
        }
    } else {
slowpath:
        GGLSurface t;
        if (buffer-&gt;usage &amp; GRALLOC_USAGE_SW_READ_MASK) {
            status_t res = buffer-&gt;lock(&amp;t, GRALLOC_USAGE_SW_READ_OFTEN);
            LOGE_IF(res, &quot;error %d (%s) locking buffer %p&quot;,
                    res, strerror(res), buffer.get());
            if (res == NO_ERROR) {
                mBufferManager.loadTexture(dirty, t);
                buffer-&gt;unlock();
            }
        } else {
            // we can't do anything
        }
    }
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/Layer.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数首先调用Layer类的成员变量mBufferManager所描述的一个BufferManager对象的成员函数getActiveBuffer来获得当前正在处理的应用程序窗口接下来需要渲染的图形缓冲区，并且保存在变量buffer中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数接着调用Layer类的成员变量mGLExtensions所描述的一个GLExtensions对象的成员函数haveDirectTexture来判断系统是否支持在硬件上直接创建纹理对象。如果支持的话，那么就调用Layer类的成员变量mBufferManager所描述的一个BufferManager对象的成员函数initEglImage来根据图形缓冲区buffer的内容在硬件上直接创建一个纹理对象。如果这个纹理对象创建成功的话，那么就会保存在Layer类的成员变量mBufferData所描述的一个BufferData中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果系统不支持在硬件上直接创建纹理对象，或者前面在硬件上直接创建纹理对象失败，那么函数就会退而求之，转换为用软件的方式来根据图形缓冲区buffer的内容来创建一个纹理对象，这是通过调用Layer类的成员变量mBufferManager所描述的一个BufferManager对象的成员函数loadTexture来实现的。创建出来的这个纹理对象就保存在Layer类的成员变量mFailoverTexture中。不过，能够使用软件的方式来创建纹理对象的一个前提是图形缓冲区buffer的内容可以通过软件的方式来读取，即它的成员变量usage的GRALLOC_USAGE_SW_READ_MASK位等于1。在这种情况下，我们就可以调用图形缓冲区buffer的成员函数lock来获得它的内容访问地址，并且保存在GGLSurface对象t，以便接下来可以通过这个GGLSurface对象t来创建一个纹理对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Layer类的成员函数reloadTexture首选在硬件上创建纹理对象，如果这种方式不可行，那么再使用软件方式来创建纹理对象。这种技术在计算机领域中就称为失效备援技术，即Failover技术。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步执行完成之后，返回到前面的Step 1中，即SurfaceFlinger类的成员函数handlePageFlip中，接下来就会继续调用SurfaceFlinger类的另外一个成员函数computeVisibleRegions来计算各个应用程序窗口的可见区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 5.&nbsp;SurfaceFlinger.computeVisibleRegions</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中，主要用来计算各个应用程序窗口的可见区域。在分析这个函数的实现之前，我们首先解释一些与应用程序窗口相关的概念：可见区域（Visible Region）、透明区域（Transparent Region）、半透明区域（Translucent Region）、完全不透明区域（Opaque Region）和被覆盖区域（Covered Region）。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;假设一个应用程序窗口的宽度和高度分别为w和h，如图4所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/26/1351182166_9415.jpg" alt="" /><br /></p><p style="text-align: center;">图4 &nbsp;应用程序窗口的可见区域</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 那么我们就可以将由(0,0)、(0, w)、(0, h)和(w,h)四个点组成的区域称为应用程序窗口的可见区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们可以在一个应用程序窗口的可见区域挖一个洞出来，如图5所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/26/1351182475_9224.jpg" alt="" /><br /></p><p style="text-align: center;">图5 应用程序窗口的透明区域</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;这时候应用程序窗口真正的可见区域就需要减去中间被挖出来的洞。这个被挖出来的洞就称为应用程序窗口的透明可见区域。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;如果应用程序窗口的可见区域的Alpha通道大于0并且小255，那么我们就认为应用程序窗口的可见区域是半透明的。有两种极端情况，即当应用程序窗口的可见区域的Alpha通道等于0或者255的时候。当等于0的时候，我们就认为应用程序窗口的可见区域是透明的，就如图5所示的洞一样，而当等于255的时候，我们就认为应用程序窗口的可见区域是完全不透明的。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;上面我们讨论的应用程序窗口的可见区域是基于单个应用程序窗口而言的，当多个应用程序窗口叠加在一起的时候，在讨论一个应用程序窗口的可见区域的时候，就需要考虑位于它上面的其它应用程序窗口的可见区域的影响了。注意，一个应用程序窗口的可见区域只受位于它上面的其它应用程序窗口影响，而不会受到位于它下面的其它的应用程序窗口影响，因此，我们是按照从上到下的顺序来计算系统中各个应用程序窗口的可见区域的。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 为了方便描述，我们假设位于一个应用程序窗口上面的所有应用程序窗口组成了一个整体的可见区域（Above Covered Layers），并且这个可见区域与我们所要讨论的应用程序窗口相交，即它们叠加在一起，如图6所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/26/1351184002_1681.jpg" alt="" /><br /></p><p style="text-align: center;">图6 应用程序窗口的被覆盖区域</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 由蓝色矩形组成的区域即为上层所有应用程序窗口所组成的一个整体可见区域，这个整体可见区域与下面绿色矩形组成的一个应用程序窗口相交的部分，即由虚线所围成的区域，就是下面的一个应用程序窗口的被覆盖区域。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;一个应用程序窗口的被覆盖区域有可能是半透明的，也有可能是完全不透明的，但是不可能是透明的，如图7所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/26/1351184432_9658.jpg" alt="" /><br /></p><p style="text-align: center;">图7&nbsp;应用程序窗口的被覆盖完全不透明区域</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 在原来由虚线围成的区域中，深蓝色的那部分区域就是完全不透明的（Above Opaque &nbsp;Layers），这时候由绿色矩形组成的应用程序窗口的可见区域除了要减去中间的洞（透明区域）之外，还要减去被覆盖的完全不透明区域，如下图8所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/26/1351185130_6816.jpg" alt="" /><br /></p><p style="text-align: center;">图8&nbsp;应用程序窗口的最终可见区域</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;从上面的讨论我们就可以清楚地知道，为了计算一个应用程序窗口的最终可见区域，我们需要知道：</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;1.&nbsp;应用程序窗口的左上角位置，以及宽度和高度，以便可以获得应用程序窗口的原始可见区域。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;2. 应用程序窗口的透明区域。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;3. 应用程序窗口的被覆盖完全不透明区域。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;用第1步到的原始可见区域减去第2步的透明区域和第3步的被覆盖完全不透明区域，就可以得到一个应用程序窗口的最终可见区域。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;为了获得第3步的被覆盖完全不透明区域，我们在计算一个应用程序窗口的最终可见区域的过程中，还需要将此前得到的应用程序窗口的完全不透明区域组合起来，形成一个覆盖完全不透明区域（Above Opaque &nbsp;Layers），因此，我们还需要知道：</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;4.&nbsp;应用程序窗口的完全不透明区域。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;此外，由于一个应用程序窗口的被覆盖半透明区域是需要与上层的应用程序窗口可见区域执行混合计算的，因此，我们在计算系统中各个应用程序窗口的可见区域的过程中，还需要将所有上层的应用程序窗口可见区域组合起来形成一个覆盖区域（Above Covered Layers）。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;有了这些背景知识之后，接下来我们就可以分析SurfaceFlinger类的成员函数computeVisibleRegions的实现了。由于SurfaceFlinger类的成员函数computeVisibleRegions的实现比较长，我们分段来阅读：</p><p style="text-align: left;"></p><pre name="code" class="cpp">void SurfaceFlinger::computeVisibleRegions(
    LayerVector&amp; currentLayers, Region&amp; dirtyRegion, Region&amp; opaqueRegion)
{
    const GraphicPlane&amp; plane(graphicPlane(0));
    const Transform&amp; planeTransform(plane.transform());
    const DisplayHardware&amp; hw(plane.displayHardware());
    const Region screenRegion(hw.bounds());

    Region aboveOpaqueLayers;
    Region aboveCoveredLayers;
    Region dirty;

    bool secureFrameBuffer = false;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先计算得到屏幕区域，保存在变量screenRegion中，接着定义了另外两个区域aboveOpaqueLayers，分别用来描述上层覆盖完全不透明区域（Above Opaque &nbsp;Layers）和上层覆盖区域（Above Covered Layers），最后定义了一个布尔变量secureFrameBuffer，用来描述系统中是否存在界面受到安全保护的应用程序窗口。<p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 界面受到安全保护的应用程序窗口的内容是不可以在进程间传输的，这个属性主要是应用在屏幕截图中。例如，如果系统中存在一个界面受到安全保护的应用程序窗口，那么我们就不可以请求SurfaceFlinger服务执行截屏功能，因为SurfaceFlinger服务截取下来的屏幕会被传输给请求的进程使用。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</p><p style="text-align: left;"></p><pre name="code" class="cpp">    size_t i = currentLayers.size();
    while (i--) {
        const sp&lt;LayerBase&gt;&amp; layer = currentLayers[i];
        layer-&gt;validateVisibility(planeTransform);</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码是一个while循环的前面几行。系统中所有需要计算可见区域的应用程序窗口都保存在参数currentLayers所描述的一个向量中。这段代码的while循环就是用来逐个地这些应用程序窗口的可见区域的。注意，这个while是先计算是按照从上到下的顺序来计算系统中各个应用程序窗口的可见区域的。<p></p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; 在计算一个应用程序窗口layer的可见区域之前，我们首先要验证它的可见性，这是通过调用它的成员函数validateVisibility来实现的，即调用LayerBase类的成员函数validateVisibility来实现的。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;LayerBase类的成员函数validateVisibility的实现如下所示：</p><p style="text-align: left;"></p><pre name="code" class="cpp">void LayerBase::validateVisibility(const Transform&amp; planeTransform)
{
    const Layer::State&amp; s(drawingState());
    const Transform tr(planeTransform * s.transform);
    const bool transformed = tr.transformed();

    uint32_t w = s.w;
    uint32_t h = s.h;
    tr.transform(mVertices[0], 0, 0);
    tr.transform(mVertices[1], 0, h);
    tr.transform(mVertices[2], w, h);
    tr.transform(mVertices[3], w, 0);
    if (UNLIKELY(transformed)) {
        // NOTE: here we could also punt if we have too many rectangles
        // in the transparent region
        if (tr.preserveRects()) {
            // transform the transparent region
            transparentRegionScreen = tr.transform(s.transparentRegion);
        } else {
            // transformation too complex, can't do the transparent region
            // optimization.
            transparentRegionScreen.clear();
        }
    } else {
        transparentRegionScreen = s.transparentRegion;
    }

    // cache a few things...
    mOrientation = tr.getOrientation();
    mTransformedBounds = tr.makeBounds(w, h);
    mLeft = tr.tx();
    mTop  = tr.ty();
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/surfaceflinger/LayerBase.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 参数planeTransform用来描述系统显示屏旋转方向，它是一个变换矩阵，而用来描述当前正在处理的应用程序窗口的当前渲染状态的一个State对象s的成员变量transform指向的也是一个变换矩阵，用来描述当前正在处理的应用程序窗口的位置、旋转方向和缩放因子等。将这两者相乘，就可以得到当前正在处理的应用程序窗口相对于系统显示屏的一个变换矩阵tr。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数首先计算当前正在处理的应用程序窗口的四个角在显示屏中的位置，并且分别保存在LayerBase的成员变量mVertices所描述的一个数组中，这是通过调用变换矩阵tr的成员函数transform来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数接着判断当前正在处理的应用程序窗口是否被旋转过或者被缩放过。如果是的话，那么前面调用变换矩阵tr的成员函数transformed的返回值就会等于true，即变量transformed的等于true。在这种情况下，函数就要相应地对当前正在处理的应用程序窗口的透明区域进行旋转或者缩放。但是有一种特殊情况，即当当前正在处理的应用程序窗口被旋转和缩放得不规则时，这时候对应用程序窗口的透明区域进行旋转或者缩放就会很复杂，于是函数就干脆将它的透明区域忽略掉。判断当前正在处理的应用程序窗口是否被旋转和缩放得不规则是通过调用变换矩阵tr的成员函数preserveRects来实现的，当它的返回值等于true的时候，就说明当前正在处理的应用程序窗口是否被旋转和缩放之后还是规则，否则就是不规则的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当前正在处理的应用程序窗口的透明区域保存在State对象s的成员变量transparentRegion中，按照上述原理，函数按照以下规则来对它进行处理：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 当变量transformed的等于false时，说明当前正在处理的应用程序窗口的透明区域就不需要进行旋转或者缩放，这时候就可以将这个透明区域保存在LayerBase类的成员变量transparentRegionScreen中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 当变量transformed的等于true，并且变换矩阵tr的成员函数preserveRects的返回值也等于true时，那么就说明当前正在处理的应用程序窗口的透明区域需要进行旋转或者缩放，这时候通过调用变换矩阵tr的成员函数transform来实现的。 最终得到的透明区域同样是保存在LayerBase类的成员变量transparentRegionScreen中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. &nbsp;当变量transformed的等于true，并且变换矩阵tr的成员函数preserveRects的返回值等于false时，那么就说明需要忽略掉当前正在处理的应用程序窗口的透明区域，这是通过LayerBase类的成员变量transparentRegionScreen所描述的一个Region对象的成员函数clear来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;最后，函数就计算当前正在处理的应用程序窗口的方向，左上角位置，以及包含了当前正在处理的应用程序窗口的一个矩形区域，这些值分别保存在在LayerBase类的成员变量mOrientation，mLeft和mTop，以及mTransformedBounds中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;返回到SurfaceFlinger类的成员函数computeVisibleRegions中，我们继续往下阅读代码：</p><p></p><pre name="code" class="cpp">        // start with the whole surface at its current location
        const Layer::State&amp; s(layer-&gt;drawingState());

        /*
         * opaqueRegion: area of a surface that is fully opaque.
         */
        Region opaqueRegion;

        /*
         * visibleRegion: area of a surface that is visible on screen
         * and not fully transparent. This is essentially the layer's
         * footprint minus the opaque regions above it.
         * Areas covered by a translucent surface are considered visible.
         */
        Region visibleRegion;

        /*
         * coveredRegion: area of a surface that is covered by all
         * visible regions above it (which includes the translucent areas).
         */
        Region coveredRegion;
</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先获得用来描述当前正在处理的应用程序窗口的当前渲染状态的一个State对象s，接着再定义了三个Region对象opaqueRegion、visibleRegion和coveredRegion，分别用来描述当前正在处理的应用程序窗口的完全不透明区域、可见区域和被覆盖区域。这三个区域的含义和作用如前所述。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;我们继续往下阅读代码：</p><p></p><pre name="code" class="cpp">        // handle hidden surfaces by setting the visible region to empty
        if (LIKELY(!(s.flags &amp; ISurfaceComposer::eLayerHidden) &amp;&amp; s.alpha)) {
            const bool translucent = layer-&gt;needsBlending();
            const Rect bounds(layer-&gt;visibleBounds());
            visibleRegion.set(bounds);
            visibleRegion.andSelf(screenRegion);
            if (!visibleRegion.isEmpty()) {
                // Remove the transparent area from the visible region
                if (translucent) {
                    visibleRegion.subtractSelf(layer-&gt;transparentRegionScreen);
                }

                // compute the opaque region
                const int32_t layerOrientation = layer-&gt;getOrientation();
                if (s.alpha==255 &amp;&amp; !translucent &amp;&amp;
                        ((layerOrientation &amp; Transform::ROT_INVALID) == false)) {
                    // the opaque region is the layer's footprint
                    opaqueRegion = visibleRegion;
                }
            }
        }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来计算当前正在处理的应用程序窗口的可见区域和完全不透明区域。只有在当前正在处理的应用程序窗口处于可见状态，并且它不是完全透明时，才需要计算这两个区域。当State对象s的成员变量flags的ISurfaceComposer::eLayerHidden位等于0时，就说明当前正在处理的应用程序窗口是处于可见状态的，而当它的另外一个成员变量alpha的值不等于0的时候，就说明当前正在处理的应用程序窗口不是完全透明的。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们首先来看当前正在处理的应用程序窗口的可见区域的计算过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;LayerBase对象layer的成员函数visibleBounds返回的是包围当前正在处理的应用程序窗口的一个矩形，即LayerBase类的成员变量mTransformedBounds，这是在前面调用LayerBase类的成员函数validateVisibility时计算得到的。函数首先将这个矩形与屏幕区域screenRegion执行一个与操作，以便可以得到当前正在处理的应用程序窗口的初始可见区域visibleRegion。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当得到当前正在处理的应用程序窗口的初始可见区域visibleRegion不为空时，函数接着判断该窗口是否是半透明的，即它是否要与其它的窗口执行混合操作。如果是半透明的话，那么前面调用LayerBase对象layer的成员函数needsBlending的返回值translucent就会等于true。在这种情况下，我们就需要将应用程序窗口的初始可见区域visibleRegion减去它的透明区域，即LayerBase对象layer的成员变量transparentRegionScreen所描述的区域。这样我们进一步得到当前正在处理的应用程序窗口的可见区域visibleRegion。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着来看当前正在处理的应用程序窗口的完全不透明区域的计算过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当当前正在处理的应用程序窗口是完全不透明，并且旋转方向也是规则时，那么它的完全不透明区域opaqueRegion就等于前面计算所得到的可见区域visibleRegion。当当前正在处理的应用程序窗口的Alpha通道等于255，即当State对象s的成员变量alpha的值等于255，并且变量translucent的值等于false时，就说明它是完全不透明的，而当当前正在处理的应用程序窗口的旋转方向layerOrientation的Transform::ROT_INVALID位等于0的时候，就说明它的旋转方向是规则的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读代码：</p><p></p><pre name="code" class="cpp">        // Clip the covered region to the visible region
        coveredRegion = aboveCoveredLayers.intersect(visibleRegion);

        // Update aboveCoveredLayers for next (lower) layer
        aboveCoveredLayers.orSelf(visibleRegion);

        // subtract the opaque region covered by the layers above us
        visibleRegion.subtractSelf(aboveOpaqueLayers);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来计算当前正在处理的应用程序窗口的被覆盖区域，以及再进一步计算它的可见区域，主要考虑是否被上层的不透明区域覆盖了。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;变量aboveCoveredLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的可见区域，将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相交，就可以得到当前正在处理的应用程序窗口的被覆盖区域coveredRegion，而将这个区域与当前正在处理的应用程序窗口的可见区域visibleRegion相或一下，就可以得到下一个应用程序窗口的所有上层应用程序窗口所组成的可见区域aboveCoveredLayers。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;变量aboveOpaqueLayers用来描述当前正在处理的应用程序窗口的所有上层应用程序窗口所组成的完全不透明区域，这个区域从当前正在处理的应用程序窗口的可见区域visibleRegion减去后，就可以得到当前正在处理的应用程序窗口的最终可见区域visibleRegion。<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读代码：</p><p></p><pre name="code" class="cpp">        // compute this layer's dirty region
        if (layer-&gt;contentDirty) {
            // we need to invalidate the whole region
            dirty = visibleRegion;
            // as well, as the old visible region
            dirty.orSelf(layer-&gt;visibleRegionScreen);
            layer-&gt;contentDirty = false;
        } else {
            /* compute the exposed region:
             *   the exposed region consists of two components:
             *   1) what's VISIBLE now and was COVERED before
             *   2) what's EXPOSED now less what was EXPOSED before
             *
             * note that (1) is conservative, we start with the whole
             * visible region but only keep what used to be covered by
             * something -- which mean it may have been exposed.
             *
             * (2) handles areas that were not covered by anything but got
             * exposed because of a resize.
             */
            const Region newExposed = visibleRegion - coveredRegion;
            const Region oldVisibleRegion = layer-&gt;visibleRegionScreen;
            const Region oldCoveredRegion = layer-&gt;coveredRegionScreen;
            const Region oldExposed = oldVisibleRegion - oldCoveredRegion;
            dirty = (visibleRegion&amp;oldCoveredRegion) | (newExposed-oldExposed);
        }
        dirty.subtractSelf(aboveOpaqueLayers);

        // accumulate to the screen dirty region
        dirtyRegion.orSelf(dirty);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来计算屏幕的脏区域。我们首先解释一下屏幕的脏区域是如何计算的。将所有应用程序窗口的脏区域都组合起来，就可以得到屏幕的脏区域，这个脏区域就是需要重新执行渲染操作的。因此，为了得到屏幕的脏区域，我们要知道当前正在处理的应用程序窗口的脏区域，以及之前已经处理了的应用程序窗口脏区域组合。前者使用变量dirty来描述，而后者使用输出参数dirtyRegion来描述。从前面的调用过程可以知道，输出参数dirtyRegion指向的就正好是SurfaceFlinger类的成员变量mDirtyRegion，因此，当这一步执行完成之后，SurfaceFlinger类的成员变量mDirtyRegion就代表了SurfaceFlinger服务所要渲染的脏区域。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们首先来看当前正在处理的应用程序窗口的脏区域dirty是如何计算的。我们分两种情况来考虑。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;首先考虑当前正在处理的应用程序窗口上一次的状态还未来得及处理的情况，即它当前的内容是脏的。在这种情况下，LayerBase对象layer的成员变量contentDirty的值就会等于true。这时候我们就需要将该应用程序窗口的上一次可见区域，以及当前的可见区域合并起来，形成一个大的脏区域，这样就可以将两次渲染操作合并成一次来执行。当前正在处理的应用程序窗口的上一次可见区域保存在LayerBase对象layer的成员变量visibleRegionScreen中，而它前的可见区域保存在变量visibleRegion中。将这两者相或一下，就可以得到当前正在处理的应用程序窗口的脏区域dirty。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接着考虑当前正在处理的应用程序窗口上一次的状态已经处理了的情况，即它当前的内容不是脏的，这意味着它所要显示的内容没有发生变化。在这种情况下，就不需要重新渲染所有的可见区域。那么那些区域是需要重新渲染的呢？第一部分区域是之前是被覆盖的，现在不被覆盖了，第二部分是由于窗口大小变化而引发的新增不被覆盖区域。接下来，我们就来看看这两部分区域是如何计算的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;将一个应用程序窗口的当前可见区域减去被覆盖区域，就可以它的当前不被覆盖的区域newExposed，按照同样的方法，我们可以也可以得到它的上一次不被覆盖的区域oldExposed。注意，一个应用程序窗口的上一次可见区域和被覆盖区域分别保存与它相对应的一个LayerBase对象的成员变量visibleRegionScreen和coveredRegionScreen中。这样，将一个应用程序窗口的当前不被覆盖的区域newExposed减去它的上一次不被覆盖的区域oldExposed，就可以得到新增的不被覆盖区域，即可以得到第二部分需要重新渲染的区域。另一方面，将一个应用程序窗口的当前可见区域visibleRegion与它的上一次被覆盖区域oldCoveredRegion相交，就可以得到之前是被覆盖的而现在不被覆盖了的区域，即可以得到第一部分需要重新渲染的区域。将第一部分和第二部分需要重新渲染的区域组合起来，就可以得到当前正在处理的应用程序窗口的脏区域dirty。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 得到了当前正在处理的应用程序窗口的脏区域dirty，接下来的事情就好办了。首先从该脏区域dirty减去上层的完全不透明区域，因为后者的渲染不需要当前应用程序窗口来参与，接着最将得到的新的脏区域dirty累加到输出参数dirtyRegion中去，这样就可以得到目前为止，SurfaceFlinger服务需要渲染的脏区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</p><p></p><pre name="code" class="cpp">        // Update aboveOpaqueLayers for next (lower) layer
        aboveOpaqueLayers.orSelf(opaqueRegion);

        // Store the visible region is screen space
        layer-&gt;setVisibleRegion(visibleRegion);
        layer-&gt;setCoveredRegion(coveredRegion);

        // If a secure layer is partially visible, lock-down the screen!
        if (layer-&gt;isSecure() &amp;&amp; !visibleRegion.isEmpty()) {
            secureFrameBuffer = true;
        }
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码是前面的while循环的几行结束代码，主要用来做三件事情。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第一件事情是计算到目前为止所得到的上层应用程序窗口的完全不透明区域，这是通过组合当前正在处理的应用程序窗口的完全不透明区域与位于它上面的的所有应用程序窗口的完全不透明区域aboveOpaqueLayers来得到的，并且最终结果保存在变量aboveOpaqueLayers中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第二件事情是调用LayerBase对象layer的成员函数setVisibleRegion和setCoveredRegion来保存当前正在处理的应用程序窗口的可见区域和被覆盖区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第三件事情是判断当前正在处理的应用程序窗口的内容是否受安全保护的。如果是的话，并且它的可见区域不为空，那么就需要将变量secureFrameBuffer的值设置为true，以表示当前SurfaceFlinger服务不可以执行截屏功能。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们接着往下阅读最后一段代码：</p><p></p><pre name="code" class="cpp">    // invalidate the areas where a layer was removed
    dirtyRegion.orSelf(mDirtyRegionRemovedLayer);
    mDirtyRegionRemovedLayer.clear();

    mSecureFrameBuffer = secureFrameBuffer;
    opaqueRegion = aboveOpaqueLayers;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 由于前面我们得到SurfaceFlinger服务需要重新渲染的脏区域dirtyRegion只考虑了那些新增或者本来已经存在的应用程序窗口的，而没有考虑那些已经被删除了的应用程序窗口。那些已经被删除了的应用程序窗口所占据的区域保存在SurfaceFlinger类的成员变量mDirtyRegionRemovedLayer中，因此，将它从输出参数dirtyRegion减去之后得到的才是SurfaceFlinger服务最终需要重新渲染的脏区域。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 此外，函数还将变量secureFrameBuffer的值保存在urfaceFlinger类的成员变量mSecureFrameBuffer中，以便SurfaceFlinger服务可以知道自己可以执行截屏功能。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 最后，函数还将前面所有的应用程序窗口组成的完全不透明区域aboveOpaqueLayers保存在输出参数opaqueRegion，以便可以返回给调用者使用。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，返回到前面的Step 1中，即SurfaceFlinger类的成员函数handlePageFlip中，接下来就会继续调用SurfaceFlinger类的另外一个成员函数unlockPageFlip来让各个应用程序窗口执行一些清理工作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析SurfaceFlinger类的成员函数unlockPageFlip的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 6.&nbsp;SurfaceFlinger.unlockPageFlip<br /></p><pre name="code" class="cpp">void SurfaceFlinger::unlockPageFlip(const LayerVector&amp; currentLayers)
{
    const GraphicPlane&amp; plane(graphicPlane(0));
    const Transform&amp; planeTransform(plane.transform());
    size_t count = currentLayers.size();
    sp&lt;LayerBase&gt; const* layers = currentLayers.array();
    for (size_t i=0 ; i&lt;count ; i++) {
        const sp&lt;LayerBase&gt;&amp; layer(layers[i]);
        layer-&gt;unlockPageFlip(planeTransform, mDirtyRegion);
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面提到，我们假设在SurfaceFlinger服务这一侧，每一个应用程序窗口都是使用一个Layer对象来描述，这些Layer对象都是从LayerBase继承下来的，因此它们可以保存在一个类型为LayerBase的向量中。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面的调用过程可以知道，参数currentLayers里面保存的一系列LayerBase对象正是用来描述系统当前的各个应用程序窗口的，SurfaceFlinger类的成员函数unlockPageFlip依次调用这些LayerBase对象的成员函数unlockPageFlip来让它们有机会执行一些清理工作。由于我们假设这些LayerBase对象的实际类型为Layer，因此，前面调用的实际上就是Layer类的成员函数unlockPageFlip。接下来，我们就继续分析Layer类的成员函数unlockPageFlip的实现。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 7.&nbsp;Layer.unlockPageFlip</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void Layer::unlockPageFlip(
        const Transform&amp; planeTransform, Region&amp; outDirtyRegion)
{
    Region dirtyRegion(mPostedDirtyRegion);
    if (!dirtyRegion.isEmpty()) {
        mPostedDirtyRegion.clear();
        // The dirty region is given in the layer's coordinate space
        // transform the dirty region by the surface's transformation
        // and the global transformation.
        const Layer::State&amp; s(drawingState());
        const Transform tr(planeTransform * s.transform);
        dirtyRegion = tr.transform(dirtyRegion);

        // At this point, the dirty region is in screen space.
        // Make sure it's constrained by the visible region (which
        // is in screen space as well).
        dirtyRegion.andSelf(visibleRegionScreen);
        outDirtyRegion.orSelf(dirtyRegion);
    }
    if (visibleRegionScreen.isEmpty()) {
        // an invisible layer should not hold a freeze-lock
        // (because it may never be updated and therefore never release it)
        mFreezeLock.clear();
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/Layer.cpp中。<p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 参数planeTransform用来描述系统显示屏的旋转方向，它是一个变换矩阵，而另外一个参数outDirtyRegion是一个输出参数，指向了SurfaceFlinger类的成员函数mDirtyRegion，即它描述的是SurfaceFlinger服务需要渲染的脏区域。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; Layer类的成员变量mPostedDirtyRegion用来描述当前正在处理的应用程序窗口的脏区域，即可能需要渲染的区域。从前面的Step 5可以知道，Layer类的成员变量visibleRegionScreen是从父类LayerBase继续下来的，用来描述当前正在处理的应用程序窗口的可见区域。这两个区域相关的那部分区域才是当前正在处理的应用程序窗口需要重新渲染的区域，因为一个区域如果是脏的，但是它同时也是不可见的，那么我们是不需要去渲染的。注意，Layer类的成员变量visibleRegionScreen的所描述的区域是相对于显示屏的，而Layer类的成员变量mPostedDirtyRegion所描述的区域是相对于当前正在处理的应用程序窗口的，因此，需要将它转换成相对于显示屏的区域之后，才能将它与前者执行一个相交操作，从而得到当前正在处理的应用程序窗口真正需要渲染的脏区域dirtyRegion。有了这个脏区域dirtyRegion之后，就可以将它组合到输出参数outDirtyRegion中去，以便可以得到SurfaceFlinger服务需要渲染的总脏区域。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 当Layer类的成员变量visibleRegionScreen所描述的区域为空时，就说明当前正在处理的应用程序窗口是不需要参与本次的渲染操作的，因此，这时候就要判断当前正在处理的应用程序窗口是否拥有一个用来冻结系统显示屏的锁。如果有的话，那么就要将这个锁释放掉，避免阻止SurfaceFlinger服务渲染其它应用程序的UI。释放当前正在处理的应用程序窗口所拥有的一个用来冻结系统显示屏的锁是通过调用Layer类的成员变量mFreezeLock所描述的一个FreezeLock对象的成员函数clear来完成的。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;至此，我们就分析完成各个应用程序窗口是如何设置它们当前所要渲染的图形缓冲区以及计算它们的可见区域的了，接下来我们继续分析当当前需要渲染的应用程序窗口只有一个，并且SurfaceFlinger服务在编译的时候指定了USE_COMPOSITION_BYPASS宏时，这个唯一的应用程序窗口是如何被渲染的，即分析SurfaceFlinger类的成员函数handleBypassLayer的实现。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;3.&nbsp;handleBypassLayer</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数handleBypassLayer跳过应用程序窗口的图形缓冲区合成阶段，它直接将系统中唯一的一个应用程序窗口的图形缓冲区渲染到硬件帧缓冲区中去，它的执行过程如图9所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201210/28/1351367276_9438.jpg" alt="" /><br /></p><p style="text-align: center;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">图9 SurfaceFlinger服务直接渲染应用程序窗口的图形缓冲区的过程</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;这个过程可以分为3个步骤，接下来我们就详细分析每一个步骤。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;Step 1.&nbsp;SurfaceFlinger.handleBypassLayer</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">bool SurfaceFlinger::handleBypassLayer()
{
    sp&lt;Layer&gt; bypassLayer(mBypassLayer.promote());
    if (bypassLayer != 0) {
        sp&lt;GraphicBuffer&gt; buffer(bypassLayer-&gt;getBypassBuffer());
        if (buffer!=0 &amp;&amp; (buffer-&gt;usage &amp; GRALLOC_USAGE_HW_FB)) {
            const DisplayHardware&amp; hw(graphicPlane(0).displayHardware());
            hw.postBypassBuffer(buffer-&gt;handle);
            return true;
        }
    }
    return false;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 从前面第2部分的内容的Step 1可以知道，SurfaceFlinger类的成员变量mBypassLayer指向了系统中唯一需要渲染的应用程序窗口，当它的值不等于0的时候，函数接下来就会检查它当前需要渲染的图形缓冲区buffer是否是直接在硬件帧缓冲区中分配的，即图形缓冲区buffer的成员变量usage的GRALLOC_USAGE_HW_FB位是否等于1。如果是直接在硬件帧缓冲区中分配的话，那么函数最后就会先获得用来描述系统主显示屏的一个DisplayHardware对象hw的成员函数postBypassBuffer来直接渲染图形缓冲区buffer。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;在前面第2部分的内容的Step 1中提到，用来描述系统中唯一需要渲染的应用程序窗口的一个Layer对象的成员变量mBypassState的值会被设置为true。这样做的目的是为了让SurfaceFlinger服务以后在为这个应用程序窗口分配图形缓冲区时，都直接在硬件帧缓冲区中分配，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文，这样SurfaceFlinger服务以后就可以直接将该图形缓冲区渲染到硬件帧缓冲区上。与那些在匿名共享内存中分配的图形缓冲区的渲染过程相比，直接在硬件帧缓冲区中分配的图形缓冲区的渲染过程要高效得多，因从就可以提高系统UI的显示性能。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就继续分析DisplayHardware类的成员函数postBypassBuffer的实现，以便可以了解系统中唯一需要渲染的应用程序窗口的图形缓冲区是如何被直接渲染到硬件帧缓冲区中去的。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;Step 2.&nbsp;DisplayHardware.postBypassBuffer</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">status_t DisplayHardware::postBypassBuffer(const native_handle_t* handle) const
{
   framebuffer_device_t *fbDev = (framebuffer_device_t *)mNativeWindow-&gt;getDevice();
   return fbDev-&gt;post(fbDev, handle);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp中。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8046659">Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析</a>一文可以知道，DisplayHardware类的成员变量mNativeWindow指向的是一个FramebufferNativeWindow对象，调用这个FramebufferNativeWindow对象的成员函数getDevice就可以获得它里面的一个framebuffer_device_t对象fbDev。这个framebuffer_device_t对象fbDev是在HAL层的模块Gralloc中打开的，通过调用它的成员函数post就可以将指定的图形缓冲区渲染到硬件帧缓冲区中去。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就继续分析framebuffer_device_t类的成员函数post的实现，以便可以了解SurfaceFlinger是如何将一个图形缓冲区渲染到硬件帧缓冲区中去的。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;Step 3.&nbsp;framebuffer_device_t.post</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文可以知道，framebuffer_device_t类的成员函数post指向了HAL层的Gralloc模块的函数fb_post中，后者定义在文件hardware/libhardware/modules/gralloc/framebuffer.cpp。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;HAL层的Gralloc模块的函数fb_post的作用就是将一个指定的图形缓冲区的内容渲染到硬件帧缓冲区中去。它会分两种情况来考虑。第一种情况是指定的图形缓冲区是直接在硬件帧缓冲区中分配的，这时候该函数就使用IO控制命令FBIOPUT_VSCREENINFO来直接在硬件帧缓冲区中渲染该图形缓冲区的内容。第二种情况是指定的图形缓冲区是直接在匿名共享内存中分配，这时候该函数就会调用函数memcpy来将图形缓冲区的内容从匿名共享内存拷贝硬件帧缓冲区中去。在我们这个场景中，指定要渲染的图形缓冲区是直接在硬件帧缓冲区中分配的，因此，它最终就会通过IO控制命令FBIOPUT_VSCREENINFO渲染到硬件帧缓冲区中去。这个过程可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文，这里不再详述。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;至此，我们就分析完成系统中唯一一个需要渲染的应用程序窗口的图形缓冲区的渲染过程了，接下来我们继续分析系统中存在多个需要渲染的应用程序窗口时，SurfaceFlinger服务是如何渲染它们的图形缓冲区的，即分析SurfaceFlinger类的成员函数handleRepaint的实现。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 4.&nbsp;handleRepaint</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceFlinger类的成员函数handleRepaint是用来合成系统中各个应用程序窗口的图形缓冲区的，以便可以将它们的内容一起渲染到硬件帧缓冲区中去，它的执行过程如图10所示：</p><p style="text-align: center;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "><img src="http://img.my.csdn.net/uploads/201210/29/1351442462_7660.jpg" alt="" /><br /></p><p style="text-align: center;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">图10&nbsp;SurfaceFlinger服务合成应用程序窗口的图形缓冲区的过程</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程可以分为5个步骤，接下来我们就详细分析每一个步骤。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1.&nbsp;SurfaceFlinger.handleRepaint</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void SurfaceFlinger::handleRepaint()
{
    // compute the invalid region
    mInvalidRegion.orSelf(mDirtyRegion);
    if (mInvalidRegion.isEmpty()) {
        // nothing to do
        return;
    }

    if (UNLIKELY(mDebugRegion)) {
        debugFlashRegions();
    }

    // set the frame buffer
    const DisplayHardware&amp; hw(graphicPlane(0).displayHardware());
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    uint32_t flags = hw.getFlags();
    if ((flags &amp; DisplayHardware::SWAP_RECTANGLE) ||
        (flags &amp; DisplayHardware::BUFFER_PRESERVED))
    {
        // we can redraw only what's dirty, but since SWAP_RECTANGLE only
        // takes a rectangle, we must make sure to update that whole
        // rectangle in that case
        if (flags &amp; DisplayHardware::SWAP_RECTANGLE) {
            // TODO: we really should be able to pass a region to
            // SWAP_RECTANGLE so that we don't have to redraw all this.
            mDirtyRegion.set(mInvalidRegion.bounds());
        } else {
            // in the BUFFER_PRESERVED case, obviously, we can update only
            // what's needed and nothing more.
            // NOTE: this is NOT a common case, as preserving the backbuffer
            // is costly and usually involves copying the whole update back.
        }
    } else {
        if (flags &amp; DisplayHardware::PARTIAL_UPDATES) {
            // We need to redraw the rectangle that will be updated
            // (pushed to the framebuffer).
            // This is needed because PARTIAL_UPDATES only takes one
            // rectangle instead of a region (see DisplayHardware::flip())
            mDirtyRegion.set(mInvalidRegion.bounds());
        } else {
            // we need to redraw everything (the whole screen)
            mDirtyRegion.set(hw.bounds());
            mInvalidRegion = mDirtyRegion;
        }
    }

    // compose all surfaces
    composeSurfaces(mDirtyRegion);

    // clear the dirty regions
    mDirtyRegion.clear();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; SurfaceFlinger类的成员变量mInvalidRegion用来描述SurfaceFlinger服务需要渲染到硬件帧缓冲区中去的脏区域的。前面提到，SurfaceFlinger类的成员变量mDirtyRegion也是用来描述SurfaceFlinger服务需要渲染的脏区域的，不过，它的作用是用来合成系统中各个应用程序窗口的图形缓冲区的，也就是说，当系统中各个应用程序窗口的图形缓冲区被合成之后，这个成员变量所描述的区域就会被清空，而成员变量mInvalidRegion会一直等到它的内容被渲染到硬件帧缓冲区中去之后，才会被清空。这样就可能会出现这种情况：上一次合成的图形缓冲区还未被渲染到硬件帧缓冲区中去，SurfaceFlinger服务又会执行新一轮的系统中各个应用程序窗口的图形缓冲区的合并操作。在这种情况下，SurfaceFlinger服务就需要将前面两次需要渲染到硬件帧缓冲区中去的区域合并在一起，以便可以正确地反映被刷新的UI。因此，函数在开头的地方，就会先SurfaceFlinger类的成员变量mDirtyRegion所描述的区域组合到成员变量mInvalidRegion所描述的区域中去。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 函数接下来调用用来描述系统主显示屏的一个DisplayHardware对象hw的成员函数getFlags来获得系统所支持的渲染方式，并且保存在一个uint32_t变量flags中。接下来，我们就分四种情况来讨论系统所支持的渲染方式：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;1.&nbsp;变量flags的DisplayHardware::PARTIAL_UPDATES位等于1。在这种情况下，系统在硬件上直接支持部分区域更新功能，不过，这个部分被更新的区域必须要是一个矩形区域。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;2.&nbsp;变量flags的DisplayHardware::SWAP_RECTANGLE位等于1。在这种情况下，系统在软件上支持部分区域更新功能，同样，这个部分被更新的区域必须要是一个矩形区域。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;3.&nbsp;变量flags的DisplayHardware::BUFFER_PRESERVED位等于1。在这种情况下，系统支持不规则的部分区域更新功能。所谓不规则，就是这个被更新的区域不必是一个矩形区域。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;4.&nbsp;变量flags的值等于0。在这种情况下，系统不支持部分更新区域，这时候就需要更新整个屏幕的内容。<br /></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;在第1种和第2种情况中，由于被更新的区域都必须是一个矩形区域，因此，函数就需要将SurfaceFlinger类的成员变量mDirtyRegion所描述的一个区域设置为包含了所有脏区域的一个最小矩形区域。在第4种情况中，由于需要更新的是整个屏幕的内容，因此，函数就需要将SurfaceFlinger类的成员变量mDirtyRegion所描述的一个区域设置为等于屏幕大小的一个矩形区域。在第3种情况中，就不需要调用被更新的区域。对于第1种、第2种和第3种渲染方式的更多描述，可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8046659">Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析</a>一文。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;得到了最终要合成的脏区域mDirtyRegion之后，SurfaceFlinger类的成员函数handleRepaint最后就调用另外一个成员函数composeSurfaces来合成系统中各个应用程序窗口的图形缓冲区，并且在合成操作完成之后，将脏区域mDirtyRegion设置为一个空区域。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就继续分析SurfaceFlinger类的成员函数composeSurfaces的实现。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;Step 2.&nbsp;SurfaceFlinger.composeSurfaces</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void SurfaceFlinger::composeSurfaces(const Region&amp; dirty)
{
    if (UNLIKELY(!mWormholeRegion.isEmpty())) {
        // should never happen unless the window manager has a bug
        // draw something...
        drawWormhole();
    }
    const Vector&lt; sp&lt;LayerBase&gt; &gt;&amp; layers(mVisibleLayersSortedByZ);
    const size_t count = layers.size();
    for (size_t i=0 ; i&lt;count ; ++i) {
        const sp&lt;LayerBase&gt;&amp; layer(layers[i]);
        const Region clip(dirty.intersect(layer-&gt;visibleRegionScreen));
        if (!clip.isEmpty()) {
            layer-&gt;draw(clip);
        }
    }
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数dirty用来描述即将要被渲染的脏区域，它是从前面的第1步传进来的，即为SurfaceFlinger类的成员变量mDirtyRegion所描述的区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员变量mVisibleLayersSortedByZ保存了系统当前所有的可见应用程序窗口，这些应用程序窗口是前面第2部分内容的Step 1中计算得到的，而且都是需要渲染的。&nbsp;SurfaceFlinger类的成员函数composeSurfaces依次检查这些应用程序窗口的可见区域是否与即将要渲染的的脏区域有交集。如果有的话，即变量clip所描述的区域不为空，那么接下来SurfaceFlinger类的成员函数composeSurfaces就会分别调用与这些应用程序窗口对应的一个LayerBase对象的成员函数draw来将它们需要渲染的图形缓冲区合成到系统的主显示屏来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析LayerBase类的成员函数draw的实现，以便了解SurfaceFlinger服务合成各个应用程序窗口的图形缓冲区的过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 3.&nbsp;LayerBase.draw</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void LayerBase::draw(const Region&amp; clip) const
{
    // reset GL state
    glEnable(GL_SCISSOR_TEST);

    onDraw(clip);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/LayerBase.cpp中。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;LayerBase类的成员函数draw的实现很简单，它只是调用了另外一个成员函数onDraw来通知各个应用程序窗口重新绘制参数clip所描述的一个区域。LayerBase类的成员函数onDraw是一个虚函数，这是由其子类来重写的。前面我们假设系统中的所有应用程序窗口都是使用一个Layer对象来描述的，而Layer类是从LayerBase类继承下来的，并且重写了其成员函数onDraw。因此，接下来我们就继续分析Layer类的成员函数onDraw的实现。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 4.&nbsp;Layer.onDraw</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/Layer.cpp中，用来绘制一个应用程序窗口的指定区域，我们分段来阅读：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void Layer::onDraw(const Region&amp; clip) const
{
    Texture tex(mBufferManager.getActiveTexture());
    if (tex.name == -1LU) {
        // the texture has not been created yet, this Layer has
        // in fact never been drawn into. This happens frequently with
        // SurfaceView because the WindowManager can't know when the client
        // has drawn the first time.

        // If there is nothing under us, we paint the screen in black, otherwise
        // we just skip this update.

        // figure out if there is something below us
        Region under;
        const SurfaceFlinger::LayerVector&amp; drawingLayers(mFlinger-&gt;mDrawingState.layersSortedByZ);
        const size_t count = drawingLayers.size();
        for (size_t i=0 ; i&lt;count ; ++i) {
            const sp&lt;LayerBase&gt;&amp; layer(drawingLayers[i]);
            if (layer.get() == static_cast&lt;LayerBase const*&gt;(this))
                break;
            under.orSelf(layer-&gt;visibleRegionScreen);
        }
        // if not everything below us is covered, we plug the holes!
        Region holes(clip.subtract(under));
        if (!holes.isEmpty()) {
            clearWithOpenGL(holes, 0, 0, 0, 1);
        }
        return;
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码主要是用来处应用程序窗口的纹理尚未创建好的情况。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在纹理未创建好的情况下，一个应用程序窗口是不应该被渲染的。这时候函数首先将位于当前正在处理的应用程序窗口下面的所有其它应用程序窗口的可见区域组合起来，并且保存在变量under所描述的区域中。由于这时候当前正在处理的应用程序窗口不会被绘制，因此，如果变量under所描述的区域小于参数clip所描述的区域，即变量holes所描述的区域不为空，那么SurfaceFlinger服务所要求缓制的区域clip就会留下一个洞。这个洞会被绘制成黑色，这是通过调用函数clearWithOpenGL来实现的。绘制完成之后，函数就可以直接返回了。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面第2部分的Step 4中提到，Layer类的成员变量mBufferManager描述的是一个BufferManager对象，通过调用它的成员函数initEglImage或者loadTexture就可以根据一个应用程序窗口的当前需要渲染的图形缓冲区来创建出一个纹理对象。这个纹理对象就保存在BufferManager类的成员变量mFailoverTexture或者另外一个成员变量mBufferData所描述的一个BufferData数组中，取决于系统是否支持在硬件上直接创建纹理对象。这个纹理对象是使用一个Texture对象来描述的，并且可以通过调用Layer类的成员变量mBufferManager描述的是一个BufferManager对象的成员函数getActiveTexture来获得。如果获得的Texture对象的名称name等于-1，那么就说明当前正在处理的应用程序窗口尚未创建好需要渲染的纹理。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读代码：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">#ifdef USE_COMPOSITION_BYPASS
    sp&lt;GraphicBuffer&gt; buffer(mBufferManager.getActiveBuffer());
    if ((buffer != NULL) &amp;&amp; (buffer-&gt;transform)) {
        // Here we have a &quot;bypass&quot; buffer, but we need to composite it
        // most likely because it's not fullscreen anymore.
        // Since the buffer may have a transformation applied by the client
        // we need to inverse this transformation here.

        // calculate the inverse of the buffer transform
        const uint32_t mask = HAL_TRANSFORM_FLIP_V | HAL_TRANSFORM_FLIP_H;
        const uint32_t bufferTransformInverse = buffer-&gt;transform ^ mask;

        // To accomplish the inverse transform, we use &quot;mBufferTransform&quot;
        // which is not used by Layer.cpp
        const_cast&lt;Layer*&gt;(this)-&gt;mBufferTransform = bufferTransformInverse;
        drawWithOpenGL(clip, tex);
        // reset to &quot;no transfrom&quot;
        const_cast&lt;Layer*&gt;(this)-&gt;mBufferTransform = 0;
        return;
    }
#endif</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码用来检查当前正在处理的应用程序窗口的图形缓冲区是否是一个可以跳过合成阶段的图形缓冲区。本来这种图形缓冲区是可以直接渲染到硬件帧缓冲区中去的，但是由于它不是全屏显示的，因此就需要与其它应用程序窗口的图形缓冲区进行合并操作。如果这个图形缓冲区之前曾经被旋转过，例如，被水平翻转或者垂直翻转过，那么在对它进行合并之前，还需要将它的旋转方向恢复回来。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 当用来描述一个图形缓冲区的一个GraphicBuffer对象的成员变量transform的值不等于0时，那么就说明这个图形缓冲区是被旋转过的，这时候函数就会对这个成员变量的值的HAL_TRANSFORM_FLIP_V位或者HAL_TRANSFORM_FLIP_H位进行取反，目的就是为了恢复它之前的旋转方向。反转后得到的方向就保存在Layer类的成员变量mBufferTransform中。Layer类的成员变量mBufferTransform是从父类LayerBase继承下来的，接下来在调用从父类LayerBase继承下来的成员函数drawWithOpenGL来绘制当前正在处理的应用程序窗口时，就需要使用到它来设置纹理的旋转方向。在后面的Step 5中，我们再详细分析LayerBase类的成员函数drawWithOpenGL的实现。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;我们继续往下阅读最后一行代码：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">    drawWithOpenGL(clip, tex);
}</pre><p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果当前正在处理的应用程序窗口的图形缓冲区没有被旋转过，或者这个图形缓冲区本来就需要进行合并的，那么Layer类的成员函数onDraw最后就会调用从父类LayerBase继承下来的成员函数drawWithOpenGL来将这个图形缓冲区的内容绘制在系统的主显示屏的指定区域上来。这个图形缓冲区的内容是使用纹理象tex来描述的，而指定的主显示屏区域是由参数clip来描述的。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析LayerBase类的成员函数drawWithOpenGL的实现，以便可以了解一个应用程序窗口的绘制过程，即它的图形缓冲区被合成到系统主显示屏的过程。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 5.&nbsp;LayerBase.drawWithOpenGL</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/LayerBase.cpp中，它通过OpenGL提供的接口来绘制一个应用程序窗口的指定区域，我们分段来阅读：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void LayerBase::drawWithOpenGL(const Region&amp; clip, const Texture&amp; texture) const
{
    const DisplayHardware&amp; hw(graphicPlane(0).displayHardware());
    const uint32_t fbHeight = hw.getHeight();
    const State&amp; s(drawingState());

    // bind our texture
    TextureManager::activateTexture(texture, needsFiltering());
    uint32_t width  = texture.width;
    uint32_t height = texture.height;

    GLenum src = mPremultipliedAlpha ? GL_ONE : GL_SRC_ALPHA;
    if (UNLIKELY(s.alpha &lt; 0xFF)) {
        const GLfloat alpha = s.alpha * (1.0f/255.0f);
        if (mPremultipliedAlpha) {
            glColor4f(alpha, alpha, alpha, alpha);
        } else {
            glColor4f(1, 1, 1, alpha);
        }
        glEnable(GL_BLEND);
        glBlendFunc(src, GL_ONE_MINUS_SRC_ALPHA);
        glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
    } else {
        glColor4f(1, 1, 1, 1);
        glTexEnvx(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
        if (needsBlending()) {
            glEnable(GL_BLEND);
            glBlendFunc(src, GL_ONE_MINUS_SRC_ALPHA);
        } else {
            glDisable(GL_BLEND);
        }
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数clip用来描述要绘制的区域，而参数texture用来描述要绘制的纹理。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先得到主显示屏的高度fbHeight、要绘制的纹理texture的宽度width和高度height，以及用来描述当前正在处理的应用程序窗口状态的一个State对象s，接下来就是调用函数再设置纹理texture的绘制模式，即是否需要以混合模式来绘制，这是通过调用函数glEnable(GL_BLEND)来实现的。在需要混合模式来绘制纹理texture的情况下，还需要调用函数glBlendFunc来指定混合函数。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在以下两种情况下，纹理texture需要以混合模式来绘制：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1.&nbsp;当前正在处理的应用程序窗口的Alpha通道的值小于0xFF，即State对象s的成员变量alpha的值小于0xFF，这表明该窗口的背景是半透明的。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 当前正在处理的应用程序窗口的像素格式是半透明的，这是通过调用LayerBase类的成员函数needsBlending来判断的。Layer类重写了父类LayerBase的成员函数needsBlending。当一个Layer对象所描述的应用程序窗口的像素格式是半透明的时候，它就会将它的成员变量mNeedsBlending的值设置为true。这样，我们就可以调用Layer类的成员函数needsBlending来检查它的成员变量mNeedsBlending是否为true来判断一个应用程序窗口的像素格式是否是半透明的。这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文的Step 6。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 我们继续往下阅读代码：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">    /*
     *  compute texture coordinates
     *  here, we handle NPOT, cropping and buffer transformations
     */

    GLfloat cl, ct, cr, cb;
    if (!mBufferCrop.isEmpty()) {
        // source is cropped
        const GLfloat us = (texture.NPOTAdjust ? texture.wScale : 1.0f) / width;
        const GLfloat vs = (texture.NPOTAdjust ? texture.hScale : 1.0f) / height;
        cl = mBufferCrop.left   * us;
        ct = mBufferCrop.top    * vs;
        cr = mBufferCrop.right  * us;
        cb = mBufferCrop.bottom * vs;
    } else {
        cl = 0;
        ct = 0;
        cr = (texture.NPOTAdjust ? texture.wScale : 1.0f);
        cb = (texture.NPOTAdjust ? texture.hScale : 1.0f);
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来计算纹理坐标，并且保存在变量cl、ct、cr和cb中，用来描述纹理texture的四个角的坐标。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文可以知道，如果Android应用程序设置了一个窗口的纹理坐标，那么SurfaceFlinger服务就会通过调用LayerBase类的成员函数setBufferCrop来保存在成员变量mBufferCrop中。另一方面，如果Android应用程序没有指定一个窗口的纹理坐标，那么这个窗口的纹理坐标的默认值就使用要绘制的纹理的四个角的坐标来描述。注意，在计算纹理坐标的时候，还要考虑纹理的大小，以及纹理本身所设置的缩放因子，以便可以正确地将纹理绘制在应用程序窗口中。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读代码：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">    /*
     * For the buffer transformation, we apply the rotation last.
     * Since we're transforming the texture-coordinates, we need
     * to apply the inverse of the buffer transformation:
     *   inverse( FLIP_V -&gt; FLIP_H -&gt; ROT_90 )
     *   &lt;=&gt; inverse( ROT_90 * FLIP_H * FLIP_V )
     *    =  inverse(FLIP_V) * inverse(FLIP_H) * inverse(ROT_90)
     *    =  FLIP_V * FLIP_H * ROT_270
     *   &lt;=&gt; ROT_270 -&gt; FLIP_H -&gt; FLIP_V
     *
     * The rotation is performed first, in the texture coordinate space.
     *
     */

    struct TexCoords {
        GLfloat u;
        GLfloat v;
    };

    enum {
        // name of the corners in the texture map
        LB = 0, // left-bottom
        LT = 1, // left-top
        RT = 2, // right-top
        RB = 3  // right-bottom
    };

    // vertices in screen space
    int vLT = LB;
    int vLB = LT;
    int vRB = RT;
    int vRT = RB;

    // the texture's source is rotated
    uint32_t transform = mBufferTransform;
    if (transform &amp; HAL_TRANSFORM_ROT_90) {
        vLT = RB;
        vLB = LB;
        vRB = LT;
        vRT = RT;
    }
    if (transform &amp; HAL_TRANSFORM_FLIP_V) {
        swap(vLT, vLB);
        swap(vRT, vRB);
    }
    if (transform &amp; HAL_TRANSFORM_FLIP_H) {
        swap(vLT, vRT);
        swap(vLB, vRB);
    }

    TexCoords texCoords[4];
    texCoords[vLT].u = cl;
    texCoords[vLT].v = ct;
    texCoords[vLB].u = cl;
    texCoords[vLB].v = cb;
    texCoords[vRB].u = cr;
    texCoords[vRB].v = cb;
    texCoords[vRT].u = cr;
    texCoords[vRT].v = ct;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码主要根据当前正在处理的应用程序窗口的旋转方向来调整前面所计算得到的纹理坐标。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文可以知道，如果Android应用程序设置了一个窗口的旋转方向时，那么SurfaceFlinger服务就会通过调用LayerBase类的成员函数setBufferTransform来保存在成员变量mBufferTransform中，因此，这段代码就可以根据这个成员变量的值来相应地调用前面所计算得到的纹理坐标。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读代码：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">    if (needsDithering()) {
        glEnable(GL_DITHER);
    } else {
        glDisable(GL_DITHER);
    }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来检查是否需要以抖动的方式来绘制纹理，如果需要的话，就调用函数glEnable(GL_DITHER)来启动抖动功能，否则的话，就调用函数glDisable(GL_DITHER)来关闭抖动功能。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文可以知道，如果一个Android应用程序窗口的像素格式的红色通道的位数大于系统主显示屏的像素格式的红色通道的位数时，SurfaceFlinger服务就会将用来描述该Android应用程序窗口的一个Layer对象的成员变量mNeedsDithering的值设置为true。Layer类重写了父类LayerBase的成员函数needsDithering，它通过检查其成员变量mNeedsDithering的值是否等于true来告诉这段代码用来检查是否需要以抖动的方式来绘制纹理。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读最后一段代码：</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">    glEnableClientState(GL_TEXTURE_COORD_ARRAY);
    glVertexPointer(2, GL_FLOAT, 0, mVertices);
    glTexCoordPointer(2, GL_FLOAT, 0, texCoords);

    Region::const_iterator it = clip.begin();
    Region::const_iterator const end = clip.end();
    while (it != end) {
        const Rect&amp; r = *it++;
        const GLint sy = fbHeight - (r.top + r.height());
        glScissor(r.left, sy, r.width(), r.height());
        glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
    }
    glDisableClientState(GL_TEXTURE_COORD_ARRAY);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码首先调用函数glEnableClientState(GL_TEXTURE_COORD_ARRAY)来指定使用顶点数组的方式绘制当前正在处理的应用程序窗口，接着又分别调用函数glVertexPointer和glTexCoordPointer来指定要绘制的顶点数组以及纹理坐标。设置好要绘制的顶点数组以及纹理坐标之后，最后就要设置裁剪区域，以便可以调用函数glDrawArrays来绘制前面指定的顶点数组以及纹理。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面提到，参数clip用来描述要绘制的区域，而要绘制的区域即为当前需要指定的裁剪区域。由于参数clip所描述的区域是可以由一系列的矩形区域来组成的，因此，这段代码就通过一个while循环来遍历里面的每一个矩形区域，并且调用函数glScissor来分别将它们设置为裁剪区域。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;至此，我们就分析完成系统中各个应用程序窗口的图形缓冲区的合成过程了，这个过程其实就是分别根据各个应用程序窗口的图形缓冲区来创建一个纹理对象，并且结合各个应用程序窗口的UI元数据来将该纹理对象绘制在系统主显示屏的指定区域中，而这个指定的区域即为系统的脏区域。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析系统中各个应用程序窗口将自己的图形缓冲区合成到系统的主显示屏之后，SurfaceFlinger服务是如何将系统的主显示屏渲染到硬件帧缓冲区中去的，即分析SurfaceFlinger类的成员函数postFramebuffer的实现。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;5.&nbsp;postFramebuffer</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceFlinger类的成员函数postFramebuffer用来将系统的主显示屏的内容渲染到硬件帧缓冲区中去，它的执行过程如图11所示：<br /></p><p style="text-align: center;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "><img src="http://img.my.csdn.net/uploads/201211/01/1351701271_4273.jpg" alt="" /><br /></p><p style="text-align: center;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">图11&nbsp;SurfaceFlinger服务渲染系统主显示屏的内容到硬件帧缓冲区的过程</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程可以划分为4步骤，接下来我们就详细分析每一个步骤。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1.&nbsp;SurfaceFlinger.postFramebuffer</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="cpp">void SurfaceFlinger::postFramebuffer()
{
    if (!mInvalidRegion.isEmpty()) {
        const DisplayHardware&amp; hw(graphicPlane(0).displayHardware());
        const nsecs_t now = systemTime();
        mDebugInSwapBuffers = now;
        hw.flip(mInvalidRegion);
        mLastSwapBufferTime = systemTime() - now;
        mDebugInSwapBuffers = 0;
        mInvalidRegion.clear();
    }
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/SurfaceFlinger.cpp中。<p></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面第4部分内容的Step 1中提到，SurfaceFlinger类的成员变量mInvalidRegion用来描述系统主显示屏的脏区域，即SurfaceFlinger服务当前需要渲染的区域。函数首先得到用来描述系统主显示屏的一个DisplayHardware对象hw，接着再调用这个DisplayHardware对象hw的成员函数flip来渲染这个脏区域。<br /></p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析DisplayHardware类的成员函数flip的实现。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2. &nbsp;DisplayHardware.flip</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/surfaceflinger/DisplayHardware/DisplayHardware.cpp中，在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8046659">Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析</a>一文中，我们已经分析过它的实现了。这个函数会检查系统是否支持部分更新功能。如果支持的话，那么就先设置要更新的区域，否则的话，就直接调用函数eglSwapBuffers来将前面已经合成好的了图形缓冲区渲染到硬件帧缓冲区去。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8046659">Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析</a>一文可以知道，调用函数eglSwapBuffers在渲染图形缓冲区的时候，会导致FramebufferNativeWindow类的成员函数queueBuffer被调用，后者会通过HAL层的Gralloc模块来执行渲染硬件帧缓冲区的操作。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 3. FramebufferNativeWindow.queueBuffer</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/libs/ui/FramebufferNativeWindow.cpp中，同样，在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8046659">Android系统Surface机制的SurfaceFlinger服务对帧缓冲区（Frame Buffer）的管理分析</a>一文中，我们已经分析过它的实现了。这个函数主要就是通过HAL层的Gralloc模块中的framebuffer_device_t设备的成员函数post来执行渲染硬件帧缓冲区的操作。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 4.&nbsp;framebuffer_device_t.post</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 这个函数指向定义在HAL层的Gralloc模块中的函数fb_post，后者定义在文件hardware/libhardware/modules/gralloc/framebuffer.cpp，在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文中，我们已经分析过这个函数的实现了。由于要渲染的图形缓冲区是用于渲染系统主显示屏的，因此，它是直接在硬件帧缓冲区上分配的，这时候函数fb_post就会通过IO控制命令FBIOPUT_VSCREENINFO来通知位内核空间的fb驱动来将系统主显示屏的UI绘制出来。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 至此，SurfaceFlinger服务渲染系统主显示屏的内容到硬件帧缓冲区的过程就分析完成了，整个SurfaceFlinger服务渲染应用程序UI的过程也分析完成了。</p><p style="text-align: left;margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 这样，我们就通过<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>和<a href="http://blog.csdn.net/luoshengyang/article/details/8010977">Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划</a>这两个系列的文章系统地分析了Android系统的SurfaceFlinger服务的实现，为后面我们后面进一步分析Android系统的UI架构打下坚实的基础！</p><p style="text-align: center; margin: 4px 0px; padding: 2px 0px;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-11-5 0:59:47 <a href="http://blog.csdn.net/luoshengyang/article/details/8079456">原文链接</a>
            </div>
            <div>
            阅读：7004 评论：39 <a href="http://blog.csdn.net/luoshengyang/article/details/8079456#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]《Android系统源代码情景分析》一书勘误]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8116866</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8116866</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-10-26 20:44:13</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在大家的支持和鼓励下，《</span><span style="color:black;">Android</span><span style="color:black;">系统源代码情景分析》一书得以出版了，老罗在此首先谢过大家了。本书的内容来源于博客的文章，经过大半年的整理之后，形成了初稿。在正式出版之前，又经过了三次排版以及修订，最终得到终稿。然而，老罗深知，书中的内容并不尽完美，除了错误之外总还会有许多不尽人意的地方，因此，欢迎广大读者以及国内外的专家给老罗指出，以便改进。为了达到此目的，老罗特别在此列出该书有错误的地方。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 现在暂时将书中出现的错误划分为三类，第一类是笔误，第二类是表达问题，第三类是技术性错误，分别使用<span style="color:black;">I、</span><span style="color:black;">II和</span><span style="color:black;">III来表示，错误所在的页码使用字母P来表示。</span></span></p><p><span style="color:black;"><span style="color:black;">&nbsp;&nbsp; &nbsp; </span><span style="color:#333333;">&nbsp;</span>1. P53，lightpointer.cpp的第16行（I）：printf(&quot;<span style="color:#FF0000;">Destory</span> LightClass Object.&quot;)。单词<span style="color:#FF0000;">Destory</span>拼写错误，应为<span style="color:#FF0000;">Destroy</span>。感谢网友@hengbo12345指出，2012-10-26。</span></p><p>&nbsp;&nbsp; &nbsp; &nbsp;2. P147，倒数第9行（I）：即将一个Binder实体对象的成员变量work的值设置为<span style="color:#FF0000;">BINDER_WORKD_NODE</span>。短语<span style="color: rgb(255, 0, 0); ">BINDER_WORKD_NODE</span>中间的单词<span style="color:#FF0000;">WORKD</span>拼写错误，多了一个字母<span style="color:#FF0000;">D</span>，应为<span style="color: rgb(255, 0, 0); ">BINDER_WORK_NODE</span>。感谢网友@brucechan1973指出，2012-10-30。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;3. P399，顺数第2行和第4行（I）：<span style="color:#FF0000;">ManActivity</span>组件。短语<span style="color: rgb(255, 0, 0); ">ManActivity中</span>的单词<span style="color:#FF0000;">Man</span>拼写错误，应改为<span style="color:#FF0000;">MainActivity</span>。感谢网友@herodie指出，2012-11-01。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;4. P400，第二段和第三段（I）：action = &quot;android.intent.action.<span style="color:#FF0000;">Main</span>&quot;、要启动的Activity组件的Action名称和Category名称分别为&quot;android.intent.action.<span style="color:#FF0000;">Main</span>&quot;和&quot;android.intent.category.LAUNCHER&quot;。单词<span style="color:#FF0000;">Main</span>应全部大写<span style="color:#FF0000;">MAIN</span>。感谢网友@herodie指出，2012-11-01。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;5. P3，倒数第2行（III）：<span style="color:#FF0000;">sudo add-apt-repository ppa:ferramrobert/java</span>。由于License问题（<a href="http://askubuntu.com/questions/109209/sun-java6-plugin-has-no-installation-candidate">http://askubuntu.com/questions/109209/sun-java6-plugin-has-no-installation-candidate</a>），官方的Sun JDK6不能在Ubuntu上发布，因此，现在从下载源ferramrobert已经下载不到JDK6来安装了，可以通过修改安装源来解决这个问题，如下所示：</p><p>&nbsp;&nbsp; &nbsp; &nbsp;A.&nbsp;<span style="color:#ff0000;">sudo add-apt-repository &quot;deb http://us.archive.ubuntu.com/ubuntu/ hardy multiverse&quot;</span></p><p>&nbsp;&nbsp; &nbsp; &nbsp;B.&nbsp;<span style="color:#FF0000;">sudo apt-get update</span></p><p>&nbsp;&nbsp; &nbsp; &nbsp;C.&nbsp;<span style="color:#FF0000;">sudo apt-get install sun-java6-jre sun-java6-plugin</span></p><p>&nbsp;&nbsp; &nbsp; &nbsp;D.&nbsp;<span style="color:#FF0000;">sudo apt-get install sun-java6-jdk</span></p><p>&nbsp;&nbsp; &nbsp; &nbsp;如果在安装过程中，碰到有依赖包未安装，就先把依赖包安装上去就行了。感谢网友@偏左和@大桥++指出，2012-11-05。</p><p>&nbsp; &nbsp; &nbsp;&nbsp;如果这样还不能安装成功，那就只有自己手动安装了，官方JDK下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a></p><p>&nbsp; &nbsp; &nbsp; 更多的环境配置信息，可以参考官方文档：<a href="http://source.android.com/source/initializing.html">http://source.android.com/source/initializing.html</a></p><p>&nbsp;&nbsp; &nbsp; &nbsp;6. P350，顺数第二段和倒数第一段（I）：<span style="color:#FF0000;">IMemoryBase</span>类定义了MemoryHeapBase服务接口、并且实现了<span style="color:#FF0000;">IMemoryBase</span>接口的四个成员函数。这两句话中的<span style="color: rgb(255, 0, 0); ">IMemoryBase</span>拼写错误，应改为<span style="color: rgb(255, 0, 0); ">IMemoryHeap</span>。感谢网友@sulliy指出，2012-11-06。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;7. P378，顺数第3行（I）：<span style="color:#FF0000;">IMemoryFile</span>接口定义了两个成员函数getFileDescriptor和setValue。短语<span style="color:#FF0000;">IMemoryFile</span>写错了，应改为<span style="color:#FF0000;">IMemoryService</span>。感谢网友@hongbog_cd指出，2012-11-14。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;8. P155，最后四段（III）：对结构体binder_transaction的成员变量<span style="color:#FF0000;">from_parent</span>和<span style="color:#FF0000;">to_parent</span>的描述有偏差。应改为：</p><p>&nbsp;&nbsp; &nbsp; &nbsp;---------------------------</p><p>&nbsp;&nbsp; &nbsp; <em>&nbsp;成员变量from_parent和to_parent分别描述一个事务所依赖的另外一个事务，以及目标线程下一个需要处理的事务。假设线程A发起了一个事务T1，需要由线程B来处理；线程B在处理事务T1时，又需要线程C先处理事务T2；线程C在处理事务T2时，又需要线程A先处理事务T3。这样，事务T1就依赖于事务T2，而事务T2又依赖于事务T3，它们的关系如下：<br /></em></p><div style="text-align: center;"><span style="color:#FF0000;"><span style="color: rgb(255, 0, 0); "><del><span style="color:#000000;"><em>T1-&gt;from_parent = T2;</em></span></del><em> </em></span><em>T2-&gt;from_parent = T1;</em></span></div><div style="text-align: center;"><span style="color:#FF0000;"><del><span style="color:#000000;"><em>T2-&gt;from_parent = T3; </em></span></del><em>T3-&gt;from_parent = T2;</em></span></div><em>&nbsp;&nbsp; &nbsp; 对于线程A来说，它需要处理的事务有两个，分别是T1和T3，它首先要处理事务T3，然后才能处理事务T1，因此，事务T1和T3的关系如下：<br /></em><div style="text-align: center;"><em>T3-&gt;to_parent = T1;</em></div><em>&nbsp;&nbsp; &nbsp;考虑这样一个情景：如果线程C在发起事务T3给线程A所属的进程来处理时，Binder驱动程序选择了该进程的另外一个线程D来处理该事务，这时候会出现什么情况呢？这时候线程A就会处于空闲等待状态，什么也不能做，因为它必须要等线程D处理完成事务T3后，它才可以继续执行事务T1。在这种情况下，与其让线程A闲着，还不如把事务T3交给它来处理，这样线程D就可以去处理其他事务，提高了进程的并发性。</em><p></p><p><em>&nbsp;&nbsp; &nbsp; 现在，关键的问题又来了——Binder驱动程序在分发事务T3给目标进程处理时，它是如何知道线程A属于目标进程，并且正在等待事务T3的处理结果的？</em><span style="color:#FF0000;"><del><span style="color:#000000;"><em>当线程B在处理事务T2时，就会将事务T2放在其事务堆栈transaction_stack的最前端。这样当线程B发起事务T3给线程C处理时，Binder驱动程序就可以沿着线程B的事务堆栈transaction_stack向下遍历，直到发现事务T3的目标进程等于事务T1的目标进程时，它就知道线程A正在等待事务T3的处理结果了。</em></span></del><span style="color:#FF0000;"><em>当线程C在处理事务T2时，就会将事务T2放在其事务堆栈transaction_stack的最前端。这样当线程C发起事务T3给线程A所属的进程处理时，Binder驱动程序就可以沿着线程C的事务堆栈transaction_stack向下遍历，即沿着事务T2的成员变量from_parent向下遍历，最后就会发现事务T3的目标进程等于事务T1的目标进程，并且事务T1是由线程A发起来的，这时候它就知道线程A正在等待事务T3的处理结果了。</em></span></span></p><p>&nbsp;&nbsp; &nbsp; &nbsp;--------------------------</p><p>&nbsp;&nbsp; &nbsp; &nbsp;PS：结构体binder_transaction的成员变量from_parent和to_parent可以结合P256的第31行到第40行代码块以及P267的第77行到第79行的代码块来理解。这是个比较严重的技术性错误，由此造成读者的疑惑和费解，老罗先道歉了，同时，非常感谢网友@hongbog_cd指出，2012-11-14。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;9. P20，第278行代码（III）：<span style="color:#FF0000;">temp = device_create(freg_class, NULL, dev, &quot;%s&quot;, FREG_DEVICE_FILE_NAME)</span>。这个函数调用的参数写错了，不过歪打正着，能正常编译以及工作，应该将第四个参数设置为NULL，即为：<span style="color:#FF0000;">temp = device_create(freg_class, NULL, dev, NULL, &quot;%s&quot;, FREG_DEVICE_FILE_NAME)</span>。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;函数device_create的原型为：<span style="line-height: 20px; ">struct device *device_create(struct class *cls, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)</span></p><p>&nbsp;&nbsp; &nbsp; &nbsp;第四个参数drvdata表示一个私有数据，它可以为任意值或者NULL，第五个参数是一个格式化字符串，用来描述设备名称，最后是一个可变参数列表，是配合第五个参数使用的。在上述错误的调用中，参数drvdata的值等于“%s”，而参数fmt的值等于FREG_DEVICE_FILE_NAME，即“freg”。由于没有可变参数列表，并且参数fmt的值不带有%s或者%d之类的格式化符号，因此，这里设置的设备名称就等于“freg”。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;感谢网友@insoonior的指出，2012-11-14。</p><p>&nbsp;&nbsp; &nbsp; 10. P240，倒数第二段，P696，倒数第五段（III）：这个内核缓冲区的大小被Binder库设置为1016<span style="color:#FF0000;">Kb</span>、第5行代码创建的匿名共享内存块的大小就为16<span style="color:#FF0000;">Kb</span>。这两句话要表达的单位是<span style="color:#FF0000;">千字节</span>，应该使用<span style="color:#FF0000;">KB</span>来表示，<span style="color:#FF0000;">Kb</span>里面的<span style="color:#FF0000;">b</span>是<span style="color:#FF0000;">bit</span>的意思，这里使用不当。感谢网友@hongbog_cd指出，2012-11-17。</p><p><span style="color:#FF0000;">&nbsp;&nbsp; &nbsp;&nbsp;</span>11. P242，倒数第一段最后3行（III）：接下来第5行到第8行代码就会在列表mHandleToObject的<span style="color:#FF0000;">第N到第（handle+1-N）个位置</span>上分别插入一个handle_entry结构体，最后第11行就可以将与句柄值handle对应的handle_entry结构体返回给调用者。<span style="color:#FF0000;">（handle+1-N）</span>描述是要插入的handle_entry结构体的个数，因此，这句话要表达的意思其实是从第<span style="color:#FF0000;">N</span>个位置开始，插入<span style="color:#FF0000;">（handle+1-N）</span>个handle_entry结构体到列表mHandleToObject中，因此，这句话里面的<span style="color:#FF0000;">第N到第（handle+1-N）个位置</span>应该改为<span style="color:#FF0000;">第N到第handle个位置</span>。感谢网友@hongbog_cd指出，2012-11-19。</p><p>&nbsp;&nbsp; &nbsp; 12. P270，顺数第一段第2行和第3行（I）：它等同于在前面5.1.1小节中介绍的结构体<span style="color:#FF0000;">flat_binder_objec</span>。<span style="color:#FF0000;">flat_binder_objec</span>后面少了一个<span style="color:#FF0000;">t</span>，应该改为<span style="color:#FF0000;">flat_binder_object</span>。感谢网友@hongbog_cd指出，2012-11-19。</p><p>&nbsp; &nbsp; &nbsp;13. P420，第16行代码（III）：app = <span style="color:#ff0000;">new ProcessRecordLocked</span>(null, info, processName)。这里是调用成员函数<span style="color:#ff0000;">newProcessRecordLocked</span>来创建一个<span style="color:#ff0000;">ProcessRecord</span>对象，而不是直接创建一个<span style="color:#ff0000;">ProcessRecordLocked</span>对象。相应地，接下来的一段描述文字“<span style="color:#ff0000;">第16行就会根据指定的名称以及用户ID来创建一个ProcessRecordLocked对象</span>”中的<span style="color:#ff0000;">ProcessRecordLocked</span>应改为<span style="color:#ff0000;">ProcessRecord</span>。感谢网友@android迷指出，2012-12-05。</p><p>&nbsp;&nbsp; &nbsp; 14. P26，顺数第二段第2行（I）：这些动态链接库文件的<span style="color:#FF0000;">命令</span>需要符合一定的规范。这句话中的<span style="color:#FF0000;">命令</span>应该改为<span style="color:#FF0000;">命名</span>。感谢网友@迷死人的东东指出，2012-12-07。</p><p>&nbsp; &nbsp; &nbsp;15. P78，倒数第一段第1行和第2行（I）：在分析这个函数之前，我们首先介绍三个结构体变量log_main、log_events和log_radio，它们的类型均为<span style="color:#ff0000;">struct logger</span>。这句话中的<span style="color:#ff0000;">struct logger</span>应改为<span style="color:#ff0000;">struct logger_log</span>。感谢网友@迷死人的东东指出，2012-12-11。</p><p>&nbsp; &nbsp; &nbsp;16. P329，顺数第四段第2行（I）：当这些小块的内存<span style="color:#ff0000;">处理</span>解锁状态时。这句话中的<span style="color:#ff0000;">处理</span>应该改为<span style="color:#ff0000;">处于</span>。感谢网友@nanfeng5651指出，2012-12-13。</p><p>&nbsp; &nbsp; &nbsp;17.&nbsp;P497，顺数第二段第1行和第2行（I）：第8行到第28行代码在LoadedApk类的mReceivers中检查是否存在一个以<span style="color:#ff0000;">广播接收者c</span>为关键字的ReceiverDispatcher对象rd。这句话中的<span style="color:#ff0000;">广播接收者c</span>应改为为<span style="color:#ff0000;">广播接收者r</span>。感谢网友@nanfeng5651指出，2012-12-19。</p><p>&nbsp; &nbsp; &nbsp;18. P528，顺数第一段最后两行（I）：其中，前者用来描述一个<span style="color:#ff0000;">vdn.shy.luo.article</span>数据集合<span style="color:#ff0000;">；</span>即一个博客文章集合，后者用来描述一个<span style="color:#ff0000;">vdn.shy.luo.article</span>数据，即一个博客文章条目。这句话中的两个<span style="color:#ff0000;">vdn.shy.luo.article</span>应改为<span style="color:#ff0000;">vnd.shy.luo.article</span>，分号<span style="color:#ff0000;">；</span>改为逗号<span style="color:#ff0000;">，</span>。感谢网友@nanfeng5651指出，2012-12-20。</p><p>&nbsp; &nbsp; &nbsp;19. P528，倒数第一段前面两行（I）：其中，<span style="color:#ff0000;">DB_TABLE</span>和DB_VERSION用来描述这个SQLite数据库的名称和版本号。这句话中的<span style="color:#ff0000;">DB_TABLE</span>应该改为<span style="color:#ff0000;">DB_NAME</span>。感谢网友@nanfeng5651指出，2012-12-20。</p><p>&nbsp; &nbsp; &nbsp;20.&nbsp;P588，倒数第三段第1行（I）：参数<span style="color:#ff0000;">memobj</span>指向了一个Java层的Binder代理对象。这句话中的<span style="color:#ff0000;">memobj</span>应改为<span style="color:#ff0000;">memObj</span>。感谢网友@nanfeng5651指出，2012-12-24。</p><p>&nbsp; &nbsp; &nbsp;21.&nbsp;P693，倒数第二段倒数第1行和第2行（I）：将前面所创建的WindowState对象win保存在Window管理服务<span style="color:#ff0000;">Window ManagerService</span>的成员变量mWindows所描述的一个应用程序窗口列表中。这句话中的<span style="color: rgb(255, 0, 0);">Window ManagerService</span>有一个多余的空格，改为<span style="color: rgb(255, 0, 0);"><span style="color: rgb(255, 0, 0);">WindowManagerService</span></span>。感谢网友@nanfeng5651指出，2012-12-27。</p><p>&nbsp; &nbsp; &nbsp;22.&nbsp;P713，倒数第三段第1行（I）：参数<span style="color:#ff0000;">sacnKey</span>和keyCode保存的分别是当前所发生的键盘事件所对应的扫描码和键盘码。这句话中的<span style="color:#ff0000;">sacnKey</span>应改为<span style="color:#ff0000;">scanCode</span>。感谢网友@nanfeng5651指出，2012-12-28。</p><p>&nbsp; &nbsp; &nbsp;23.&nbsp;P716，顺数第四段第1行（I）：第一种情况是在将一个新发生的键盘事件添加到<span style="color:#ff0000;">待分键盘事件队列</span>之前。这句话中的<span style="color:#ff0000;">待分键盘事件队列</span>应改为<span style="color:#ff0000;">待分发键盘事件队列</span>。感谢网友@nanfeng5651指出，2012-12-28。</p><p>&nbsp; &nbsp; &nbsp;24.&nbsp;P730，倒数第四段第2行和第3行（I）：第30行代码获得它的一个引用，并且保存在变量inputHandlerObjGlobal中。这句话中的<span style="color: rgb(255, 0, 0);">inputHandlerObjGlobal</span>应改为<span style="color: rgb(255, 0, 0);">inputHandlerObjLocal</span>。感谢网友@nanfeng5651指出，2013-01-03。</p><p>&nbsp; &nbsp; &nbsp;25.&nbsp;P768，倒数第一段（II）：<span style="color:#ff0000;">HandlerThread类的成员函数quit的实现如下所示</span>。这段话描述有误，改为：<span style="color:#ff0000;">如前所示，HandlerThread类的成员函数quit首先获得前面在子线程中所创建的一个Looper对象，然后再调用这个Looper对象的成员函数quit来退出子线程。Looper类的成员函数quit的实现如下所示</span>。感谢网友@nanfeng5651指出，2013-01-04。</p><p>&nbsp; &nbsp; &nbsp;26.&nbsp;P771，倒数第五段（I）：最后，参数<span style="color:#ff0000;">workerQueue</span>和threadFactory分别用来描述一个ThreadPoolExecutor线程池的工作任务队列和线程创建工厂。这句话中的<span style="color: rgb(255, 0, 0);">workerQueue</span>应改为<span style="color: rgb(255, 0, 0);">workQueue</span>。感谢网友@nanfeng5651指出，2013-01-04。</p><p>&nbsp; &nbsp; &nbsp;27.&nbsp;P807，顺数第二段第3行和第4行（I）：在这种情况下，参数pkg所描述的一个应用程序所获得的<span style="color:#ff0000;">资源权访问权限</span>就与它所共享的Linux用户所具有的<span style="color:#ff0000;">资源权访问权限</span>相同。这句话中的<span style="color:#ff0000;">资源权访问权限</span>应改为<span style="color:#ff0000;">资源访问权限</span>。感谢网友@nanfeng5651指出，2013-01-05。</p><p>&nbsp; &nbsp; &nbsp;28.&nbsp;P812，顺数第三段第2行和第3行（I）：如果不存在，那么第22行代码就会将文件/data/system/packages.xml<span style="color:#ff0000;">重命令</span>为/data/system/packages-backup.xml。这句话中的<span style="color:#ff0000;">重命令</span>应改为<span style="color:#ff0000;">重命名</span>。感谢网友@nanfeng5651指出，2013-01-05。</p><p>&nbsp; &nbsp; &nbsp;29.&nbsp;P828，倒数第二段第1行（I）：这一步执行完成之后，<span style="color:#ff0000;">这回</span>到前面的Step 10中。这句话中的<span style="color:#ff0000;">这回</span>应改为<span style="color:#ff0000;">返回</span>。感谢网友@nanfeng5651指出，2013-01-05。</p><p><br /></p><p style="text-align: center;"><span style="color:#cc0000;"><span style="font-size:14px;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-10-26 20:44:13 <a href="http://blog.csdn.net/luoshengyang/article/details/8116866">原文链接</a>
            </div>
            <div>
            阅读：8627 评论：133 <a href="http://blog.csdn.net/luoshengyang/article/details/8116866#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android应用程序窗口（Activity）实现框架简要介绍和学习计划]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8170307</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8170307</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-11-19 0:56:14</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面我们学习了</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务的实现原理。有了这个基础之后，从本文开始，我们就可以分析</span><span style="color:black;">Android</span><span style="color:black;">系统在</span><span style="color:black;">Java</span><span style="color:black;">层的</span><span style="color:black;">UI</span><span style="color:black;">实现了。我们知道，在</span><span style="color:black;">Android</span><span style="color:black;">应用程序的四大组件中，只有</span><span style="color:black;">Activity</span><span style="color:black;">组件与</span><span style="color:black;">UI</span><span style="color:black;">相关，它描述的是应用程序窗口，因此，我们就通过它的</span><span style="color:black;">UI</span><span style="color:black;">实现来分析</span><span style="color:black;">Android</span><span style="color:black;">系统在</span><span style="color:black;">Java</span><span style="color:black;">层的</span><span style="color:black;">UI</span><span style="color:black;">实现。</span>本文主要是对<span style="color:black;">Activity</span><span style="color:black;">组件的</span><span style="color:black;">UI</span><span style="color:black;">实现作简要介绍以及制定学习计划。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<span style="color: black; ">Activity</span><span style="color: black; ">组件的</span><span style="color: black; ">UI</span><span style="color: black; ">实现需要与WindowManagerService服务和SurfaceFlinger服务进行交互。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6882903">Android应用程序键盘（Keyboard）消息处理机制分析</a>一文可以知道，Activity组件在启动完成后，会通过一个类型为Session的Binder对象来请求WindowManagerService为它创建一个类型为WindowState的对象，用来描述它的窗口状态。此外，<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">从Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>这一系列的文章又可以知道，Android应用程序会通过一个类型为Client的Binder对象来请求SurfaceFlinger服务为它创建一个类型为Layer的对象，用来描述它的窗口数据。</span></span></p><p><span style="color:black;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文又可以知道，SurfaceFlinger服务为Android应用程序创建一个类型为Layer的对象之后，会返回一个类型为SurfaceLayer的Binder对象给Android应用程序，这样Android应用程序就可以通过这个Binder对象来请求SurfaceFlinger服务来分配图形缓冲区。</span></span></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;综合上述信息，我们就可以得到A<span style="color: black; ">ctivity</span><span style="color: black; ">组件</span><span style="color: black; ">与WindowManagerService服务和SurfaceFlinger服务的交互模型，如图1所示：</span></p><p style="text-align: center;"><span style="color: black; "><img src="http://img.my.csdn.net/uploads/201211/12/1352650023_9398.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color: black; ">图1 Activity组件与WindowManagerService服务和SurfaceFlinger服务的交互模型</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;事实上，用来关联Activity组件和Layer对象的SurfaceLayer对象并不是由Android应用程序请求SurfaceFlinger服务来创建的，而是由WindowManagerService服务请求SurfaceFlinger服务来创建的。WindowManagerService服务得到这个SurfaceLayer对象之后，再将它的一个代理对象返回给在Android应用程序这一侧的Activity组件。这样，Activity组件和WindowManagerService服务就可以通过同一个SurfaceLayer对象来操作在SurfaceFlinger服务这一侧的Layer对象，而操作Layer对象的目的就是为了修改Activity组件的UI。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>和<a href="http://blog.csdn.net/luoshengyang/article/details/8010977">Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划</a>这两个系列的文章中，我们已经分析在SurfaceFlinger服务这一侧的Layer类和SurfaceLayer类的实现了。在现在的这一系列文章中，我们主要分析在Android应用程序这一侧的Activity组件与UI相关的类的实现，以及在WindowManagerService服务这一侧的WindowState类的实现。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们首先看Activity组件的实现，如图2所示：</span></p><p style="text-align: center;"><span style="color: black; "><img width="684" src="http://img.my.csdn.net/uploads/201211/11/1352647846_3903.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color: black; ">图2 Activity组件的类关系图</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Activity类是从ContextThemeWrapper类继承下来的，而ContextThemeWrapper类又是从ContextWrapper类继承下来的，最后ContextWrapper类又继承了Context类。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>一文可以知道，Activity组件在启动的过程中，系统会为它创建一个ContextImpl对象，用来描述它的运行上下文环境。这个ContextImpl对象首先是通过调用Acitivity类的成员函数attach传递到Acticity组件内部，接着再依次通过调用父类ContextThemeWrapper和ContextWrapper的成员函数attachBaseContext来分别保存在它们的成员变量mBase中。因此，ContextThemeWrapper和ContextWrapper类的成员变量mBase指向的实际上是一个ContextImpl对象。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>一文还可以知道，系统为一个正在启动的Activity组件创建了一个ContextImpl对象之后，还会调用这个ContextImpl对象的成员函数setOuterContext来将正在启动的Activity组件保存在其成员变量mOuterContext中。这样，一个Activity组件就可以通过其父类ContextThemeWrapper或者ContextWrapper的成员变量mBase来访问用来描述它的运行上下文环境的一个ContextImpl对象，同时，一个ContextImpl对象也可以通过它的成员变量mOuterContext来访问它的宿主Activity组件。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;Activity类还有另外一个类型为WindowManager的成员变量mWindowManager，它实际上指向的一个LocalWindowManager对象。LocalWindowManager类是用来管理应用程序窗口的，例如，用来维护应用程序窗口内部的视图（View）。LocalWindowManager类有一个类型为WindowManager的成员变量mWindowManager，它实际上指向的是一个WindowManagerImpl对象。系统通过调用WindowManagerImpl类的静态成员函数getDefault来获得一个WindowManagerImpl对象，然后保存在LocalWindowManager类的成员变量mWindowManager中。这样，LocalWindowManager类就可以通过WindowManagerImpl类来真正实现管理应用程序窗口的功能。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;从上面的分析中，我们还看不出的一个Activity组件的窗口是如何描述的。为了弄清楚这个问题，我们继续分析Activity类的另外一个成员变量mWindow，如图3所示：</span></p><p style="text-align: center;"><span style="color: black; "><img src="http://img.my.csdn.net/uploads/201211/29/1354201827_9391.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color: black; ">图3 Window类的实现</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Activity类的成员变量mWindow的类型为Window，它用来描述一个应用程序窗口。这样，通过这个成员变量，每一个Activity组件就都会有一个对应的Window对象，即一个对应的应用程序窗口。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Window类有一个类型为Context的成员变量mContext。这个成员变量指向的是一个Activity对象。当系统为一个Activity组件创建一个对应的Window对象时，就会将这个Activity组件的Context接口保存在这个对应的Window对象的成员变量mContext中。这样，一个Window对象就可以通过它的成员变量mContext来访问它所描述的Activity组件的资源。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Window类还有一个类型为Window.Callback的成员变量mCallback。这个成员变量和成员变量mContext一样，都是指向同一个Activity对象，因为Activity类是实现了Window.Callback接口的。当系统为一个Activity组件创建一个对应的Window对象时，就会将这个Activity组件所实现的Window.Callback接口通过Window类的成员函数setCallback保存在对应的Window对象的成员变量mCallback。这样，一个Window对象就可以通过它的成员变量mCallback来将一些事件交给与它所对应的Activity组件来处理，例如，将接收的键盘事件交给对应的Activity组件来处理。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;最后，Window类还有一个类型为WindowManager的成员变量mWindowManager。这个成员变量指向的是一个LocalWindowManager对象。前面提到，Activity组件的成员变量mWindowManager指向的也是一个LocalWindowManager对象。系统在启动一个Activity组件的过程中，会通过Window类的成员函数setWindowManager来将保存在它的成员变量mWindowManager中的一个LocalWindowManager对象也保存在对应的Window对象的成员变量mWindowManager。这样，一个Activity组件以及它所对应的Window对象就可以使用同一个LocalWindowManager对象来管理它们所描述的UI了。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 事实上，Activity类的成员变量mWindow指向的并不是一个Window对象，而是一个PhoneWindow对象。也就是说，一个Activity组件的UI是使用一个PhoneWindow对象来描述的。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;Activity类的成员变量mWindow所指向的一个PhoneWindow对象是通过调用PolicyManager类的静态成员函数makeNewWindow来创建的。PolicyManager类的实现如图4所示：</span></p><p style="text-align: center;"><span style="color: black; "><img src="http://img.my.csdn.net/uploads/201211/13/1352737483_1274.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color: black; ">图4&nbsp;PolicyManager类的实现</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;PolicyManager类有一个类型为IPolicy的静态成员变量sPolicy，它实际指向的是一个Policy对象。Policy类实现了IPolicy接口的成员函数makeNewWindow，而PolicyManager类就是通过这个成员函数来为一个Activity组件创建一个PhoneWindow对象的。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; PhoneWindow类继承了Window类，因此，它的对象可以保存Activity类的成员变量mWindow中。PhoneWindow类的实现如图5所示：</span></p><p style="text-align: center;"><span style="color: black; "><img src="http://img.my.csdn.net/uploads/201211/13/1352736693_6736.jpg" alt="" /><br /></span></p><p style="text-align: center;">图5 PhoneWindow类的实现</p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;PhoneWindow类有两个重要的成员变量mDecor和mContentParent，它们的类型分别DecorView和ViewGroup。其中，成员变量mDecor是用描述自己的窗口视图，而成员变量mContentParent用来描述父窗口视图。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DecorView类继承了FrameLayout类，而FrameLayout类又继承了ViewGroup类，最后ViewGroup类又继承了View类。View类有一个成员函数draw，它是用来绘制应用程序窗口的UI的。DecorView类、FrameLayout类和ViewGroup类都重写了父类的成员函数draw，这样，它们就都可以定制自己的UI。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DecorView类所描述的应用程序窗口视图是否需要重新绘制是由另外一个类ViewRoot来控制的。系统在启动一个Activity组件的过程中，会为这个Activity组件创建一个ViewRoot对象，同时还会将前面为这个Activity组件所创建的一个PhoneWindow对象的成员变量mDecor所描述的一个视图（DecorView）保存在这个ViewRoot对象的成员变量mView中。这样，这个ViewRoot对象就可以通过调用它的成员变量mView的所描述的一个DecorView的成员函数draw来绘制一个Acitivity组件的UI了。ViewRoot类的作用是非常大的，它除了用来控制一个Acitivity组件的UI绘制之外，还负责接收Acitivity组件的IO输入事件，例如，键盘事件，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/6882903">Android应用程序键盘（Keyboard）消息处理机制分析</a>一文。</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的实现如图6所示：</span></p><p style="text-align: center;"><span style="color: black; "><img width="684" src="http://img.my.csdn.net/uploads/201211/17/1353087703_2343.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color: black; ">图6 ViewRoot类的实现</span></p><p><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类是从Handler类继承下来的。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6817933">Android应用程序消息处理机制（Looper、Handler）分析</a>一文可以知道，从Handler类继承下来的子类可以调用父类的成员函数sendMessage来向指定的线程的消息队列发送消息，以及在自己重写的成员函数handleMessage中处理该消息。&nbsp;ViewRoot类在两种情况需要经常应用程序进程的主线程的消息队列发送消息。</span></p><p><span style="color: black; "></span>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第一种情况是当ViewRoot类从系统输入管理器InputManager接收到键盘、触摸屏等输入事件时，它就会把这些输入事件封装成一个消息，并且发送到应用程序进程的主线程的消息队列中去进一步处理，这样就可以保证键盘、触摸屏等输入事件可以在应用程序进程的主线程中进行处理。这一点可以参考前面A<a href="http://blog.csdn.net/luoshengyang/article/details/6882903">ndroid应用程序键盘（Keyboard）消息处理机制分析</a>一文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第二种情况是当ViewRoot类需要重新绘制与它所关联的一个Activity组件的UI时，它就会将这个绘制UI的操作封装成一个消息，并且发送到应用程序进程的主线程的消息队列中去进一步处理，这样同样可以保证绘制UI的操作可以在应用程序进程的主线程中执行。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;每一个ViewRoot对象都有一个类型为View的成员变量mView，它指向了一个DecorView对象。这个DecorView对象是从哪里来的呢？前面提到，每一个Activity组件都有一个对应的ViewRoot对象以及一个对应的PhoneWindow对象，这个DecorView对象就是来自于这个对应的PhoneWindow对象的成员变量mDecor。也就是说，与同一个Activity组件对应的ViewRoot对象和PhoneWindow对象分别通过各自的成员变量mView和mDecor引用了共一个DecorView对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;每一个ViewRoot对象都有一个类型为WindowManager.LayoutParams的成员变量mWindowAttributes，它指向了一个ViewGroup.LayoutParams对象，用来描述与该ViewRoot对象对应的一个Activity组件的UI布局信息。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从上面的描述就可以知道，每一个Activity组件都有一个对应的ViewRoot对象、View对象以及WindowManager.LayoutParams对象。这三个对象的对应关系是由WindowManagerImpl类来维护的。具体来说，就是由WindowManagerImpl类的成员变量mRoots、mViews和mParams所描述的三个数组来维护的。例如，假设一个应用程序进程运行有两个Activity组件，那么WindowManagerImpl类的成员变量mRoots、mViews和mParams所描述的三个数组的大小就等于2，其中，mRoots[0]、mViews[0]和mParams[0]对应于第一个启动的Activity组件，而mRoots[1]、mViews[1]和mParams[1]对应于第二个启动的Activity组件。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;每一个ViewRoot对象都有一个类型为Surface的成员变量mSurface，它指向了一个Java层的Surface对象。这个Java层的Surface对象通过它的成员变量mNativeSurface与一个C++层的Surface对象。这个C++层的Surface对象就是我们在<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>这一系列文章中所分析的Surface类的实例了。这个Surface类是用来在Android应用程序进程这一侧描述应用程序窗口的。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文可以知道，在C++层中，每一个Surface对象都有一个对应的SurfaceControl对象。这个对应的SurfaceControl对象是用来设置应用程序窗口的属性，例如，设置大小、位置等属性。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;但是，与ViewRoot类的成员变量mSurface所对应的在C++层的Surface对象并没有一个对应的SurfaceControl对象，这是因为ViewRoot类并不需要设置应用程序窗口的属性，它需要做的只是往应用程序窗口的图形缓冲区填充UI数据，即它需要设置的只是应用程序窗口的纹理。应用程序窗口的纹理保存在Java层的Surface类的成员变量mCanvas所描述一个画布（Canvas）中，即通过这个画布可以访问到应用程序窗口的图形缓冲区。当ViewRoot类需要重新绘制与它对应的Activity组件的UI时，它就会调用它的成员函数draw来执行这个绘制的操作。ViewRoot类的成员函数draw首先通过获得保存它的成员变量mSurface内部的一块画布，然后再将这个画布传递给它的成员变量mView所描述的一个View对象的成员函数draw。View类的成员函数draw得到了这块画布之后，就可以随心所欲地上面绘制应用程序窗口的纹理了。这些纹理的绘制工作是通过Skia图形库API来进行的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;那么，应用程序窗口的属性是由谁来管理的呢？这是由WindowManagerService服务来管理的。前面提到，在Android应用程序这一侧的Activity组件是由WindowManagerService服务来为它请求SurfaceFlinger服务创建一个Layer对象以及一个SurfaceLayer对象的。这个SurfaceLayer对象创建完成之后，WindowManagerService服务就会将它封装在一个Java层的Surface对象中，以后就可以通过这个Java层的Surface对象来请求SurfaceFlinger服务设置一个对应的应用程序窗口的属性。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;由于Java层的Surface对象实现了Parcelable接口，因此，WindowManagerService服务在为一个Activity组件请求SurfaceFlinger服务创建一个Layer对象以及一个SurfaceLayer对象之后，就可以将得到的Java层的Surface对象跨进程地返回给该Activity组件。Activity组件得到这个Surface对象之后，再使用保存在里面的SurfaceLayer对象来初始化与它所对应的一个ViewRoot对象的成员变量mSurface所描述的一个Java层的Surface对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;那么，WindowManagerService服务又是什么时候会为一个Activity组件请求SurfaceFlinger服务创建一个Layer对象以及一个SurfaceLayer对象呢？ViewRoot类有一个类型为IWindowSession的静态成员变量sWindowSession，它指向的实际上是一个实现了IWindowSession接口的Binder对象。这个Binder对象的类型为Session，运行在WindowManagerService服务这一侧。当一个Activity组件的UI第一次要被绘制之前，它所运行在的应用程序进程就会通过ViewRoot类的静态成员变量sWindowSession来向WindowManagerService服务发送一个请求。WindowManagerService服务接收到这个请求之后，再请求SurfaceFlinger服务为这个Activity组件创建一个Layer对象以及一个SurfaceLayer对象。这样，这个Activity组件的UI才能真正地绘制在屏幕中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;至此，我们就简要分析完成了在Android应用程序这一侧的Activity组件与UI相关的类的实现，接下来我们继续分析在WindowManagerService服务这一侧的WindowState类的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;WindowState类的实现如图7所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201211/17/1353087795_6634.jpg" alt="" /><br /></p><p style="text-align: center;">图7 WindowState类的实现</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在Android应用程序这一侧，每一个Activity组件在WindowManagerService服务这一侧都有一个对应的WindowState对象，用来描述Activity组件的窗口状态。WindowState类有两个重要的成员变量mSession和mSurface，它们的类型分别为SurfaceSession和Surface。接下来，我们就描述这两个成员变量的作用。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;前面提到，Activity组件是在启动完成之后，请求WindowManagerService服务为它创建一个WindowState对象的。创建完成这个WindowState对象之后，WindowManagerService服务再调用它的成员函数attach来为它附加一个SurfaceSession对象。WindowState类的成员函数attach又是通过调用它的成员变量mSession所描述的一个Session对象的成员函数windowAddedLocked来附加一个SurfaceSession对象的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Session类有一个类型为SurfaceSession的成员变量mSurfaceSession。当WindowState类的成员函数attach调用Session类的成员函数windowAddedLocked来为一个WindowState对象附加一个SurfaceSession对象的时候，后者首先会检查它的成员变量mSurfaceSession是否已经指向了一个SurfaceSession对象。如果如果指向了的话，那么Session类的成员函数windowAddedLocked就什么也不用做，否则的话，Session类的成员函数windowAddedLocked就会创建一个SurfaceSession对象，并且保存在它的成员变量mSurfaceSession中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;SurfaceSession类有一个类型为int的成员变量mClient，它保存的是一个C++层的SurfaceComposerClient对象的地址，即每一个Java层的SurfaceSession对象在C++层都有一个对应的SurfaceComposerClient对象。当一个SurfaceSession对象创建的时候，与它所关联的SurfaceComposerClient对象也会同时被创建。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7857163">Android应用程序与SurfaceFlinger服务的连接过程分析</a>一文可以知道，SurfaceComposerClient类用来描述Android应用程序进程与SurfaceFlinger服务之间的一个连接，即每一个与UI相关的Android应用程序进程都有一个SurfaceComposerClient对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;读者可能会觉得奇怪，既然SurfaceComposerClient是用来描述Android应用程序进程与SurfaceFlinger服务的连接的，那么为什么WindowManagerService服务会在内部创建SurfaceComposerClient对象呢？由于WindowManagerService需要请求SurfaceFlinger服务来设置Android应用程序窗口的属性，例如，设置应用程序窗口的位置、大小等，因此，它就需要为每一个Android应用程序进程创建一个SurfaceComposerClient对象连接到SurfaceFlinger服务中去，以便可以和SurfaceFlinger服务进行通信。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从上面的描述我们就可以知道，在WindowManagerService服务中，每一个Android应用程序进程都对应有一个SurfaceComposerClient对象。由于每一个SurfaceComposerClient对象都关联有一个SurfaceSession对象，因此，我们又可以推断出每一个Android应用程序进程在WindowManagerService服务中都对应有一个SurfaceSession对象。由于每一个SurfaceSession对象所属的Session对象是一个Binder本地对象，并且它的Binder代理对象是保存在Android应用程序进程这一侧的ViewRoot类的静态成员变量sWindowSession中，因此，我们又可以推断出每一个Android应用程序进程在WindowManagerService服务都有一个对应的Session对象。综合起来就是，每一个Android应用程序进程在WindowManagerService服务这一侧对应有一个Session对象、一个SurfaceSession对象以及一个SurfaceComposerClient对象。由于每一个Android应用程序进程都可以运行若干个Activity组件，因此，我们又可以说，Activity组件与WindowServiceManager服务这一侧的Session对象、SurfaceSession对象以及SurfaceComposerClient对象是多对一的关系。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;介绍了WindowState类的成员变量mSession之后，我们接着介绍另外一个成员变量mSurface，它的类型为Surface，前面我们已经介绍过Surface类在Android应用程序进程这一侧的作用了，接下来我们就介绍它在WindowManagerService这一侧的作用。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 前面提到，WindowManagerService服务会在内部为每一个应用程序窗口，即每一个Activity组件，创建一个SurfaceLayer对象，这个SurfaceLayer对象是封装成一个Java层的Surface对象中的。在Java层的Surface类中，有一个类型为int的成员变量mSurfaceControl，它保存的是在C++层的一个SurfaceControl对象的地址值，即在WindowManagerService服务这一侧，每一个Java层的Surface对象在 C++层都有一个对应的SurfaceControl对象。这里我们强调是在WindowManagerService服务这一侧，是因为在前面提到，在Android应用程序这一侧，每一个Activity组件所对应的Java层的Surface对象在C++层是没有一个对应的SurfaceControl对象，而只是对应有一个C++层的Surface对象。通过C++层的SurfaceControl对象可以设置应用程序窗口的属性，而通过C++层的Surface对象则可以设置应用程序窗口的图形缓冲区，即设置应用程序窗口的纹理，因此，我们就可以知道应用程序窗口的属性是由WindowManagerService服务来设置的，而应用程序窗口的纹理是由它所在的进程负责设置的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就简要地介绍了Android应用程序窗口的实现框架了。上面所介绍的类及其交互关系可能会比较模糊，不易理解。不要紧，接下来我们会通过一系列的文章来弄清楚它们的来龙去脉：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. <a href="http://blog.csdn.net/luoshengyang/article/details/8201936">Android应用程序窗口的运行上下文的创建过程，即创建ContextImpl的创建过程</a>；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. <a href="http://blog.csdn.net/luoshengyang/article/details/8223770">Android应用程序窗口的创建过程，即PhoneWindow的创建过程</a>；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 3.&nbsp;<a href="http://blog.csdn.net/luoshengyang/article/details/8245546">Android应用程序窗口的视图的创建过程，即DecorView的创建过程</a>；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 4. <a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口与WindowManagerService服务的连接过程，即WindowState的创建过程</a>；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 5. <a href="http://blog.csdn.net/luoshengyang/article/details/8303098">Android应用程序窗口与SurfaceFlinger服务的连接过程，即Surface的创建过程；</a></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 6. <a href="http://blog.csdn.net/luoshengyang/article/details/8372924">Android应用程序窗口的绘制过程，即Surface的渲染过程；</a></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 学习了这些文章，我们就可以掌握Android应用程序窗口的实现框架了。掌握了Android应用程序窗口的实现框架之后，我们就可以再进一步去详细地学习Android应用程序窗口的渲染过程。敬请关注！</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-11-19 0:56:14 <a href="http://blog.csdn.net/luoshengyang/article/details/8170307">原文链接</a>
            </div>
            <div>
            阅读：8751 评论：30 <a href="http://blog.csdn.net/luoshengyang/article/details/8170307#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android应用程序窗口（Activity）的运行上下文环境（Context）的创建过程分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8201936</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8201936</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-11-26 0:55:58</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前文中，我们简要介绍了</span><span style="color:black;">Android</span><span style="color:black;">应用程序窗口的框架。</span><span style="color:black;">Android</span><span style="color:black;">应用程序窗口在运行的过程中，需要访问一些特定的资源或者类。这些特定的资源或者类构成了</span><span style="color:black;">Android</span><span style="color:black;">应用程序的运行上下文环境，</span><span style="color:black;">Android</span><span style="color:black;">应用程序窗口可以通过一个</span><span style="color:black;">Context</span><span style="color:black;">接口来访问它，这个</span><span style="color:black;">Context</span><span style="color:black;">接口也是我们在开发应用程序时经常碰到的。在本文中，我们就将详细分析</span><span style="color:black;">Android</span><span style="color:black;">应用程序窗口的运行上下文环境的创建过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文中提到，Android应用程序窗口的运行上下文环境是通过ContextImpl类来描述的，即每一个Activity组件都关联有一个ContextImpl对象。ContextImpl类继承了Context类，它与Activity组件的关系如图1所示：</span></p><p style="text-align: center;"><span style="color:black;"><img src="http://img.my.csdn.net/uploads/201211/20/1353422798_8383.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color:black;">图1 ContextImpl类与Activity类的关系图</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个类图在设计模式里面就可以称为装饰模式。Activity组件通过其父类ContextThemeWrapper和ContextWrapper的成员变量mBase来引用了一个ContextImpl对象，这样，Activity组件以后就可以通过这个ContextImpl对象来执行一些具体的操作，例如，<a href="http://blog.csdn.net/luoshengyang/article/details/6677029">启动Service组件</a>、<a href="http://blog.csdn.net/luoshengyang/article/details/6737352">注册广播接收者</a>和<a href="http://blog.csdn.net/luoshengyang/article/details/6963418">启动Content Provider组件</a>等操作。同时，ContextImpl类又通过自己的成员变量mOuterContext来引用了与它关联的一个Activity组件，这样，ContextImpl类也可以将一些操作转发给Activity组件来处理。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面<a href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>一文中，我们已经详细分析过一个Activity组件的启动过程了。在这个启动过程中，最后一步便是通过ActivityThread类的成员函数performLaunchActivity在应用程序进程中创建一个Activity实例，并且为它设置运行上下文环境，即为它创建一个ContextImpl对象。接下来，我们就从ActivityThread类的成员函数performLaunchActivity开始，分析一个Activity实例的创建过程，以便可以从中了解它的运行上下文环境的创建过程，如图2所示：</span></p><p style="text-align: center;"><img width="698" src="http://img.my.csdn.net/uploads/201211/22/1353597670_7506.jpg" alt="" /><br /></p><p style="text-align: center;"><span style="color:black;"></span>图2 Android应用程序窗口的运行上下文环境的创建过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程一共分为10个步骤，接下来我们就详细分析每一个步骤。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. ActivityThread.performLaunchActivity</p><p></p><pre name="code" class="java">public final class ActivityThread {
    ......
  
    Instrumentation mInstrumentation;
    ......

    private final Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        ......

        ComponentName component = r.intent.getComponent();
        ......

        Activity activity = null;
        try {
            java.lang.ClassLoader cl = r.packageInfo.getClassLoader();
            activity = mInstrumentation.newActivity(
                    cl, component.getClassName(), r.intent);
            ......
        } catch (Exception e) {
            ......
        }

        try {
            Application app = r.packageInfo.makeApplication(false, mInstrumentation);
            ......

            if (activity != null) {
                ContextImpl appContext = new ContextImpl();
                ......
                appContext.setOuterContext(activity);
                ......
                Configuration config = new Configuration(mConfiguration);
                ......

                activity.attach(appContext, this, getInstrumentation(), r.token,
                        r.ident, app, r.intent, r.activityInfo, title, r.parent,
                        r.embeddedID, r.lastNonConfigurationInstance,
                        r.lastNonConfigurationChildInstances, config);
                ......

                mInstrumentation.callActivityOnCreate(activity, r.state);

                ......  
            }

            ......
        } catch (SuperNotCalledException e) {
            ......
        } catch (Exception e) {
            ......
        }

        return activity;
    }
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/ActivityThread.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;要启动的Activity组件的类名保存在变量component。有了这个类名之后，函数就可以调用ActivityThread类的成员变量mInstrumentation所描述一个Instrumentation对象的成员函数newActivity来创建一个Activity组件实例了，并且保存变量activity中。Instrumentation类是用来记录应用程序与系统的交互过程的，在接下来的Step 2中，我们再分析它的成员函数newActivity的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 创建好了要启动的Activity组件实例之后，函数接下来就可以对它进行初始化了。初始化一个Activity组件实例需要一个Application对象app、一个ContextImpl对象appContext以及一个Configuration对象config，它们分别用来描述该Activity组件实例的应用程序信息、运行上下文环境以及配置信息。这里我们主要关心运行上下文环境的创建过程，即ContextImpl对象appContext的创建过程，这个过程我们在接下来的Step 4中再分析。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; ContextImpl对象appContext创建完成之后，函数就会调用它的成员函数setOuterContext来将与它所关联的Activity组件实例activity保存在它的内部。这样，ContextImpl对象appContext以后就可以访问与它所关联的Activity组件的属性或者方法。在接下来的Step 5中，我们再分析ContextImpl类的成员函数setOuterContext的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接着，函数就调用Activity组件实例activity的成员函数attach来将前面所创建的ContextImpl对象appContext以及Application对象app和Configuration对象config保存在它的内部。这样，Activity组件实例activity就可以访问它的运行上下文环境信息了。在接下来的Step 6中，我们再分析Activity类的成员函数attach的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 最后，函数又通过调用ActivityThread类的成员变量mInstrumentation所描述一个Instrumentation对象的成员函数callActivityOnCreate来通知Activity组件实例activity，它已经被创建和启动起来了。在接下来的Step 9中，我们再分析它的成员函数callActivityOnCreate的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就分别分析Instrumentation类的成员函数newActivity、ContextImpl类的构造函数以及成员函数setOuterContext、Activity类的成员函数attach和Instrumentation类的成员函数callActivityOnCreate的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 2.&nbsp;Instrumentation.newActivity</p><p></p><pre name="code" class="java">public class Instrumentation {
    ......

    public Activity newActivity(ClassLoader cl, String className,
            Intent intent)
            throws InstantiationException, IllegalAccessException,
            ClassNotFoundException {
        return (Activity)cl.loadClass(className).newInstance();
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/Instrumentation.java中。<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数cl描述的是一个类加载器，而参数className描述的要加载的类。以className为参数来调用cl描述的是一个类加载器的成员函数loadClass，就可以得到一个Class对象。由于className描述的是一个Activity子类，因此，当函数调用前面得到的Class对象的成员函数newInstance的时候，就会创建一个Activity子类实例。这个Activity实例就是用来描述在前面Step 1中所要启动的Activity组件的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Activity子类实例在创建的过程，会调用父类Activity的默认构造函数，以便可以完成Activity组件的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 3. new Activity</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Activity类定义在文件frameworks/base/core/java/android/app/Activity.java中，它没有定义自己的构造函数，因此，系统就会为它提供一个默认的构造函数。一般来说，一个类的构造函数是用来初始化该类的实例的，但是，系统为Activity类提供的默认构造函数什么也不做，也就是说，Activity类实例在创建的时候，还没有执行实质的初始化工作。这个初始化工作要等到Activity类的成员函数attach被调用的时候才会执行。在后面的Step 6中，我们就会看到Activity类的成员函数attach是如何初始化一个Activity类实例的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;这一步执行完成之后，回到前面的Step 1中，即ActivityThread类的成员函数performLaunchActivity中，接下来就会调用ContextImpl类的构造函数来创建一个ContextImpl对象，以便可以用来描述正在启动的Activity组件的运行上下文信息。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 4. new ContextImpl</p><p></p><pre name="code" class="java">class ContextImpl extends Context {
    ......

    private Context mOuterContext;
    ......

    ContextImpl() {
        // For debug only
        //++sInstanceCount;
        mOuterContext = this;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/app/ContextImpl.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; ContextImpl类的成员变量mOuterContext的类型为Context。当一个ContextImpl对象是用来描述一个Activity组件的运行上下文环境时，那么它的成员变量mOuterContext指向的就是该Activity组件。由于一个ContextImpl对象在创建的时候，并没有参数用来指明它是用来描述一个Activity组件的运行上下文环境，因此，这里就暂时将它的成员变量mOuterContext指向它自己。在接下来的Step 5中，我们就会看到，一个ContextImpl对象所关联的一个Activity组件是通过调用ContextImpl类的成员函数setOuterContext来设置的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;这一步执行完成之后，回到前面的Step 1中，即ActivityThread类的成员函数performLaunchActivity中，接下来就会调用ContextImpl类的成员函数setOuterContext来设置前面所创建一个ContextImpl对象所关联的一个Activity组件，即正在启动的Activity组件。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 5.&nbsp;ContextImpl.setOuterContext</p><p></p><pre name="code" class="java">class ContextImpl extends Context {
    ......

    private Context mOuterContext;
    ......

    final void setOuterContext(Context context) {
        mOuterContext = context;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/core/java/android/app/ContextImpl.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 参数context描述的是一个正在启动的Activity组件，ContextImpl类的成员函数setOuterContext只是简单地将它保存在成员变量mContext中，以表明当前正在处理的一个ContextImpl对象是用来描述一个Activity组件的运行上下文环境的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这一步执行完成之后，回到前面的Step 1中，即ActivityThread类的成员函数performLaunchActivity中，接下来就会调用Activity类的成员函数attach来初始化正在启动的Activity组件，其中，就包括设置正在启动的Activity组件的运行上下文环境。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 6. Activity.attach</p><p></p><pre name="code" class="java">public class Activity extends ContextThemeWrapper
        implements LayoutInflater.Factory,
        Window.Callback, KeyEvent.Callback,
        OnCreateContextMenuListener, ComponentCallbacks {
    ......

    private Application mApplication;
    ......

    /*package*/ Configuration mCurrentConfig;
    ......

    private Window mWindow;

    private WindowManager mWindowManager;
    ......

    final void attach(Context context, ActivityThread aThread,
            Instrumentation instr, IBinder token, int ident,
            Application application, Intent intent, ActivityInfo info,
            CharSequence title, Activity parent, String id,
            Object lastNonConfigurationInstance,
            HashMap&lt;String,Object&gt; lastNonConfigurationChildInstances,
            Configuration config) {
        attachBaseContext(context);

        mWindow = PolicyManager.makeNewWindow(this);
        mWindow.setCallback(this);
        if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
            mWindow.setSoftInputMode(info.softInputMode);
        }
        ......

        mApplication = application;
        ......

        mWindow.setWindowManager(null, mToken, mComponent.flattenToString());
        ......

        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;
    }

    ......
}</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/Activity.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数首先调用从父类ContextThemeWrapper继承下来的成员函数attachBaseConext来设置运行上下文环境，即将参数context所描述的一个ContextImpl对象保存在内部。在接下来的Step 7中，我们再分析ContextThemeWrapper类的成员函数attachBaseConext的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数接下来调用PolicyManager类的静态成员函数makeNewWindow来创建了一个PhoneWindow，并且保存在Activity类的成员变量mWindow中。这个PhoneWindow是用来描述当前正在启动的应用程序窗口的。这个应用程序窗口在运行的过程中，会接收到一些事件，例如，键盘、触摸屏事件等，这些事件需要转发给与它所关联的Activity组件处理，这个转发操作是通过一个Window.Callback接口来实现的。由于Activity类实现了Window.Callback接口，因此，函数就可以将当前正在启动的Activity组件所实现的一个Window.Callback接口设置到前面创建的一个PhoneWindow里面去，这是通过调用Window类的成员函数setCallback来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 参数info指向的是一个ActivityInfo对象，用来描述当前正在启动的Activity组件的信息。其中，这个ActivityInfo对象的成员变量softInputMode用来描述当前正在启动的一个Activity组件是否接受软键盘输入。如果接受的话，那么它的值就不等于WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED，并且描述的是当前正在启动的Activity组件所接受的软键盘输入模式。这个软键盘输入模式设置到前面所创建的一个PhoneWindow对象内部去，这是通过调用Window类的成员函数setSoftInputMode来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在Android系统中，每一个应用程序窗口都需要由一个窗口管理者来管理，因此，函数再接下来就会调用前面所创建的一个PhoneWindow对象从父类Window继承下来的成员函数setWindowManager来为它设置一个合适的窗口管理者。这个窗口管理者设置完成之后，就可以通过调用Window类的成员函数getWindowManager来获得。获得这个窗口管理者之后，函数就将它保存在Activity类的成员变量mWindowManager中。这样，当前正在启动的Activity组件以后就可以通过它的成员变量mWindowManager来管理与它所关联的窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 除了创建和初始化一个PhoneWindow之外，函数还会分别把参数application和config所描述的一个Application对象和一个Configuration对象保存在Activity类的成员变量mApplication和mCurrentConfig中。这样，当前正在启动的Activity组件就可以访问它的应用程序信息以及配置信息。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;在接下来的一篇文章中，我们再详细分析PolicyManager类的静态成员函数makeNewWindow，以及Window类的成员函数setCallback、setSoftInputMode和setWindowManager的实现，以便可以了解应用程序窗口的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们继续分析ContextThemeWrapper类的成员函数attachBaseConext的实现，以便可以继续了解一个应用程序窗口的运行上下文环境的设置过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 7.&nbsp;ContextThemeWrapper.attachBaseConext</p><p></p><pre name="code" class="java">public class ContextThemeWrapper extends ContextWrapper {
    private Context mBase;
    ......

    @Override protected void attachBaseContext(Context newBase) {
        super.attachBaseContext(newBase);
        mBase = newBase;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ContextThemeWrapper.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ContextThemeWrapper类用来维护一个应用程序窗口的主题，而用来描述这个应用程序窗口的运行上下文环境的一个ContextImpl对象就保存在ContextThemeWrapper类的成员函数mBase中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ContextThemeWrapper类的成员函数attachBaseConext的实现很简单，它首先调用父类ContextWrapper的成员函数attachBaseConext来将参数newBase所描述的一个ContextImpl对象保存到父类ContextWrapper中去，接着再将这个ContextImpl对象保存在ContextThemeWrapper类的成员变量mBase中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析ContextWrapper类的成员函数attachBaseConext的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 8.&nbsp;ContextWrapper.attachBaseConext</p><p></p><pre name="code" class="java">public class ContextWrapper extends Context {
    Context mBase;
    ......

    protected void attachBaseContext(Context base) {
        if (mBase != null) {
            throw new IllegalStateException(&quot;Base context already set&quot;);
        }
        mBase = base;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/content/ContextWrapper.java&nbsp;中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ContextWrapper类只是一个代理类，它只是简单地封装了对其成员变量mBase所描述的一个Context对象的操作。ContextWrapper类的成员函数attachBaseConext的实现很简单，它只是将参数base所描述的一个ContextImpl对象保存在成员变量mBase中。这样，ContextWrapper类就可以将它的功能交给ContextImpl类来具体实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步执行完成之后，当前正在启动的Activity组件的运行上下文环境就设置完成了，回到前面的Step 1中，即ActivityThread类的成员函数performLaunchActivity中，接下来就会调用Instrumentation类的成员函数callActivityOnCreate来通知当前正在启动的Activity组件，它已经创建和启动完成了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 9.&nbsp;Instrumentation.callActivityOnCreate</p><p></p><pre name="code" class="java">public class Instrumentation {
    ......

    public void callActivityOnCreate(Activity activity, Bundle icicle) {
        ......

        activity.onCreate(icicle);

        ......
    }
 
    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/app/Instrumentation.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数主要就是调用当前正在启动的Activity组件的成员函数onCreate，用来通知它已经成功地创建和启动完成了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 10. Activity.onCreate</p><p></p><pre name="code" class="java">public class Activity extends ContextThemeWrapper
        implements LayoutInflater.Factory,
        Window.Callback, KeyEvent.Callback,
        OnCreateContextMenuListener, ComponentCallbacks {
    ......

    boolean mCalled;
    ......

    /*package*/ boolean mVisibleFromClient = true;
    ......    

    protected void onCreate(Bundle savedInstanceState) {
        mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(
                com.android.internal.R.styleable.Window_windowNoDisplay, false);
        mCalled = true;
    }
 
    ......
}</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/app/Activity.java中。<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 一般来说，我们都是通过定义一个Activity子类来实现一个Activity组件的。重写父类Activity的某些成员函数的时候，必须要回调父类Activity的这些成员函数。例如，当Activity子类在重写父类Activity的成员函数onCreate时，就必须回调父类Activity的成员函数onCreate。这些成员函数被回调了之后，Activity类就会将其成员变量mCalled的值设置为true。这样，Activity类就可以通过其成员变量mCalled来检查其子类在重写它的某些成员函数时，是否正确地回调了父类的这些成员函数。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;Activity类的另外一个成员变量mVisibleFromClient用来描述一个应用程序窗口是否是可见的。如果是可见的，那么它的值就会等于true。当Activity类的成员函数onCreate被其子类回调时，它就会检查对应的应用程序窗口的主题属性android:windowNoDisplay的值是否等于true。如果等于true的话，那么就说明当前所启动的应用程序窗口是不可见的，这时候Activity类的成员变量mVisibleFromClient的值就会被设置为false，否则的话，就会被设置为true。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Activity子类在重写成员函数onCreate的时候，一般都会调用父类Activity的成员函数setContentView来为为当前正启动的应用程序窗口创建视图（View）。在接下来的文章中，我们再详细描述应用程序窗口的视图的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;至此，一个Activity组件的创建过程，以及它的运行上下文环境的创建过程，就分析完成了。这个过程比较简单，我们是从中获得以下三点信息：</p><p>&nbsp;&nbsp; &nbsp; &nbsp;1. 一个Android应用窗口的运行上下文环境是使用一个ContextImpl对象来描述的，这个ContextImpl对象会分别保存在Activity类的父类ContextThemeWrapper和ContextWrapper的成员变量mBase中，即ContextThemeWrapper类和ContextWrapper类的成员变量mBase指向的是一个ContextImpl对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;2.&nbsp;Activity组件在创建过程中，即在它的成员函数attach被调用的时候，会创建一个PhoneWindow对象，并且保存在成员变量mWindow中，用来描述一个具体的Android应用程序窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;3. &nbsp;Activity组件在创建的最后，即在它的子类所重写的成员函数onCreate中，会调用父类Activity的成员函数setContentView来创建一个Android应用程序窗口的视图。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;在接下来的两篇文章中，我们就将会详细描述Android应用程序窗口以及它的视图的创建过程，敬请关注！</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span></p>
            <div>
                作者：Luoshengyang 发表于2012-11-26 0:55:58 <a href="http://blog.csdn.net/luoshengyang/article/details/8201936">原文链接</a>
            </div>
            <div>
            阅读：5474 评论：18 <a href="http://blog.csdn.net/luoshengyang/article/details/8201936#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android应用程序窗口（Activity）的窗口对象（Window）的创建过程分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8223770</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8223770</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-12-3 0:55:54</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 在前文中，我们分析了</span><span style="color:black;">Android</span><span style="color:black;">应用程序窗口的运行上下文环境的创建过程。由此可知，每一个</span><span style="color:black;">Activity</span><span style="color:black;">组件都有一个关联的</span><span style="color:black;">ContextImpl</span><span style="color:black;">对象，同时，它还关联有一个</span><span style="color:black;">Window</span><span style="color:black;">对象，用来描述一个具体的应用程序窗口。由此又可知，</span><span style="color:black;">Activity</span><span style="color:black;">只不过是一个高度抽象的</span><span style="color:black;">UI</span><span style="color:black;">组件，它的具体</span><span style="color:black;">UI</span><span style="color:black;">实现其实是由其它的一系列对象来实现的。在本文中，我们就将详细分析</span><span style="color:black;">Android</span><span style="color:black;">应用程序窗口对象的创建过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文可以知道，在PHONE平台上，与Activity组件所关联的窗口对象的实际类型为PhoneWindow，后者是从Window类继承下来的。Activity、Window和PhoneWindow三个类的关系可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文中的图3和图5。为了方便接下来描述类型为PhoneWindow的应用程序窗口的创建过程，我们将这两个图拿过来，如以下的图1和图2所示：</span></p><p style="text-align: center;"><span style="color: black; "><img src="http://img.my.csdn.net/uploads/201211/29/1354201827_9391.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color: black; ">图1 Activity和Window的类关系图</span></p><p style="text-align: center;"><span style="color: black; "><img src="http://img.my.csdn.net/uploads/201211/13/1352736693_6736.jpg" alt="" /><br /></span></p><p style="text-align: center;">图2 Window和PhoneWindow的类关系图</p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 上述两个图中所涉及到的类的描述可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文，本文主要从<span style="color: black; ">Android</span><span style="color: black; ">应用程序窗口的创建过程来</span>理解Activity、Window和PhoneWindow三个类的关系。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 从<a href="http://blog.csdn.net/luoshengyang/article/details/8201936">Android应用程序窗口（Activity）的运行上下文环境（Context）的创建过程分析</a>一文又可以知道，与Activity组件所关联的一个PhoneWindow对象是从Activity类的成员函数attach中创建的，如图3所示：</span></p><p style="text-align: center;"><span style="color:black;"><img width="691" src="http://img.my.csdn.net/uploads/201211/26/1353944092_1763.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color:black;">图3 Android应用程序窗口的创建过程</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 这个过程可以分为9个步骤，接下来我们就详细分析每一个步骤。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; Step 1. Activity.attach</span></p><p><span style="color:black;"></span></p><pre name="code" class="java">public class Activity extends ContextThemeWrapper  
        implements LayoutInflater.Factory,  
        Window.Callback, KeyEvent.Callback,  
        OnCreateContextMenuListener, ComponentCallbacks {  
    ......   
  
    private Window mWindow;   
    ......  
  
    final void attach(Context context, ActivityThread aThread,  
            Instrumentation instr, IBinder token, int ident,  
            Application application, Intent intent, ActivityInfo info,  
            CharSequence title, Activity parent, String id,  
            Object lastNonConfigurationInstance,  
            HashMap&lt;String,Object&gt; lastNonConfigurationChildInstances,  
            Configuration config) {  
        ......  
  
        mWindow = PolicyManager.makeNewWindow(this);  
        mWindow.setCallback(this);  
        if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {  
            mWindow.setSoftInputMode(info.softInputMode);  
        }  
        ......  
  
        mWindow.setWindowManager(null, mToken, mComponent.flattenToString());  
        ......  
    
    }  
  
    ......  
}  </pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/Activity.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8201936">Android应用程序窗口（Activity）的运行上下文环境（Context）的创建过程分析</a>一文中，我们已经分析过这个函数的实现了，这里我们只关注与应用程序窗口创建相关的代码。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数首先调用PolicyManager类的静态成员函数makeNewWindow来创建一个类型为PhoneWindow的应用程序窗口，并且保存在Activity类的成员变量mWindow中。有了这个类型为PhoneWindow的应用程序窗口，函数接下来还会调用它的成员函数setCallback、setSoftInputMode和setWindowManager来设置窗口回调接口、软键盘输入区域的显示模式和本地窗口管理器。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;PhoneWindow类的成员函数setCallback、setSoftInputMode和setWindowManager都是从父类Window继承下来的，因此，接下来我们就继续分析PolicyManager类的静态成员函数makeNewWindow，以及Window类的成员函数setCallback、setSoftInputMode和setWindowManager的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2.&nbsp;PolicyManager.makeNewWindow</p><p></p><pre name="code" class="java">public final class PolicyManager {
    private static final String POLICY_IMPL_CLASS_NAME =
        &quot;com.android.internal.policy.impl.Policy&quot;;

    private static final IPolicy sPolicy;

    static {
        // Pull in the actual implementation of the policy at run-time
        try {
            Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME);
            sPolicy = (IPolicy)policyClass.newInstance();
        } catch (ClassNotFoundException ex) {
            throw new RuntimeException(
                    POLICY_IMPL_CLASS_NAME + &quot; could not be loaded&quot;, ex);
        } catch (InstantiationException ex) {
            throw new RuntimeException(
                    POLICY_IMPL_CLASS_NAME + &quot; could not be instantiated&quot;, ex);
        } catch (IllegalAccessException ex) {
            throw new RuntimeException(
                    POLICY_IMPL_CLASS_NAME + &quot; could not be instantiated&quot;, ex);
        }
    }

    ......

    // The static methods to spawn new policy-specific objects
    public static Window makeNewWindow(Context context) {
        return sPolicy.makeNewWindow(context);
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/com/android/internal/policy/PolicyManager.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; PolicyManager是一个窗口管理策略类，它在第一次被使用的时候，就会创建一个Policy类实例，并且保存在静态成员变量sPolicy中，以后PolicyManager类的窗口管理策略就是通过这个Policy类实例来实现的，例如，PolicyManager类的静态成员函数makeNewWindow就是通过调用这个Policy类实例的成员函数makeNewWindow来创建一个具体的应用程序窗口的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析Policy类的成员函数makeNewWindow的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 3.&nbsp;Policy.makeNewWindow</p><p></p><pre name="code" class="java">public class Policy implements IPolicy {
    ......

    public PhoneWindow makeNewWindow(Context context) {
        return new PhoneWindow(context);
    }
 
    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/Policy.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Policy类的成员函数makeNewWindow的实现很简单，它只是创建了一个PhoneWindow对象，然后返回给调用者。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析PhoneWindow类的构造函数的实现，以便可以了解一个类型为PhoneWindow的应用程序窗口的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 4. new PhoneWindow</p><p></p><pre name="code" class="java">public class PhoneWindow extends Window implements MenuBuilder.Callback {
    ......

    // This is the top-level view of the window, containing the window decor.
    private DecorView mDecor;

    // This is the view in which the window contents are placed. It is either
    // mDecor itself, or a child of mDecor where the contents go.
    private ViewGroup mContentParent;
    ......

    private LayoutInflater mLayoutInflater;
    ......

    public PhoneWindow(Context context) {
        super(context);
        mLayoutInflater = LayoutInflater.from(context);
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;PhoneWindow类的构造函数很简单，它首先调用父类Window的构造函数来执行一些初始化操作，接着再调用LayoutInflater的静态成员函数from创建一个LayoutInflater实例，并且保存在成员变量mLayoutInflater中。这样，PhoneWindow类以后就可以通过成员变量mLayoutInflater来创建应用程序窗口的视图，这个视图使用类型为DecorView的成员变量mDecor来描述。PhoneWindow类还有另外一个类型为ViewGroup的成员变量mContentParent，用来描述一个视图容器，这个容器存放的就是成员变量mDecor所描述的视图的内容，不过这个容器也有可能指向的是mDecor本身。在后面的文章中，我们再详细分析类型为PhoneWindow的应用程序窗口的视图的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Window的构造函数定义在文件frameworks/base/core/java/android/view/Window.java中，它的实现很简单，只是初始化了其成员变量mContext，如下所示：</p><p></p><pre name="code" class="java">public abstract class Window {
    ......

    private final Context mContext;
    ......

    public Window(Context context) {
        mContext = context;
    }
  
    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 从前面的调用过程可以知道，参数context描述的是正在启动的Activity组件，将它保存在Window类的成员变量mContext之后，Window类就可以通过它来访问与Activity组件相关的资源了。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，回到前面的Step 1中，即Activity类的成员函数attach中，接下来就会继续调用前面所创建的PhoneWindow对象从父类Window继承下来的成员函数setCallback来设置窗口回调接口，因此，接下来我们就继续分析Window类的成员函数setCallback的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 5. Window.setCallback</p><p></p><pre name="code" class="java">public abstract class Window {
    ......

    private Callback mCallback;
    ......

    /**
     * Set the Callback interface for this window, used to intercept key
     * events and other dynamic operations in the window.
     *
     * @param callback The desired Callback interface.
     */
    public void setCallback(Callback callback) {
        mCallback = callback;
    }
  
    ......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/Window.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;正在启动的Activity组件会将它所实现的一个Callback接口设置到与它所关联的一个PhoneWindow对象的父类Window的成员变量mCallback中去，这样当这个PhoneWindow对象接收到系统给它分发的IO输入事件，例如，键盘和触摸屏事件，转发给与它所关联的Activity组件处理，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/6882903">Android应用程序键盘（Keyboard）消息处理机制分析</a>一文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步执行完成之后，回到前面的Step 1中，即Activity类的成员函数attach中，接下来就会继续调用前面所创建的PhoneWindow对象从父类Window继承下来的成员函数setSoftInputMode来设置应用程序窗口的软键盘输入区域的显示模式，因此，接下来我们就继续分析Window类的成员函数setSoftInputMode的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 6.&nbsp;Window.setSoftInputMode</p><pre name="code" class="java">public abstract class Window {
    ......

    private boolean mHasSoftInputMode = false;
    ......

    public void setSoftInputMode(int mode) {
        final WindowManager.LayoutParams attrs = getAttributes();
        if (mode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
            attrs.softInputMode = mode;
            mHasSoftInputMode = true;
        } else {
            mHasSoftInputMode = false;
        }
        if (mCallback != null) {
            mCallback.onWindowAttributesChanged(attrs);
        }
    }

    ......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/Window.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 参数mode有SOFT_INPUT_STATE_UNSPECIFIED、SOFT_INPUT_STATE_UNCHANGED、SOFT_INPUT_STATE_HIDDEN、SOFT_INPUT_STATE_ALWAYS_HIDDEN、SOFT_INPUT_STATE_VISIBLE和SOFT_INPUT_STATE_ALWAYS_VISIBLE一共六个取值，用来描述窗口的软键盘输入区域的显示模式，它们的含义如下所示：</p><p>&nbsp;&nbsp; &nbsp; &nbsp;1.&nbsp;<strong>SOFT_INPUT_STATE_UNSPECIFIED</strong>：没有指定软键盘输入区域的显示状态。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;2.&nbsp;<strong>SOFT_INPUT_STATE_UNCHANGED</strong>：不要改变软键盘输入区域的显示状态。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;3.&nbsp;<strong>SOFT_INPUT_STATE_HIDDEN</strong>：在合适的时候隐藏软键盘输入区域，例如，当用户导航到当前窗口时。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;4.&nbsp;<strong>SOFT_INPUT_STATE_ALWAYS_HIDDEN</strong>：当窗口获得焦点时，总是隐藏软键盘输入区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;5.&nbsp;<strong>SOFT_INPUT_STATE_VISIBLE</strong>：在合适的时候显示软键盘输入区域，例如，当用户导航到当前窗口时。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;6.&nbsp;<strong>SOFT_INPUT_STATE_ALWAYS_VISIBLE</strong>：当窗口获得焦点时，总是显示软键盘输入区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;当参数mode的值不等于SOFT_INPUT_STATE_UNSPECIFIED时，就表示当前窗口被指定软键盘输入区域的显示模式，这时候Window类的成员函数setSoftInputMode就会将成员变量mHasSoftInputMode的值设置为true，并且将这个显示模式保存在用来描述窗口布局属性的一个WindowManager.LayoutParams对象的成员变量softInputMode中，否则的话，就会将成员变量mHasSoftInputMode的值设置为false。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;设置完成窗口的软键盘输入区域的显示模式之后，如果Window类的成员变量mCallback指向了一个窗口回调接口，那么Window类的成员函数setSoftInputMode还会调用它的成员函数onWindowAttributesChanged来通知与窗口所关联的Activity组件，它的窗口布局属性发生了变化。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，回到前面的Step 1中，即Activity类的成员函数attach中，接下来就会继续调用前面所创建的PhoneWindow对象从父类Window继承下来的成员函数setWindowManager来设置应用程序窗口的本地窗口管理器，因此，接下来我们就继续分析Window类的成员函数setWindowManager的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 7.&nbsp;Window.setWindowManager</p><p></p><pre name="code" class="java">public abstract class Window {
    ......

    private WindowManager mWindowManager;
    private IBinder mAppToken;
    private String mAppName;
    ......

    public void setWindowManager(WindowManager wm,
            IBinder appToken, String appName) {
        mAppToken = appToken;
        mAppName = appName;
        if (wm == null) {
            wm = WindowManagerImpl.getDefault();
        }
        mWindowManager = new LocalWindowManager(wm);
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/core/java/android/view/Window.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 参数appToken用来描述当前正在处理的窗口是与哪一个Activity组件关联的，它是一个Binder代理对象，引用了在ActivityManagerService这一侧所创建的一个类型为ActivityRecord的Binder本地对象。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6685853">Android应用程序的Activity启动过程简要介绍和学习计划</a>一系列文章可以知道，每一个启动起来了的Activity组件在ActivityManagerService这一侧，都有一个对应的ActivityRecord对象，用来描述该Activity组件的运行状态。这个Binder代理对象会被保存在Window类的成员变量mAppToken中，这样当前正在处理的窗口就可以知道与它所关联的Activity组件是什么。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 参数appName用来描述当前正在处理的窗口所关联的Activity组件的名称，这个名称会被保存在Window类的成员变量mAppName中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 参数wm用来描述一个窗口管理器。从前面的调用过程可以知道， 这里传进来的参数wm的值等于null，因此，函数首先会调用WindowManagerImpl类的静态成员函数getDefault来获得一个默认的窗口管理器。有了这个窗口管理器之后，函数接着再使用它来创建一个本地窗口管理器，即一个LocalWindowManager对象，用来维护当前正在处理的应用程序窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们首先分析WindowManagerImpl类的静态成员函数getDefault的实现，接着再分析本地窗口管理器的创建过程，即LocalWindowManager类的构造函数的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 8.&nbsp;WindowManagerImpl.getDefault</p><p></p><pre name="code" class="java">public class WindowManagerImpl implements WindowManager {
    ......

    public static WindowManagerImpl getDefault()
    {
        return mWindowManager;
    }
 
    ......

    private static WindowManagerImpl mWindowManager = new WindowManagerImpl();
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/WindowManagerImpl.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;WindowManagerImpl类的静态成员函数getDefault的实现很简单，它只是将静态成员变量mWindowManager所指向的一个WindowManagerImpl对象返回给调用者，这个WindowManagerImpl对象实现了WindowManager接口，因此，它就可以用来管理应用程序窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;这一步执行完成之后，回到前面的Step 7中，即Window类的成员函数setWindowManager中，接下来就会使用前面所获得一个WindowManagerImpl对象来创建一个本地窗口管理器，即一个LocalWindowManager对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 9. new&nbsp;LocalWindowManager</p><p></p><pre name="code" class="java">public abstract class Window {
    ......

    private final Context mContext;
    ......

    private class LocalWindowManager implements WindowManager {
        LocalWindowManager(WindowManager wm) {
            mWindowManager = wm;
            mDefaultDisplay = mContext.getResources().getDefaultDisplay(
                    mWindowManager.getDefaultDisplay());
        }

        ......

        private final WindowManager mWindowManager;

        private final Display mDefaultDisplay;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/Window.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;LocalWindowManager类的构造函数首先将参数wm所描述的一个WindowManagerImpl对象保存它的成员变量mWindowManager中，这样以后就将窗口管理工作交给它来处理。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;LocalWindowManager类的构造函数接着又通过成员变量mWindowManager所描述的一个WindowManagerImpl对象的成员函数getDefaultDisplay来获得一个Display对象，用来描述系统屏幕属性。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 由于前面所获得的Display对象描述的是全局的屏幕属性，而当前正在处理的窗口可能配置了一些可自定义的屏幕属性，因此，LocalWindowManager类的构造函数需要进一步地调整前面所获得的Display对象所描述的屏幕属性，以便可以适合当前正在处理的窗口使用。LocalWindowManager类的构造函数首先通过外部类Window的成员变量mContext的成员函数getResources来获得一个Resources对象，接着再调用这个Resources对象的成员函数getDefaultDisplay来调整前面所获得的Display对象所描述的屏幕属性。最终调整完成的Display对象就保存在LocalWindowManager类的成员变量mDefaultDisplay中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面的Step 4可以知道，类Window的成员变量mContext描述的是与当前窗口所关联的一个Activity组件。Activity类的成员函数getResources是从父类ContextWrapper继续下来的，它实现在文件frameworks/base/core/java/android/content/ContextWrapper.java中，如下所示：</p><p></p><pre name="code" class="java">public class ContextWrapper extends Context {
    Context mBase;
    ......

    @Override
    public Resources getResources()
    {
        return mBase.getResources();
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8201936">Android应用程序窗口（Activity）的运行上下文环境（Context）的创建过程分析</a>一文可以知道，ContextWrapper类的成员变量mBase指向的是一个ContextImpl对象，用来描述一个Activity组件的运行上下文环境。通过调用这个ContextImpl对象的成员函数getResources，就可以获得与一个Resources对象，而通过这个Resources对象，就可以访问一个Activity组件的资源信息，从而可以获得它所配置的屏幕属性。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成一个Activity组件所关联的应用程序窗口对象的创建过程了。从分析的过程可以知道：</p><p>&nbsp;&nbsp; &nbsp; &nbsp;1. 一个Activity组件所关联的应用程序窗口对象的类型为PhoneWindow。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;2. 这个类型为PhoneWindow的应用程序窗口是通过一个类型为LocalWindowManager的本地窗口管理器来维护的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;3. 这个类型为LocalWindowManager的本地窗口管理器又是通过一个类型为WindowManagerImpl的窗口管理器来维护应用程序窗口的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;4.&nbsp;这个类型为PhoneWindow的应用程序窗口内部有一个类型为DecorView的视图对象，这个视图对象才是真正用来描述一个Activity组件的UI的。<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp;在接下来的一篇文章中，我们将继续分析应用程序窗口内部的视图对象的创建过程，敬请关注！</p><p style="text-align: center;"><strong><span style="font-size:14px;color:#cc0000;">老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank" style="text-align: center;">http://weibo.com/shengyangluo</a>，欢迎关注！</span></strong></p>
            <div>
                作者：Luoshengyang 发表于2012-12-3 0:55:54 <a href="http://blog.csdn.net/luoshengyang/article/details/8223770">原文链接</a>
            </div>
            <div>
            阅读：6241 评论：18 <a href="http://blog.csdn.net/luoshengyang/article/details/8223770#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android应用程序窗口（Activity）的视图对象（View）的创建过程分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8245546</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8245546</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-12-10 0:55:28</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 从前文可知道，每一个</span><span style="color:black;">Activity</span><span style="color:black;">组件都有一个关联的</span><span style="color:black;">Window</span><span style="color:black;">对象，用来描述一个应用程序窗口。每一个应用程序窗口内部又包含有一个</span><span style="color:black;">View</span><span style="color:black;">对象，用来描述应用程序窗口的视图。应用程序窗口视图是真正用来实现</span><span style="color:black;">UI</span><span style="color:black;">内容和布局的，也就是说，每一个</span><span style="color:black;">Activity</span><span style="color:black;">组件的</span><span style="color:black;">UI</span><span style="color:black;">内容和布局都是通过与其所关联的一个</span><span style="color:black;">Window</span><span style="color:black;">对象的内部的一个</span><span style="color:black;">View</span><span style="color:black;">对象来实现的。在本文中，我们就详细分析应用程序窗口视图的创建过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文中提到，应用程序窗口内部所包含的视图对象的实际类型为DecorView。DecorView类继承了View类，是作为容器（ViewGroup）来使用的，它的实现如图1所示：</span></p><p style="text-align: center;"><span style="color: black; "><img src="http://img.my.csdn.net/uploads/201211/13/1352736693_6736.jpg" alt="" /><br /></span></p><p style="text-align: center;">图1 DecorView类的实现</p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个图的具体描述可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文中的图5，这里不再详述。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文还可以知道，每一个应用程序窗口的视图对象都有一个关联的ViewRoot对象，这些关联关系是由窗口管理器来维护的，如图2所示：</span></p><p style="text-align: center;"><span style="color: black; "><img width="684" src="http://img.my.csdn.net/uploads/201211/17/1353087703_2343.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color: black; ">图2 应用程序窗口视图与ViewRoot的关系图</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个图的具体描述可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文中的图6，这里不再详述。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;简单来说，ViewRoot相当于是MVC模型中的Controller，它有以下职责：</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 负责为应用程序窗口视图创建Surface。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 配合WindowManagerService来管理系统的应用程序窗口。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. 负责管理、布局和渲染应用程序窗口视图的UI。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;那么，应用程序窗口的视图对象及其所关联的ViewRoot对象是什么时候开始创建的呢？ 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8223770">Android应用程序窗口（Activity）的窗口对象（Window）的创建过程分析</a>一文可以知道，Activity组件在启动的时候，系统会为它创建窗口对象（Window），同时，系统也会为这个窗口对象创建视图对象。另一方面，当Activity组件被激活的时候，系统如果发现与它的应用程序窗口视图对象所关联的ViewRoot对象还没有创建，那么就会先创建这个ViewRoot对象，以便接下来可以将它的UI渲染出来。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>一文可以知道，Activity组件在启动的过程中，会调用ActivityThread类的成员函数handleLaunchActivity，用来创建以及首次激活Activity组件，因此，接下来我们就从这个函数开始，具体分析应用程序窗口的视图对象及其所关联的ViewRoot对象的创建过程，如图3所示：</span></p><p style="text-align: center;"><span style="color:black;"><img width="680" src="http://img.my.csdn.net/uploads/201212/08/1354900406_7918.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color:black;">图3 应用程序窗口视图的创建过程</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程一共可以分为13个步骤，接下来我们就详细分析每一个步骤。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. ActivityThread.handleLaunchActivity</span></p><p><span style="color:black;"></span></p><pre name="code" class="java">public final class ActivityThread {
    ......

    private final void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {
        ......

        Activity a = performLaunchActivity(r, customIntent);

        if (a != null) {
            ......

            handleResumeActivity(r.token, false, r.isForward);

            ......
        }

        ......
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/ActivityThread.java文件中。<br /><p></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数首先调用ActivityThread类的成员函数performLaunchActivity来创建要启动的Activity组件。在创建Activity组件的过程中，还会为该Activity组件创建窗口对象和视图对象。Activity组件创建完成之后，就可以将它激活起来了，这是通过调用ActivityThread类的成员函数handleResumeActivity来执行的。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们首先分析ActivityThread类的成员函数performLaunchActivity的实现，以便可以了解应用程序窗口视图对象的创建过程，接着再回过头来继续分析ActivityThread类的成员函数handleResumeActivity的实现，以便可以了解与应用程序窗口视图对象所关联的ViewRoot对象的创建过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2.&nbsp;ActivityThread.performLaunchActivity</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/ActivityThread.java文件中。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/8201936">Android应用程序窗口（Activity）的运行上下文环境（Context）的创建过程分析</a>一文的Step 1，它主要就是创建一个Activity组件实例，并且调用这个Activity组件实例的成员函数onCreate来让其执行一些自定义的初始化工作。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 3.&nbsp;Activity.onCreate</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/Activity.java中。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步可以参考<a href="http://blog.csdn.net/luoshengyang/article/details/8201936">Android应用程序窗口（Activity）的运行上下文环境（Context）的创建过程分析</a>一文的Step 10。我们在实现一个Activity组件的时候，也就是在实现一个Activity子类的时候，一般都会重写成员函数onCreate，以便可以执行一些自定义的初始化工作，其中就包含初始化UI的工作。例如，在前面<a href="http://blog.csdn.net/luoshengyang/article/details/6580267">在Ubuntu上为Android系统内置Java应用程序测试Application Frameworks层的硬件服务</a>一文中，我们实现了一个名称为Hello的Activity组件，用来测试硬件服务，它的成员函数onCreate的样子长得大概如下所示：</span></p><p><span style="color:black;"></span></p><pre name="code" class="java">public class Hello extends Activity implements OnClickListener {  
    ......  
      
    /** Called when the activity is first created. */  
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
  
        ......  
    }  

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 其中，调用从父类Activity继承下来的成员函数setContentView就是用来创建应用程序窗口视图对象的。<p></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析Activity类的成员函数setContentView的实现。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; Step 4.&nbsp;Activity.setContentView</span></p><p><span style="color:black;"></span></p><pre name="code" class="java">public class Activity extends ContextThemeWrapper
        implements LayoutInflater.Factory,
        Window.Callback, KeyEvent.Callback,
        OnCreateContextMenuListener, ComponentCallbacks {
    ......

    private Window mWindow;
    ......

    public Window getWindow() {
        return mWindow;
    }
    ......

    public void setContentView(int layoutResID) {
        getWindow().setContentView(layoutResID);
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/Activity.java中。<p></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Activity类的成员函数setContentView首先调用另外一个成员函数getWindow来获得成员变量mWindow所描述的一个窗口对象，接着再调用这个窗口对象的成员函数setContentView来执行创建应用程序窗口视图对象的工作。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8223770">Android应用程序窗口（Activity）的窗口对象（Window）的创建过程分析</a>一文可以知道，Activity类的成员变量mWindow指向的是一个PhoneWindow对象，因此，接下来我们就继续分析PhoneWindow类的成员函数setContentView的实现。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 5. PhoneWindow.setContentView</span></p><p><span style="color:black;"></span></p><pre name="code" class="java">public class PhoneWindow extends Window implements MenuBuilder.Callback {
    ......

    // This is the view in which the window contents are placed. It is either
    // mDecor itself, or a child of mDecor where the contents go.
    private ViewGroup mContentParent;
    ......

    @Override
    public void setContentView(int layoutResID) {
        if (mContentParent == null) {
            installDecor();
        } else {
            mContentParent.removeAllViews();
        }
        mLayoutInflater.inflate(layoutResID, mContentParent);
        final Callback cb = getCallback();
        if (cb != null) {
            cb.onContentChanged();
        }
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java中。<p></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;PhoneWindow类的成员变量mContentParent用来描述一个类型为DecorView的视图对象，或者这个类型为DecorView的视图对象的一个子视图对象，用作UI容器。当它的值等于null的时候，就说明正在处理的应用程序窗口的视图对象还没有创建。在这种情况下，就会调用成员函数installDecor来创建应用程序窗口视图对象。否则的话，就说明是要重新设置应用程序窗口的视图。在重新设置之前，首先调用成员变量mContentParent所描述的一个ViewGroup对象来移除原来的UI内空。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;由于我们是在Activity组件启动的过程中创建应用程序窗口视图的，因此，我们就假设此时PhoneWindow类的成员变量mContentParent的值等于null。接下来，函数就会调用成员函数installDecor来创建应用程序窗口视图对象，接着再通过调用PhoneWindow类的成员变量mLayoutInflater所描述的一个LayoutInflater对象的成员函数inflate来将参数layoutResID所描述的一个UI布局设置到前面所创建的应用程序窗口视图中去，最后还会调用一个Callback接口的成员函数onContentChanged来通知对应的Activity组件，它的视图内容发生改变了。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8223770">Android应用程序窗口（Activity）的窗口对象（Window）的创建过程分析</a>一文可以知道，Activity组件自己实现了这个Callback接口，并且将这个Callback接口设置到了与它所关联的应用程序窗口对象的内部去，因此，前面实际调用的是Activity类的成员函数onContentChanged来发出一个视图内容变化通知。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就继续分析PhoneWindow类的成员函数installDecor的实现，以便可以继续了解应用程序窗口视图对象的创建过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp;Step 6.&nbsp;PhoneWindow.installDecor</span></p><p><span style="color:black;"></span></p><pre name="code" class="java">public class PhoneWindow extends Window implements MenuBuilder.Callback {
    ......

    // This is the top-level view of the window, containing the window decor.
    private DecorView mDecor;
    ......

    // This is the view in which the window contents are placed. It is either
    // mDecor itself, or a child of mDecor where the contents go.
    private ViewGroup mContentParent;
    ......

    private TextView mTitleView;
    ......

    private CharSequence mTitle = null;
    ......

    private void installDecor() {
        if (mDecor == null) {
            mDecor = generateDecor();
            ......
        }
        if (mContentParent == null) {
            mContentParent = generateLayout(mDecor);

            mTitleView = (TextView)findViewById(com.android.internal.R.id.title);
            if (mTitleView != null) {
                if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) {
                    View titleContainer = findViewById(com.android.internal.R.id.title_container);
                    if (titleContainer != null) {
                        titleContainer.setVisibility(View.GONE);
                    } else {
                        mTitleView.setVisibility(View.GONE);
                    }
                    if (mContentParent instanceof FrameLayout) {
                        ((FrameLayout)mContentParent).setForeground(null);
                    }
                } else {
                    mTitleView.setText(mTitle);
                }
            }
        }
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java中。<p></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;由于我们是在Activity组件启动的过程中创建应用程序窗口视图的，因此，我们同时假设此时PhoneWindow类的成员变量mDecor的值等于null。这时候PhoneWindow类的成员函数installDecor就会调用另外一个成员函数generateDecor来创建一个DecorView对象，并且保存在PhoneWindow类的成员变量mDecor中。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;PhoneWindow类的成员函数installDecor接着再调用另外一个成员函数generateLayout来根据当前应用程序窗口的Feature来加载对应的窗口布局文件。这些布局文件保存在frameworks/base/core/res/res/layout目录下，它们必须包含有一个id值为“content”的布局控件。这个布局控件必须要从ViewGroup类继承下来，用来作为窗口的UI容器。PhoneWindow类的成员函数generateLayout执行完成之后，就会这个id值为“content”的ViewGroup控件来给PhoneWindow类的成员函数installDecor，后者再将其保存在成员变量mContentParent中。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; PhoneWindow类的成员函数installDecor还会检查前面加载的窗口布局文件是否包含有一个id值为“title”的TextView控件。如果包含有的话，就会将它保存在PhoneWindow类的成员变量mTitleView中，用来描述当前应用程序窗口的标题栏。但是，如果当前应用程序窗口是没有标题栏的，即它的Feature位FEATURE_NO_TITLE的值等于1，那么PhoneWindow类的成员函数installDecor就需要将前面得到的标题栏隐藏起来。注意，PhoneWindow类的成员变量mTitleView所描述的标题栏有可能是包含在一个id值为“title_container”的容器里面的，在这种情况下，就需要隐藏该标题栏容器。另一方面，如果当前应用程序窗口是设置有标题栏的，那么PhoneWindow类的成员函数installDecor就会设置它的标题栏文字。应用程序窗口的标题栏文字保存在PhoneWindow类的成员变量mTitle中，我们可以调用PhoneWindow类的成员函数setTitle来设置。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，应用程序窗口视图就创建完成了，回到前面的Step 1中，即ActivityThread类的成员函数handleLaunchActivity中，接下来就会调用ActivityThread类的另外一个成员函数handleResumeActivity来激活正在启动的Activity组件。由于在是第一次激活该Activity组件，因此，在激活之前，还会为该Activity组件创建一个ViewRoot对象，并且与前面所创建的应用程序窗口视图关联起来，以便后面可以通过该ViewRoot对象来控制应用程序窗口视图的UI展现。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析ActivityThread类的成员函数handleResumeActivity的实现。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; Step 7.&nbsp;ActivityThread.handleResumeActivity</span></p><p><span style="color:black;"></span></p><pre name="code" class="java">public final class ActivityThread {
    ......

    final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward) {
        ......

        ActivityClientRecord r = performResumeActivity(token, clearHide);

        if (r != null) {
            final Activity a = r.activity;
            ......

            // If the window hasn't yet been added to the window manager,
            // and this guy didn't finish itself or start another activity,
            // then go ahead and add the window.
            boolean willBeVisible = !a.mStartedActivity;
            if (!willBeVisible) {
                try {
                    willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible(
                            a.getActivityToken());
                } catch (RemoteException e) {
                }
            }
            if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {
                r.window = r.activity.getWindow();
                View decor = r.window.getDecorView();
                decor.setVisibility(View.INVISIBLE);
                ViewManager wm = a.getWindowManager();
                WindowManager.LayoutParams l = r.window.getAttributes();
                a.mDecor = decor;
                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;
                ......
                if (a.mVisibleFromClient) {
                    a.mWindowAdded = true;
                    wm.addView(decor, l);
                }
            } 

            ......
        }

        ......
    }
  
    ......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/ActivityThread.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ActivityThread类的成员函数handleResumeActivity首先调用另外一个成员函数performResumeActivity来通知Activity组件，它要被激活了，即会导致Activity组件的成员函数onResume被调用。ActivityThread类的成员函数performResumeActivity的返回值是一个ActivityClientRecord对象r，这个ActivityClientRecord对象的成员变量activity描述的就是正在激活的Activity组件a。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ActivityThread类的成员函数handleResumeActivity接下来判断正在激活的Activity组件接下来是否是可见的。如果是可见的，那么变量willBeVisible的值就会等于true。Activity类的成员变量mStartedActivity用来描述一个Activity组件是否正在启动一个新的Activity组件，并且等待这个新的Activity组件的执行结果。如果是的话，那么这个Activity组件的成员变量mStartedActivity的值就会等于true，表示在新的Activity组件的执行结果返回来之前，当前Activity组件要保持不可见的状态。因此，当Activity组件a的成员变量mStartedActivity的值等于true的时候，它接下来就是不可见的，否则的话，就是可见的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;虽然说在Activity组件a的成员变量mStartedActivity的值等于true的情况下，它接下来的状态要保持不可见的，但是有可能它所启动的Activity组件的UI不是全屏的。在这种情况下，Activity组件a的UI仍然是有部分可见的，这时候也要将变量willBeVisible的值设置为true。因此，如果前面得到变量willBeVisible的值等于false，那么ActivityThread类的成员函数handleResumeActivity接下来就会通过Binder进程间通信机制来调用ActivityManagerService服务的成员函数willActivityBeVisible来检查位于Activity组件a上面的其它Activity组件（包含了Activity组件a正在等待其执行结果的Activity组件）是否是全屏的。如果不是，那么ActivityManagerService服务的成员函数willActivityBeVisible的返回值就会等于true，表示接下来需要显示Activity组件a。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 前面得到的ActivityClientRecord对象r的成员变量window用来描述当前正在激活的Activity组件a所关联的应用程序窗口对象。当它的值等于null的时候，就表示当前正在激活的Activity组件a所关联的应用程序窗口对象还没有关联一个ViewRoot对象。进一步地，如果这个正在激活的Activity组件a还活着，并且接下来是可见的，即ActivityClientRecord对象r的成员变量mFinished的值等于false，并且前面得到的变量willBeVisible的值等于true，那么这时候就说明需要为与Activity组件a所关联的一个应用程序窗口视图对象关联的一个ViewRoot对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 将一个Activity组件的应用程序窗口视图对象与一个ViewRoot对象关联是通过该Activity组件所使用的窗口管理器来执行的。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8223770">Android应用程序窗口（Activity）的窗口对象（Window）的创建过程分析</a>一文可以知道，一个Activity组件所使用的本地窗口管理器保存它的成员变量mWindowManager中，这可以通过Activity类的成员函数getWindowManager来获得。在接下来的Step 10中，我们再分析Activity类的成员函数getWindowManager的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 由于我们现在要给Activity组件a的应用程序窗口视图对象关联一个ViewRoot对象，因此，我们就需要首先获得这个应用程序窗口视图对象。从前面的Step 6可以知道，一个Activity组件的应用程序窗口视图对象保存在与其所关联的一个应用程序窗口对象的内部，因此，我们又要首先获得这个应用程序窗口对象。与一个Activity组件所关联的应用程序窗口对象可以通过调用该Activity组件的成员函数getWindow来获得。一旦获得了这个应用程序窗口对象（类型为PhoneWindow）之后，我们就可以调用它的成员函数getDecorView来获得它内部的视图对象。在接下来的Step 8和Step 9中，我们再分别分析Activity类的成员函数Activity类的成员函数getWindow和PhoneWindow类的成员函数getDecorView的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;在关联应用程序窗口视图对象和ViewRoot对象的时候，还需要第三个参数，即应用程序窗口的布局参数，这是一个类型为WindowManager.LayoutParams的对象，可以通过调用应用程序窗口的成员函数getAttributes来获得。一切准备就绪之后，还要判断最后一个条件是否成立，即当前正在激活的Activity组件a在本地进程中是否是可见的，即它的成员变量mVisibleFromClient的值是否等于true。如果是可见的，那么最后就可以调用前面所获得的一个本地窗口管理器wm（类型为LocalWindowManager）的成员函数addView来执行关联应用程序窗口视图对象和ViewRoot对象的操作。</p><p>&nbsp;&nbsp; &nbsp; 接下来，我们就分别分析Activity类的成员函数getWindow、PhoneWindow类的成员函数getDecorView、ctivity类的成员函数getWindowManager以及LocalWindowManager类的成员函数addView的实现。</p><p>&nbsp;&nbsp; &nbsp; Step 8.&nbsp;Activity.getWindow</p><p></p><pre name="code" class="java">public class Activity extends ContextThemeWrapper
        implements LayoutInflater.Factory,
        Window.Callback, KeyEvent.Callback,
        OnCreateContextMenuListener, ComponentCallbacks {
    ......

    private Window mWindow;
    ......

    public Window getWindow() {
        return mWindow;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/Activity.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8223770">Android应用程序窗口（Activity）的窗口对象（Window）的创建过程分析</a>一文可以知道，Activity类的成员变量mWindow指向的是一个类型为PhoneWindow的窗口对象，因此，Activity类的成员函数getWindow返回给调用者的是一个PhoneWindow对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步执完成之后，返回到前面的Step 7中，即ActivityThread类的成员函数handleResumeActivity中，接下来就会继续调用前面所获得的一个PhoneWindow对象的成员函数getDecorView来获得当前正在激活的Activity组件所关联的一个应用程序窗口视图对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 9.&nbsp;PhoneWindow.getDecorView</p><p></p><pre name="code" class="java">public class PhoneWindow extends Window implements MenuBuilder.Callback {
    ......

    private DecorView mDecor;
    ......

    @Override
    public final View getDecorView() {
        if (mDecor == null) {
            installDecor();
        }
        return mDecor;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;PhoneWindow类的成员函数getDecorView首先判断成员变量mDecor的值是否等于null。如果是的话，那么就说明当前正在处理的应用程序窗口还没有创建视图对象。这时候就会调用另外一个成员函数installDecor来创建这个视图对象。从前面的调用过程可以知道，当前正在处理的应用程序窗口已经创建过视图对象，因此，这里的成员变量mDecor的值不等于null，PhoneWindow类的成员函数getDecorView直接将它返回给调用者。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步执完成之后，返回到前面的Step 7中，即ActivityThread类的成员函数handleResumeActivity中，接下来就会继续调用当前正在激活的Activity组件的成员函数getWindowManager来获得一个本地窗口管理器。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 10.&nbsp;Activity.getWindowManager</p><p></p><pre name="code" class="java">public class Activity extends ContextThemeWrapper
        implements LayoutInflater.Factory,
        Window.Callback, KeyEvent.Callback,
        OnCreateContextMenuListener, ComponentCallbacks {
    ......

    private WindowManager mWindowManager;
    ......

    public WindowManager getWindowManager() {
        return mWindowManager;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/app/Activity.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8201936">Android应用程序窗口（Activity）的运行上下文环境（Context）的创建过程分析</a>一文可以知道，Activity类的成员变量mWindowManager指向的一是类型为LocalWindowManager的本地窗口管理器，Activity类的成员函数getWindowManager直接将它返回给调用者。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步执完成之后，返回到前面的Step 7中，即ActivityThread类的成员函数handleResumeActivity中，接下来就会继续调用前面所获得的一个LocalWindowManager对象的成员函数addView来为当前正在激活的Activity组件的应用程序窗口视图对象关联一个ViewRoot对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 11.&nbsp;LocalWindowManager.addView</p><p></p><pre name="code" class="java">public abstract class Window {
    ......

    private class LocalWindowManager implements WindowManager {
        ......

        public final void addView(View view, ViewGroup.LayoutParams params) {
            ......

            mWindowManager.addView(view, params);
        }

        ......

        private final WindowManager mWindowManager;
 
        ......
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/Window.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8223770">Android应用程序窗口（Activity）的窗口对象（Window）的创建过程分析</a>一文可以知道，LocalWindowManager类的成员变量mWindowManager指向的是一个WindowManagerImpl对象，因此，LocalWindowManager类的成员函数addView接下来调用WindowManagerImpl类的成员函数addView来给参数view所描述的一个应用程序窗口视图对象关联一个ViewRoot对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 12.&nbsp;WindowManagerImpl.addView</p><p></p><pre name="code" class="java">public class WindowManagerImpl implements WindowManager {
    ......

    public void addView(View view, ViewGroup.LayoutParams params)
    {
        addView(view, params, false);
    }

    ......

    private void addView(View view, ViewGroup.LayoutParams params, boolean nest)
    {
        ......

        final WindowManager.LayoutParams wparams
                = (WindowManager.LayoutParams)params;

        ViewRoot root;
        View panelParentView = null;

        synchronized (this) {
            // Here's an odd/questionable case: if someone tries to add a
            // view multiple times, then we simply bump up a nesting count
            // and they need to remove the view the corresponding number of
            // times to have it actually removed from the window manager.
            // This is useful specifically for the notification manager,
            // which can continually add/remove the same view as a
            // notification gets updated.
            int index = findViewLocked(view, false);
            if (index &gt;= 0) {
                if (!nest) {
                    throw new IllegalStateException(&quot;View &quot; + view
                            + &quot; has already been added to the window manager.&quot;);
                }
                root = mRoots[index];
                root.mAddNesting++;
                // Update layout parameters.
                view.setLayoutParams(wparams);
                root.setLayoutParams(wparams, true);
                return;
            }

            // If this is a panel window, then find the window it is being
            // attached to for future reference.
            if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;
                    wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) {
                final int count = mViews != null ? mViews.length : 0;
                for (int i=0; i&lt;count; i++) {
                    if (mRoots[i].mWindow.asBinder() == wparams.token) {
                        panelParentView = mViews[i];
                    }
                }
            }

            root = new ViewRoot(view.getContext());
            root.mAddNesting = 1;

            view.setLayoutParams(wparams);

            if (mViews == null) {
                index = 1;
                mViews = new View[1];
                mRoots = new ViewRoot[1];
                mParams = new WindowManager.LayoutParams[1];
            } else {
                index = mViews.length + 1;
                Object[] old = mViews;
                mViews = new View[index];
                System.arraycopy(old, 0, mViews, 0, index-1);
                old = mRoots;
                mRoots = new ViewRoot[index];
                System.arraycopy(old, 0, mRoots, 0, index-1);
                old = mParams;
                mParams = new WindowManager.LayoutParams[index];
                System.arraycopy(old, 0, mParams, 0, index-1);
            }
            index--;

            mViews[index] = view;
            mRoots[index] = root;
            mParams[index] = wparams;
        }
        // do this last because it fires off messages to start doing things
        root.setView(view, wparams, panelParentView);
    }

    ......

    private View[] mViews;
    private ViewRoot[] mRoots;
    private WindowManager.LayoutParams[] mParams;

    ......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/WindowManagerImpl.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在WindowManagerImpl类中，两个参数版本的成员函数addView是通过调用三个参数版本的成同函数addView来实现的，因此，我们接下来就主要分析三个参数版本的成员函数addView的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在分析WindowManagerImpl类的三个参数版本的成员函数addView的实现之前，我们首先了解一下WindowManagerImpl类是如何关联一个应用程序窗口视图对象（View对象）和一个ViewRoot对象的。一个View对象在与一个ViewRoot对象关联的同时，还会关联一个WindowManager.LayoutParams对象，这个WindowManager.LayoutParams对象是用来描述应用程序窗口视图的布局属性的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;WindowManagerImpl类有三个成员变量mViews、mRoots和mParams，它们分别是类型为View、ViewRoot和WindowManager.LayoutParams的数组。这三个数组的大小是始终保持相等的。这样， 有关联关系的View对象、ViewRoot对象和WindowManager.LayoutParams对象就会分别保存在数组mViews、mRoots和mParams的相同位置上，也就是说，mViews[i]、mRoots[i]和mParams[i]所描述的View对象、ViewRoot对象和WindowManager.LayoutParams对象是具有关联关系的。因此，WindowManagerImpl类的三个参数版本的成员函数addView在关联一个View对象、一个ViewRoot对象和一个WindowManager.LayoutParams对象的时候，只要分别将它们放在数组mViews、mRoots和mParams的相同位置上就可以了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 理解了一个View对象、一个ViewRoot对象和一个WindowManager.LayoutParams对象是如何关联之后，WindowManagerImpl类的三个参数版本的成员函数addView的实现就容易理解了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 参数view和参数params描述的就是要关联的View对象和WindowManager.LayoutParams对象。成员函数addView首先调用另外一个成员函数findViewLocked来检查参数view所描述的一个View对象是否已经存在于数组中mViews中了。如果已经存在的话，那么就说明该View对象已经关联过ViewRoot对象以及WindowManager.LayoutParams对象了。在这种情况下，如果参数nest的值等于false，那么成员函数addView是不允许重复对参数view所描述的一个View对象进行重新关联的。另一方面，如果参数nest的值等于true，那么成员函数addView只是重新修改参数view所描述的一个View对象及其所关联的一个ViewRoot对象内部使用的一个WindowManager.LayoutParams对象，即更新为参数params所描述的一个WindowManager.LayoutParams对象，这是通过调用它们的成员函数setLayoutParams来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 如果参数view所描述的一个View对象还没有被关联过一个ViewRoot对象，那么成员函数addView就会创建一个ViewRoot对象，并且将它与参数view和params分别描述的一个View对象和一个WindowManager.LayoutParams对象保存在数组mViews、mRoots和mParams的相同位置上。注意，如果数组mViews、mRoots和mParams尚未创建，那么成员函数addView就会首先分别为它们创建一个大小为1的数组，以便可以用来分别保存所要关联的View对象、ViewRoot对象和WindowManager.LayoutParams对象。另一方面，如果数组mViews、mRoots和mParams已经创建，那么成员函数addView就需要分别将它们的大小增加1，以便可以在它们的末尾位置上分别保存所要关联的View对象、ViewRoot对象和WindowManager.LayoutParams对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 还有另外一个需要注意的地方是当参数view描述的是一个子应用程序窗口的视图对象时，即WindowManager.LayoutParams对象wparams的成员变量type的值大于等于WindowManager.LayoutParams.FIRST_SUB_WINDOW并且小于等于WindowManager.LayoutParams.LAST_SUB_WINDOW时，那么成员函数addView还需要找到这个子视图对象的父视图对象panelParentView，这是通过遍历数组mRoots来查找的。首先，WindowManager.LayoutParams对象wparams的成员变量token指向了一个类型为W的Binder本地对象的一个IBinder接口，用来描述参数view所描述的一个子应用程序窗口视图对象所属的父应用程序窗口视图对象。其次，每一个ViewRoot对象都通过其成员变量mWindow来保存一个类型为W的Binder本地对象，因此，如果在数组mRoots中，存在一个ViewRoot对象，它的成员变量mWindow所描述的一个W对象的一个IBinder接口等于WindowManager.LayoutParams对象wparams的成员变量token所描述的一个IBinder接口时，那么就说明与该ViewRoot对象所关联的View对象即为参数view的父应用程序窗口视图对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;成员函数addView为参数view所描述的一个View对象和参数params所描述的一个WindowManager.LayoutParams对象关联好一个ViewRoot对象root之后，最后还会将这个View对view象和这个WindowManager.LayoutParams对象，以及变量panelParentView所描述的一个父应用程序窗视图对象，保存在这个ViewRoot对象root的内部去，这是通过调用这个ViewRoot对象root的成员函数setView来实现的，因此，接下来我们就继续分析ViewRoot类的成员函数setView的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 13. ViewRoot.setView</p><p></p><pre name="code" class="java">public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......

    final WindowManager.LayoutParams mWindowAttributes = new WindowManager.LayoutParams();
    ......

    View mView;
    ......

    final View.AttachInfo mAttachInfo;
    ......

    boolean mAdded;
    ......

    public void setView(View view, WindowManager.LayoutParams attrs,
            View panelParentView) {
        synchronized (this) {
            if (mView == null) {
                mView = view;
                mWindowAttributes.copyFrom(attrs);
                ......

                mAttachInfo.mRootView = view;
                .......

                if (panelParentView != null) {
                    mAttachInfo.mPanelParentWindowToken
                            = panelParentView.getApplicationWindowToken();
                }
                mAdded = true;
                ......

                requestLayout();
                ......
                try {
                    res = sWindowSession.add(mWindow, mWindowAttributes,
                            getHostVisibility(), mAttachInfo.mContentInsets,
                            mInputChannel);
                } catch (RemoteException e) {
                    mAdded = false;
                    mView = null;
                    ......
                    throw new RuntimeException(&quot;Adding window failed&quot;, e);
                } finally {
                    if (restore) {
                        attrs.restore();
                    }
                }

                ......
            }

            ......
        }
    }

    ......
}</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数view所描述的一个View对象会分别被保存在ViewRoot类的成员变量mView以及成员变量mAttachInfo所描述的一个AttachInfo的成员变量mRootView中，而参数attrs所描述的一个WindowManager.LayoutParams对象的内容会被拷贝到ViewRoot类的成员变量mWindowAttributes中去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 当参数panelParentView的值不等于null的时候，就表示参数view描述的是一个子应用程序窗口视图对象。在这种情况下，参数panelParentView描述的就是一个父应用程序窗口视图对象。这时候我们就需要获得用来描述这个父应用程序窗口视图对象的一个类型为W的Binder本地对象的IBinder接口，以便可以保存在ViewRoot类的成员变量mAttachInfo所描述的一个AttachInfo的成员变量mPanelParentWindowToken中去。这样以后就可以知道ViewRoot类的成员变量mView所描述的一个子应用程序窗口视图所属的父应用程序窗口视图是什么了。注意，通过调用参数panelParentView的所描述的一个View对象的成员函数getApplicationWindowToken即可以获得一个对应的W对象的IBinder接口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 上述操作执行完成之后，ViewRoot类的成员函数setView就可以将成员变量mAdded的值设置为true了，表示当前正在处理的一个ViewRoot对象已经关联好一个View对象了。接下来，ViewRoot类的成员函数setView还需要执行两个操作：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. 调用ViewRoot类的另外一个成员函数requestLayout来请求对应用程序窗口视图的UI作第一次布局。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. 调用ViewRoot类的静态成员变量sWindowSession所描述的一个类型为Session的Binder代理对象的成员函数add来请求WindowManagerService增加一个WindowState对象，以便可以用来描述当前正在处理的一个ViewRoot所关联的一个应用程序窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成Android应用程序窗口视图对象的创建过程了。在接下来的一篇文章中，我们将会继续分析Android应用程序窗口与WindowManagerService服务的连接过程，即Android应用程序窗口请求WindowManagerService为其增加一个WindowState对象的过程，而在接下来的两篇文章中，我们还会分析用来渲染Android应用程序窗口的Surface的创建过程，以及Android应用程序窗口的渲染过程。通过这三个过程的分析，我们就可以看到上述第1点和第2点提到的两个函数的执行过程，敬请期待！</p><p style="text-align: center;"><span style="color: rgb(204, 0, 0);"><strong><span style="font-size:14px;">老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</span></strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-12-10 0:55:28 <a href="http://blog.csdn.net/luoshengyang/article/details/8245546">原文链接</a>
            </div>
            <div>
            阅读：5759 评论：27 <a href="http://blog.csdn.net/luoshengyang/article/details/8245546#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8275938</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8275938</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-12-17 0:57:11</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前两文中，我们分析了</span><span style="color:black;">Activity</span><span style="color:black;">组件的窗口对象和视图对象的创建过程。</span><span style="color:black;">Activity</span><span style="color:black;">组件在其窗口对象和视图对象创建完成之后，就会请求与</span><span style="color:black;">WindowManagerService</span><span style="color:black;">建立一个连接，即请求</span><span style="color:black;">WindowManagerService</span><span style="color:black;">为其增加一个</span><span style="color:black;">WindowState</span><span style="color:black;">对象，用来描述它的窗口状态。在本文中，我们就详细分析</span><span style="color:black;">Activity</span><span style="color:black;">组件与</span><span style="color:black;">WindowManagerService</span><span style="color:black;">的连接过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们从两方面来看Activity组件与WindowManagerService服务之间的连接。一方面是从Activity组件到WindowManagerService服务的连接，另一方面是从WindowManagerService服务到Activity组件的连接。从Activity组件到WindowManagerService服务的连接是以Activity组件所在的应用程序进程为单位来进行的。当一个应用程序进程在启动第一个Activity组件的时候，它便会打开一个到WindowManagerService服务的连接，这个连接以应用程序进程从WindowManagerService服务处获得一个实现了IWindowSession接口的Session代理对象来标志。从WindowManagerService服务到Activity组件的连接是以Activity组件为单位来进行的。在应用程序进程这一侧，每一个Activity组件都关联一个实现了IWindow接口的W对象，这个W对象在Activity组件的视图对象创建完成之后，就会通过前面所获得一个Session代理对象来传递给WindowManagerService服务，而WindowManagerService服务接收到这个W对象之后，就会在内部创建一个WindowState对象来描述与该W对象所关联的Activity组件的窗口状态，并且以后就通过这个W对象来控制对应的Activity组件的窗口状态。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 上述Activity组件与WindowManagerService服务之间的连接模型如图1所示：</span></p><p style="text-align: center;"><span style="color:black;"><img src="http://img.my.csdn.net/uploads/201212/12/1355241649_1015.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color:black;">图1 Activity组件与WindowManagerService服务之间的连接模型</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从图1还可以看出，每一个Activity组件在ActivityManagerService服务内部，都对应有一个ActivityRecord对象，这个ActivityRecord对象是Activity组件启动的过程中创建的，用来描述Activity组件的运行状态，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>一文。这样，每一个Activity组件在应用程序进程、WindowManagerService服务和ActivityManagerService服务三者之间就分别一一地建立了连接。在本文中，我们主要关注Activity组件在应用程序进程和WindowManagerService服务之间以及在WindowManagerService服务和ActivityManagerService服务之间的连接。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来我们就通过Session类、W类和WindowState类的实现来简要描述Activity组件与WindowManagerService服务之间的连接，如图2和图3所示：</span></p><p style="text-align: center;"><span style="color:black;"><img width="614" src="http://img.my.csdn.net/uploads/201212/12/1355242823_2059.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color:black;">图2 W类的实现</span></p><p style="text-align: center;"><span style="color:black;"><img width="614" src="http://img.my.csdn.net/uploads/201212/12/1355242835_4885.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color:black;">图3 Session类和WindowState类的实现</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;W类实现了IWindow接口，它的类实例是一个Binder本地对象。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8245546">Android应用程序窗口（Activity）的视图对象（View）的创建过程分析</a>一文可以知道，一个Activity组件在启动的过程中，会创建一个关联的ViewRoot对象，用来配合WindowManagerService服务来管理该Activity组件的窗口状态。在这个ViewRoot对象内部，有一个类型为W的成员变量mWindow，它是在ViewRoot对象的创建过程中创建的。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类有一个静态成员变量sWindowSession，它指向了一个实现了IWindowSession接口的Session代理对象。当应用程序进程启动第一个Activity组件的时候，它就会请求WindowManagerService服务发送一个建立连接的Binder进程间通信请求。WindowManagerService服务接收到这个请求之后，就会在内部创建一个类型为Session的Binder本地对象，并且将这个Binder本地对象返回给应用程序进程，后者于是就会得到一个Session代理对象，并且保存在ViewRoot类的静态成员变量sWindowSession中。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;有了这个Session代理对象之后，应用程序进程就可以在启动Activity组件的时候，调用它的成员函数add来将与该Activity组件所关联的一个W对象传递给WindowManagerService服务，后者于是就会得到一个W代理对象，并且会以这个W代理对象来创建一个WindowState对象，即将这个W代理对象保存在新创建的WindowState对象的成员变量mClient中。这个WindowState对象的其余成员变量的描述可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文的图7，这里不再详述。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Session类的描述同样可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文，这里我们主要描述一下它的作用。从图3可以看出，Session类实现了IWindowSession接口，因此，应用程序进程就可以通过保存在ViewRoot类的静态成员变量sWindowSession所描述的一个Session代理对象所实现的IWindowSession接口来与WindowManagerService服务通信，例如：</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 在Activity组件的启动过程中，调用这个IWindowSession接口的成员函数add可以将一个关联的W对象传递到WindowManagerService服务，以便WindowManagerService服务可以为该Activity组件创建一个WindowState对象。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 在Activity组件的销毁过程中，调用这个这个IWindowSession接口的成员函数remove来请求WindowManagerService服务之前为该Activity组件所创建的一个WindowState对象，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/6882903">Android应用程序键盘（Keyboard）消息处理机制分析</a>一文的键盘消息接收通道注销过程分析。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. 在Activity组件的运行过程中，调用这个这个IWindowSession接口的成员函数relayout来请求WindowManagerService服务来对该Activity组件的UI进行布局，以便该Activity组件的UI可以正确地显示在屏幕中。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们再来看W类的作用。从图2可以看出，W类实现了IWindow接口，因此，WindowManagerService服务就可以通过它在内部所创建的WindowState对象的成员变量mClient来要求运行在应用程序进程这一侧的Activity组件来配合管理窗口的状态，例如：</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1.&nbsp;当一个Activity组件的窗口的大小发生改变后，WindowManagerService服务就会调用这个IWindow接口的成员函数resized来通知该Activity组件，它的大小发生改变了。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp;当一个Activity组件的窗口的可见性之后，WindowManagerService服务就会调用这个IWindow接口的成员函数dispatchAppVisibility来通知该Activity组件，它的可见性发生改变了。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. 当一个Activity组件的窗口获得或者失去焦点之后，WindowManagerService服务就会调用这个IWindow接口的成员函数windowFoucusChanged来通知该Activity组件，它的焦点发生改变了。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;理解了Activity组件在应用程序进程和WindowManagerService服务之间的连接模型之后，接下来我们再通过简要分析Activity组件在WindowManagerService服务和ActivityManagerService服务之间的连接。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Activity组件在WindowManagerService服务和ActivityManagerService服务之间的连接是通过一个AppWindowToken对象来描述的。AppWindowToken类的实现如图4所示：</span></p><p style="text-align: center;"><span style="color:black;"><img width="614" src="http://img.my.csdn.net/uploads/201212/12/1355245661_6061.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color:black;">图4 AppWindowToken类的实现</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;每一个Activity组件在启动的时候，ActivityManagerService服务都会内部为该Activity组件创建一个ActivityRecord对象，并且会以这个ActivityRecord对象所实现的一个IApplicationToken接口为参数，请求WindowManagerService服务为该Activity组件创建一个AppWindowToken对象，即将这个IApplicationToken接口保存在新创建的AppWindowToken对象的成员变量appToken中。同时，这个ActivityRecord对象还会传递给它所描述的Activity组件所运行在应用程序进程，于是，应用程序进程就可以</span>在启动完成该Activity组件之后，将这个ActivityRecord对象以及一个对应的W对象传递给WindowManagerService服务，后者接着就会做两件事情：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. 根据获得的ActivityRecord对象的IApplicationToken接口来找到与之对应的一个AppWindowToken对象；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. 根据获得的AppWindowToken对象以及前面传递过来的W代理对象来为正在启动的Activity组件创建一个WindowState对象，并且将该AppWindowToken对象保存在新创建的WindowState对象的成员变量mAppToken中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 顺便提一下，AppWindowToken类是从WindowToken类继续下来的。WindowToken类也是用来标志一个窗口的，不过这个窗口类型除了是应用程序窗口，即Activity组件窗口之外，还可以是其它的，例如，输入法窗口或者壁纸窗口类型等，而AppWindowToken类只是用来描述Activity组件窗口。当WindowToken类是用来描述Activity组件窗口的时候，它的成员变量token指向的就是用来描述该Activity组件的一个ActivityRecord对象所实现的一个IBinder接口，而成员变量appWindowToken指向的就是其子类AppWindowToken对象。当另一方面，当WindowToken类是用来描述非Activity组件窗口的时候，它的成员变量appWindowToken的值就会等于null。这样，我们就可以通过WindowToken类的成员变量appWindowToken的值来判断一个WindowToken对象是否是用来描述一个Activity组件窗口的，即是否是用来描述一个应用程序窗口的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 上面所描述的Activity组件在ActivityManagerService服务和WindowManagerService服务之间以及应用程序进程和WindowManagerService服务之间的连接模型比较抽象，接下来，我们再通过三个过程来分析它们彼此之间的连接模型，如下所示：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1.&nbsp;ActivityManagerService服务请求WindowManagerService服务为一个Activity组件创建一个AppWindowToken对象的过程；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. 应用程序进程请求WindowManagerService服务创建一个Session对象的过程；</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 3.&nbsp;应用程序进程请求WindowManagerService服务为一个Activity组件创建一个WindowState对象的过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 通过这三个过程的分析，我们就可以对应用程序进程、ActivityManagerService服务和WindowManagerService服务的关系有一个深刻的认识了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 一.&nbsp;AppWindowToken对象的创建过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>一文的Step 9可以知道，Activity组件在启动的过程中，会调用到ActivityStack类的成员函数startActivityLocked，该函数会请求WindowManagerService服务为当前正在启动的Activity组件创建一个AppWindowToken对象。接下来，我们就从ActivityStack类的成员函数startActivityLocked开始分析一个AppWindowToken对象的创建过程，如图5所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201212/13/1355330887_3428.jpg" alt="" /><br /></p><p style="text-align: center;">图4 AppWindowToken对象的创建过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程可以分为3步，接下来我们就详细分析每一个步骤。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. ActivityStack.startActivityLocked</p><p></p><pre name="code" class="java">public class ActivityStack {
    ......

    final ActivityManagerService mService;
    ......

    final ArrayList mHistory = new ArrayList();
    ......

    private final void startActivityLocked(ActivityRecord r, boolean newTask,
            boolean doResume) {
        final int NH = mHistory.size();

        int addPos = -1;

        if (!newTask) {
            // If starting in an existing task, find where that is...
            boolean startIt = true;
            for (int i = NH-1; i &gt;= 0; i--) {
                ActivityRecord p = (ActivityRecord)mHistory.get(i);
                if (p.finishing) {
                    continue;
                }
                if (p.task == r.task) {
                    // Here it is!  Now, if this is not yet visible to the
                    // user, then just add it without starting; it will
                    // get started when the user navigates back to it.
                    addPos = i+1;
                    if (!startIt) {
                        mHistory.add(addPos, r);
                        ......

                        mService.mWindowManager.addAppToken(addPos, r, r.task.taskId,
                                r.info.screenOrientation, r.fullscreen);
                        ......
                        return;
                    }
                    break;
                }
                if (p.fullscreen) {
                    startIt = false;
                }
            }
        }

        // Place a new activity at top of stack, so it is next to interact
        // with the user.
        if (addPos &lt; 0) {
            addPos = NH;
        }
        ......

        // Slot the activity into the history stack and proceed
        mHistory.add(addPos, r);
        ......

        if (NH &gt; 0) {    
            ......

            mService.mWindowManager.addAppToken(
                    addPos, r, r.task.taskId, r.info.screenOrientation, r.fullscreen);
            .....
        } else {
            // If this is the first activity, don't do any fancy animations,
            // because there is nothing for it to animate on top of.
            mService.mWindowManager.addAppToken(addPos, r, r.task.taskId,
                    r.info.screenOrientation, r.fullscreen);
        }
        ......

        if (doResume) {
            resumeTopActivityLocked(null);
        }
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/am/ActivityStack.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数r是一个ActivityRecord对象，用来描述的是要启动的Activity组件，参数newTask是一个布尔变量，用来描述要启动的Activity组件是否是在新任务中启动的，参数doResume也是一个布尔变量，用来描述是否需要马上将Activity组件启动起来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ActivityStack类的成员变量mService指向的是系统的ActivityManagerService，另外一个成员变量mHistory是一个数组列表，用来描述系统的Activity组件堆栈。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当参数newTask的值等于false时，就说明参数r所描述的Activity组件是在已有的一个任务中启动的，因此，这时候ActivityStack类的成员函数startActivityLocked就会从上到下遍历保存成员变量mHistory，找到一个已有的Activity组件，它与参数r所描述的Activity组件是属于同一个任务的，即它们的成员变量task的值相等。找到这样的一个Activity组件之后，如果位于它上面的其它Activity组件的窗口至少有一个全屏的，即变量startIt的值等于true，那么ActivityStack类的成员函数startActivityLocked就只是将参数r所描述的Activity组件加入到成员变量mHistory所描述的一个Activity组件堆栈中，以及调用成员变量mService所描述的ActivityManagerService服务的成员变量mWindowManager所描述的WindowManagerService服务的成员函数addAppToken来为它创建一个AppWindowToken对象，然后就返回了，即不会执行下面的代码来启动参数r所描述的Activity组件。这相当于是延迟到参数r所描述的Activity组件可见时，才将它启动起来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 当参数newTask的值等于true时，就说明参数r所描述的Activity组件是在一个任务中启动的，这时候ActivityStack类的成员函数startActivityLocked就会首先将它添加到成员变量mHistory所描述的一个Activity组件堆栈，接着再判断它是否是系统中第一个启动的Activity组件。如果是系统中第一个启动的Activity组件，那么ActivityStack类的成员函数startActivityLocked就只是简单地调用WindowManagerService服务的成员函数addAppToken来为它创建一个AppWindowToken对象就完事了。如果不是系统系统中第一个启动的Activity组件，那么ActivityStack类的成员函数startActivityLocked除了会调用WindowManagerService服务的成员函数addAppToken来为它创建一个AppWindowToken对象之外，还会为它创建一些启动动画等，我们忽略这些代码。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从上面的分析就可以看出，无论如何，ActivityStack类的成员函数startActivityLocked都会调用WindowManagerService服务的成员函数addAppToken为正在启动的Activity组件创建一个AppWindowToken对象。创建完成这个AppWindowToken对象之后，如果参数doResume的值等于true，那么ActivityStack类的成员函数startActivityLocked就会继续调用另外一个成员函数resumeTopActivityLocked来继续执行启动参数r所描述的一个Activity组件，这一步可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>一文的Step 10。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就继续分析WindowManagerService类的成员函数addAppToken的实现，以便可以了解WindowManagerService服务是如何为一个Activity组件创建一个AppWindowToken对象的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 2.&nbsp;WindowManagerService.addAppToken</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    /**
     * Mapping from a token IBinder to a WindowToken object.
     */
    final HashMap&lt;IBinder, WindowToken&gt; mTokenMap =
            new HashMap&lt;IBinder, WindowToken&gt;();

    /**
     * The same tokens as mTokenMap, stored in a list for efficient iteration
     * over them.
     */
    final ArrayList&lt;WindowToken&gt; mTokenList = new ArrayList&lt;WindowToken&gt;();
    ......

    /**
     * Z-ordered (bottom-most first) list of all application tokens, for
     * controlling the ordering of windows in different applications.  This
     * contains WindowToken objects.
     */
    final ArrayList&lt;AppWindowToken&gt; mAppTokens = new ArrayList&lt;AppWindowToken&gt;();
    ......

    public void addAppToken(int addPos, IApplicationToken token,
            int groupId, int requestedOrientation, boolean fullscreen) {
        ......

        long inputDispatchingTimeoutNanos;
        try {
            inputDispatchingTimeoutNanos = token.getKeyDispatchingTimeout() * 1000000L;
        } catch (RemoteException ex) {
            ......
            inputDispatchingTimeoutNanos = DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS;
        }

        synchronized(mWindowMap) {
            AppWindowToken wtoken = findAppWindowToken(token.asBinder());
            if (wtoken != null) {
                ......
                return;
            }
            wtoken = new AppWindowToken(token);
            wtoken.inputDispatchingTimeoutNanos = inputDispatchingTimeoutNanos;
            wtoken.groupId = groupId;
            wtoken.appFullscreen = fullscreen;
            wtoken.requestedOrientation = requestedOrientation;
            mAppTokens.add(addPos, wtoken);
            ......
            mTokenMap.put(token.asBinder(), wtoken);
            mTokenList.add(wtoken);

            // Application tokens start out hidden.
            wtoken.hidden = true;
            wtoken.hiddenRequested = true;

            //dump();
        }
    }

    ......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; WindowManagerService类有三个成员变量mTokenMap、mTokenList和mAppTokens，它们都是用来描述系统中的窗口的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 成员变量mTokenMap指向的是一个HashMap，它里面保存的是一系列的WindowToken对象，每一个WindowToken对象都是用来描述一个窗口的，并且是以描述这些窗口的一个Binder对象的IBinder接口为键值的。例如，对于Activity组件类型的窗口来说，它们分别是以用来描述它们的一个ActivityRecord对象的IBinder接口保存在成员变量mTokenMap所指向的一个HashMap中的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 成员变量mTokenList指向的是一个ArrayList，它里面保存的也是一系列WindowToken对象，这些WindowToken对象与保存在成员变量mTokenMap所指向的一个HashMap中的WindowToken对象是一样的。成员变量mTokenMap和成员变量mTokenList的区别就在于，前者在给定一个IBinder接口的情况下，可以迅速指出是否存在一个对应的窗口，而后者可以迅速遍历系统中的窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 成员变量mAppTokens指向的也是一个ArrayList，不过它里面保存的是一系列AppWindowToken对象，每一个AppWindowToken对象都是用来描述一个Activity组件的窗口的，而这些AppWindowToken对象是以它们描述的窗口的Z轴坐标由小到大保存在这个ArrayList中的，这样我们就可以通过这个ArrayList来从上到下或者从下到上地遍历系统中的所有Activity组件窗口。由于这些AppWindowToken对象所描述的Activity组件窗口也是一个窗口，并且AppWindowToken类是从WindowToken继承下来的，因此，这些AppWindowToken对象还会同时被保存在成员变量mTokenMap所指向的一个HashMap和成员变量mTokenList所指向的一个ArrayList中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;理解了WindowManagerService类的成员变量mTokenMap、mTokenList和mAppTokens的作用之后，WindowManagerService类的成员函数addAppToken的实现就容易理解了。由于参数token描述的是一个Activity组件窗口，因此，函数就会为它创建一个AppWindowToken对象，并且将这个AppWindowToken对象分别保存在&nbsp;WindowManagerService类的三个成员变量mTokenMap、mTokenList和mAppTokens中。不过在创建对象，首先会检查与参数token所对应的AppWindowToken对象已经存在。如果已经存在，就什么也不做就返回了。注意，参数addPos用来指定参数token描述的是一个Activity组件在系统Activity组件堆栈中的位置，这个位置同时也指定了为该Activity组件在成员变量成员变量mAppTokens所指向的一个ArrayList中的位置。由于保存在系统Activity组件堆栈的Activity组件本来就是按照它们的Z轴坐标从小到大的顺序来排列的，因此，保存在成员变量mAppTokens所指向的一个ArrayList中的AppWindowToken对象也是按照它们的Z轴坐标从小到大的顺序来排列的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数在为参数token所描述一个Activity组件窗口创建了一个AppWindowToken对象之后，还会初始化它的一系列成员变量，这些成员变量的含义如下所示：</p><p>&nbsp;&nbsp; &nbsp; &nbsp;1.&nbsp;inputDispatchingTimeoutNanos，表示Activity组件窗口收到了一个IO输入事件之后，如果没有在规定的时间内处理完成该事件，那么系统就认为超时。这个超时值可以由Activity组件本身来指定，即可以通过调用一个对应的ActivityRecord对象的成员函数getKeyDispatchingTimeout来获得。假如Activity组件没有指定的话，那么就会使用默认值DEFAULT_INPUT_DISPATCHING_TIMEOUT_NANOS，即5000 * 1000000纳秒。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;2. groupId，表示Activity组件所属的任务的ID。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>一文可以知道，每一个Activity组件都是属于某一个任务的，而每一个任务都用来描述一组相关的Activity组件的，这些Activity组件用来完成用户的某一个操作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;3.&nbsp;appFullscreen，表示Activity组件的窗口是否是全屏的。如果一个Activity组件的窗口是全屏的，那么它就会将位于它下面的所有窗口都挡住，这样就可以在渲染系统UI时进行优化，即不用渲染位于全屏窗口以下的其它窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;4.&nbsp;requestedOrientation，表示Activity组件所请求的方向。这个方向可以是横的（LANDSCAPE），也可以是竖的（PORTRAIT）。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;5.&nbsp;hidden，表示Activity组件是否是处于不可见状态。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;6.&nbsp;hiddenRequested，与hidden差不多，也是表示Activity组件是否是处于不可见状态。两者的区别在于，在设置目标Activity组件的可见状态时，如果系统等待执行Activity组件切换操作，那么目标Activity组件的可见状态不会马上被设置，即它的hidden值不会马上被设置，而只是设置它的hiddenRequested值，表示它的可见性状态正在等待被设置。等到系统执行完成Activity组件切换操作之后，两者的值就会一致了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们继续分析一个AppWindowToken对象的创建过程，它AppWindowToken类的构造函数的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;Step 3. new&nbsp;AppWindowToken</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    class WindowToken {
        // The actual token.
        final IBinder token;

        // The type of window this token is for, as per WindowManager.LayoutParams.
        final int windowType;

        // Set if this token was explicitly added by a client, so should
        // not be removed when all windows are removed.
        final boolean explicit;
        ......

        // If this is an AppWindowToken, this is non-null.
        AppWindowToken appWindowToken;
        ......

        WindowToken(IBinder _token, int type, boolean _explicit) {
            token = _token;
            windowType = type;
            explicit = _explicit;
        }
     
        ......
    }


    class AppWindowToken extends WindowToken {
        // Non-null only for application tokens.
        final IApplicationToken appToken;
        ......

        AppWindowToken(IApplicationToken _token) {
            super(_token.asBinder(),
                    WindowManager.LayoutParams.TYPE_APPLICATION, true);
            appWindowToken = this;
            appToken = _token;
        }

        ......
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; AppWindowToken类的构造函数首先调用父类WindowToken的构造函数来执行父类的初始化工作，然后从父类WindowToken继承下来的成员变量appWindowToken以及自己的成员变量appToken的值。参数_token指向的是一个ActivityRecord对象的IBinder接口，因此，AppWindowToken类的成员变量appToken描述的就是一个ActivityRecord对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; WindowToken类的构造函数用来初始化token、windowType和explicit这三个成员变量。在我们这个场景中，成员变量token指向的也是一个ActivityRecord对象的IBinder接口，用来标志一个Activity组件的窗口，成员变量windowType用来描述窗口的类型，它的值等于WindowManager.LayoutParams.TYPE_APPLICATION，表示这是一个Activity组件窗口，成员变量explicit用来表示窗口是否是由应用程序进程请求添加的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 注意，当一个WindowToken对象的成员变量appWindowToken的值不等于null时，就表示它实际描述的是Activity组件窗口，并且这个成员变量指向的就是与该Activity组件所关联的一个AppWindowToken对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成一个AppWindowToken对象的创建过程了，通过这个过程我们就可以知道，每一个Activity组件，在ActivityManagerService服务内部都有一个对应的ActivityRecord对象，并且在WindowManagerService服务内部关联有一个AppWindowToken对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 二.&nbsp;Session对象的创建过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 应用程序进程在启动第一个Activity组件的时候，就会请求与WindowManagerService服务建立一个连接，以便可以配合WindowManagerService服务来管理系统中的所有窗口。具体来说，就是应用程序进程在为它里面启动的第一个Activity组件的视图对象创建一个关联的ViewRoot对象的时候，就会向WindowManagerService服务请求返回一个类型为Session的Binder本地对象，这样应用程序进程就可以获得一个类型为Session的Binder代理对象，以后就可以通过这个Binder代理对象来和WindowManagerService服务进行通信了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8245546">Android应用程序窗口（Activity）的视图对象（View）的创建过程分析</a>一文可以知道，应用程序进程在为它里面启动的Activity组件的视图对象创建关联ViewRoot对象是通过调用WindowManagerImpl类的成员函数addView来实现的，因此，接下来我们就从WindowManagerImpl类的成员函数addView开始分析应用程序进程与WindowManagerService服务的连接过程，即一个Session对象的创建过程，如图5所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201212/15/1355513409_2303.jpg" alt="" /><br /></p><p style="text-align: center;">图5 Session对象的创建过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程可以分为5个步骤，接下来我们就详细分析每一个步骤。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. WindowManagerImpl.addView</p><p></p><pre name="code" class="java">public class WindowManagerImpl implements WindowManager {  
    ......  
  
    private void addView(View view, ViewGroup.LayoutParams params, boolean nest)  
    {  
        ...... 
  
        ViewRoot root;  
        ......
  
        synchronized (this) {  
            ......
  
            root = new ViewRoot(view.getContext());  
            
            ......  
        }  
        // do this last because it fires off messages to start doing things  
        root.setView(view, wparams, panelParentView);  
    }   
  
    ......  
}  </pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/WindowManagerImpl.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里的参数view即为正在启动的Activity组件的视图对象，WindowManagerImpl类的成员函数addView的目标就是为它创建一个ViewRoot对象。这里我们只关注这个ViewRoot对象的创建过程，即ViewRoot类的构造函数的实现，WindowManagerImpl类的成员函数addView的详细实现可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8245546">Android应用程序窗口（Activity）的视图对象（View）的创建过程分析</a>一文的Step 12。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2. new ViewRoot</p><p></p><pre name="code" class="java">public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......

    public ViewRoot(Context context) {
        super();

        ......

        // Initialize the statics when this class is first instantiated. This is
        // done here instead of in the static block because Zygote does not
        // allow the spawning of threads.
        getWindowSession(context.getMainLooper());

        ......
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java文件中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的构造函数是通过调用静态成员函数getWindowSession来请求WindowManagerService服务为应用程序进程创建一个返回一个类型为Session的Binder本地对象的，因此，接下来我们就继续分析ViewRoot类的静态成员函数getWindowSession的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 3. ViewRoot.getWindowSession</p><p></p><pre name="code" class="java">public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......

    static IWindowSession sWindowSession;
    
    static final Object mStaticInit = new Object();
    static boolean mInitialized = false;
    ......

    public static IWindowSession getWindowSession(Looper mainLooper) {
        synchronized (mStaticInit) {
            if (!mInitialized) {
                try {
                    InputMethodManager imm = InputMethodManager.getInstance(mainLooper);
                    sWindowSession = IWindowManager.Stub.asInterface(
                            ServiceManager.getService(&quot;window&quot;))
                            .openSession(imm.getClient(), imm.getInputContext());
                    mInitialized = true;
                } catch (RemoteException e) {
                }
            }
            return sWindowSession;
        }
    }

    ......
}</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java文件中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; ViewRoot类的静态成员函数getWindowSession首先获得获得应用程序所使用的输入法管理器，接着再获得系统中的WindowManagerService服务的一个Binder代理对象。有了这个Binder代理对象之后，就可以调用它的成员函数openSession来请求WindowManagerService服务返回一个类型为Session的Binder本地对象。这个Binder本地对象返回来之后，就变成了一个类型为Session的Binder代理代象，即一个实现了IWindowSession接口的Binder代理代象，并且保存在ViewRoot类的静态成员变量sWindowSession中。在请求WindowManagerService服务返回一个类型为Session的Binder本地对象的时候，应用程序进程传递给WindowManagerService服务的参数有两个，一个是实现IInputMethodClient接口的输入法客户端对象，另外一个是实现了IInputContext接口的一个输入法上下文对象，它们分别是通过调用前面所获得的一个输入法管理器的成员函数getClient和getInputContext来获得的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从这里就可以看出，只有当ViewRoot类的静态成员函数getWindowSession第一次被调用的时候，应用程序进程才会请求WindowManagerService服务返回一个类型为Session的Binder本地对象。又由于ViewRoot类的静态成员函数getWindowSession第一次被调用的时候，正好是处于应用程序进程中的第一个Activity组件启动的过程中，因此，应用程序进程是在启动第一个Activity组件的时候，才会请求与WindowManagerService服务建立连接。一旦连接建立起来之后，ViewRoot类的静态成员变量mInitialized的值就会等于true，并且另外一个静态成员变量sWindowSession的值不等于null。同时，ViewRoot类的静态成员函数getWindowSession是线程安全的，这样就可以避免多个线程同时调用它来重复请求WindowManagerService服务为当前应用程序进程创建连接。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析求WindowManagerService类的成员函数openSession的实现，以便可以了解一个Session对象的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 4.&nbsp;indowManagerService.openSession</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    public IWindowSession openSession(IInputMethodClient client,
            IInputContext inputContext) {
        if (client == null) throw new IllegalArgumentException(&quot;null client&quot;);
        if (inputContext == null) throw new IllegalArgumentException(&quot;null inputContext&quot;);
        Session session = new Session(client, inputContext);
        return session;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数openSession的实现很简单，它以应用程序进程传递过来的一个输入法客户端对象和一个输入法上下文对象来参数，来创建一个类型为Session的Binder本地对象，并且将这个类型为Session的Binder本地对象返回给应用程序进程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来我们就继续分析Session类的构造函数的实现，以便可以了解一个Session对象的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 5. new Session</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    final boolean mHaveInputMethods;
    ......

    IInputMethodManager mInputMethodManager;
    ......

    private final class Session extends IWindowSession.Stub
            implements IBinder.DeathRecipient {
        final IInputMethodClient mClient;
        final IInputContext mInputContext;
        ......

        public Session(IInputMethodClient client, IInputContext inputContext) {
            mClient = client;
            mInputContext = inputContext;
            ......

            synchronized (mWindowMap) {
                if (mInputMethodManager == null &amp;&amp; mHaveInputMethods) {
                    IBinder b = ServiceManager.getService(
                            Context.INPUT_METHOD_SERVICE);
                    mInputMethodManager = IInputMethodManager.Stub.asInterface(b);
                }
            }
            long ident = Binder.clearCallingIdentity();
            try {
                // Note: it is safe to call in to the input method manager
                // here because we are not holding our lock.
                if (mInputMethodManager != null) {
                    mInputMethodManager.addClient(client, inputContext,
                            mUid, mPid);
                } else {
                    client.setUsingInputMethod(false);
                }
                client.asBinder().linkToDeath(this, 0);
            } catch (RemoteException e) {
                ......
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
        }

        ......
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Session类有两个成员变量mClient和mInputContext，分别用来保存在从应用程序进程传递过来的一个输入法客户端对象和一个输入法上下文对象，它们是在Session类的构造函数中初始化的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Session类的构造函数还会检查WindowManagerService服务是否需要获得系统中的输入法管理器服务，即检查WindowManagerService类的成员变量mHaveInputMethods的值是否等于true。如果这个值等于true，并且WindowManagerService服务还没有获得系统中的输入法管理器服务，即WindowManagerService类的成员变量mInputMethodManager的值等于null，那么Session类的构造函数就会首先获得这个输入法管理器服务，并且保存在WindowManagerService类的成员变量mInputMethodManager中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 获得了系统中的输入法管理器服务之后，Session类的构造函数就可以调用它的成员函数addClient来为正在请求与WindowManagerService服务建立连接的应用程序进程增加它所使用的输入法客户端对象和输入法上下文对象了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;至此，我们就分析完成一个Session对象的创建过程了，通过这个过程我们就可以知道，每一个应用程序进程在WindowManagerService服务内部都有一个类型为Session的Binder本地对象，用来它与WindowManagerService服务之间的连接，而有了这个连接之后，WindowManagerService服务就可以请求应用进程配合管理系统中的应用程序窗口了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;三. WindowState对象的创建过程<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp;在Android系统中，WindowManagerService服务负责统一管理系统中的所有窗口，因此，当运行在应用程序进程这一侧的Activity组件在启动完成之后，需要与WindowManagerService服务建立一个连接，以便WindowManagerService服务可以管理它的窗口。具体来说，就是应用程序进程将一个Activitty组件的视图对象设置到与它所关联的一个ViewRoot对象的内部的时候，就会将一个实现了IWindow接口的Binder本地对象传递WindowManagerService服务。这个实现了IWindow接口的Binder本地对象唯一地标识了一个Activity组件，WindowManagerService服务接收到了这个Binder本地对象之后，就会将它保存在一个新创建的WindowState对象的内部，这样WindowManagerService服务以后就可以通过它来和Activity组件通信，以便可以要求Activity组件配合来管理系系统中的所有窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8245546">Android应用程序窗口（Activity）的视图对象（View）的创建过程分析</a>一文可以知道，应用程序进程将一个Activity组件的视图对象设置到与它所关联的一个ViewRoot对象的内部是通过调用ViewRoot类的成员函数setView来实现的，因此，接下来我们就从ViewRoot类的成员函数setView开始分析Activity组件与WindowManagerService服务的连接过程，即一个WindowState对象的创建过程，如图6所示：</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201212/15/1355548211_1712.jpg" alt="" /><br /></p><p style="text-align: center;">图6 WindowState对象的创建过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程可以分为7个步骤，接下来我们就详细分析每一个步骤。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. ViewRoot.setView</p><p></p><pre name="code" class="java">public final class ViewRoot extends Handler implements ViewParent,  
        View.AttachInfo.Callbacks {  
    ......

    static IWindowSession sWindowSession;
    ......  
  
    final W mWindow;

    View mView;  
    ......  

    public ViewRoot(Context context) {
        super();
        ......

        mWindow = new W(this, context);
        ......

    }

    ......
  
    public void setView(View view, WindowManager.LayoutParams attrs,  
            View panelParentView) {  
        synchronized (this) {  
            if (mView == null) {  
                mView = view;  
                ......  
                  
                try {  
                    res = sWindowSession.add(mWindow, mWindowAttributes,  
                            getHostVisibility(), mAttachInfo.mContentInsets,  
                            mInputChannel);  
                } catch (RemoteException e) {  
                    ......  
                } finally {  
                    ......
                }  
  
                ......  
            }  
  
            ......  
        }  
    }  
  
    ......  
}  </pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java文件中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这里的参数view即为正在启动的Activity组件的视图对象，ViewRoot类的成员函数setView会将它保存成员变量mView中，这样就可以将一个Activity组件的视图对象和一个ViewRoot对象关联起来。ViewRoot类的成员函数setView接下来还会调用静态成员变量sWindowSession所描述的一个实现了IWindowSession接口的Binder代理对象的成员函数add来请求WindowManagerService服务为正在启动的Activity组件创建一个WindowState对象。接下来我们就主要关注WindowState对象的创建过程，ViewRoot类的成员函数setView的详细实现可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8245546">Android应用程序窗口（Activity）的视图对象（View）的创建过程分析</a>一文的Step 13。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;注意，ViewRoot类的成员函数setView在请求WindowManagerService服务为正在启动的Activity组件创建一个WindowState对象的时候，会传递一个类型为W的Binder本地对象给WindowManagerService服务。这个类型为W的Binder本地对象实现了IWindow接口，保存在ViewRoot类的成员变量mWindow中，它是在ViewRoot类的构造函数中创建的，以后WindowManagerService服务就会通过它来和Activity组件通信。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面第二部的内容可以知道，ViewRoot类的静态成员变量sWindowSession所指向的一个Binder代理对象引用的是运行在WindowManagerService服务这一侧的一个Session对象，因此，接下来我们就继续分析Session类的成员函数add的实现，以便可以了解一个WindowState对象的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 2. Session.add</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final class Session extends IWindowSession.Stub
            implements IBinder.DeathRecipient {
        ......

        public int add(IWindow window, WindowManager.LayoutParams attrs,
                int viewVisibility, Rect outContentInsets, InputChannel outInputChannel) {
            return addWindow(this, window, attrs, viewVisibility, outContentInsets,
                    outInputChannel);
        }

        ......
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Session类的成员函数add的实现很简单，它只是调用了外部类WindowManagerService的成员函数addWindow来进一步为正在启动的Activity组件创建一个WindowState对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 3. WindowManagerService.addWindow</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中，它的实现比较长，我们分段来阅读：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    public int addWindow(Session session, IWindow client,
            WindowManager.LayoutParams attrs, int viewVisibility,
            Rect outContentInsets, InputChannel outInputChannel) {
        ......

        WindowState attachedWindow = null;
        WindowState win = null;

        synchronized(mWindowMap) {
            ......

            if (mWindowMap.containsKey(client.asBinder())) {
                ......
                return WindowManagerImpl.ADD_DUPLICATE_ADD;
            }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先在WindowManagerService类的成员变量mWindowMap所描述的一个HashMap中检查是否存在一个与参数client所对应的WindowState对象，如果已经存在，那么就说明WindowManagerService服务已经为它创建过一个WindowState对象了，因此，这里就不会继续往前执行，而是直接返回一个错误码WindowManagerImpl.ADD_DUPLICATE_ADD。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往前看代码：</p><p></p><pre name="code" class="java">            if (attrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp; attrs.type &lt;= LAST_SUB_WINDOW) {
                attachedWindow = windowForClientLocked(null, attrs.token, false);
                if (attachedWindow == null) {
                    ......
                    return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
                }
                if (attachedWindow.mAttrs.type &gt;= FIRST_SUB_WINDOW
                        &amp;&amp; attachedWindow.mAttrs.type &lt;= LAST_SUB_WINDOW) {
                    ......
                    return WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN;
                }
            }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数attrs指向的是一个WindowManager.LayoutParams对象，用来描述正在启动的Activity组件的UI布局，当它的成员变量type的值大于等于FIRST_SUB_WINDOW并且小于等于LAST_SUB_WINDOW的时候，就说明现在要增加的是一个子窗口。在这种情况下，就必须要指定一个父窗口，而这个父窗口是通过数attrs指向的是一个WindowManager.LayoutParams对象的成员变量token来指定的，因此，这段代码就会调用WindowManagerService类的另外一个成员函数windowForClientLocked来获得用来描述这个父窗口的一个WindowState对象，并且保存在变量attachedWindow。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果得到变量attachedWindow的值等于null，那么就说明父窗口不存在，这是不允许的，因此，函数就不会继续向前执行，而是直接返回一个错误码WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN。另一方面，如果变量attachedWindow的值不等于null，但是它的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量type的值也是大于等于FIRST_SUB_WINDOW并且小于等于LAST_SUB_WINDOW，那么也说明找到的父窗口也是一个子窗口，这种情况也是不允许的，因此，函数就不会继续向前执行，而是直接返回一个错误码WindowManagerImpl.ADD_BAD_SUBWINDOW_TOKEN。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;我们继续往前看代码：</p><p></p><pre name="code" class="java">            boolean addToken = false;
            WindowToken token = mTokenMap.get(attrs.token);
            if (token == null) {
                if (attrs.type &gt;= FIRST_APPLICATION_WINDOW
                        &amp;&amp; attrs.type &lt;= LAST_APPLICATION_WINDOW) {
                    ......
                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
                }
                if (attrs.type == TYPE_INPUT_METHOD) {
                    ......
                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
                }
                if (attrs.type == TYPE_WALLPAPER) {
                    ......
                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
                }
                token = new WindowToken(attrs.token, -1, false);
                addToken = true;
            } else if (attrs.type &gt;= FIRST_APPLICATION_WINDOW
                    &amp;&amp; attrs.type &lt;= LAST_APPLICATION_WINDOW) {
                AppWindowToken atoken = token.appWindowToken;
                if (atoken == null) {
                    ......
                    return WindowManagerImpl.ADD_NOT_APP_TOKEN;
                } else if (atoken.removed) {
                    ......
                    return WindowManagerImpl.ADD_APP_EXITING;
                }
                if (attrs.type == TYPE_APPLICATION_STARTING &amp;&amp; atoken.firstWindowDrawn) {
                    // No need for this guy!
                    ......
                    return WindowManagerImpl.ADD_STARTING_NOT_NEEDED;
                }
            } else if (attrs.type == TYPE_INPUT_METHOD) {
                if (token.windowType != TYPE_INPUT_METHOD) {
                    ......
                      return WindowManagerImpl.ADD_BAD_APP_TOKEN;
                }
            } else if (attrs.type == TYPE_WALLPAPER) {
                if (token.windowType != TYPE_WALLPAPER) {
                    ......
                      return WindowManagerImpl.ADD_BAD_APP_TOKEN;
                }
            }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这段代码首先在WindowManagerService类的成员变量mTokenMap所描述的一个HashMap中检查WindowManagerService服务是否已经为正在增加的窗口创建过一个WindowToken对象了。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 如果还没有创建过WindowToken对，即变量token的值等于null，那么这段代码就会进一步检查正在增加的窗口的类型。如果正在增加的窗口是属于应用程序窗口（FIRST_APPLICATION_WINDOW~LAST_APPLICATION_WINDOW，即Activity组件窗口），或者输入法窗口（TYPE_INPUT_METHOD），或者壁纸窗口（TYPE_WALLPAPER），那么这三种情况都是不允许的，因此，函数就不会继续向前执行，而是直接返回一个错误码WindowManagerImpl.ADD_BAD_APP_TOKEN。例如，对于应用程序窗口来说，与它所对应的Activity组件是在之前就已经由ActivityManagerService服务请求WindowManagerService服务创建过一个AppWindowToken对象了的（AppWindowToken对象也是一个WindowToken对象，因为AppWindowToken类继承了WindowToken类），这个过程可以参考前面第一部分的内容。如果不是上述三种情况，那么这段代码就会为正在增加的窗口创建一个WindowToken对象，并且保存在变量token中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果已经创建过WindowToken对象，即变量token的值不等于null，那么就说明正在增加的窗口或者是应用程序窗口，或者是输入法窗口，或者是壁纸窗口。下面我们就为三种情况来讨论。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果是应用程序窗口，从前面第一部分的内容可以知道，WindowToken对象token的成员变量appWindowToken的值必须不能等于null，并且指向的是一个AppWindowToken对象。因此，当WindowToken对象token的成员变量appWindowToken的值等于null的时候，函数就不会继续向前执行，而是直接返回一个错误码WindowManagerImpl.ADD_NOT_APP_TOKEN。另一方面，虽然WindowToken对象token的成员变量appWindowToken的值不等于null，但是它所指向的一个AppWindowToken对象的成员变量removed的值等于true时，那么就表示对应的Activity组件已经被移除，在这种情况下，函数也不会继续向前执行，而是直接返回一个错误码WindowManagerImpl.ADD_APP_EXITING。还有一种特殊的应用程序窗口，它的类型为TYPE_APPLICATION_STARTING。这种类型的窗口称为起始窗口，它是在一个Activity组件的窗口显示出来之前就显示的。因此，如果当前正在增加的是一个超始窗口，并且它所附属的应用程序窗口，即变量atoken所描述的应用程序窗口，已经显示出来了，即变量atoken所指向的一个AppWindowToken对象的成员变量firstWindowDrawn的值等于true，那么函数也不会继续向前执行，而是直接返回一个错误码WindowManagerImpl.ADD_STARTING_NOT_NEEDED。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果是输入法窗口，但是参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量windowType的值不等于TYPE_INPUT_METHOD，那么指定的窗口类型就是不匹配的。在这种情况下，函数就不会继续向前执行，而是直接返回一个错误码WindowManagerImpl.ADD_BAD_APP_TOKEN。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果是壁纸窗口，但是参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量windowType的值不等于TYPE_WALLPAPER，那么指定的窗口类型就是不匹配的。在这种情况下，函数也不会继续向前执行，而是直接返回一个错误码WindowManagerImpl.ADD_BAD_APP_TOKEN。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往前看代码：</p><p></p><pre name="code" class="java">            win = new WindowState(session, client, token,
                    attachedWindow, attrs, viewVisibility);
            ......

            mPolicy.adjustWindowParamsLw(win.mAttrs);

            res = mPolicy.prepareAddWindowLw(win, attrs);
            if (res != WindowManagerImpl.ADD_OKAY) {
                return res;
            }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;通过上面的合法性检查之后，这里就可以为正在增加的窗口创建一个WindowState对象了。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService类的成员变量mPolicy指向的是一个实现了WindowManagerPolicy接口的窗口管理策略器。在Phone平台中，这个窗口管理策略器是由com.android.internal.policy.impl.PhoneWindowManager来实现的，它负责对系统中的窗口实现制定一些规则。这里主要是调用窗口管理策略器的成员函数adjustWindowParamsLw来调整当前正在增加的窗口的布局参数，以及调用成员函数prepareAddWindowLw来检查当前应用程序进程请求增加的窗口是否是合法的。如果不是合法的，即变量res的值不等于WindowManagerImpl.ADD_OKAY，那么函数就不会继续向前执行，而直接返回错误码res。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;WindowState对象的创建过程我们在接下来的Step 4中再分析，现在我们继续向前看代码：</p><p></p><pre name="code" class="java">            if (outInputChannel != null) {
                String name = win.makeInputChannelName();
                InputChannel[] inputChannels = InputChannel.openInputChannelPair(name);
                win.mInputChannel = inputChannels[0];
                inputChannels[1].transferToBinderOutParameter(outInputChannel);
                mInputManager.registerInputChannel(win.mInputChannel);
            }</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码是用创建IO输入事件连接通道的，以便正在增加的窗口可以接收到系统所发生的键盘和触摸屏事件，可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/6882903">Android应用程序键盘（Keyboard）消息处理机制分析</a>一文，这里不再详述。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;我们继续向前看代码：</p><p></p><pre name="code" class="java">            if (addToken) {
                mTokenMap.put(attrs.token, token);
                mTokenList.add(token);
            }
            win.attach();
            mWindowMap.put(client.asBinder(), win);

            if (attrs.type == TYPE_APPLICATION_STARTING &amp;&amp;
                    token.appWindowToken != null) {
                token.appWindowToken.startingWindow = win;
            }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先检查变量addToken的值是否等于true。如果等于true的话，那么就说明变量token所指向的一个WindowToken对象是在前面新创建的。在这种情况下，就需要将这个新创建的WindowToken对象分别添加到WindowManagerService类的成员变量mTokeMap和mTokenList分别描述的一个HashMap和一个ArrayList中去。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码接下来再调用前面所创建的一个WindowState对象win的成员函数attach来为当前正在增加的窗口创建一个用来连接到SurfaceFlinger服务的SurfaceSession对象。有了这个SurfaceSession对象之后，当前正在增加的窗口就可以和SurfaceFlinger服务通信了。在接下来的Step 5中，我们再详细分析WindowState类的成员函数attach的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码最后还做了两件事情。第一件事情是将前面所创建的一个WindowState对象win添加到WindowManagerService类的成员变量mWindowMap所描述的一个HashMap中，这是以参数所描述的一个类型为W的Binder代理对象的IBinder接口来键值来保存的。第二件事情是检查当前正在增加的是否是一个起始窗口，如果是的话，那么就会将前面所创建的一个WindowState对象win设置到用来描述它所属的Activity组件的一个AppWindowToken对象的成员变量startingWindow中去，这样系统就可以在显示这个Activity组件的窗口之前，先显示该起始窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续向前看代码：</p><p></p><pre name="code" class="java">            boolean imMayMove = true;

            if (attrs.type == TYPE_INPUT_METHOD) {
                mInputMethodWindow = win;
                addInputMethodWindowToListLocked(win);
                imMayMove = false;
            } else if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
                mInputMethodDialogs.add(win);
                addWindowToListInOrderLocked(win, true);
                adjustInputMethodDialogsLocked();
                imMayMove = false;
            } else {
                addWindowToListInOrderLocked(win, true);
                if (attrs.type == TYPE_WALLPAPER) {
                    ......
                    adjustWallpaperWindowsLocked();
                } else if ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != 0) {
                    adjustWallpaperWindowsLocked();
                }
            }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService类有一个成员变量mWindows，它是一个类型为WindowState的ArrayList，保存在它里面的WindowState对象所描述的窗口是按照它们的Z轴坐标从小到大的顺序来排列的。现在我们需要考虑将用来描述当前正在增加的窗口的WindowState对象win添加到这个ArrayList的合适位置中去。我们分三种情况考虑。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果当前正在增加的窗口是一个输入法窗口，那么WindowManagerService服务就需要按照Z轴坐标从大到小的顺序来检查当前是哪一个窗口是需要输入法窗口的。找到了这个位于最上面的需要输入法窗口的窗口之后，就可以将输入法窗口放置在它的上面了，即可以将WindowState对象win添加到WindowManagerService类的成员变量mWindows所描述的一个ArrayList的合适位置了。这两个操作是通过调用WindowManagerService类的成员函数addInputMethodWindowToListLocked来实现的。同时，WindowManagerService类的成员变量mInputMethodWindow指向的是系统当前正在使用的输入法窗口，因此，在这种情况下，我们还需要将WindowState对象win保存在它里面。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果当前正在添加的窗口是一个输入法对话框，那么WindowManagerService服务就需要做两件事情。第一件事情是将WindowState对象win添加到WindowManagerService类的成员变量mWindows所描述的一个ArrayList中去，这是通过调用WindowManagerService类的成员函数addWindowToListInOrderLocked来实现的。第二件事情是调用WindowManagerService类的成员函数adjustInputMethodDialogsLocked来调整正在增加的输入法对话框在WindowManagerService类的成员变量mWindows所描述的一个ArrayList中的位置，使得它位于输入法窗口的上面。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在上述两种情况下，系统的输入法窗口和输入法对话框的位置都是得到合适的调整的了，因此，这段代码就会将变量imMayMove的值设置为false，表示后面不需要再调整输入法窗口和输入法对话框的位置了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 如果当前正在添加的窗口是一个应用程序窗口或者壁纸窗口，那么WindowManagerService服务都需要将WindowState对象win添加到WindowManagerService类的成员变量mWindows所描述的一个ArrayList中去。添加完成之后，如果发现当前添加的窗口是一个壁纸窗口或者当前添加的是一个需要显示壁纸的应用程序窗口，那么WindowManagerService服务还需要进一步调整系统中已经添加了的壁纸窗口的Z轴位置，使得它们位于最上面的需要显示壁纸的窗口的下面，这是通过调用WindowManagerService类的成员函数adjustWallpaperWindowsLocked来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;我们继续向前看代码：</p><p></p><pre name="code" class="java">            win.mEnterAnimationPending = true;

            mPolicy.getContentInsetHintLw(attrs, outContentInsets);

            if (mInTouchMode) {
                res |= WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE;
            }
            if (win == null || win.mAppToken == null || !win.mAppToken.clientHidden) {
                res |= WindowManagerImpl.ADD_FLAG_APP_VISIBLE;
            }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码做了四件事情。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第一件事情是将前面所创建的一个WindowState对象win的成员变量mEnterAnimationPending的值设置为true，表示当前正在增加的窗口需要显示一个进入动画。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第二件事情是调用WindowManagerService类的成员变量mPolicy所描述的一个窗口管理策略器的成员函数getContentInsetHintLw来获得当前正在增加的窗口的UI内容边衬大小，即当前正在增加的窗口可以在屏幕中所获得的用来显示UI内容的区域的大小，这通常是要排除屏幕边框和状态栏等所占据的屏幕区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第三件事情是检查WindowManagerService类的成员变量mInTouchMode的值是否等于true。如果等于true的话，那么就说明系统运行在触摸屏模式中，这时候这段代码就会将返回值res的WindowManagerImpl.ADD_FLAG_IN_TOUCH_MODE位设置为1。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第四件事情是检查当前正在增加的窗口是否是处于可见的状态。从第二个if语句可以看出，由于WindowState对象win的值在这里不可以等于null，因此，这里只有两种情况下，前正在增加的窗口是处于可见状态的。第一种情况是WindowState对象的成员变量mAppToken的值等于null，这表明当前正在增加的窗口不是一个应用程序窗口，即不是一个Activity组件窗口，那么它就有可能是一个子窗口。由于子窗口通常是在其父窗口处于可见的状态下才会创建的，因此，这个子窗口就需要马上显示出来的，即需要将它的状态设置为可见的。第二种情况是WindowState对象的成员变量mAppToken的值不等于null，这表明当前正在增加的窗口是一个应用程序窗口。在这种情况下，WindowState对象的成员变量mAppToken指向的就是一个AppWindowToken对象。当这个AppWindowToken对象的成员变量clientHidden的值等于false的时候，就表明它所描述的一个Activity组件是处于可见状态的，因此，这时候就需要将该Activity组件的窗口（即当前正在增加的窗口）的状态设置为可见的。在当前正在增加的窗口是处于可见状态的情况下，这段代码就会将返回值res的WindowManagerImpl.ADD_FLAG_APP_VISIBLE位设置为1。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续向前看最后一段代码：</p><p></p><pre name="code" class="java">            boolean focusChanged = false;
            if (win.canReceiveKeys()) {
                focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS);
                if (focusChanged) {
                    imMayMove = false;
                }
            }

            if (imMayMove) {
                moveInputMethodWindowsIfNeededLocked(false);
            }

            assignLayersLocked();
            ......

            if (focusChanged) {
                finishUpdateFocusedWindowAfterAssignLayersLocked();
            }

            ......    
        }

        ...

        return res;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;最后一段代码做了以下五件事情。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第一件事情是检查当前正在增加的窗口是否是能够接收IO输入事件的，即键盘输入事件或者触摸屏输入事件。如果可以的话，那么就需要调用WindowManagerService类的成员函数updateFocusedWindowLocked来调整系统当前获得输入焦点的窗口，因为当前正在增加的窗口可能会成为新的可以获得输入焦点的窗口。如果WindowManagerService类的成员函数updateFocusedWindowLocked的返回值等于true，那么就表明系统当前获得输入焦点的窗口发生了变化。在这种情况下，WindowManagerService类的成员函数updateFocusedWindowLocked也会顺便调整输入法窗口的位置，使得它位于系统当前获得输入焦点的窗口的上面，因此，这时候这段代码也会将变量imMayMove的值设置为false，表示接下来不用调整输入法窗口的位置了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第二件事情是检查变量imMayMove的值是否等于true。如果等于true的话，那么就说明当前正在增加的窗口可能已经影响到系统的输入法窗口的Z轴位置了，因此，这段代码就需要调用WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked来重新调整调整输入法窗口的Z轴位置，使得它可以位于最上面的那个需要输入法窗口的窗口的上面。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第三件事情是调用WindowManagerService类的成员函数assignLayersLocked来调整系统中所有窗口的Z轴位置，这也是因为当前正在增加的窗口可能已经影响到系统中所有窗口的Z轴位置了。例如，假如当前增加的是一个正在启动的Activity组件的窗口，那么这个窗口的Z轴位置就应该是最大的，以便可以在最上面显示。又如，假如当前增加的是一个子窗口，那么这个子窗口就应该位于它的父窗口的上面。这些都要求重新调整系统中所有窗口的Z轴位置，以便每一个窗口都可以在一个正确的位置上来显示。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第四件事情检查变量focusChanged的值是否等于true。如果等于true的话，那么就说明系统中获得输入焦点的窗口已经发生了变化。在这种情况下，这段代码就会调用WindowManagerService类的成员函数finishUpdateFocusedWindowAfterAssignLayersLocked来通知系统IO输入管理器，新的获得焦点的窗口是哪一个，以便系统IO输入管理器接下来可以将键盘输入事件或者触摸屏输入事件分发给新的获得焦点的窗口来处理。WindowManagerService类的成员函数finishUpdateFocusedWindowAfterAssignLayersLocked的实现可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/6882903">Android应用程序键盘（Keyboard）消息处理机制分析</a>一文，这里不再详述。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 第五件事情是变量res的值返回给应用程序进程，以便它可以知道请求WindowManagerService服务增加一个窗口的执行情况。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，WindowManagerService类的成员函数addWindow的实现就分析完成了，接下来我们就继续分析WindowState类的构造函数和成员函数attach的实现，以便可以了解一个WindowSate对象及其相关联的一个SurfaceSession对象的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 4. new&nbsp;WindowState</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中，它的实现比较长，我们分段来阅读：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final class WindowState implements WindowManagerPolicy.WindowState {
        ......

        WindowState(Session s, IWindow c, WindowToken token,
               WindowState attachedWindow, WindowManager.LayoutParams a,
               int viewVisibility) {
            mSession = s;
            mClient = c;
            mToken = token;
            mAttrs.copyFrom(a);
            mViewVisibility = viewVisibility;
            DeathRecipient deathRecipient = new DeathRecipient();
            mAlpha = a.alpha;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码初始化WindowState类的以下六个成员变量：<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mSession</strong>：指向一个类型为Session的Binder本地对象，使用参数s来初始化，表示当前所创建的WindowState对象是属于哪一个应用程序进程的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mClient</strong>：指向一个实现了IWindow接口的Binder代理对象，它引用了运行在应用程序进程这一侧的一个类型为W的Binder本地对象，使用参数c来初始化，通过它可以与运行在应用程序进程这一侧的Activity组件进行通信。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mToken</strong>：指向一个WindowToken对象，使用参数token来初始化，通过它就可以知道唯一地标识一个窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mAttrs</strong>：指向一个WindowManager.LayoutParams对象，使用参数a来初始化，通过它就可以知道当前当前所创建的WindowState对象所描述的窗口的布局参数。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mViewVisibility</strong>：这是一个整型变量，使用参数viewVisibility来初始化，表示当前所创建的WindowState对象所描述的窗口视图的可见性。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mAlpha</strong>：这是一个浮点数，使用参数a所描述的一WindowManager.LayoutParams对象的成员变量alpha来初始化，表示当前所创建的WindowState对象所描述的窗口的Alpha通道。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;此外，这段代码还创建了一个类型为DeathRecipient的死亡通知接收者deathRecipient，它是用来监控参数c所引用的一个类型为W的Binder本地对象的生命周期的。当这个Binder本地对象死亡的时候，就意味着当前所创建的WindowState对象所描述的窗口所在的应用程序进程已经退出了。接下来的这段代码就是用来注册死亡通知接收者deathRecipient的，如下所示：</p><p></p><pre name="code" class="java">            try {
                c.asBinder().linkToDeath(deathRecipient, 0);
            } catch (RemoteException e) {
                mDeathRecipient = null;
                mAttachedWindow = null;
                mLayoutAttached = false;
                mIsImWindow = false;
                mIsWallpaper = false;
                mIsFloatingLayer = false;
                mBaseLayer = 0;
                mSubLayer = 0;
                return;
            }
            mDeathRecipient = deathRecipient;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;注册完成之后，前面所创建的死亡通知接收者deathRecipient就会保存在WindowState类的成员变量mDeathRecipientk 。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续向前看代码：</p><p></p><pre name="code" class="java">            if ((mAttrs.type &gt;= FIRST_SUB_WINDOW &amp;&amp;
                    mAttrs.type &lt;= LAST_SUB_WINDOW)) {
                // The multiplier here is to reserve space for multiple
                // windows in the same type layer.
                mBaseLayer = mPolicy.windowTypeToLayerLw(
                        attachedWindow.mAttrs.type) * TYPE_LAYER_MULTIPLIER
                        + TYPE_LAYER_OFFSET;
                mSubLayer = mPolicy.subWindowTypeToLayerLw(a.type);
                mAttachedWindow = attachedWindow;
                mAttachedWindow.mChildWindows.add(this);
                mLayoutAttached = mAttrs.type !=
                        WindowManager.LayoutParams.TYPE_APPLICATION_ATTACHED_DIALOG;
                mIsImWindow = attachedWindow.mAttrs.type == TYPE_INPUT_METHOD
                        || attachedWindow.mAttrs.type == TYPE_INPUT_METHOD_DIALOG;
                mIsWallpaper = attachedWindow.mAttrs.type == TYPE_WALLPAPER;
                mIsFloatingLayer = mIsImWindow || mIsWallpaper;
            } else {
                // The multiplier here is to reserve space for multiple
                // windows in the same type layer.
                mBaseLayer = mPolicy.windowTypeToLayerLw(a.type)
                        * TYPE_LAYER_MULTIPLIER
                        + TYPE_LAYER_OFFSET;
                mSubLayer = 0;
                mAttachedWindow = null;
                mLayoutAttached = false;
                mIsImWindow = mAttrs.type == TYPE_INPUT_METHOD
                        || mAttrs.type == TYPE_INPUT_METHOD_DIALOG;
                mIsWallpaper = mAttrs.type == TYPE_WALLPAPER;
                mIsFloatingLayer = mIsImWindow || mIsWallpaper;
            }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码初始化WindowState类的以下七个成员变量：<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mBaseLayer</strong>：这是一个整型变量，用来描述一个窗口的基础Z轴位置值，这个值是与窗口类型相关的。对于子窗口来说，它的值由父窗口的基础Z轴位置值乘以常量TYPE_LAYER_MULTIPLIER再加固定偏移量TYPE_LAYER_OFFSET得到；对于非子窗口来说，它的值就是由窗口的类型来决定的。一个窗口的基础Z轴位置值是通过调用WindowManagerService类的成员变量mPolicy所描述的一个窗口管理策略器的成员函数windowTypeToLayerLw来获得的，而窗口管理策略器的成员函数windowTypeToLayerLw主要是根据窗口的类型来决定它的基础Z轴位置值的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mSubLayer</strong>：这是一个整型变量，用来描述一个子窗口相对其父窗口的Z轴偏移值。对于非子窗口来说，这个值固定为0；对于子窗口来说，这个值是由WindowManagerService类的成员变量mPolicy所描述的一个窗口管理策略器的成员函数subWindowTypeToLayerLw来获得的，而窗口管理策略器的成员函数subWindowTypeToLayerLw主要是根据子窗口的类型来决定它相对其父窗口的Z轴偏移值的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mAttachedWindow</strong>：指向一个WindowState对象，用来描述一个子窗口的父窗口。对于非子窗口来说，这个值固定为null；对于子窗口来说， 这个值使用参数attachedWindow来初始化。如果当前所创建的WindowState对象所描述的窗口是一个子窗口，那么这个子窗口还会被添加用来描述它的父窗口的一WindowState对象的成员变量mChildWindows所描述的一个子窗口列表中去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mLayoutAttached</strong>：这是一个布尔变量，用来描述一个子窗口的视图是否是嵌入在父窗口的视图里面的。对于非子窗口来说，这个值固定为false；对于子窗口来说，这个值只有子窗口的类型是非对话框时，它的值才会等于true，否则都等于false。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mIsImWindow</strong>：这是一个布尔变量，表示当前所创建的WindowState对象所描述的窗口是否是一个输入法窗口或者一个输入法对话框。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>-mIsWallpaper</strong> ：这是一个布尔变量，表示当前所创建的WindowState对象所描述的窗口是否是一个壁纸窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>&nbsp;-mIsFloatingLayer</strong> ：这是一个布尔变量，表示当前所创建的WindowState对象所描述的窗口是否是一个浮动窗口。当一个窗口是一个输入法窗口、输入法对话框口或者壁纸窗口时，它才是一个浮动窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续向前看代码：<br /></p><pre name="code" class="java">            WindowState appWin = this;
            while (appWin.mAttachedWindow != null) {
                appWin = mAttachedWindow;
            }
            WindowToken appToken = appWin.mToken;
            while (appToken.appWindowToken == null) {
                WindowToken parent = mTokenMap.get(appToken.token);
                if (parent == null || appToken == parent) {
                    break;
                }
                appToken = parent;
            }
            mRootToken = appToken;
            mAppToken = appToken.appWindowToken;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码主要用来初始化成员变量mRootToken和mAppToken。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;成员变量mRootToken的类型为WindowToken，用来描述当前所创建的WindowState对象所描述的窗口的根窗口。如果当前所创建的WindowState对象所描述的窗口是一个子窗口，那么就先找到它的父窗口，然后再找到它的父窗口所属的应用程序窗口，即Activity组件窗口，这时候找到的Activity组件窗口就是一个根窗口。如果当前所创建的WindowState对象所描述的窗口是一个子窗口，但是它不属于任何一个应用程序窗口的，那么它的父窗口就是一个根窗口。如果当前所创建的WindowState对象所描述的窗口不是一个子窗口，并且它也不属于一个应用程序窗口的，那么它本身就是一个根窗口。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;成员变量mAppToken的类型为AppWindowToken，只有当成员变量mRootToken所描述的一个根窗口是一个应用程序窗口时，它的值才不等于null。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续向前看最后一段代码：</p><p></p><pre name="code" class="java">            mSurface = null;
            mRequestedWidth = 0;
            mRequestedHeight = 0;
            mLastRequestedWidth = 0;
            mLastRequestedHeight = 0;
            mXOffset = 0;
            mYOffset = 0;
            mLayer = 0;
            mAnimLayer = 0;
            mLastLayer = 0;
        }

        ......
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码将以下十个成员变量的值设置为null或者0：<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>-mSurface</strong>：指向一个mSurface对象，用来描述窗口的绘图表面。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;<strong> -mRequestedWidth</strong>：这是一个整型变量，用来描述应用程序进程所请求的窗口宽度。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>-mRequestedHeight</strong>：这是一个整型变量，用来描述应用程序进程所请求的窗口高度。</p><p></p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; <strong>-mLastRequestedWidth</strong>：这是一个整型变量，用来描述应用程序进程上一次所请求的窗口宽度。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; <strong>-mLastRequestedHeight</strong>：这是一个整型变量，用来描述应用程序进程上一次所请求的窗口高度。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; <strong>-mXOffset</strong>：这是一个整型变量，用来描述壁纸窗口相对屏幕在X轴上的偏移量，对其它类型的窗口为说，这个值等于0。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; <strong>-mYOffset</strong>：这是一个整型变量，用来描述壁纸窗口相对屏幕在Y轴上的偏移量，对其它类型的窗口为说，这个值等于0。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; <strong>-mLayer</strong>：这是一个整型变量，用来描述窗口的Z轴位置值。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; <strong>-mAnimLayer</strong>：这是一个整型变量，用来描述窗口的Z轴位置值，它的值可能等于mLayer的值，但是在以下四种情况中不相等。当一个窗口关联有一个目标窗口的时候，那么它的值就等于mLayer的值加上目标窗口指定的一个动画层调整值；当一个窗口的根窗口是一个应用程序窗口时，那么它的值就等于mLayer的值加上根窗口指定的一个动画层调整值；当一个窗口是一个输入法窗口时，那么它的值就等于mLayer的值加上系统设置的输入法动画层调整值；当一个窗口是壁纸窗口时，那么它的值就等于mLayer的值加上系统设置的壁纸动画层调整值。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; <strong>-mLastLayer</strong>：这是一个整型变量，用描述窗口上一次所使用的mAnimLayer的值。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成WindowState的构造函数的实现了，返回到前面的Step 3中，即WindowManagerService类的成员函数addWindow中，接下来就会继续调用前面所创建的一个WindowState对象的成员函数attach来创建一个关联的SurfaceSession对象，以便可以用来和SurfaceFlinger服务通信。</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; ">&nbsp;&nbsp; &nbsp; &nbsp; Step 5.&nbsp;WindowState.attach</p><p style="margin-top: 4px; margin-right: 0px; margin-bottom: 4px; margin-left: 0px; padding-top: 2px; padding-right: 0px; padding-bottom: 2px; padding-left: 0px; "></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final class WindowState implements WindowManagerPolicy.WindowState {
        final Session mSession;
        ......

        void attach() {
            ......
            mSession.windowAddedLocked();
        }

        ......
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<br /><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;WindowState类的成员变量mSession指向的是一个Session对象，这个Session对象就是用来连接应用程序进程和WindowManagerService服务，WindowState类的成员函数attach调用它的成员函数windowAddedLocked来检查是否需要为当前正在请求增加窗口的应用程序进程创建一个SurfaceSession对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们继续分析Session类的成员函数windowAddedLocked的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 6.&nbsp;Session.windowAddedLocked</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    /**
     * All currently active sessions with clients.
     */
    final HashSet&lt;Session&gt; mSessions = new HashSet&lt;Session&gt;();
    ......

    private final class Session extends IWindowSession.Stub
            implements IBinder.DeathRecipient {
        ......

        SurfaceSession mSurfaceSession;
        int mNumWindow = 0;
        ......

        void windowAddedLocked() {
            if (mSurfaceSession == null) {
                ......
                mSurfaceSession = new SurfaceSession();
                ......
                mSessions.add(this);
            }
            mNumWindow++;
        }

        ......
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Session类的成员变量mSurfaceSession指向的是一个SurfaceSession对象，这个SurfaceSession对象是WindowManagerService服务用来与SurfaceSession服务建立连接的。Session类的成员函数windowAddedLocked首先检查这个成员变量的值是否等于null。如果等于null的话，那么就说明WindowManagerService服务尚未为当前正在请求增加窗口的应用程序进程创建一个用来连接SurfaceSession服务的SurfaceSession对象，因此，Session类的成员函数windowAddedLocked就会创建一个SurfaceSession对象，并且保存在成员变量mSurfaceSession中，并且将正在处理的Session对象添加WindowManagerService类的成员变量mSession所描述的一个HashSet中去，表示WindowManagerService服务又多了一个激活的应用程序进程连接。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Session类的另外一个成员变量mNumWindow是一个整型变量，用来描述当前正在处理的Session对象内部包含有多少个窗口，即运行在引用了当前正在处理的Session对象的应用程序进程的内部的窗口的数量。每当运行在应用程序进程中的窗口销毁时，该应用程序进程就会通知WindowManagerService服务移除用来描述该窗口状态的一个WindowState对象，并且通知它所引用的Session对象减少其成员变量mNumWindow的值。当一个Session对象的成员变量mNumWindow的值减少为0时，就说明该Session对象所描述的应用程序进程连接已经不需要了，因此，该Session对象就可以杀掉其成员变量mSurfaceSession所描述的一个SurfaceSession对象，以便可以断开和SurfaceSession服务的连接。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析SurfaceSession类的构造函数的实现，以便可以了解一个SurfaceSession对象是如何与SurfaceSession服务建立连接的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 7. new&nbsp;SurfaceSession</p><p></p><pre name="code" class="java">public class SurfaceSession {
    /** Create a new connection with the surface flinger. */
    public SurfaceSession() {
        init();
    }

    ......

    private native void init();
    ......

    private int mClient;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/SurfaceSession.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceSession类的构造函数的实现很简单，它只是调用了另外一个成员函数init来执行一些初始化操作，其实就是用来初始化SurfaceSession类的成员变量mClient。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;SurfaceSession类的成员函数init是一个JNI方法，它是由C++层的函数SurfaceSession_init来实现的，如下所示：</p><p></p><pre name="code" class="cpp">static void SurfaceSession_init(JNIEnv* env, jobject clazz)
{
    sp&lt;SurfaceComposerClient&gt; client = new SurfaceComposerClient;
    client-&gt;incStrong(clazz);
    env-&gt;SetIntField(clazz, sso.client, (int)client.get());
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/jni/android_view_Surface.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在分析函数SurfaceSession_init的实现之前，我们首先看看全局变量sso的定义，如下所示：</p><p></p><pre name="code" class="cpp">struct sso_t {
    jfieldID client;
};
static sso_t sso;</pre>&nbsp;&nbsp; &nbsp; &nbsp; 它是一个类型为sso_t的结构体变量，它的成员变量client描述的是SurfaceSession类的成员变量mClient在SurfaceSession类中的偏移量：<p></p><p></p><pre name="code" class="cpp">void nativeClassInit(JNIEnv* env, jclass clazz)
{
    ......

    jclass surfaceSession = env-&gt;FindClass(&quot;android/view/SurfaceSession&quot;);
    sso.client = env-&gt;GetFieldID(surfaceSession, &quot;mClient&quot;, &quot;I&quot;);

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 回到函数SurfaceSession_init中，它首先创建一个SurfaceComposerClient对象client，接着再增加这个SurfaceComposerClient对象的强引用计数，因为再接下来会将这个SurfaceComposerClient对象的地址值保存在参数clazz所描述的一个SurfaceSession对象的成员变量mClient中，这相当于是参数clazz所描述的一个SurfaceSession对象引用了刚才所创建的SurfaceComposerClient对象client。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>这一系列的文章中，我们已经分析过SurfaceComposerClient类的作用了，这主要就是用来在应用程序进程和SurfaceFlinger服务之间建立连接的，以便应用程序进程可以为运行在它里面的应用程序窗口请求SurfaceComposerClient创建绘制表面（Surface）的操作等。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这样，每一个Java层的SurfaceSession对象在C++层就都有一个对应的SurfaceComposerClient对象，因此，Java层的应用程序就可以通过SurfaceSession类来和SurfaceFlinger服务建立连接。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成一个WindowState对象的创建过程了，通过这个过程我们就可以知道，每一个Activity组件窗口在WindowManagerService服务内部都有一个对应的WindowState对象，用来描述它的窗口状态。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们也分析完成Android应用程序窗口与WindowManagerService服务的连接过程了。从这个连接过程以及前面<a href="http://blog.csdn.net/luoshengyang/article/details/8223770">Android应用程序窗口（Activity）的窗口对象（Window）的创建过程分析</a>和<a href="http://blog.csdn.net/luoshengyang/article/details/8245546">Android应用程序窗口（Activity）的视图对象（View）的创建过程分析</a>这两篇文章，我们就可以知道，为了实现一个Activity组件的UI，无论是应用程序进程，还是WindowManagerService，都做了大量的工作，例如，应用程序进程为它创建一个窗口（Window）对象、一个视图（View）对象、一个ViewRoot对象、一个W对象，WindowManagerService服务为它创建一个AppWindowToken对象和一个WindowState对象。此外，WindowManagerService服务还为一个Activity组件所运行在的应用程序进程创建了一个Session对象。理解这些对象的实现以及作用对我们了解Android应用程序窗口的实现框架以及WindowManagerService服务的实现原理都是非常重要的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 虽然到目前为止，我们已经为Android应用程序窗口创建了很多对象，但是我们仍然还有一个最重要的对象还没有创建，那就是Android应用程序窗口的绘图表面，即用来渲染UI的Surface还没有创建。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>这一系列的文章可以知道，这个Surface是要请求SurfaceFlinger服务来创建的，因此，在接下来的一篇文章中，我们就将继续分析Android应用程序窗口的绘图表面（Surface）的创建过程，敬请关注！</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-12-17 0:57:11 <a href="http://blog.csdn.net/luoshengyang/article/details/8275938">原文链接</a>
            </div>
            <div>
            阅读：4576 评论：30 <a href="http://blog.csdn.net/luoshengyang/article/details/8275938#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8303098</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8303098</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-12-24 0:55:51</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前文中，我们分析了应用程序窗口连接到</span><span style="color:black;">WindowManagerService</span><span style="color:black;">服务的过程。在这个过程中，</span><span style="color:black;">WindowManagerService</span><span style="color:black;">服务会为应用程序窗口创建过一个到</span><span style="color:black;">SurfaceFlinger</span><span style="color:black;">服务的连接。有了这个连接之后，</span><span style="color:black;">WindowManagerService</span><span style="color:black;">服务就可以为应用程序窗口创建绘图表面了，以便可以用来渲染窗口的</span><span style="color:black;">UI</span><span style="color:black;">。在本文中，我们就详细分析应用程序窗口的绘图表面的创建过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>和<a href="http://blog.csdn.net/luoshengyang/article/details/8010977">Android系统Surface机制的SurfaceFlinger服务简要介绍和学习计划</a>这两个系列的文章可以知道，每一个在C++层实现的应用程序窗口都需要有一个绘图表面，然后才可以将自己的UI表现出来。这个绘图表面是需要由应用程序进程请求SurfaceFlinger服务来创建的，在SurfaceFlinger服务内部使用一个Layer对象来描述，同时，SurfaceFlinger服务会返回一个实现了ISurface接口的Binder本地对象给应用程序进程，于是，应用程序进程就可以获得一个实现了ISurface接口的Binder代理对象。有了这个实现了ISurface接口的Binder代理对象之后，在C++层实现的应用程序窗口就可以请求SurfaceFlinger服务分配图形缓冲区以及渲染已经填充好UI数据的图形缓冲区了。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;对于在Java层实现的Android应用程序窗口来说，它也需要请求SurfaceFlinger服务为它创建绘图表面，这个绘图表面使用一个Surface对象来描述。由于在Java层实现的Android应用程序窗口还要接受WindowManagerService服务管理，因此，它的绘图表面的创建流程就会比在C++层实现的应用程序窗口复杂一些。具体来说，就是在在Java层实现的Android应用程序窗口的绘图表面是通过两个Surface对象来描述，一个是在应用程序进程这一侧创建的，另一个是在WindowManagerService服务这一侧创建的，它们对应于SurfaceFlinger服务这一侧的同一个Layer对象，如图1所示：</span></p><p style="text-align: center;"><span style="color:black;"><img src="http://img.my.csdn.net/uploads/201212/19/1355850216_7048.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color:black;">图1 应用程序窗口的绘图表面的模型图</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在应用程序进程这一侧，每一个应用程序窗口，即每一个Activity组件，都有一个关联的Surface对象，这个Surface对象是保在在一个关联的ViewRoot对象的成员变量mSurface中的，如图2所示：</span></p><p style="text-align: center;"><span style="color: black; "><img width="684" src="http://img.my.csdn.net/uploads/201211/17/1353087703_2343.jpg" alt="" /><br /></span></p><p style="text-align: center;"><span style="color: black; ">图2 应用程序窗口在应用程序进程这一侧的Surface的实现</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;图2的类关系图的详细描述可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文的图6，这里我们只关注Surface类的实现。在应用程序进程这一侧，每一个Java层的Surface对都对应有一个C++层的Surface对象，并且后者的地址值保存在前者的成员变量mNativeSurface中。C++层的Surface类的实现以及作用可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>这个系列的文章。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在WindowManagerService服务这一侧，每一个应用程序窗口，即每一个Activity组件，都有一个对应的WindowState对象，这个WindowState对象的成员变量mSurface同样是指向了一个Surface对象，如图3所示：</span></p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201211/17/1353087795_6634.jpg" alt="" /><br /></p><p style="text-align: center;">图3 应用程序窗口在WindowManagerService服务这一侧的Surface的实现</p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;图3的类关系图的详细描述可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文的图7，这里我们同样只关注Surface类的实现。在WindowManagerService服务这一侧，每一个Java层的Surface对都对应有一个C++层的SurfaceControl对象，并且后者的地址值保存在前者的成员变量mSurfaceControl中。C++层的SurfaceControl类的实现以及作用同样可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>这个系列的文章。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 一个应用程序窗口分别位于应用程序进程和WindowManagerService服务中的两个Surface对象有什么区别呢？虽然它们都是用来操作位于SurfaceFlinger服务中的同一个Layer对象的，不过，它们的操作方式却不一样。具体来说，就是位于应用程序进程这一侧的Surface对象负责绘制应用程序窗口的UI，即往应用程序窗口的图形缓冲区填充UI数据，而位于WindowManagerService服务这一侧的Surface对象负责设置应用程序窗口的属性，例如位置、大小等属性。这两种不同的操作方式分别是通过C++层的Surface对象和SurfaceControl对象来完成的，因此，位于应用程序进程和WindowManagerService服务中的两个Surface对象的用法是有区别的。之所以会有这样的区别，是因为绘制应用程序窗口是独立的，由应用程序进程来完即可，而设置应用程序窗口的属性却需要全局考虑，即需要由WindowManagerService服务来统筹安排，例如，一个应用程序窗口的Z轴坐标大小要考虑它到的窗口类型以及它与系统中的其它窗口的关系。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;说到这里，另外一个问题又来了，由于一个应用程序窗口对应有两个Surface对象，那么它们是如何创建出来的呢？简单地说，就是按照以下步骤来创建：</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 1. 应用程序进程请求WindowManagerService服务为一个应用程序窗口创建一个Surface对象；</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 2. WindowManagerService服务请求SurfaceFlinger服务创建一个Layer对象，并且获得一个ISurface接口；</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 3.&nbsp;WindowManagerService服务将获得的ISurface接口保存在其内部的一个Surface对象中，并且将该ISurface接口返回给应用程序进程；</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 4. 应用程序进程得到WindowManagerService服务返回的ISurface接口之后，再将其封装成其内部的另外一个Surface对象中。</span></p><p style="text-align: left;"><span style="color: black; ">&nbsp;&nbsp; &nbsp; &nbsp; 那么应用程序窗口的绘图表面又是什么时候创建的呢？一般是在不存在的时候就创建，因为应用程序窗口在运行的过程中，它的绘图表面会根据需要来销毁以及重新创建的，例如，应用程序窗口在第一次显示的时候，就会请求WindowManagerService服务为其创建绘制表面。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8245546">Android应用程序窗口（Activity）的视图对象（View）的创建过程分析</a>一文可以知道，当一个应用程序窗口被激活并且它的视图对象创建完成之后，应用程序进程就会调用与其所关联的一个ViewRoot对象的成员函数requestLayout来请求对其UI进行布局以及显示。由于这时候应用程序窗口的绘图表面尚未创建，因此，ViewRoot类的成员函数requestLayout就会请求WindowManagerService服务来创建绘图表面。接下来，我们就从ViewRoot类的成员函数requestLayout开始，分析应用程序窗口的绘图表面的创建过程，如图4所示：</span></p><p style="text-align: center;"><span style="color: black; "><img width="614" src="http://img.my.csdn.net/uploads/201212/20/1355933934_6913.jpg" alt="" /><br /></span></p><p style="text-align: center;">图4 应用程序窗口的绘图表面的创建过程</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程可以分为10个步骤，接下来我们就详细分析每一个步骤。</p><p style="text-align: left;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. ViewRoot.requestLayout</p><p style="text-align: left;"></p><pre name="code" class="java">public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......

    boolean mLayoutRequested;
    ......

    public void requestLayout() {
        checkThread();
        mLayoutRequested = true;
        scheduleTraversals();
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。<br /><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的成员函数requestLayout首先调用另外一个成员函数checkThread来检查当前线程是否就是创建当前正在处理的ViewRoot对象的线程。如果不是的话，那么ViewRoot类的成员函数checkThread就会抛出一个异常出来。ViewRoot类是从Handler类继承下来的，用来处理应用程序窗口的UI布局和渲染等消息。由于这些消息都是与Ui相关的，因此它们就需要在UI线程中处理，这样我们就可以推断出当前正在处理的ViewRoot对象是要应用程序进程的UI线程中创建的。进一步地，我们就可以推断出ViewRoot类的成员函数checkThread实际上就是用来检查当前线程是否是应用程序进程的UI线程，如果不是的话，它就会抛出一个异常出来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;通过了上述检查之后，ViewRoot类的成员函数requestLayout首先将其成员变量mLayoutRequested的值设置为true，表示应用程序进程的UI线程正在被请求执行一个UI布局操作，接着再调用另外一个成员函数scheduleTraversals来继续执行UI布局的操作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2.&nbsp;ViewRoot.scheduleTraversals</p><p></p><pre name="code" class="java">public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......
 
    boolean mTraversalScheduled;
    ......

    public void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            sendEmptyMessage(DO_TRAVERSAL);
        }
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的成员变量mTraversalScheduled用来表示应用程序进程的UI线程是否已经调度了一个DO_TRAVERSAL消息。如果已经调度了的话，它的值就会等于true。在这种情况下，&nbsp;ViewRoot类的成员函数scheduleTraversals就什么也不做，否则的话，它就会首先将成员变量mTraversalScheduled的值设置为true，然后再调用从父类Handler继承下来的成员函数sendEmptyMessage来往应用程序进程的UI线程发送一个DO_TRAVERSAL消息。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个类型为DO_TRAVERSAL的消息是由ViewRoot类的成员函数performTraversals来处理的，因此，接下来我们就继续分析ViewRoot类的成员函数performTraversals的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 3.&nbsp;ViewRoot.performTraversals</p><p></p><pre name="code" class="java">public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......

    View mView;
    ......

    boolean mLayoutRequested;
    boolean mFirst;
    ......
    boolean mFullRedrawNeeded;
    ......

    private final Surface mSurface = new Surface();
    ......

    private void performTraversals() {
        ......

        final View host = mView;
        ......

        mTraversalScheduled = false;
        ......
        boolean fullRedrawNeeded = mFullRedrawNeeded;
        boolean newSurface = false;
        ......

        if (mLayoutRequested) {
            ......

            host.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            
            .......
        }

        ......

        int relayoutResult = 0;
        if (mFirst || windowShouldResize || insetsChanged
                || viewVisibilityChanged || params != null) {
            ......

            boolean hadSurface = mSurface.isValid();
            try {
                ......

                relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);
                ......

                if (!hadSurface) {
                    if (mSurface.isValid()) {
                        ......
                        newSurface = true;
                        fullRedrawNeeded = true;
                        ......
                    }
                } 
                ......
            } catch (RemoteException e) {
            }

            ......
        }

        final boolean didLayout = mLayoutRequested;
        ......

        if (didLayout) {
            mLayoutRequested = false;
            ......

            host.layout(0, 0, host.mMeasuredWidth, host.mMeasuredHeight);

            ......
        }

        ......

        mFirst = false;
        ......

        boolean cancelDraw = attachInfo.mTreeObserver.dispatchOnPreDraw();

        if (!cancelDraw &amp;&amp; !newSurface) {
            mFullRedrawNeeded = false;
            draw(fullRedrawNeeded);

            ......
        } else {
            ......

            // Try again
            scheduleTraversals();
        }
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的成员函数performTraversals的实现是相当复杂的，这里我们分析它的实现框架，在以后的文章中，我们再详细分析它的实现细节。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在分析ViewRoot类的成员函数performTraversals的实现框架之前，我们首先了解ViewRoot类的以下五个成员变量：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--mView</strong>：它的类型为View，但它实际上指向的是一个DecorView对象，用来描述应用程序窗口的顶级视图，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8245546">Android应用程序窗口（Activity）的视图对象（View）的创建过程分析</a>一文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--mLayoutRequested</strong>：这是一个布尔变量，用来描述应用程序进程的UI线程是否需要正在被请求执行一个UI布局操作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--mFirst</strong>：这是一个布尔变量，用来描述应用程序进程的UI线程是否第一次处理一个应用程序窗口的UI。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>&nbsp;--mFullRedrawNeeded</strong>：这是一个布尔变量，用来描述应用程序进程的UI线程是否需要将一个应用程序窗口的全部区域都重新绘制。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;<strong>--mSurface</strong>：它指向一个Java层的Surface对象，用来描述一个应用程序窗口的绘图表面。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;注意，成员变量mSurface所指向的Surface对象在创建的时候，还没有在C++层有一个关联的Surface对象，因此，这时候它描述的就是一个无效的绘图表面。另外，这个Surface对象在应用程序窗口运行的过程中，也会可能被销毁，因此，这时候它描述的绘图表面也会变得无效。在上述两种情况中，我们都需要请求WindowManagerService服务来为当前正在处理的应用程序窗口创建有一个有效的绘图表面，以便可以在上面渲染UI。这个创建绘图表面的过程正是本文所要关心的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;理解了上述五个成员变量之后，我们就可以分析ViewRoot类的成员函数performTraversals的实现框架了，如下所示：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 将成员变量mView和mFullRedrawNeeded的值分别保存在本地变量host和fullRedrawNeeded中，并且将成员变量mTraversalScheduled的值设置为false，表示应用程序进程的UI线程中的DO_TRAVERSAL消息已经被处理了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 本地变量newSurface用来描述当前正在处理的应用程序窗口在本轮的DO_TRAVERSAL消息处理中是否新创建了一个绘图表面，它的初始值为false。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. 如果成员变量mLayoutRequested的值等于true，那么就表示应用程序进程的UI线程正在被请求对当前正在处理的应用程序窗口执行一个UI布局操作，因此，这时候就会调用本地变量host所描述的一个顶层视图对象的成员函数measure来测量位于各个层次的UI控件的大小。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;4. 如果当前正在处理的应用程序窗口的UI是第一次被处理，即成员变量mFirst的值等于true，或者当前正在处理的应用程序窗口的大小发生了变化，即本地变量windowShouldResize的值等于true，或者当前正在处理的应用程序窗口的边衬发生了变化，即本地变量insetsChanged的值等于true，或者正在处理的应用程序窗口的可见性发生了变化，即本地变量viewVisibilityChanged的值等于true，或者正在处理的应用程序窗口的UI布局参数发生了变化，即本地变量params指向了一个WindowManager.LayoutParams对象，那么应用程序进程的UI线程就会调用另外一个成员函数relayoutWindow来请求WindowManagerService服务重新布局系统中的所有窗口。WindowManagerService服务在重新布局系统中的所有窗口的过程中，如果发现当前正在处理的应用程序窗口尚未具有一个有效的绘图表面，那么就会为它创建一个有效的绘图表面，这一点是我们在本文中所要关注的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;5. 应用程序进程的UI线程在调用ViewRoot类的成员函数relayoutWindow来请求WindowManagerService服务重新布局系统中的所有窗口之前，会调用成员变量mSurface所指向的一个Surface对象的成员函数isValid来判断它描述的是否是一个有效的绘图表面，并且将结果保存在本地变量hadSurface中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;6.&nbsp;应用程序进程的UI线程在调用ViewRoot类的成员函数relayoutWindow来请求WindowManagerService服务重新布局系统中的所有窗口之后，又会继续调用成员变量mSurface所指向的一个Surface对象的成员函数isValid来判断它描述的是否是一个有效的绘图表面。如果这时候成员变量mSurface所指向的一个Surface对象描述的是否是一个有效的绘图表面，并且本地变量hadSurface的值等于false，那么就说明WindowManagerService服务为当前正在处理的应用程序窗口新创建了一个有效的绘图表面，于是就会将本地变量newSurface和fullRedrawNeeded的值均修改为true。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;7.&nbsp;应用程序进程的UI线程再次判断mLayoutRequested的值是否等于true。如果等于的话，那么就说明需要对当前正在处理的应用程序窗口的UI进行重新布局，这是通过调用本地变量host所描述的一个顶层视图对象的成员函数layout来实现的。在对当前正在处理的应用程序窗口的UI进行重新布局之前，应用程序进程的UI线程会将成员变量mLayoutRequested的值设置为false，表示之前所请求的一个UI布局操作已经得到处理了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;8.&nbsp;应用程序进程的UI线程接下来就要开始对当前正在处理的应用程序窗口的UI进行重新绘制了，不过在重绘之前，会先询问一下那些注册到当前正在处理的应用程序窗口中的Tree Observer，即调用它们的成员函数dispatchOnPreDraw，看看它们是否需要取消接下来的重绘操作，这个询问结果保存在本地变量cancelDraw中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;9. 如果本地变量cancelDraw的值等于false，并且本地变量newSurface的值也等于false，那么就说明注册到当前正在处理的应用程序窗口中的Tree Observer不要求取消当前的这次重绘操作，并且当前正在处理的应用程序窗口也没有获得一个新的绘图表面。在这种情况下，应用程序进程的UI线程就会调用ViewRoot类的成员函数draw来对当前正在处理的应用程序窗口的UI进行重绘。在重绘之前，还会将ViewRoot类的成员变量mFullRedrawNeeded的值重置为false。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 10.&nbsp;如果本地变量cancelDraw的值等于true，或者本地变量newSurface的值等于true，那么就说明注册到当前正在处理的应用程序窗口中的Tree Observer要求取消当前的这次重绘操作，或者当前正在处理的应用程序窗口获得了一个新的绘图表面。在这两种情况下，应用程序进程的UI线程就不能对当前正在处理的应用程序窗口的UI进行重绘了，而是要等到下一个DO_TRAVERSAL消息到来的时候，再进行重绘，以便使得当前正在处理的应用程序窗口的各项参数可以得到重新设置。下一个DO_TRAVERSAL消息需要马上被调度，因此，应用程序进程的UI线程就会重新执行ViewRoot类的成员函数scheduleTraversals。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这样，我们就分析完成ViewRoot类的成员函数performTraversals的实现框架了，接下来我们就继续分析ViewRoot类的成员函数relayoutWindow的实现，以便可以看到当前正在处理的应用程序窗口的绘图表面是如何创建的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 4.&nbsp;ViewRoot.relayoutWindow</p><p></p><pre name="code" class="java">public final class ViewRoot extends Handler implements ViewParent,  
        View.AttachInfo.Callbacks {  
    ......  
  
    static IWindowSession sWindowSession;  
    ......  

    final W mWindow;
    ......
  
    private final Surface mSurface = new Surface();  
    ......  
  
    private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,  
            boolean insetsPending) throws RemoteException {  
        ......  
  
        int relayoutResult = sWindowSession.relayout(  
                mWindow, params,  
                (int) (mView.mMeasuredWidth * appScale + 0.5f),  
                (int) (mView.mMeasuredHeight * appScale + 0.5f),  
                viewVisibility, insetsPending, mWinFrame,  
                mPendingContentInsets, mPendingVisibleInsets,  
                mPendingConfiguration, mSurface);  
        ......  
  
        return relayoutResult;  
    }  
  
    ......  
}  </pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;ViewRoot类的成员函数relayoutWindow调用静态成员变量sWindowSession所描述的一个实现了IWindowSession接口的Binder代理对象的成员函数relayout来请求WindowManagerService服务对成员变量mWindow所描述的一个应用程序窗口的UI进行重新布局，同时，还会将成员变量mSurface所描述的一个Surface对象传递给WindowManagerService服务，以便WindowManagerService服务可以根据需要来重新创建一个绘图表面给成员变量mWindow所描述的一个应用程序窗口使用。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 实现了IWindowSession接口的Binder代理对象是由IWindowSession.Stub.Proxy类来描述的，接下来我们就继续分析它的成员函数relayout的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 5.&nbsp;IWindowSession.Stub.Proxy.relayout</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;IWindowSession接口是使用AIDL语言来描述的，如下所示：</p><p></p><pre name="code" class="java">interface IWindowSession {
    ......

    int relayout(IWindow window, in WindowManager.LayoutParams attrs,
            int requestedWidth, int requestedHeight, int viewVisibility,
            boolean insetsPending, out Rect outFrame, out Rect outContentInsets,
            out Rect outVisibleInsets, out Configuration outConfig,
            out Surface outSurface);

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个接口定义在frameworks/base/core/java/android/view/IWindowSession.aidl文件中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;使用AIDL语言来描述的IWindowSession接口被编译后，就会生成一个使用Java语言来描述的IWindowSession.Stub.Proxy类，它的成员函数relayout的实现如下所示：</p><p></p><pre name="code" class="java">public interface IWindowSession extends android.os.IInterface
{
    ......

    public static abstract class Stub extends android.os.Binder implements android.view.IWindowSession
    {
         ......

         private static class Proxy implements android.view.IWindowSession
         {
             private android.os.IBinder mRemote;
             ......

             public int relayout(android.view.IWindow window, android.view.WindowManager.LayoutParams attrs, 
                   int requestedWidth, int requestedHeight, int viewVisibility, boolean insetsPending, 
                   android.graphics.Rect outFrame, 
                   android.graphics.Rect outContentInsets, 
                   android.graphics.Rect outVisibleInsets, 
                   android.content.res.Configuration outConfig, 
                   android.view.Surface outSurface) throws android.os.RemoteException
            {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();

                int _result;
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    _data.writeStrongBinder((((window!=null))?(window.asBinder()):(null)));

                    if ((attrs!=null)) {
                        _data.writeInt(1);
                        attrs.writeToParcel(_data, 0);
                    }
                    else {
                        _data.writeInt(0);
                    }

                    _data.writeInt(requestedWidth);
                    _data.writeInt(requestedHeight);
                    _data.writeInt(viewVisibility);
                    _data.writeInt(((insetsPending)?(1):(0)));
                   
                    mRemote.transact(Stub.TRANSACTION_relayout, _data, _reply, 0);
                
                    _reply.readException();
                    _result = _reply.readInt();

                    if ((0!=_reply.readInt())) {
                        outFrame.readFromParcel(_reply);
                    }

                    if ((0!=_reply.readInt())) {
                        outContentInsets.readFromParcel(_reply);
                    }

                    if ((0!=_reply.readInt())) {
                        outVisibleInsets.readFromParcel(_reply);
                    }

                    if ((0!=_reply.readInt())) {
                        outConfig.readFromParcel(_reply);
                    }

                    if ((0!=_reply.readInt())) {
                        outSurface.readFromParcel(_reply);
                    }

                } finally {
                    _reply.recycle();
                    _data.recycle();
                }

                return _result;
            }

            ......
        }

        ......
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/view/IWindowSession.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;IWindowSession.Stub.Proxy类的成员函数relayout首先将从前面传进来的各个参数写入到Parcel对象_data中，接着再通过其成员变量mRemote所描述的一个Binder代理对象向运行在WindowManagerService服务内部的一个Session对象发送一个类型为TRANSACTION_relayout的进程间通信请求，其中，这个Session对象是用来描述从当前应用程序进程到WindowManagerService服务的一个连接的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当运行在WindowManagerService服务内部的Session对象处理完成当前应用程序进程发送过来的类型为TRANSACTION_relayout的进程间通信请求之后，就会将处理结果写入到Parcel对象_reply中，并且将这个Parcel对象_reply返回给当前应用程序进程处理。返回结果包含了一系列与参数window所描述的应用程序窗口相关的参数，如下所示：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. 窗口的大小：最终保存在输出参数outFrame中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. 窗口的内容区域边衬大小：最终保存在输出参数outContentInsets中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 3. 窗口的可见区域边衬大小：最终保存在输出参数outVisibleInsets中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 4. 窗口的配置信息：最终保存在输出参数outConfig中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 5. 窗口的绘图表面：最终保存在输出参数outSurface中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这里我们只关注从WindowManagerService服务返回来的窗口绘图表面是如何保存到输出参数outSurface中的，即关注Surface类的成员函数readFromParcel的实现。从前面的调用过程可以知道，输出参数outSurface描述的便是当前正在处理的应用程序窗口的绘图表面，将WindowManagerService服务返回来的窗口绘图表面保存在它里面，就相当于是为当前正在处理的应用程序窗口创建了一个绘图表面。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在分析Surface类的成员函数readFromParcel的实现之前，我们先分析Session类的成员函数relayout的实现，因为它是用来处理类型为TRANSACTION_relayout的进程间通信请求的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 6.&nbsp;Session.relayout</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final class Session extends IWindowSession.Stub
            implements IBinder.DeathRecipient {
        ......

        public int relayout(IWindow window, WindowManager.LayoutParams attrs,
                int requestedWidth, int requestedHeight, int viewFlags,
                boolean insetsPending, Rect outFrame, Rect outContentInsets,
                Rect outVisibleInsets, Configuration outConfig, Surface outSurface) {
            //Log.d(TAG, &quot;&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from &quot; + Binder.getCallingPid());
            int res = relayoutWindow(this, window, attrs,
                    requestedWidth, requestedHeight, viewFlags, insetsPending,
                    outFrame, outContentInsets, outVisibleInsets, outConfig, outSurface);
            //Log.d(TAG, &quot;&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to &quot; + Binder.getCallingPid());
            return res;
        }

        ......

    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Session类的成员函数relayout调用了外部类WindowManagerService的成员函数relayoutWindow来对参数参数window所描述的一个应用程序窗口的UI进行布局，接下来我们就继续分析WindowManagerService类的成员函数relayoutWindow的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 7.&nbsp;WindowManagerService.relayoutWindow</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    public int relayoutWindow(Session session, IWindow client,
            WindowManager.LayoutParams attrs, int requestedWidth,
            int requestedHeight, int viewVisibility, boolean insetsPending,
            Rect outFrame, Rect outContentInsets, Rect outVisibleInsets,
            Configuration outConfig, Surface outSurface) {
        ......

        synchronized(mWindowMap) {
            WindowState win = windowForClientLocked(session, client, false);
            if (win == null) {
                return 0;
            }

            if (viewVisibility == View.VISIBLE &amp;&amp;
                    (win.mAppToken == null || !win.mAppToken.clientHidden)) {
                ......

                try {
                    Surface surface = win.createSurfaceLocked();
                    if (surface != null) {
                        outSurface.copyFrom(surface);
                        ......
                    } else {
                        // For some reason there isn't a surface.  Clear the
                        // caller's object so they see the same state.
                        outSurface.release();
                    }
                } catch (Exception e) {
                    ......
                    return 0;
                }
               
                ......
            }

            ......
        }

        return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0)
                | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
    }
    
    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService类的成员函数relayoutWindow的实现是相当复杂的，这里我们只关注与创建应用程序窗口的绘图表面相关的代码，在后面的文章中，我们再详细分析它的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;简单来说，WindowManagerService类的成员函数relayoutWindow根据应用程序进程传递过来的一系列数据来重新设置由参数client所描述的一个应用程序窗口的大小和可见性等信息，而当一个应用程序窗口的大小或者可见性发生变化之后，系统中当前获得焦点的窗口，以及输入法窗口和壁纸窗口等都可能会发生变化，而且也会对其它窗口产生影响，因此，这时候WindowManagerService类的成员函数relayoutWindow就会对系统中的窗口的布局进行重新调整。对系统中的窗口的布局进行重新调整的过程是整个WindowManagerService服务最为复杂和核心的内容，我们同样是在后面的文章中再详细分析。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;现在，我们就主要分析参数client所描述的一个应用程序窗口的绘图表面的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService类的成员函数relayoutWindow首先获得与参数client所对应的一个WindowState对象win，这是通过调用WindowManagerService类的成员函数windowForClientLocked来实现的。如果这个对应的WindowState对象win不存在，那么就说明应用程序进程所请求处理的应用程序窗口不存在，这时候WindowManagerService类的成员函数relayoutWindow就直接返回一个0值给应用程序进程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService类的成员函数relayoutWindow接下来判断参数client所描述的一个应用程序窗口是否是可见的。一个窗口只有在可见的情况下，WindowManagerService服务才会为它创建一个绘图表面。&nbsp;一个窗口是否可见由以下两个条件决定：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 参数viewVisibility的值等于View.VISIBLE，表示应用程序进程请求将它设置为可见的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp;WindowState对象win的成员变量mAppToken不等于null，并且它所描述的一个AppWindowToken对象的成员变量clientHidden的值等于false。这意味着参数client所描述的窗口是一个应用程序窗口，即一个Activity组件窗口，并且这个Activity组件当前是处于可见状态的。当一个Activity组件当前是处于不可见状态时，它的窗口就也必须是处于不可见状态。WindowState类的成员变量mAppToken的具体描述可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;注意，当WindowState对象win的成员变量mAppToken等于null时，只要满足条件1就可以了，因为这时候参数client所描述的窗口不是一个Activity组件窗口，它的可见性不像Activity组件窗口一样受到Activity组件的可见性影响。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们假设参数client所描述的是一个应用程序窗口，并且这个应用程序窗口是可见的，那么WindowManagerService类的成员函数relayoutWindow接下来就会调用WindowState对象win的成员函数createSurfaceLocked来为它创建一个绘图表面。如果这个绘图表面能创建成功，那么WindowManagerService类的成员函数relayoutWindow就会将它的内容拷贝到输出参数outSource所描述的一个Surface对象去，以便可以将它返回给应用程序进程处理。另一方面，如果这个绘图表面不能创建成功，那么WindowManagerService类的成员函数relayoutWindow就会将输出参数outSource所描述的一个Surface对象的内容释放掉，以便应用程序进程知道该Surface对象所描述的绘图表面已经失效了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析WindowState类的成员函数createSurfaceLocked的实现，以便可以了解一个应用程序窗口的绘图表面的创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 8. WindowState.createSurfaceLocked</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final class WindowState implements WindowManagerPolicy.WindowState {
        ......

        Surface mSurface;
        ......
    
        Surface createSurfaceLocked() {
            if (mSurface == null) {
                mReportDestroySurface = false;
                mSurfacePendingDestroy = false;
                mDrawPending = true;
                mCommitDrawPending = false;
                mReadyToShow = false;
                if (mAppToken != null) {
                    mAppToken.allDrawn = false;
                }

                int flags = 0;
                if (mAttrs.memoryType == MEMORY_TYPE_PUSH_BUFFERS) {
                    flags |= Surface.PUSH_BUFFERS;
                }

                if ((mAttrs.flags&amp;WindowManager.LayoutParams.FLAG_SECURE) != 0) {
                    flags |= Surface.SECURE;
                }

                ......

                int w = mFrame.width();
                int h = mFrame.height();
                if ((mAttrs.flags &amp; LayoutParams.FLAG_SCALED) != 0) {
                    // for a scaled surface, we always want the requested
                    // size.
                    w = mRequestedWidth;
                    h = mRequestedHeight;
                }

                // Something is wrong and SurfaceFlinger will not like this,
                // try to revert to sane values
                if (w &lt;= 0) w = 1;
                if (h &lt;= 0) h = 1;

                mSurfaceShown = false;
                mSurfaceLayer = 0;
                mSurfaceAlpha = 1;
                mSurfaceX = 0;
                mSurfaceY = 0;
                mSurfaceW = w;
                mSurfaceH = h;
                try {
                    mSurface = new Surface(
                            mSession.mSurfaceSession, mSession.mPid,
                            mAttrs.getTitle().toString(),
                            0, w, h, mAttrs.format, flags);
                    ......
                } catch (Surface.OutOfResourcesException e) {
                    ......
                    reclaimSomeSurfaceMemoryLocked(this, &quot;create&quot;);
                    return null;
                } catch (Exception e) {
                    ......
                    return null;
                }
                Surface.openTransaction();
                try {
                    try {
                        mSurfaceX = mFrame.left + mXOffset;
                        mSurfaceY = mFrame.top + mYOffset;
                        mSurface.setPosition(mSurfaceX, mSurfaceY);
                        mSurfaceLayer = mAnimLayer;
                        mSurface.setLayer(mAnimLayer);
                        mSurfaceShown = false;
                        mSurface.hide();
                        if ((mAttrs.flags&amp;WindowManager.LayoutParams.FLAG_DITHER) != 0) {
                            ......
                            mSurface.setFlags(Surface.SURFACE_DITHER,
                                    Surface.SURFACE_DITHER);
                        }
                    } catch (RuntimeException e) {
                        ......
                        reclaimSomeSurfaceMemoryLocked(this, &quot;create-init&quot;);
                    }
                    mLastHidden = true;
                } finally {
                    ......
                    Surface.closeTransaction();
                }
                ......
            }
            return mSurface;
        }

        ......
    }

    ......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在创建一个应用程序窗口的绘图表面之前，我们需要知道以下数据：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 应用程序窗口它所运行的应用程序进程的PID。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 与应用程序窗口它所运行的应用程序进程所关联的一个SurfaceSession对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3.&nbsp;应用程序窗口的标题。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;4. 应用程序窗口的像素格式。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;5.&nbsp;应用程序窗口的宽度。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;6.&nbsp;应用程序窗口的高度。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;7. 应用程序窗口的图形缓冲区属性标志。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;第1个和第2个数据可以通过当前正在处理的WindowState对象的成员变量mSession所描述的一个Session对象的成员变量mPid和mSurfaceSession来获得；第3个和第4个数据可以通过当前正在处理的WindowState对象的成员变量mAttr所描述的一个WindowManager.LayoutParams对象的成员函数getTitle以及成员变量format来获得；接下来我们就分析后面3个数据是如何获得的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;WindowState类的成员变量mFrame的类型为Rect，它用来描述应用程序窗口的位置和大小，它们是由WindowManagerService服务根据屏幕大小以及其它属性计算出来的，因此，通过调用过它的成员函数width和height就可以得到要创建绘图表面的应用程序窗口的宽度和高度，并且保存在变量w和h中。但是，当当前正在处理的WindowState对象的成员变量mAttr所描述的一个WindowManager.LayoutParams对象的成员变量flags的LayoutParams.FLAG_SCALED位不等于0时，就说明应用程序进程指定了该应用程序窗口的大小，这时候指定的应用程序窗口的宽度和高度就保存在WindowState类的成员变量mRequestedWidth和mRequestedHeight中，因此，我们就需要将当前正在处理的WindowState对象的成员变量mRequestedWidth和mRequestedHeight的值分别保存在变量w和h中。经过上述两步计算之后，如果得到的变量w和h等于0，那么就说明当前正在处理的WindowState对象所描述的应用程序窗口的大小还没有经过计算，或者还没有被指定过，这时候就需要将它们的值设置为1，避免接下来创建一个大小为0的绘图表面。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;如果当前正在处理的WindowState对象的成员变量mAttr所描述的一个WindowManager.LayoutParams对象的成员变量memoryType的值等于MEMORY_TYPE_PUSH_BUFFERS，那么就说明正在处理的应用程序窗口不拥有专属的图形缓冲区，这时候就需要将用来描述正在处理的应用程序窗口的图形缓冲区属性标志的变量flags的Surface.PUSH_BUFFERS位设置为1。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 此外，如果当前正在处理的WindowState对象的成员变量mAttr所描述的一个WindowManager.LayoutParams对象的成员变量flags的WindowManager.LayoutParams.FLAG_SECURE位不等于0，那么就说明正在处理的应用程序窗口的界面是安全的，即是受保护的，这时候就需要将用来描述正在处理的应用程序窗口的图形缓冲区属性标志的变量flags的Surface.SECURE位设置为1。当一个应用程序窗口的界面是受保护时，SurfaceFlinger服务在执行截屏功能时，就不能把它的界面截取下来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 上述数据准备就绪之后，就可以创建当前正在处理的WindowState对象所描述的一个应用程序窗口的绘图表面了，不过在创建之前，还会初始化该WindowState对象的以下成员变量：</p><p>&nbsp;&nbsp; &nbsp; &nbsp;<strong> --mReportDestroySurface的值被设置为false</strong>。当一个应用程序窗口的绘图表面被销毁时，WindowManagerService服务就会将相应的WindowState对象的成员变量mReportDestroySurface的值设置为true，表示要向该应用程序窗口所运行在应用程序进程发送一个绘图表面销毁通知。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;<strong> --mSurfacePendingDestroy的值被设置为false</strong>。当一个应用程序窗口的绘图表面正在等待销毁时，WindowManagerService服务就会将相应的WindowState对象的成员变量mReportDestroySurface的值设置为true。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>--mDrawPending的值被设置为true</strong>。当一个应用程序窗口的绘图表面处于创建之后并且绘制之前时，WindowManagerService服务就会将相应的WindowState对象的成员变量mDrawPending的值设置为true，以表示该应用程序窗口的绘图表面正在等待绘制。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>--mCommitDrawPending的值被设置为false</strong>。当一个应用程序窗口的绘图表面绘制完成之后并且可以显示出来之前时，WindowManagerService服务就会将相应的WindowState对象的成员变量mCommitDrawPending的值设置为true，以表示该应用程序窗口正在等待显示。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>--mReadyToShow的值被设置为fals</strong>e。有时候当一个应用程序窗口的绘图表面绘制完成并且可以显示出来之后，由于与该应用程序窗口所关联的一个Activity组件的其它窗口还未准备好显示出来，这时候WindowManagerService服务就会将相应的WindowState对象的成员变量mReadyToShow的值设置为true，以表示该应用程序窗口需要延迟显示出来，即需要等到与该应用程序窗口所关联的一个Activity组件的其它窗口也可以显示出来之后再显示。</p><p>&nbsp;&nbsp; &nbsp; <strong>&nbsp;&nbsp;--如果成员变量mAppToken的值不等于null，那么就需要将它所描述的一个AppWindowToken对象的成员变量allDrawn的值设置为false</strong>。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，一个AppWindowToken对象用来描述一个Activity组件的，当该AppWindowToken对象的成员变量allDrawn的值等于true时，就表示属于该Activity组件的所有窗口都已经绘制完成了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>--mSurfaceShown的值被设置为false</strong>，表示应用程序窗口还没有显示出来，它是用来显示调试信息的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>--mSurfaceLayer的值被设置为0</strong>，表示应用程序窗口的Z轴位置，它是用来显示调试信息的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>--mSurfaceAlpha的值被设置为1</strong>，表示应用程序窗口的透明值，它是用来显示调试信息的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>--mSurfaceX的值被设置为0</strong>，表示应用程序程序窗口的X轴位置，它是用来显示调试信息的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<strong>--mSurfaceY的值被设置为0</strong>，表示应用程序程序窗口的Y轴位置，它是用来显示调试信息的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; <strong>--mSurfaceW的值被设置为w</strong>，表示应用程序程序窗口的宽度，它是用来显示调试信息的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;<strong>--mSurfaceH的值被设置为h</strong>，表示应用程序程序窗口的高度，它是用来显示调试信息的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 一个应用程序窗口的绘图表面在创建完成之后，函数就会将得到的一个Surface对象保存在当前正在处理的WindowState对象的成员变量mSurface中。注意，如果创建绘图表面失败，并且从Surface类的构造函数抛出来的异常的类型为Surface.OutOfResourcesException，那么就说明系统当前的内存不足了，这时候函数就会调用WindowManagerService类的成员函数reclaimSomeSurfaceMemoryLocked来回收内存。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 如果一切正常，那么函数接下来还会设置当前正在处理的WindowState对象所描述应用程序窗口的以下属性：</p><p>&nbsp;&nbsp; &nbsp; &nbsp;1. X轴和Y轴位置。前面提到，WindowState类的成员变量mFrame是用来描述应用程序窗口的位置和大小的，其中，位置就是通过它所描述的一个Rect对象的成员变量left和top来表示的，它们分别应用窗口在X轴和Y轴上的位置。此外，当一个WindowState对象所描述的应用程序窗口是一个壁纸窗口时，该WindowState对象的成员变量mXOffset和mYOffset用来描述壁纸窗口相对当前要显示的窗口在X轴和Y轴上的偏移量。因此，将WindowState类的成员变量mXOffset的值加上另外一个成员变量mFrame所描述的一个Rect对象的成员变量left的值，就可以得到一个应用程序窗口在X轴上的位置，同样，将WindowState类的成员变量mYOffset的值加上另外一个成员变量mFrame所描述的一个Rect对象的成员变量top的值，就可以得到一个应用程序窗口在Y轴上的位置。最终得到的位置值就分别保存在WindowState类的成员变量mSurfaceX和mSurfaceY，并且会调用WindowState类的成员变量mSurface所描述的一个Surface对象的成员函数setPosition来将它们设置到SurfaceFlinger服务中去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;2. Z轴位置。在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文中提到，WindowState类的成员变量mAnimLayer用来描述一个应用程序窗口的Z轴位置，因此，这里就会先将它保存在WindowState类的另外一个成员变量mSurfaceLayer中，然后再调用WindowState类的成员变量mSurface所描述的一个Surface对象的成员函数setLayer来将它设置到SurfaceFlinger服务中去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;3. 抖动标志。如果WindowState类的成员变量mAttr所描述的一个WindowManager.LayoutParams对象的成员变量flags的WindowManager.LayoutParams.FLAG_DITHER位不等于0，那么就说明一个应用程序窗口的图形缓冲区在渲染时，需要进行抖动处理，这时候就会调用WindowState类的成员变量mSurface所描述的一个Surface对象的成员函数setLayer来将对应的应用程序窗口的图形缓冲区的属性标志的Surface.SURFACE_DITHER位设置为1。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;4. 显示状态。由于当前正在处理的WindowState对象所描述的一个应用程序窗口的绘图表面刚刚创建出来，因此，我们就需要通知SurfaceFlinger服务将它隐藏起来，这是通过调用当前正在处理的WindowState对象的成员变量mSurface所描述的一个Surface对象的成员变量hide来实现的。这时候还会将当前正在处理的WindowState对象的成员变量mSurfaceShown和mLastHidden的值分别设置为false和true，以表示对应的应用程序窗口是处于隐藏状态的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;注意，为了避免SurfaceFlinger服务每设置一个应用程序窗口属性就重新渲染一次系统的UI，上述4个属性设置需要在一个事务中进行，这样就可以避免出现界面闪烁。我们通过调用Surface类的静态成员函数openTransaction和closeTransaction就可以分别在SurfaceFlinger服务中打开和关闭一个事务。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;还有另外一个地方需要注意的是，在设置应用程序窗口属性的过程中，如果抛出了一个RuntimeException异常，那么就说明系统当前的内存不足了，这时候函数也会调用WindowManagerService类的成员函数reclaimSomeSurfaceMemoryLocked来回收内存。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;接下来，我们就继续分析Surface类的构造函数的实现，以便可以了解一个应用程序窗口的绘图表面的详细创建过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 9. new Surface</p><p></p><pre name="code" class="java">public class Surface implements Parcelable {
    ......

    private int mSurfaceControl;
    ......
    private Canvas mCanvas;
    ......
    private String mName;
    ......

    public Surface(SurfaceSession s,
            int pid, String name, int display, int w, int h, int format, int flags)
        throws OutOfResourcesException {
        ......

        mCanvas = new CompatibleCanvas();
        init(s,pid,name,display,w,h,format,flags);
        mName = name;
    }

    ......

    private native void init(SurfaceSession s,
            int pid, String name, int display, int w, int h, int format, int flags)
            throws OutOfResourcesException;

    ......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/Surface.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Surface类有三个成员变量mSurfaceControl、mCanvas和mName，它们的类型分别是int、Canvas和mName，其中，mSurfaceControl保存的是在C++层的一个SurfaceControl对象的地址值，mCanvas用来描述一块类型为CompatibleCanvas的画布，mName用来描述当前正在创建的一个绘图表面的名称。画布是真正用来绘制UI的地方，不过由于现在正在创建的绘图表面是在WindowManagerService服务这一侧使用的，而WindowManagerService服务不会去绘制应用程序窗口的UI，它只会去设置应用程序窗口的属性，因此，这里创建的画布实际上没有什么作用，我们主要关注与成员变量mSurfaceControl所关联的C++层的SurfaceControl对象是如何创建的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Surface类的构造函数是通过调用另外一个成员函数init来创建与成员变量mSurfaceControl所关联的C++层的SurfaceControl对象的。Surface类的成员函数init是一个JNI方法，它是由C++层的函数Surface_init来实现的，如下所示：</p><p></p><pre name="code" class="cpp">static void Surface_init(
        JNIEnv* env, jobject clazz,
        jobject session,
        jint pid, jstring jname, jint dpy, jint w, jint h, jint format, jint flags)
{
    if (session == NULL) {
        doThrow(env, &quot;java/lang/NullPointerException&quot;);
        return;
    }

    SurfaceComposerClient* client =
            (SurfaceComposerClient*)env-&gt;GetIntField(session, sso.client);

    sp&lt;SurfaceControl&gt; surface;
    if (jname == NULL) {
        surface = client-&gt;createSurface(pid, dpy, w, h, format, flags);
    } else {
        const jchar* str = env-&gt;GetStringCritical(jname, 0);
        const String8 name(str, env-&gt;GetStringLength(jname));
        env-&gt;ReleaseStringCritical(jname, str);
        surface = client-&gt;createSurface(pid, name, dpy, w, h, format, flags);
    }

    if (surface == 0) {
        doThrow(env, OutOfResourcesException);
        return;
    }
    setSurfaceControl(env, clazz, surface);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/jni/android_view_Surface.cpp中。<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数session指向了在Java层所创建的一个SurfaceSession对象。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，Java层的SurfaceSession对象有一个成员变量mClient，它指向了在C++层中的一个SurfaceComposerClient对象。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>这一系列的文章又可以知道，C++层的SurfaceComposerClient对象可以用来请求SurfaceFlinger服务为应用程序窗口创建绘图表面，即创建一个Layer对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;因此，函数首先将参数session所指向的一个Java层的SurfaceSession对象的成员变量mClient转换成一个SurfaceComposerClient对象，然后再调用这个SurfaceComposerClient对象的成员函数createSurface来请求SurfaceFlinger服务来为参数clazz所描述的一个Java层的Surface对象所关联的应用程序窗口创建一个Layer对象。SurfaceFlinger服务创建完成这个Layer对象之后，就会将该Layer对象内部的一个实现了ISurface接口的SurfaceLayer对象返回给函数，于是，函数就可以获得一个实现了ISurface接口的Binder代理对象。这个实现了ISurface接口的Binder代理对象被封装在C++层的一个SurfaceControl对象surface中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 注意，sso是一个全局变量，它是一个类型为sso_t的结构体，它的定义如下所示：</p><p></p><pre name="code" class="cpp">struct sso_t {
    jfieldID client;
};
static sso_t sso;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;它的成员函数client用来描述Java层中的SurfaceSession类的成员变量mClient在类中的偏移量，因此，函数Surface_init通过这个偏移量就可以访问参数session所指向的一个SurfaceSession对象的成员变量mClient的值，从而获得一个SurfaceComposerClient对象。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 另外一个需要注意的地方是，当参数name的值等于null时，函数Surface_init调用前面所获得一个SurfaceComposerClient对象的六个参数版本的成员函数createSurface来请求SurfaceFlinger服务创建一个Layer对象，否则的话，就调用七个参数版本的成员函数createSurface来请求SurfaceFlinger服务创建一个Layer对象。SurfaceComposerClient类的成员函数createSurface的实现可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7884628">Android应用程序请求SurfaceFlinger服务创建Surface的过程分析</a>一文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 得到了SurfaceControl对象surface之后，函数Surface_init接下来继续调用另外一个函数setSurfaceControl来它的地址值保存在参数clazz所指向的一个Java层的Surface对象的成员变量mSurfaceControl中，如下所示：</p><p></p><pre name="code" class="cpp">static void setSurfaceControl(JNIEnv* env, jobject clazz,
        const sp&lt;SurfaceControl&gt;&amp; surface)
{
    SurfaceControl* const p =
        (SurfaceControl*)env-&gt;GetIntField(clazz, so.surfaceControl);
    if (surface.get()) {
        surface-&gt;incStrong(clazz);
    }
    if (p) {
        p-&gt;decStrong(clazz);
    }
    env-&gt;SetIntField(clazz, so.surfaceControl, (int)surface.get());
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/jni/android_view_Surface.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在分析函数setSurfaceControl的实现之前，我们先分析全局变量so的定义，如下所示：</p><p></p><pre name="code" class="cpp">struct so_t {
    jfieldID surfaceControl;
    jfieldID surface;
    jfieldID saveCount;
    jfieldID canvas;
};
static so_t so;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;它是一个类型为so_t的结构体。结构体so_t有四个成员变量surfaceControl、surface、saveCount和canvas，它们分别用来描述Java层的Surface类的四个成员变量mSurfaceControl、mNativeSurface、mSaveCount和mCanvas在类中的偏移量。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 回到函数setSurfaceControl中，它首先通过结构体so的成员变量surfaceControl来获得参数clazz所指向的一个Java层的Surface对象的成员变量mSurfaceControl所关联的一个C++层的SurfaceControl对象。如果这个SurfaceControl对象存在，那么变量p的值就不会等于null，在这种情况下，就需要调用它的成员函数decStrong来减少它的强引用计数，因为接下来参数clazz所指向的一个Java层的Surface对象不再通过成员变量mSurfaceControl来引用它了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 另一方面，函数setSurfaceControl需要增加参数surface所指向的一个C++层的SurfaceControl对象的强引用计数，即调用参数surface所指向的一个C++层的SurfaceControl对象的成员函数incStrong，因为接下来参数clazz所指向的一个Java层的Surface对象要通过成员变量mSurfaceControl来引用它，即将它的地址值保存在参数clazz所指向的一个Java层的Surface对象的成员变量mSurfaceControl中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，沿着调用路径层层返回，回到前面的Step 8中，即WindowState类的成员函数createSurfaceLocked中，这时候一个绘图表面就创建完成了。这个绘图表面最终会返回给请求创建它的应用程序进程，即前面的Step 5，也就是IWindowSession.Stub.Proxy类的成员函数relayout。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; IWindowSession.Stub.Proxy类的成员函数relayout获得了从WindowManagerService服务返回来的一个绘图表面，即一个Java层的Surface对象之后，就会将它的内容拷贝到参数outSurface所描述的另外一个Java层的Surface对象中，这里通过调用Surface类的成员函数readFromParcel来实现的。注意，参数outSurface所描述的这个Java层的Surface对象是在应用程序进程这一侧创建的，它的作用是用来绘制应用程序窗品的UI。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析Surface类的成员函数readFromParcel的实现，以便可以了解在应用程序进程这一侧的Surface对象是如何创建的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 10.&nbsp;Surface.readFromParcel</p><p></p><pre name="code" class="java">public class Surface implements Parcelable {
    ......

    public native   void readFromParcel(Parcel source);
    ......

}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/Surface.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;Surface类的成员函数readFromParcel是一个JNI方法，它是由C++层的函数Surface_readFromParcel来实现的，如下所示：</p><p></p><pre name="code" class="cpp">static void Surface_readFromParcel(
        JNIEnv* env, jobject clazz, jobject argParcel)
{
    Parcel* parcel = (Parcel*)env-&gt;GetIntField( argParcel, no.native_parcel);
    if (parcel == NULL) {
        doThrow(env, &quot;java/lang/NullPointerException&quot;, NULL);
        return;
    }

    sp&lt;Surface&gt; sur(Surface::readFromParcel(*parcel));
    setSurface(env, clazz, sur);
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/core/jni/android_view_Surface.cpp中。<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 参数argParcel所指向的一个Parcel对象的当前位置保存的是一个Java层的Surface对象的内容，函数readFromParcel首先调用C++层的Surface类的成员函数readFromParcel来将这些内容封装成一个C++层的Surface对象，如下所示：</p><p></p><pre name="code" class="cpp">sp&lt;Surface&gt; Surface::readFromParcel(const Parcel&amp; data) {
    Mutex::Autolock _l(sCachedSurfacesLock);
    sp&lt;IBinder&gt; binder(data.readStrongBinder());
    sp&lt;Surface&gt; surface = sCachedSurfaces.valueFor(binder).promote();
    if (surface == 0) {
       surface = new Surface(data, binder);
       sCachedSurfaces.add(binder, surface);
    }
    if (surface-&gt;mSurface == 0) {
      surface = 0;
    }
    cleanCachedSurfacesLocked();
    return surface;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数data所指向的一个Parcel对象的当前位置保存的是一个Binder代理对象，这个Binder代理对象实现了ISurface接口，它所引用的Binder本地对象就是在前面的Step 9中WindowManagerService服务请求SurfaceFlinger服务所创建的一个Layer对象的内部的一个SurfaceLayer对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;获得了一个实现了ISurface接口的Binder代理对象binder之后，C++层的Surface类的成员函数readFromParcel就可以将它封装在一个C++层的Surface对象中了，并且将这个C++层的Surface对象返回给调用者。注意，C++层的Surface类的成员函数readFromParcel在创建为Binder代理对象binder创建一个C++层的Surface对象之前，首先会在C++层的Surface类的静态成员变量sCachedSurfaces所描述的一个DefaultKeyedVectort向量中检查是否已经为存在一个对应的C++层的Surface对象了。如果已经存在，那么就会直接将这个C++层的Surface对象返回给调用者。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回到函数Surface_readFromParcel中，接下来它就会调用另外一个函数setSurface来将前面所获得的一个C++层的Surface对象sur保存在参数clazz所描述的一个Java层的Surface对象的成员变量mNativeSurface中，如下所示：</p><p></p><pre name="code" class="cpp">static void setSurface(JNIEnv* env, jobject clazz, const sp&lt;Surface&gt;&amp; surface)
{
    Surface* const p = (Surface*)env-&gt;GetIntField(clazz, so.surface);
    if (surface.get()) {
        surface-&gt;incStrong(clazz);
    }
    if (p) {
        p-&gt;decStrong(clazz);
    }
    env-&gt;SetIntField(clazz, so.surface, (int)surface.get());
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/core/jni/android_view_Surface.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 全局变量so是一个类型为so_t的结构体，在前面的Step 9中，我们已经分析过它的定义了，函数setSurface首先通过它的成员变量surface来将参数clazz所描述的一个Java层的Surface对象的成员变量mNativeSurface转换成一个Surface对象p。如果这个Surface对象p存在，那么就需要调用它的成员函数decStrong来减少它的强引用计数，因为接下来参数clazz所描述的一个Java层的Surface对象不再通过成员变量mNativeSurface来引用它了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;函数setSurface接下来就会将参数surface所指向的一个C++层的Surface对象的地址值保存在参数clazz所描述的一个Java层的Surface对象的成员变量mNativeSurface中。在执行这个操作之前，函数setSurface需要调用参数surface所指向的一个C++层的Surface对象的成员函数incStrong来增加它的强引用计数，这是因为接下来它要被参数clazz所描述的一个Java层的Surface对象通过成员变量mNativeSurface来引用了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成Android应用程序窗口的绘图表面的创建过程了。通过这个过程我们就可以知道：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. 每一个应用程序窗口都对应有两个Java层的Surface对象，其中一个是在WindowManagerService服务这一侧创建的，而另外一个是在应用程序进程这一侧创建的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. 在WindowManagerService服务这一侧创建的Java层的Surface对象在C++层关联有一个SurfaceControl对象，用来设置应用窗口的属性，例如，大小和位置等。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 3.&nbsp;在应用程序进程这一侧创建的ava层的Surface对象在C++层关联有一个Surface对象，用来绘制应用程序窗品的UI。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 理解上述三个结论对理解Android应用程序窗口的实现框架以及WindowManagerService服务的实现都非常重要。&nbsp;一个应用程序窗口的绘图表面在创建完成之后，接下来应用程序进程就可以在上面绘制它的UI了。在接下来的一篇文章中，我们就继续分析Android应用程序窗品的绘制过程，敬请关注！</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-12-24 0:55:51 <a href="http://blog.csdn.net/luoshengyang/article/details/8303098">原文链接</a>
            </div>
            <div>
            阅读：5460 评论：15 <a href="http://blog.csdn.net/luoshengyang/article/details/8303098#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8372924</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8372924</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-12-31 0:55:26</pubDate>
        <description><![CDATA[
            <p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在前面一篇文章中，我们分析了</span><span style="color:black;">Android</span><span style="color:black;">应用程序窗口的绘图表面的创建过程。</span><span style="color:black;">Android</span><span style="color:black;">应用程序窗口的绘图表面在创建完成之后，我们就可以从上到下地绘制它里面的各个视图了，即各个</span><span style="color:black;">UI</span><span style="color:black;">元素了。不过在绘制这些</span><span style="color:black;">UI</span><span style="color:black;">元素之前，我们还需要从上到下地测量它们实际所需要的大小，以及对它们的位置进行合适的安排，即对它们进行合适的布局。在本文中，我们就将详细地分析</span><span style="color:black;">Android</span><span style="color:black;">应用程序窗口的测量、布局以及绘制过程。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7846923">Android应用程序与SurfaceFlinger服务的关系概述和学习计划</a>这一系列的文章可以知道，Android应用程序窗口请求SurfaceFlinger服务创建了一个绘图表面之后，就可以接着请求为该绘图表面创建图形缓冲区，而当Android应用程序窗口往这些图形缓冲区填充好UI数据之后，就可以请求SurfaceFlinger服务将它们渲染到硬件帧缓冲区中去，这样我们就可以看到应用程序窗口的UI了。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Android应用程序窗口一般不会直接去操作分配给它的图形缓冲区，而是通过一些图形库API来操作。例如，在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7691321">Android系统的开机画面显示过程分析</a>一文中，使用C++来开发的开机动画应用程序bootanimation，它是通过OpenGL提供的API来绘制UI的。对于使用Java来开发的Android应用程序来说，它们一般是使用<a href="http://zh.wikipedia.org/wiki/Skia_Graphics_Library">Skia</a>图形库提供的API来绘制UI的。在Skia图库中，所有的UI都是绘制在画布（Canvas）上的，因此，Android应用程序窗口需要将它的图形缓冲区封装在一块画布里面，然后才可以使用Skia库提供的API来绘制UI。</span></p><p><span style="color:black;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们知道，一个Android应用程序窗口里面包含了很多UI元素，这些UI元素是以树形结构来组织的，即它们存在着父子关系，其中，子UI元素位于父UI元素里面，因此，在绘制一个Android应用程序窗口的UI之前，我们首先要确定它里面的各个子UI元素在父UI元素里面的大小以及位置。确定各个子UI元素在父UI元素里面的大小以及位置的过程又称为测量过程和布局过程。因此，Android应用程序窗口的UI渲染过程可以分为测量、布局和绘制三个阶段，如图1所示：</span></p><p style="text-align: center;"><span style="color:black;"><img alt="" src="http://img.my.csdn.net/uploads/201212/23/1356275187_5515.jpg" /><br /></span></p><p style="text-align: center;">图1 Android应用程序窗口渲染三步曲</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8245546">Android应用程序窗口（Activity）的视图对象（View）的创建过程分析</a>一文可以知道，Android应用程序窗口的顶层视图是一个类型为DecorView的UI元素，而从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8303098">Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析</a>一文的Step 3又可以知道，这个顶层视图最终是由ViewRoot类的成员函数performTraversals来启动测量、布局和绘制操作的，这三个操作分别由DecorView类的成员函数measure和layout以及ViewRoot类的成员函数draw来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就分别从DecorView类的成员函数measure和layout以及ViewRoot类的成员函数draw开始，分析Android应用程序窗口的测量、布局和绘制过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. Android应用程序窗口的测量过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DecorView类的成员函数measure是从父类View继承下来的，因此，我们就从View类的成员函数measure开始分析应用程序窗口的测量过程，如图2所示：</p><p style="text-align: center;"><img alt="" src="http://img.my.csdn.net/uploads/201212/24/1356360396_5233.jpg" /><br /></p><p style="text-align: center;">图2 Android应用程序窗口的测量过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程可以分为3个步骤，接下来我们就详细分析每一个步骤。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. View.measure</p><p></p><pre class="java" name="code">public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {
    ......

    int mPrivateFlags;
    ......

    int mOldWidthMeasureSpec = Integer.MIN_VALUE;
    ......

    int mOldHeightMeasureSpec = Integer.MIN_VALUE;
    ......

    public final void measure(int widthMeasureSpec, int heightMeasureSpec) {
        if ((mPrivateFlags &amp; FORCE_LAYOUT) == FORCE_LAYOUT ||
                widthMeasureSpec != mOldWidthMeasureSpec ||
                heightMeasureSpec != mOldHeightMeasureSpec) {

            // first clears the measured dimension flag
            mPrivateFlags &amp;= ~MEASURED_DIMENSION_SET;

            ......

            // measure ourselves, this should set the measured dimension flag back
            onMeasure(widthMeasureSpec, heightMeasureSpec);

            // flag not set, setMeasuredDimension() was not invoked, we raise
            // an exception to warn the developer
            if ((mPrivateFlags &amp; MEASURED_DIMENSION_SET) != MEASURED_DIMENSION_SET) {
                throw new IllegalStateException(&quot;onMeasure() did not set the&quot;
                        + &quot; measured dimension by calling&quot;
                        + &quot; setMeasuredDimension()&quot;);
            }

            mPrivateFlags |= LAYOUT_REQUIRED;
        }

        mOldWidthMeasureSpec = widthMeasureSpec;
        mOldHeightMeasureSpec = heightMeasureSpec;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/View.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数widthMeasureSpec和heightMeasureSpec用来描述当前正在处理的视图可以获得的最大宽度和高度。对于应用程序窗口的顶层视图来说，我们也可以认为这两个参数是用来描述应用程序窗口的宽度和高度。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的成员变量mPrivateFlags的类型为int，如果它的某一个位的值不等于0，那么就隐含着当前视图有一个相应的操作在等待执行中。ViewRoot类的另外两个成员变量mOldWidthMeasureSpec和mOldHeightMeasureSpec用来保存当前视图上一次可以获得的最大宽度和高度。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当ViewRoot类的成员变量mPrivateFlags的FORCE_LAYOUT位不等于0时，就表示当前视图正在请求执行一次布局操作，这时候函数就需要重新测量当前视图的宽度和高度。此外，当参数widthMeasureSpec和heightMeasureSpec的值不等于ViewRoot类的成员变量mldWidthMeasureSpec和mOldHeightMeasureSpec的值时，就表示当前视图上一次可以获得的最大宽度和高度已经失效了，这时候函数也需要重新测量当前视图的宽度和高度。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当View类的成员函数measure决定要重新测量当前视图的宽度和高度之后，它就会首先将成员变量mPrivateFlags的MEASURED_DIMENSION_SET位设置为0，接着再调用另外一个成员函数onMeasure来真正执行测量宽度和高度的操作。View类的成员函数onMeasure执行完成之后，需要再调用另外一个成员函数setMeasuredDimension来将测量好的宽度和高度设置到View类的成员变量mMeasuredWidth和mMeasuredHeight中，并且将成员变量mPrivateFlags的EASURED_DIMENSION_SET位设置为1。这个操作是强制的，因为当前视图最终就是通过View类的成员变量mMeasuredWidth和mMeasuredHeight来获得它的宽度和高度的。为了保证这个操作是强制的，View类的成员函数measure再接下来就会检查成员变量mPrivateFlags的EASURED_DIMENSION_SET位是否被设置为1了。如果不是的话，那么就会抛出一个类型为IllegalStateException的异常来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;View类的成员函数measure最后就会把参数widthMeasureSpec和heightMeasureSpec的值保存在成员变量mldWidthMeasureSpec和mOldHeightMeasureSpec中，以便可以记录当前视图上一次可以获得的最大宽度和高度。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;View类的成员函数onMeasure一般是由其子类来重写的。例如，对于用来应用程序窗口的顶层视图的DecorView类来说，它是通过父类FrameLayout来重写祖父类View的成员函数onMeasure的。因此，接下来我们就分析FrameLayout类的成员函数onMeasure的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2.&nbsp;rameLayout.onMeasure</p><p></p><pre class="java" name="code">public class FrameLayout extends ViewGroup {
    ......

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        final int count = getChildCount();

        int maxHeight = 0;
        int maxWidth = 0;

        // Find rightmost and bottommost child
        for (int i = 0; i &lt; count; i++) {
            final View child = getChildAt(i);
            if (mMeasureAllChildren || child.getVisibility() != GONE) {
                measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
                maxWidth = Math.max(maxWidth, child.getMeasuredWidth());
                maxHeight = Math.max(maxHeight, child.getMeasuredHeight());
            }
        }

        // Account for padding too
        maxWidth += mPaddingLeft + mPaddingRight + mForegroundPaddingLeft + mForegroundPaddingRight;
        maxHeight += mPaddingTop + mPaddingBottom + mForegroundPaddingTop + mForegroundPaddingBottom;

        // Check against our minimum height and width
        maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());
        maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());

        // Check against our foreground's minimum height and width
        final Drawable drawable = getForeground();
        if (drawable != null) {
            maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());
            maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());
        }

        setMeasuredDimension(resolveSize(maxWidth, widthMeasureSpec),
                resolveSize(maxHeight, heightMeasureSpec));
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/widget/FrameLayout.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FrameLayout类是从ViewGroup类继承下来的，后者用来描述一个视图容器，它有一个类型为View的数组mChildren，里面保存的就是它的各个子视图。ViewGroup类所供了两个成员函数getChildCount和getChildAt，它们分别用来获得一个视图容器所包含的子视图的个数，以及获得每一个子视图。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FrameLayout类的成员函数onMeasure首先是调用另一个成员函数measureChildWithMargins来测量每一个子视图的宽度和高度，并且找到这些子视图的最大宽度和高度值，保存在变量maxWidth和maxHeight 中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FrameLayout类的成员函数onMeasure接着再将前面得到的宽度maxWidth和高度maxHeight分别加上当前视图所设置的Padding值，其中，（mPaddingLeft，mPaddingRight，mPaddingTop，mPaddingBottom&nbsp;）表示当前视图的内容区域的左右上下四条边分别到当前视图的左右上下四条边的距离，它们是父类View的四个成员变量，（mForegroundPaddingLeft，mForegroundPaddingRight，mForegroundPaddingTop，mForegroundPaddingBottom）表示当前视图的各个子视图所围成的区域的左右上下四条边到当前视视的前景区域的左右上下四条边的距离。从这里就可以看出，当前视图的内容区域的大小就等于前景区域的大小，而前景区域的大小大于等于各个子视图的所围成的区域，这是因为前景区域本来就是用来覆盖各个子视图所围成的区域的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 加上各个Padding值之后，得到的宽度maxWidth和高度maxHeight还不是最终的宽度和高度，还需要考虑以下两个因素：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. 当前视图是否设置有最小宽度和高度。如果设置有的话，并且它们比前面计算得到的宽度maxWidth和高度maxHeight还要大，那么就将它们作为当前视图的宽度和高度值。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. 当前视图是否设置有前景图。如果设置有的话，并且它们比前面计算得到的宽度maxWidth和高度maxHeight还要大，那么就将它们作为当前视图的宽度和高度值。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 经过上述两步检查之后，FrameLayout类的成员函数onMeasure就得到了当前视图的宽度maxWidth和高度maxHeight。由于得到的宽度和高度又必须要限制在参数widthMeasureSpec和heightMeasureSpec所描述的宽度和高度规范之内，因此，FrameLayout类的成员函数onMeasure就会调用从View类继承下来的成员函数resolveSize来获得正确的大小。得到了当前视图的正确大小之后，FrameLayout类的成员函数onMeasure就可以调用从父类View继承下来的成员函数setMeasuredDimension来将它们为当前视图的大小了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 为了理解参数widthMeasureSpec和heightMeasureSpec的含义，我们继续分析View类的成员函数resolveSize的实现，如下所示：</p><p></p><pre class="java" name="code">public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {
    ......

    public static int resolveSize(int size, int measureSpec) {
        int result = size;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize =  MeasureSpec.getSize(measureSpec);
        switch (specMode) {
        case MeasureSpec.UNSPECIFIED:
            result = size;
            break;
        case MeasureSpec.AT_MOST:
            result = Math.min(size, specSize);
            break;
        case MeasureSpec.EXACTLY:
            result = specSize;
            break;
        }
        return result;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件rameworks/base/core/java/android/view/View.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数measureSpec的值其实是由两部分内容来组成的，最高2位表示一个测量规范，而低30位表示一个宽度值或者高度值。测量规范有三种，分别是0、1和2，使用常量MeasureSpec.UNSPECIFIED、MeasureSpec.EXACTLY和MeasureSpec.AT_MOST来表示。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当参数measureSpec描述的规范是MeasureSpec.UNSPECIFIED时，就表示当前视图没有指定它的大小测量模式，这时候就使用参数size的值；当参数measureSpec描述的规范是MeasureSpec.AT_MOST时，就表示当前视图的大小等于参数size和参数measureSpec所指定的值中的较小值；当参数measureSpec描述的规范是MeasureSpec.EXACTLY时，就表示当前视图的大小等于参数measureSpec中所指定的值。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;回到FrameLayout类的成员函数onMeasure中，我们再来看一下View类的成员函数setMeasuredDimension是如何设置当前视图的大小的，如下所示：</p><p></p><pre class="java" name="code">public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {
    ......

    protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) {
        mMeasuredWidth = measuredWidth;
        mMeasuredHeight = measuredHeight;

        mPrivateFlags |= MEASURED_DIMENSION_SET;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件rameworks/base/core/java/android/view/View.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; View类的成员函数setMeasuredDimension首先将参数measuredWidth和measuredHeight的值保存在成员变量mMeasuredWidth和mMeasuredHeight中，用来作为当前视图的宽度和高度，并且将成员变量mPrivateFlags的位MEASURED_DIMENSION_SET设置为1，这样返回到前面的Step 1时，就不会抛出一个类型为IllegalStateException的异常了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FrameLayout类的另一个成员函数measureChildWithMargins是从父类ViewGroup继承下来的，接下来我们就继续分析它的实现，以便可以了解一个视图容器的各个子视图的大小的测量过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 3. ViewGroup.measureChildWithMargins</p><p></p><pre class="java" name="code">public abstract class ViewGroup extends View implements ViewParent, ViewManager {
    ......

    protected void measureChildWithMargins(View child,
            int parentWidthMeasureSpec, int widthUsed,
            int parentHeightMeasureSpec, int heightUsed) {
        final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();

        final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin
                        + widthUsed, lp.width);
        final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,
                mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin
                        + heightUsed, lp.height);

        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件rameworks/base/core/java/android/view/ViewGroup.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数child用来描述当前要测量大小的子视图，参数parentWidthMeasureSpec和parentHeightMeasureSpec用来描述当前子视图可以获得的最大宽度和高度，参数widthUsed和heightUsed用来描述父窗口已经使用了的宽度和高度。ViewGroup类的成员函数measureChildWithMargins必须要综合考虑上述参数，以及当前正在测量的子视图child所设置的大小和Margin值，还有当前视图容器所设置的Padding值，来得到当前正在测量的子视图child的正确宽度childWidthMeasureSpec和高度childHeightMeasureSpec，这是通过调用ViewGroup类的另外一个成员函数getChildMeasureSpec来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 得到了当前正在测量的子视图child的正确宽度childWidthMeasureSpec和高度childHeightMeasureSpec之后，就可以调用它的成员函数measure来设置它的大小了，即执行前面Step 1的操作。注意，如果当前正在测量的子视图child描述的也是一个视图容器，那么它又会重复执行Step 2和Step 3的操作，直到它的所有子孙视图的大小都测量完成为止。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成Android应用程序窗口的测量过程了，接下来我们继续分析Android应用程序窗口的布局过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2.&nbsp;Android应用程序窗口的布局过程<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;DecorView类的成员函数layout是从父类View继承下来的，因此，我们就从View类的成员函数layout开始分析应用程序窗口的布局过程，如图3所示：</p><p style="text-align: center;"><img alt="" src="http://img.my.csdn.net/uploads/201212/25/1356448764_8004.jpg" /><br /></p><p style="text-align: center;">图3&nbsp;Android应用程序窗口的布局过程</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 这个过程可以分为5个步骤，接下来我们就详细地分析每一个步骤。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; Step 1. View.layout</p><p></p><pre class="java" name="code">public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {
    ......
 
    int mPrivateFlags;
    ......

    public final void layout(int l, int t, int r, int b) {
        boolean changed = setFrame(l, t, r, b);
        if (changed || (mPrivateFlags &amp; LAYOUT_REQUIRED) == LAYOUT_REQUIRED) {
            ......

            onLayout(changed, l, t, r, b);
            mPrivateFlags &amp;= ~LAYOUT_REQUIRED;
        }
        mPrivateFlags &amp;= ~FORCE_LAYOUT;
    }

    ......
}</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/View.java中。<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数l、t、r和b分别用来描述当前视图的左上右下四条边与其父视图的左上右下四条边的距离，这样当前视图通过这四个参数就可以知道它在父视图中的位置以及大小。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;View类的成员函数layout首先调用另外一个成员函数setFrame来设置当前视图的位置以及大小。设置完成之后，如果当前视图的大小或者位置与上次相比发生了变化，那么View类的成员函数setFrame的返回值changed就会等于true。在这种情况下，&nbsp;View类的成员函数layout就会继续调用另外一个成员函数onLayout重新布局当前视图的子视图。此外，如果此时View类的成员变量mPrivateFlags的LAYOUT_REQUIRED位不等于0，那么也表示当前视图需要重新布局它的子视图，因此，这时候View类的成员函数layout也会调用另外一个成员函数onLayout。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当前视图的子视图都重新布局完成之后，View类的成员函数layout就可以将成员变量mPrivateFlags的LAYOUT_REQUIRED位设置为0了，因为此时当前视图及其子视图都已经执行了一次布局操作了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;View类的成员函数layout最后还会将成员变量mPrivateFlags的FORCE_LAYOUT位设置为0，也是因为此时当前视图及其子视图的布局已经是最新的了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析View类的成员函数setFrame和onLayout的实现，以便可以了解当前视图及其子视图是如何执行布局操作的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 2. View.setFrame</p><p></p><pre class="java" name="code">public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {
    ......
 
    int mPrivateFlags;
    ......

    int mViewFlags;
    ......

    protected int mLeft;
    ......

    protected int mRight;
    ......

    protected int mTop;
    ......

    protected int mBottom;
    ......

    private boolean mBackgroundSizeChanged;
    ......

    protected boolean setFrame(int left, int top, int right, int bottom) {
        boolean changed = false;

        ......

        if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) {
            changed = true;

            // Remember our drawn bit
            int drawn = mPrivateFlags &amp; DRAWN;

            // Invalidate our old position
            invalidate();


            int oldWidth = mRight - mLeft;
            int oldHeight = mBottom - mTop;

            mLeft = left;
            mTop = top;
            mRight = right;
            mBottom = bottom;

            mPrivateFlags |= HAS_BOUNDS;

            int newWidth = right - left;
            int newHeight = bottom - top;

            if (newWidth != oldWidth || newHeight != oldHeight) {
                onSizeChanged(newWidth, newHeight, oldWidth, oldHeight);
            }

            if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) {
                // If we are visible, force the DRAWN bit to on so that
                // this invalidate will go through (at least to our parent).
                // This is because someone may have invalidated this view
                // before this call to setFrame came in, therby clearing
                // the DRAWN bit.
                mPrivateFlags |= DRAWN;
                invalidate();
            }

            // Reset drawn bit to original value (invalidate turns it off)
            mPrivateFlags |= drawn;

            mBackgroundSizeChanged = true;
        }
        return changed;
    }

    ......
}</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/View.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; View类的成员变量mLeft、mRight、mTop和mBottom分别用来描述当前视图的左右上下四条边与其父视图的左右上下四条边的距离，如果它们的值与参数left、right、top和bottom的值不相等，那么就说明当前视图的大小或者位置发生变化了。这时候View类的成员函数setFrame就需要将参数left、right、top和bottom的值分别记录在成员变量mLeft、mRight、mTop和mBottom中。在记录之前，还会执行两个操作：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. 将成员变量mPrivateFlags的DRAWN位记录在变量drawn中，并且调用另外一个成员函数invalidate来检查当前视图上次请求的UI绘制操作是否已经执行。如果已经执行了的话，那么就会再请求执行一个UI绘制操作，以便可以在修改当前视图的大小和位置之前，将当前视图在当前位置按照当前大小显示一次。在接下来的Step 3中，我们再详细分析View类的成员函数invalidate的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. 计算当前视图上一次的宽度oldWidth和oldHeight，以便接下来可以检查当前视图的大小是否发生了变化。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 当前视图距离父视图的边距一旦设置好之后，它就是一个具有边界的视图了，因此，View类的成员函数setFrame接着还会将成员变量mPrivateFlags的HAS_BOUNDS设置为1。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; View类的成员函数setFrame再接下来又会计算当前视图新的宽度newWidth和高度newHeight，如果它们与上一次的宽度oldWidth和oldHeight的值不相等，那么就说明当前视图的大小发生了变化，这时候就会调用另外一个成员函数onSizeChanged来让子类有机会处理这个变化事件。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;View类的成员函数setFrame接下来继续判断当前视图是否是可见的，即成员变量mViewFlags的VISIBILITY_MASK位的值是否等于VISIBLE。如果是可见的话，那么就需要将成员变量mPrivateFlags的DRAWN位设置为1，以便接下来可以调用另外一个成员函数invalidate来成功地执行一次UI绘制操作，目的是为了将当前视图马上显示出来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; View类的成员变量mPrivateFlags的DRAWN位描述的是当前视图上一次请求的UI绘制操作是否已经执行过了。如果它的值等于1，就表示已经执行过了，否则的话，就表示还没在等待执行。前面第一次调用View类的成员函数invalidate来检查当前视图上次请求的UI绘制操作是否已经执行时，如果发现已经执行了，那么就会重新请求执行一次新的UI绘制操作，这时候会导致当前视图的成员变量mPrivateFlags的DRAWN位重置为0。注意，新请求执行的UI绘制只是为了在修改当前视图的大小以及大小之前，先将它在上一次设置的大小以及位置中绘制出来，这样就可以使得当前视图的大小以及位置出现平滑的变换。换句话说，新请求执行的UI绘制只是为了获得一个中间效果，它不应该影响当前视图的绘制状态，即不可以修改当前视图的成员变量mPrivateFlags的DRAWN位。因此，我们就需要在前面第一次调用View类的成员函数invalidate前，先将当前视图的成员变量mPrivateFlags的DRAWN位保存下来，即保存在变量drawn中，然后等到调用之后，再将变量drawn的值恢复到当前视图的成员变量mPrivateFlags的DRAWN位中去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;另一方面，如果当前视图的大小和位置发生了变化，View类的成员函数setFrame还会将成员变量mBackgroundSizeChanged的值设置为true，以便可以表示当前视图的背景大小发生了变化。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;最后，View类的成员函数setFrame将变量changed的值返回给调用者，以便调用者可以知道当前视图的大小和位置是否发生了变化。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们继续分析View类的成员函数invalidate的实现，以便可以了解当前视图是如何执行一次UI绘制操作的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 3.&nbsp;View.invalidate</p><p></p><pre class="java" name="code">public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {
    ......

    protected ViewParent mParent;
    ......
 
    int mPrivateFlags;
    ......    

    public void invalidate() {
        ......

        if ((mPrivateFlags &amp; (DRAWN | HAS_BOUNDS)) == (DRAWN | HAS_BOUNDS)) {
            mPrivateFlags &amp;= ~DRAWN &amp; ~DRAWING_CACHE_VALID;
            final ViewParent p = mParent;
            final AttachInfo ai = mAttachInfo;
            if (p != null &amp;&amp; ai != null) {
                final Rect r = ai.mTmpInvalRect;
                r.set(0, 0, mRight - mLeft, mBottom - mTop);
                // Don't call invalidate -- we don't want to internally scroll
                // our own bounds
                p.invalidateChild(this, r);
            }
        }
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/core/java/android/view/View.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;View类的成员函数invalidate首先检查成员变量mPrivateFlags的DRAWN位和HAS_BOUNDS位是否都被设置为1。如果是的话，那么就说明当前视图上一次请求执行的UI绘制操作已经执行完成了，这时候View类的成员函数invalidate才可以请求执行新的UI绘制操作。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;View类的成员函数invalidate在请求新的UI绘制操作之前，会将成员变量mPrivateFlags的DRAWN位和DRAWING_CACHE_VALID位重置为0，其中，后者表示当前视图正在缓存的一些绘图对象已经失效了，这是因为接下来就要重新开始绘制当前视图的UI了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;请求绘制当前视图的UI是通过调用View类的成员变量mParent所描述的一个ViewParent接口的成员函数invalidateChild来实现的。前面我们假设当前视图是应用程序窗口的顶层视图，即它是一个类型为DecoreView的视图，它的成员变量mParent指向的是与其所关联的一个ViewRoot对象。因此，绘制当前视图的UI的操作实际上是通过调用ViewRoot类的成员函数invalidateChild来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 注意，在调用ViewRoot类的成员函数invalidateChild的成员函数invalidateChild来绘制当前视图的UI之前，会将当前视图即将要绘制的区域记录在View类的成员变量mAttachInfo所描述的一个AttachInfo对象的成员变量mTmpInvalRect中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析ViewRoot类的成员函数invalidateChild的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 4. ViewRoot.invalidateChild</p><p></p><pre class="java" name="code">public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......

    public void invalidateChild(View child, Rect dirty) {
        checkThread();
        ......
        if (mCurScrollY != 0 || mTranslator != null) {
            mTempRect.set(dirty);
            dirty = mTempRect;
            if (mCurScrollY != 0) {
               dirty.offset(0, -mCurScrollY);
            }
            if (mTranslator != null) {
                mTranslator.translateRectInAppWindowToScreen(dirty);
            }
            if (mAttachInfo.mScalingRequired) {
                dirty.inset(-1, -1);
            }
        }
        mDirty.union(dirty);
        if (!mWillDrawSoon) {
            scheduleTraversals();
        }
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的成员函数invalidateChild首先调用另外一个成员函数checkThread来检查当前正在执行的是否是一个UI线程。如果不是的话，ViewRoot类的成员函数checkThread就会抛出一个异常出来。这是因为所有的UI操作都必须要在UI线程中执行。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的成员函数invalidateChild接下来还会检查当前正在处理的应用程序窗口在Y轴上是否出现有滚动条，即成员变量mCurScrollY的值不等于0，&nbsp;或者前正在处理的应用程序窗口是否运行在兼容模式之下，即成员变量mTranslator的值不等于null。当一个应用程序窗口运行在兼容模式时，它显示出来的大小和它实际被设置的大小是不一样的，要经过相应的转换处理。对于上述这两种情况，ViewRoot类的成员函数invalidateChild都需要调整参数dirty所描述的一个需要重新绘制的区域的大小和位置。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;调整好参数dirty所描述的一个需要重新绘制的区域之后，&nbsp;ViewRoot类的成员函数invalidateChild就将它所描述的一个区域与成员变量mDirty所描述的一区域执行一个合并操作，并且将得到的新区域保存在成员变量mDirty中。从这个操作就可以看出，ViewRoot类的成员变量mDirty描述的就是当前正在处理的应用程序窗口下一次所要重新绘制的总区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;设置好当前正在处理的应用程序窗口下一次所要重新绘制的总区域之后，ViewRoot类的成员函数invalidateChild最后就检查成员变量mWillDrawSoon的值是否不等于true。如果ViewRoot类的成员mWillDrawSoon的值等于true的话，那么就说明UI线程的消息队列中已经有一个DO_TRAVERSAL消息在等待执行了，这时候就不需要调用ViewRoot类的成员函数scheduleTraversals来向UI线程的消息队列发送一个DO_TRAVERSAL消息了，否则的话，就需要调用ViewRoot类的成员函数scheduleTraversals来向UI线程的消息队列发送一个DO_TRAVERSAL消息。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的成员函数scheduleTraversals在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8303098">Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析</a>一文中已经分析过了，这里不再详述。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步执行完成之后，返回到前面的Step 1中，即View类的成员函数layout中，接下来它就会调用另外一个成员函数onLayout来重新布局当前视图的子视图的布局了。View类的成员函数onLayout是由子类来重写的，并且只有当该子类描述的是一个容器视图时，它才会重写父类View的成员函数onLayout。前面我们已经假设当前正在处理的是应用程序窗口的顶层视图，它的类型为DecorView，并且它描述的是一个容器视图，因此，接下来我们就会继续分析DecorView类的成员函数onLayout的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;事实上，DecorView类是通过FrameLayout类来间接继承View类的，并且它的成员函数onLayout是从FrameLayout类继承下来的，因此，接下来我们实际上要分析的是FrameLayout类的成员函数onLayout的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 5.&nbsp;FrameLayout.onLayout</p><p></p><pre class="java" name="code">public class FrameLayout extends ViewGroup {
    ......

    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        final int count = getChildCount();

        final int parentLeft = mPaddingLeft + mForegroundPaddingLeft;
        final int parentRight = right - left - mPaddingRight - mForegroundPaddingRight;

        final int parentTop = mPaddingTop + mForegroundPaddingTop;
        final int parentBottom = bottom - top - mPaddingBottom - mForegroundPaddingBottom;

        mForegroundBoundsChanged = true;

        for (int i = 0; i &lt; count; i++) {
            final View child = getChildAt(i);
            if (child.getVisibility() != GONE) {
                final LayoutParams lp = (LayoutParams) child.getLayoutParams();

                final int width = child.getMeasuredWidth();
                final int height = child.getMeasuredHeight();

                int childLeft = parentLeft;
                int childTop = parentTop;

                final int gravity = lp.gravity;

                if (gravity != -1) {
                    final int horizontalGravity = gravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK;
                    final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;

                    switch (horizontalGravity) {
                        case Gravity.LEFT:
                            childLeft = parentLeft + lp.leftMargin;
                            break;
                        case Gravity.CENTER_HORIZONTAL:
                            childLeft = parentLeft + (parentRight - parentLeft - width) / 2 +
                                    lp.leftMargin - lp.rightMargin;
                            break;
                        case Gravity.RIGHT:
                            childLeft = parentRight - width - lp.rightMargin;
                            break;
                        default:
                            childLeft = parentLeft + lp.leftMargin;
                    }
                    switch (verticalGravity) {
                        case Gravity.TOP:
                            childTop = parentTop + lp.topMargin;
                            break;
                        case Gravity.CENTER_VERTICAL:
                            childTop = parentTop + (parentBottom - parentTop - height) / 2 +
                                    lp.topMargin - lp.bottomMargin;
                            break;
                        case Gravity.BOTTOM:
                            childTop = parentBottom - height - lp.bottomMargin;
                            break;
                        default:
                            childTop = parentTop + lp.topMargin;
                    }
                }

                child.layout(childLeft, childTop, childLeft + width, childTop + height);
            }
        }
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/widget/FrameLayout.java中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FrameLayout类的成员变量mPaddingLeft、mPaddingRight、mPaddingTop、mPaddingBottom和mForegroundPaddingLeft、mForegroundPaddingRight、mForegroundPaddingTop、mForegroundPaddingBottom的含义我们在前面分析Android应用程序窗品的测量过程时已经解释过了，它们描述的是当前视图的内边距，而参数left、top、right和bottom描述的是当前视图的外边距，即它与父窗口的边距。通过上述这些参数，我们就可以得到当前视图的子视图所能布局在的区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FrameLayout类的成员函数onLayout通过一个for循环来布局当前视图的每一个子视图。如果一个子视图child是可见的，那么FrameLayout类的成员函数onLayout就会根据当前视图可以用来显示子视图的区域以及它所设置的gravity属性来得到它在应用程序窗口中的左上角位置（childeLeft，childTop）。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;当一个子视图child在应用程序窗口中的左上角位置确定了之后，再结合它在前面的测量过程中所确定的宽度width和高度height，我们就可以完全地确定它在应用程序窗口中的布局了，即可以调用它的成员函数layout来设置它的位置和大小了，这刚好就是前面的Step 1所执行的操作。注意，如果当前正在布局的子视图child描述的也是一个视图容器，那么它又会重复执行Step 5的操作，直到它的所有子孙视图都布局完成为止。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;至此，我们就分析完成Android应用程序窗口的布局过程了，接下来我们继续分析Android应用程序窗口的绘制过程。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; 3.&nbsp;Android应用程序窗口的绘制过程</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;ViewRoot类的成员函数draw首先会创建一块画布，接着再在画布上绘制Android应用程序窗口的UI，最后再将画布的内容交给SurfaceFlinger服务来渲染，这个过程如图4所示：</p><p style="margin: 4px 0px; padding: 2px 0px; text-align: center;"><img alt="" src="http://img.my.csdn.net/uploads/201212/29/1356756550_3597.jpg" width="614" /><br /></p><p style="margin: 4px 0px; padding: 2px 0px; text-align: center;">图4 Android应用程序窗口的绘制过程</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个过程可以分为14个步骤，接下来我们就详细分析每一个步骤。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 1. ViewRoot.draw</p><p style="margin: 4px 0px; padding: 2px 0px;"></p><pre class="java" name="code">public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......

    private void draw(boolean fullRedrawNeeded) {
        Surface surface = mSurface;
        ......

        int yoff;
        final boolean scrolling = mScroller != null &amp;&amp; mScroller.computeScrollOffset();
        if (scrolling) {
            yoff = mScroller.getCurrY();
        } else {
            yoff = mScrollY;
        }
        if (mCurScrollY != yoff) {
            mCurScrollY = yoff;
            fullRedrawNeeded = true;
        }
        float appScale = mAttachInfo.mApplicationScale;
        boolean scalingRequired = mAttachInfo.mScalingRequired;

        Rect dirty = mDirty;
        ......

        if (mUseGL) {
            if (!dirty.isEmpty()) {
                Canvas canvas = mGlCanvas;
                if (mGL != null &amp;&amp; canvas != null) {
                    ......

                    int saveCount = canvas.save(Canvas.MATRIX_SAVE_FLAG);
                    try {
                        canvas.translate(0, -yoff);
                        if (mTranslator != null) {
                            mTranslator.translateCanvas(canvas);
                        }
                        canvas.setScreenDensity(scalingRequired
                                ? DisplayMetrics.DENSITY_DEVICE : 0);
                        mView.draw(canvas);
                        ......
                    } finally {
                        canvas.restoreToCount(saveCount);
                    }

                    ......
                }
            }
            if (scrolling) {
                mFullRedrawNeeded = true;
                scheduleTraversals();
            }
            return;
        }

        if (fullRedrawNeeded) {
            ......
            dirty.union(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));
        }

        ......

        if (!dirty.isEmpty() || mIsAnimating) {
            Canvas canvas;
            try {
                ......
                canvas = surface.lockCanvas(dirty);

                ......
            } catch (Surface.OutOfResourcesException e) {
                ......
                return;
            } catch (IllegalArgumentException e) {
                ......
                return;
            }

            try {
                if (!dirty.isEmpty() || mIsAnimating) {
                    .....

                    mView.mPrivateFlags |= View.DRAWN;

                    ......
                    int saveCount = canvas.save(Canvas.MATRIX_SAVE_FLAG);
                    try {
                        canvas.translate(0, -yoff);
                        if (mTranslator != null) {
                            mTranslator.translateCanvas(canvas);
                        }
                        canvas.setScreenDensity(scalingRequired
                                ? DisplayMetrics.DENSITY_DEVICE : 0);
                        mView.draw(canvas);
                    } finally {
                        ......
                        canvas.restoreToCount(saveCount);
                    }

                    ......
                }

            } finally {
                surface.unlockCanvasAndPost(canvas);
            }
        }

        ......

        if (scrolling) {
            mFullRedrawNeeded = true;
            scheduleTraversals();
        }
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。<p></p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;ViewRoot类的成员函数draw的执行流程如下所示：</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 将成员变量mSurface所描述的应用程序窗口的绘图表面保存在变量surface中，以便接下来可以通过变量surface来操作应用程序窗口的绘图表面。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 调用成员变量mScroller所描述的一个Scroller对象的成员函数computeScrollOffset来计算应用程序窗口是否处于正在滚动的状态中。如果是的话，那么得到的变量scrolling就会等于true，这时候调用成员变量mScroller所描述的一个Scroller对象的成员函数getCurrY就可以得到应用程序窗口在Y轴上的即时滚动位置yoff。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. 成员变量mScrollY用来描述应用程序窗口下一次绘制时在Y轴上应该滚动到的位置，因此，如果应用程序窗口不是处于正在滚动的状态，那么它在下一次绘制时，就应该直接将它在Y轴上的即时滚动位置yoff设置为mScrollY。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;4. 成员变量mCurScrollY用来描述应用程序窗口上一次绘制时在Y轴上的滚动位置，如果它的值不等变量yoff的值，那么就表示应用程序窗口在Y轴上的滚动位置发生变化了，这时候就需要将变量yoff的值保存在成员变量mCurScrollY中，并且将参数fullRedrawNeeded的设置为true，表示要重新绘制应用程序窗口的所有区域。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;5. 成员变量mAttachInfo所描述的一个AttachInfo对象的成员变量mScalingRequired表示应用程序窗口是否正在请求进行大小缩放，如果是的话，那么所请求的大小缩放因子就保存在这个AttachInfo对象的另外一个成员变量mApplicationScale中。函数将这两个值保存在变量scalingRequired和appScale中，以便接下来可以使用。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;6. 成员变量mDirty描述的是一个矩形区域，表示应用程序窗口的脏区域，即需要重新绘制的区域。函数将这个脏区域保存变量dirty中，以便接下来可以使用。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;7. 成员变量mUseGL用来描述应用程序窗口是否直接使用OpenGL接口来绘制UI。当应用程序窗口的绘图表面的内存类型等于WindowManager.LayoutParams.MEMORY_TYPE_GPU时，那么就表示它需要使用OpenGL接口来绘制UI，以便可以利用GPU来绘制UI。当应用程序窗口需要直接使用OpenGL接口来绘制UI时，另外一个成员变量mGlCanvas就表示应用程序窗口的绘图表面所使用的画布，这块画布同样是通过OpenGL接口来创建的。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;8. 当应用程序窗口需要直接使用OpenGL接口来绘制UI时，函数接下来就会将它的UI绘制在成员变量mGlCanvas所描述的一块画布上，这是通过调用成员变量mView所描述的一个类型为DecorView的顶层视图的成员函数draw来实现的。注意，在绘制之前，还需要对画布进行适当的转换：A. 设置画布在Y轴上的偏移值yoff，以便可以正确反映应用程序窗口的滚动状态；B. 如果成员变量mTranslator的值不等于null，即它指向了一个Translator对象，那么就说明应用程序窗口运行在兼容模式下，这时候就需要相应对画布进行变换，以便可以正确反映应用程序窗口的大小；C. 当变量scalingRequired的值等于true时，同样说明应用程序窗口是运行在兼容模式下，这时候就需要修改画布在兼容模式下的点密度，以便可以正确地反映应用程序窗口的分辨率，注意，这时候屏幕在兼容模式下的点密度保存在DisplayMetrics类的静态成员变量DENSITY_DEVICE中。由于上述画布的转换操作只针对当前的这一次绘制操作有效，因此，函数就需要在绘制之后，调用画布的成员函数save来保存它在转换前的矩阵变换堆栈状态，以便在绘制完成之后，可以调用画布的成员函数restoreToCount来恢复之前的矩阵变换堆栈状态。<br /></p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; 9.&nbsp;使用OpenGL接口来绘制完成UI后，如果变量scrolling的值等于true，即应用程序窗口是处于正在滚动的状态，那么就意味着应用程序窗口接下来还需要马上进行下一次重绘，而且是所有的区域都需要重绘，因此，函数接下来就会将成员变量mFullRedrawNeeded的值设置为true，并且调用另外一个成员函数scheduleTraversals来请求执行下一次的重绘操作。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp;10. 以下的步骤针适用于使用非OpenGL接口来绘制UI的情况，也是本文所要关注的重点。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp;11. 参数fullRedrawNeeded用来描述是否需要绘制应用程序窗口的所有区域。如果需要的话，那么就会将应用程序窗口的脏区域的大小设置为整个应用程序窗口的大小（0，0，mWidth，mHeight），其中，成员变量mWidth和mHeight表示应用程序窗口的宽度和高度。注意，如果应用程序窗口的大小被设置了一个缩放因子，即变量appScale的值不等于1，那么就需要将应用程序窗口的宽度mWidth和高度mHeight乘以这个缩放因子，然后才可以得到应用程序窗口的实际大小。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp;12. 经过前面的一系列计算之后，如果应用程序窗口的脏区域dirty不等于空，或者应用程序窗口在正处于动画状态，即成员变量mIsAnimating的值等于true，那么函数接下来就需要重新绘制应用程序窗口的UI了。在绘制之前，首先会调用用来描述应用程序窗口的绘图表面的一个Surface对象surface的成员函数lockCanvas来创建一块画布canvas。有了这块画布之后，接下来就可以调用成员变量mView所描述的一个类型为DecorView的顶层视图的成员函数draw来在上面绘制应用程序窗口的UI了。&nbsp;与前面的第8步一样，在绘制之前，还需要对画布进行适当的A、B和C转换，以及需要在绘制之后恢复画布在绘制之前的矩阵变换堆栈状态。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp;13. 绘制完成之后，应用程序窗口的UI就都体现在前面所创建的画布canvas上了，因此，这时候就需要将它交给SurfaceFlinger服务来渲染，这是通过调用用来描述应用程序窗口的绘图表面的一个Surface对象surface的成员函数unlockCanvasAndPost来实现的。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp;14. 在请求SurfaceFlinger服务渲染应用程序窗口的UI之后，函数同样是需要判断变量scrolling的值是否等于true。如果等于的话，那么就与前面的第9步一样，函数需要将成员变量mFullRedrawNeeded的值设置为true，并且调用另外一个成员函数scheduleTraversals来请求执行下一次的重绘操作。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; 在本文中，我们只关注使用非OpenGL接口来绘制应用程序窗口的UI的步骤，其中，第12步和第13步是关键所在。第12步调用了Java层的Surface类的成员函数lockCanvas来为应用程序窗口的绘图表面创建了一块画布，并且调用了DecorView类的成员函数draw来在这块画布上绘制了应用程序窗口的UI，而第13步调用了Java层的Surface类的成员函数unlockCanvasAndPost来将前面已经绘制了应用程序窗口UI的画布交给SurfaceFlinger服务来渲染。接下来，我们就分别分析Java层的Surface类的成员函数lockCanvas、DecorView类的成员函数draw和Java层的Surface类的成员函数unlockCanvasAndPost的实现。</p><p style="margin: 4px 0px; padding: 2px 0px;">&nbsp;&nbsp; &nbsp; &nbsp; Step 2.&nbsp;Surface.lockCanvas</p><p style="margin: 4px 0px; padding: 2px 0px;"></p><pre class="java" name="code">public class Surface implements Parcelable {
    ......

    public Canvas lockCanvas(Rect dirty) throws OutOfResourcesException, IllegalArgumentException
    {
        /* the dirty rectangle may be expanded to the surface's size, if
         * for instance it has been resized or if the bits were lost, since
         * the last call.
         */
        return lockCanvasNative(dirty);
    }

    private native Canvas lockCanvasNative(Rect dirty);

    ......
} </pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/Surface.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Surface类的成员函数lockCanvas调用另外一个成员函数lockCanvasNative来创建一块画布。Surface类的成员函数lockCanvasNative是一个JNI方法，它是由C++层的函数Surface_lockCanvas来实现的，如下所示：</p><p><span style="font-family: monospace;"><span style="white-space: pre;"><span style="font-family:Arial, Helvetica, sans-serif;"><span style="white-space: normal;"></span></span></span></span></p><pre class="cpp" name="code">static jobject Surface_lockCanvas(JNIEnv* env, jobject clazz, jobject dirtyRect)  
{  
    const sp&lt;Surface&gt;&amp; surface(getSurface(env, clazz));  
    ......  
  
    // get dirty region  
    Region dirtyRegion;  
    if (dirtyRect) {  
        Rect dirty;  
        dirty.left  = env-&gt;GetIntField(dirtyRect, ro.l);  
        dirty.top   = env-&gt;GetIntField(dirtyRect, ro.t);  
        dirty.right = env-&gt;GetIntField(dirtyRect, ro.r);  
        dirty.bottom= env-&gt;GetIntField(dirtyRect, ro.b);  
        if (!dirty.isEmpty()) {  
            dirtyRegion.set(dirty);  
        }  
    }   
    ......  
  
    Surface::SurfaceInfo info;  
    status_t err = surface-&gt;lock(&amp;info, &amp;dirtyRegion);  
    ......  
  
    // Associate a SkCanvas object to this surface  
    jobject canvas = env-&gt;GetObjectField(clazz, so.canvas);  
    ......  
  
    SkCanvas* nativeCanvas = (SkCanvas*)env-&gt;GetIntField(canvas, no.native_canvas);  
    SkBitmap bitmap;  
    ......  
    if (info.w &gt; 0 &amp;&amp; info.h &gt; 0) {  
        bitmap.setPixels(info.bits);  
    } else {  
        // be safe with an empty bitmap.  
        bitmap.setPixels(NULL);  
    }  
    ......  
  
    SkRegion clipReg;  
    if (dirtyRegion.isRect()) { // very common case  
        const Rect b(dirtyRegion.getBounds());  
        clipReg.setRect(b.left, b.top, b.right, b.bottom);  
    } else {  
        size_t count;  
        Rect const* r = dirtyRegion.getArray(&amp;count);  
        while (count) {  
            clipReg.op(r-&gt;left, r-&gt;top, r-&gt;right, r-&gt;bottom, SkRegion::kUnion_Op);  
            r++, count--;  
        }  
    }  
  
    nativeCanvas-&gt;clipRegion(clipReg);  
  
    int saveCount = nativeCanvas-&gt;save();
    env-&gt;SetIntField(clazz, so.saveCount, saveCount);  
  
    if (dirtyRect) {  
        const Rect&amp; bounds(dirtyRegion.getBounds());  
        env-&gt;SetIntField(dirtyRect, ro.l, bounds.left);  
        env-&gt;SetIntField(dirtyRect, ro.t, bounds.top);  
        env-&gt;SetIntField(dirtyRect, ro.r, bounds.right);  
        env-&gt;SetIntField(dirtyRect, ro.b, bounds.bottom);  
    }  
  
    return canvas;  
}  </pre><p></p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/jni/android_view_Surface.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数clazz指向的是一个Java层的Surface对象。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8303098">Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析</a>一文可以知道，每一个Java层的Surface对象在C++层都对应有一个Surface对象。因此，函数首先调用另外一个函数getSurface来获得与参数clazz所对应的C++层的Surface对象surface。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数dirtyRect指向的是一个Java层的Rect对象，它描述的是应用程序窗口即将要重绘的一块矩形区域，函数接下来就将它所描述的矩形区域转换成一个C++层的Region对象dirtyRegion来表示。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;函数接下来就调用前面所获得的C++层的Surface对象surface的成员函数lock来获得一个图形缓冲区，这个图形缓冲区使用一个SurfaceInfo对象info来描述，其中，图形缓冲区的地址就保存在它的成员变量bits中。<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;获得图形缓冲区之后，我们就可以在上面绘制应用程序窗口的UI了。由于Java层的应用程序窗口是通Skia图形库来绘制应用程序窗口的UI的，而Skia图形库在绘制UI时，是需要一块画布的，因此，函数接下来就会将前面所获得的图形缓冲区封装在一块画布中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8303098">Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析</a>一文还可以知道，每一个Java层的Surface对象内部都有一块画布，这块画布是通过它的成员变量mCanvas所指向的一个Java层的CompatibleCanvas对象来描述的。so是一个类型为so_t的结构体，它的成员变量canvas描述的是Java层的Surface类的成员变量mCanva在类中的偏移量，因此，通过这个偏移量就可以获得参数clazz所指向的一个Java层的Surface对象的内部的一块类型为CompatibleCanvas的画布canvas。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;画布canvas的类型为Java层的CompatibleCanvas，它是从Canvas类继承下来的。Canvas类有一个成员变量mNativeCanvas，它指向的是一个C++层的SkCanvas对象，这个C++层的SkCanvas对象描述的就是Skia图形库绘制应用程序窗口UI时所需要的画布。no是一个类型为no_t的结构体，它的成员变量native_canvas描述的是Java层的Canvas类的成员变量mNativeCanvas在类中的偏移量，因此，通过这个偏移量就可以获得变量canvas所指向的一个Java层的CompatibleCanvas对象的内部的一块类型为SkCanvas的画布nativeCanvas。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 获得了Skia图形库所需要的画布nativeCanvas之后，函数就可以将前面所获得的图形缓冲区的地址，即SurfaceInfo对象info的成员变量bits封装到它内部去了，这是通过调用它的成员函数setPixels来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数接下来还会设置画布nativeCanvas的裁剪区域。这个裁剪区域是通过Region对象dirtyRegion来描述的，不过Skia图形库需要使用另外一个类型为SkRegion的对象clipReg来描述它。Region对象dirtyRegion所描述的区域有可能是一个矩形区域，也可能是一个不规则的区域。如果Region对象dirtyRegion描述的是一个矩形区域，那么就可以直接将这个矩形区域设置到SkRegion的对象clipReg里面去。如果Region对象dirtyRegion描述的是一个不规则区域，那么这个不规则区域就是由一系列的矩形小区域来描述的，这时候就将这些矩形小区域合并起来，并且设置到kRegion的对象clipReg里面去。&nbsp;</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;设置好SkRegion的对象clipReg所包含的区域之后，函数就可以调用前面得到的SkCanvas画布nativeCanvas的成员函数clipRegion来将它设置为自己的裁剪区域了，接下来函数还会将该裁剪区域所围成的一个矩形区域的位置和大小设置到参数dirtyRect所描述的一个Java层的Rect对象中去，以便调用者可以知道现在正在创建的画布的大小。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 函数在将与C++层的SkCanvas画布nativeCanvas所关联的一个Java层的CompatibleCanvas画布canvas返回给调用者之前，还会将画布的当前堆栈状态保存下来，以便在绘制完成应用程序窗口的UI之后，可以恢复回来，这是通过调用C++层的SkCanvas画布nativeCanvas的成员函数save来实现的。画布的当前堆栈状态是通过一个整数来描述的，这个整数即为C++层的SkCanvas画布nativeCanvas的成员函数save的返回值saveCount，它会被保存在参数clazz所描述的一个Java层的Surface对象的成员变量mSaveCount中，等到应用程序窗口的UI绘制完成之后，就可以通过这个整数来恢复画布的堆栈状态了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们继续分析C++层的Surface类的成员函数lock的实现，以便可以了解用来创建绘制应用程序窗口UI所需要的画布的图形缓冲区是如何获得的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 3. Surface.lock</p><p></p><pre class="cpp" name="code">status_t Surface::lock(SurfaceInfo* other, Region* dirtyIn, bool blocking)
{
    ......

    if (mApiLock.tryLock() != NO_ERROR) {
        ......
        return WOULD_BLOCK;
    }

    /* Here we're holding mApiLock */

    if (mLockedBuffer != 0) {
        ......
        mApiLock.unlock();
        return INVALID_OPERATION;
    }

    // we're intending to do software rendering from this point
    setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);

    android_native_buffer_t* out;
    status_t err = dequeueBuffer(&amp;out);
    ......
    if (err == NO_ERROR) {
        sp&lt;GraphicBuffer&gt; backBuffer(GraphicBuffer::getSelf(out));
        err = lockBuffer(backBuffer.get());
        ......
        if (err == NO_ERROR) {
            const Rect bounds(backBuffer-&gt;width, backBuffer-&gt;height);
            const Region boundsRegion(bounds);
            Region scratch(boundsRegion);
            Region&amp; newDirtyRegion(dirtyIn ? *dirtyIn : scratch);
            newDirtyRegion &amp;= boundsRegion;

            // figure out if we can copy the frontbuffer back
            const sp&lt;GraphicBuffer&gt;&amp; frontBuffer(mPostedBuffer);
            const bool canCopyBack = (frontBuffer != 0 &amp;&amp;
                    backBuffer-&gt;width  == frontBuffer-&gt;width &amp;&amp;
                    backBuffer-&gt;height == frontBuffer-&gt;height &amp;&amp;
                    backBuffer-&gt;format == frontBuffer-&gt;format &amp;&amp;
                    !(mFlags &amp; ISurfaceComposer::eDestroyBackbuffer));

            ......

            if (canCopyBack) {
                // copy the area that is invalid and not repainted this round
                const Region copyback(mOldDirtyRegion.subtract(newDirtyRegion));
                if (!copyback.isEmpty())
                    copyBlt(backBuffer, frontBuffer, copyback);
            } else {
                // if we can't copy-back anything, modify the user's dirty
                // region to make sure they redraw the whole buffer
                newDirtyRegion = boundsRegion;
            }

            ......

            void* vaddr;
            status_t res = backBuffer-&gt;lock(
                    GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
                    newDirtyRegion.bounds(), &amp;vaddr);

            ......

            mLockedBuffer = backBuffer;
            other-&gt;w      = backBuffer-&gt;width;
            other-&gt;h      = backBuffer-&gt;height;
            other-&gt;s      = backBuffer-&gt;stride;
            other-&gt;usage  = backBuffer-&gt;usage;
            other-&gt;format = backBuffer-&gt;format;
            other-&gt;bits   = vaddr;
        }
    }
    mApiLock.unlock();
    return err;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; Surface类的成员变量mApiLock是一个类型为Mutex的互斥锁，它是用来保证Surface类的成员函数lock是线程安全的。如果调用Surface类的成员变量mApiLock所描述的一个Mutex对象的成员函数tryLock的返回值不等于NO_ERROR，那么就说明这个Mutex对象已经被另外一个线程获得了，因此，这时候函数就直接返回一个错误码WOULD_BLOCK给调用者了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Surface类的成员变量mLockedBuffer的类型为GraphicBuffer，如果它的值不等于0，那么它指向的就是应用程序窗口当前正在使用的图形缓冲区。如果应用程序窗口正在使用一个图形缓冲区，那么它是不可以再请求分配另一个图形缓冲区的，因此，当Surface类的成员变量mLockedBuffer的值不等于0时，函数就直接返回一个错误码INVALID_OPERATION给调用者了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 通过了前面的检查之后，Surface类的成员函数lock接下来就开始要分配一个图形缓冲区了，不过在分配之后，首先调用另外一个成员函数setUsage来将当前正在处理的Surface对象所描述的应用程序窗口的绘图表面的属性设置为（GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN），表示该应用程序窗口的UI是需要通过软件方式来渲染的，这是相对于使用GPU来渲染而言的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;Surface类的成员函数lock接下来就调用另外一个成员函数dequeueBuffer来获得一个新的图形缓冲区了，这个新的图形缓冲区使用一个android_native_buffer_t对象out来描述的。在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文中，我们已经分析过Surface类的成员函数dequeueBuffer的实现了，它主要就是请求SurfaceFlinger服务来分配一个图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 前面获得的android_native_buffer_t对象out接下来又会被封装成一个GraphicBuffer对象backBuffer，这样，Surface类的成员函数lock接下来就会通过GraphicBuffer对象backBuffer来访问前面所获得的图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Surface类是使用一种称为双缓冲的技术来渲染应用程序窗口的UI的。这种双缓冲技术需要两个图形缓冲区，其中一个称为前端缓冲区，另外一个称为后端缓冲区。前端缓冲区是正在渲染的图形缓冲区，而后端缓冲区是接下来要渲染的图形缓冲区，它们分别通过Surface类的成员变量mPostedBuffer和mLockedBuffer所指向的两个GraphicBuffer对象来描述。前面所获得的图形缓冲区backBuffer是作为后端缓冲区来使用的，即接下来它所指向的图形缓冲区也需要保存在Surface类的成员变量mLockedBuffer中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在将图形缓冲区backBuffer返回给调用者之前，Surface类的成员函数lock还需要对它进行进一步的处理，即判断是否需要前端缓冲区mPostedBuffer的内容拷贝回它里面去，以便可以支持部分更新应用程序窗口UI的功能。在满足以下三个条件下，Surface类的成员函数lock可以将前端缓冲区的内容拷贝到后端缓冲区中去：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1.&nbsp;前端缓冲区的内容拷贝到后端缓冲区所描述的区域的宽度和高度相同。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2.&nbsp;前端缓冲区和后端缓冲区的像素格式相同。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 3. 应用程序窗口绘图表面的属性值mFlags的ISurfaceComposer::eDestroyBackbuffer位等于0，即在渲染了应用程序窗口的UI之后，应该保留正在渲染的图形缓冲区的内容。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 如果能将前端缓冲区的内容拷贝到后端缓冲区中去，那么就不用重新绘制应用程序窗口的所有区域，而只需要绘制那些脏的区域，即Region对象newDirtyRegion所描述的区域。注意，参数dirtyIn所描述的区域是原先指定的脏区域，但是在分配了新的后端缓冲区backBuffer之后，我们需要将新的图形缓冲区backBuffer所描述的区域boundsRegion与原先指定的脏区域作一个与操作，得到才是最后需要重绘的脏区域newDirtyRegion。由于在这种情况下，我们只在后端缓冲区backBuffer绘制中绘制应用程序窗口的脏区域，因此，就需要将那些干净的区域从前端缓冲区frontBuffer拷贝到图形缓冲区backBuffer的对应位置去，这是通过调用函数copyBlt来实现的。应用程序窗口的干净区域使用Region对象copyback来描述，它是从应用程序窗口上一次所重绘的区域减去接下来需要重绘的脏区域newDirtyRegion得到的，而应用程序窗口上一次所重绘的区域是保存在Surface类的成员变量mOldDirtyRegion中的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;如果不能将前端缓冲区的内容拷贝到后端缓冲区中去，那么接下来就需要重新绘制应用程序窗口的所有区域了，这时候应用程序窗口的脏区域newDirtyRegion就会被修改为后端缓冲区backBuffer所描述的区域boundsRegion。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;Surface类的成员函数lock处理完成前后端缓冲区的拷贝问题之后，接下来就会调用后端缓冲区backBuffer所指向的一个GraphicBuffer对象的成员函数lock来获得它的地址vaddr，以便接下来保存在参数other所描述的一个SurfaceInfo对象的成员变量bits中，这样调用者就获得后端缓冲区backBuffer的地址值了。注意，同时保存在SurfaceInfo对象中的信息还包括后端缓冲区backBuffer的宽度width、高度height、每行像素点stride、用途usage和像素格式format。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Surface类的成员函数lock还会将接下来要重绘的脏缓冲区newDirtyRegion保存在Surface类的成员变量mOldDirtyRegion中，以便再下一次为应用程序窗口分配图形缓冲区时，可以知道应用程序窗口的上一次重绘区域，即上一次干净区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 此外，Surface类的成员函数lock还会将后端缓冲区backBuffer保存在Surface类的成员变量mLockedBuffer，这样就可以知道应用程序窗口当前正在使用的图形缓冲区，即下一次要请求SurfaceFlinger服务渲染的图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 最后，Surface类的成员函数lock首先调用成员变量mApiLock所指向的一个Mutex对象的成员函数unlock，以便中可以释放前面所获得的锁，然后再返回到上一步去。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们继续分析GraphicBuffer类的成员函数lock的实现，以便可以了解一个图形缓冲区的地址是如何获得的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 4.&nbsp;GraphicBuffer.lock</p><p></p><pre class="cpp" name="code">status_t GraphicBuffer::lock(uint32_t usage, const Rect&amp; rect, void** vaddr)
{
    ......

    status_t res = getBufferMapper().lock(handle, usage, rect, vaddr);
    return res;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/libs/ui/GraphicBuffer.cpp中。<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;GraphicBuffer类的成员变量handle是从父类android_native_buffer_t继承下来的，它的类型为buffer_handle_t，用来作为一个图形缓冲区的句柄，这个知识点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;GraphicBuffer类的成员函数lockGraphicBuffer首先调用另外一个成员函数getBufferMapper来获得一个GraphicBufferMapper对象，然后再调用这个GraphicBufferMapper对象的成员函数lock来获得成员变量handle所描述的一个图形缓冲区的地址，并且保存在输出参数vaddr中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析GraphicBufferMapper类的成员函数lock的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 5.&nbsp;GraphicBufferMapper.lock</p><p></p><pre class="cpp" name="code">status_t GraphicBufferMapper::lock(buffer_handle_t handle,
        int usage, const Rect&amp; bounds, void** vaddr)
{
    status_t err;
    if (sw_gralloc_handle_t::validate(handle) &lt; 0) {
        err = mAllocMod-&gt;lock(mAllocMod, handle, usage,
                bounds.left, bounds.top, bounds.width(), bounds.height(),
                vaddr);
    } else {
        err = sw_gralloc_handle_t::lock((sw_gralloc_handle_t*)handle, usage,
                bounds.left, bounds.top, bounds.width(), bounds.height(),
                vaddr);
    }
    LOGW_IF(err, &quot;lock(...) failed %d (%s)&quot;, err, strerror(-err));
    return err;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/ui/GraphicBufferMapper.cpp。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;GraphicBufferMapper类的成员函数lock首先调用sw_gralloc_handle_t类的静态成员函数validate来验证参数andle所描述的一个图形缓冲区是否是在w_gralloc_handle_t模块中分配的。如果是的话，那么就需要调用sw_gralloc_handle_t类的静态成员函数lock来获得参数andle所描述的一个图形缓冲区的地址，否则的话，就需要调用GraphicBufferMapper类的成员变量mAllocMod所描述的一个HAL模块Gralloc的成员函数lock来获得参数andle所描述的一个图形缓冲区的地址。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文可以知道，应用程序窗口所使用的图形缓冲区一般都是在HAL模块Gralloc中分配的，因此，GraphicBufferMapper类的成员函数lock接下来就会调用成员变量mAllocMod所描述的一个HAL模块Gralloc的成员函数lock来获得参数andle所描述的一个图形缓冲区的地址，并且保存在输出参数vaddr中。HAL模块Gralloc的成员函数lock的实现可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文，这里不再详述。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这一步执行完成之后，返回到前面的Step 1中，即ViewRoot类的成员函数draw中，接下来就会继续调用其成员变量mView所描述的一个DecorView对象的成员函数draw来在前面所获得一块画布上面绘制应用程序窗口的UI。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 6. DecorView.draw</p><p></p><pre class="java" name="code">public class PhoneWindow extends Window implements MenuBuilder.Callback {
    ......

    private final class DecorView extends FrameLayout implements RootViewSurfaceTaker {
        ......

        private Drawable mMenuBackground;
        ......

        @Override
        public void draw(Canvas canvas) {
            super.draw(canvas);

            if (mMenuBackground != null) {
                mMenuBackground.draw(canvas);
            }
        }

        ......
    }

    ......
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindow.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;DecorView类的成员函数draw首先调用父类FrameLayout的成员函数draw来绘制它的UI内容，然后再检查它是否设置了菜单背景，即成员变量mMenuBackground的值是否不等于null。如果不等于null的话，那么就会调用它所指向的一个Drawable对象的成员函数draw来在画布canvas上绘制这个菜单背景。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析FrameLayout的成员函数draw的实现，以便可以了解应用程序窗口UI的绘制过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 7.&nbsp;FrameLayout.draw</p><p></p><pre class="java" name="code">public class FrameLayout extends ViewGroup {
    ......
  
    private Drawable mForeground;
    ......

    public void draw(Canvas canvas) {
        super.draw(canvas);

        if (mForeground != null) {
            final Drawable foreground = mForeground;

            if (mForegroundBoundsChanged) {
                mForegroundBoundsChanged = false;
                final Rect selfBounds = mSelfBounds;
                final Rect overlayBounds = mOverlayBounds;

                final int w = mRight-mLeft;
                final int h = mBottom-mTop;

                if (mForegroundInPadding) {
                    selfBounds.set(0, 0, w, h);
                } else {
                    selfBounds.set(mPaddingLeft, mPaddingTop, w - mPaddingRight, h - mPaddingBottom);
                }

                Gravity.apply(mForegroundGravity, foreground.getIntrinsicWidth(),
                        foreground.getIntrinsicHeight(), selfBounds, overlayBounds);
                foreground.setBounds(overlayBounds);
            }

            foreground.draw(canvas);
        }
    }

    ......
}</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/widget/FrameLayout.java中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;FrameLayout类的成员函数draw首先调用父类View的成员函数draw来绘制它的UI内容，然后再检查它是否设置了一个前景图，即成员变量mForeground的值是否等于null。如果不等于null的话，那么就会先设置这个前景图的大小和位置，然后再调用用成员变量mForeground所指向的一个Drawable对象的成员函数draw来在画布canvas上绘制这个前景图。<br /></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析View类的成员函数draw的实现，以便可以了解应用程序窗口UI的绘制过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 8. View.draw</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/View.java中，它主要是完成以下六个操作：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 绘制当前视图的背景。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 保存当前画布的堆栈状态，并且在在当前画布上创建额外的图层，以便接下来可以用来绘制当前视图在滑动时的边框渐变效果。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. 绘制当前视图的内容。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;4. 绘制当前视图的子视图的内容。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;5. 绘制当前视图在滑动时的边框渐变效果。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;6. 绘制当前视图的滚动条。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在上面六个操作中，有些是可以优化的。例如，如果当前视图的某一个子视图是不透明的，并且覆盖了当前视图的内容，那么当前视图的背景以及内容就不会绘制了，即不用执行第1和第3个操作。又如，如果当前视图不是处于滑动的状态，那么第2和第5个操作也是不用执行的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来我们就分段来阅读View类的成员函数draw的代码：</p><p></p><pre class="java" name="code">public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {
    ......

    public void draw(Canvas canvas) {
        ......

        final int privateFlags = mPrivateFlags;
        final boolean dirtyOpaque = (privateFlags &amp; DIRTY_MASK) == DIRTY_OPAQUE &amp;&amp;
                (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState);
        mPrivateFlags = (privateFlags &amp; ~DIRTY_MASK) | DRAWN;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码检查View类的成员变量mPrivateFlags的DIRTY_OPAQUE位是否等于1。如果等于1的话，那么就说明当前视图的某一个子视图请求了一个不透明UI绘制操作。在这种情况下，当前视图会被子视图覆盖，因此，就不需要执行前面所说的第1和第3个操作了。不过，不用执行第1和第3个操作还有一个前提，那就是View类的成员变量mAttachInfo所指向的一个AttachInfo对象的成员变量mIgnoreDirtyState的值等于false，这表示当前视图不可以忽略成员变量mPrivateFlags的DIRTY_OPAQUE位。满足了上述两个条件之后，变量dirtyOpaque的值就会等于true。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; View类的成员函数在继续往下执行之前，还会将成员变量mPrivateFlags的DIRTY_MASK位重置为0，以及将DRAWN位设置为1，因为接下来就要开始绘制当前视图的UI了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 我们继续往下阅读代码：</p><p></p><pre class="java" name="code">        // Step 1, draw the background, if needed
        int saveCount;

        if (!dirtyOpaque) {
            final Drawable background = mBGDrawable;
            if (background != null) {
                final int scrollX = mScrollX;
                final int scrollY = mScrollY;

                if (mBackgroundSizeChanged) {
                    background.setBounds(0, 0,  mRight - mLeft, mBottom - mTop);
                    mBackgroundSizeChanged = false;
                }

                if ((scrollX | scrollY) == 0) {
                    background.draw(canvas);
                } else {
                    canvas.translate(scrollX, scrollY);
                    background.draw(canvas);
                    canvas.translate(-scrollX, -scrollY);
                }
            }
        }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来执行上述的第1个操作，但是它只会变量dirtyOpaque的值等于false的情况下才会执行。当前视图的背景是通过成员变量mBGDrawable所指向的一个Drawable对象来描述的。在绘制当前视图的背景之前，还会先设置它的大小和位置。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读代码：</p><p></p><pre class="java" name="code">        // skip step 2 &amp; 5 if possible (common case)
        final int viewFlags = mViewFlags;
        boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0;
        boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0;
        if (!verticalEdges &amp;&amp; !horizontalEdges) {
            // Step 3, draw the content
            if (!dirtyOpaque) onDraw(canvas);

            // Step 4, draw the children
            dispatchDraw(canvas);

            // Step 6, draw decorations (scrollbars)
            onDrawScrollBars(canvas);

            // we're done...
            return;
        }</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码检查是否可以跳过上述的第2和第5个操作。当View类的成员变量mViewFlags的FADING_EDGE_HORIZONTAL位等于1的时候，就说明当前视图正在处于水平滑动状态，并且需要绘制水平边框的渐变效果。同样，当View类的成员变量mViewFlags的FADING_EDGE_VERTICAL位等于1的时候，就说明当前视图正在处于垂直滑动状态，并且需要绘制垂直边框的渐变效果。但是，如果当前视图不是处于滑动状态，即变量horizontalEdges和verticalEdges的值均等于false的时候，那么就不需要执行上述的第2和第5个操作了，而只需要执行第3、第4和第6个操作。注意，当变量dirtyOpaque的值等于true的时候，第3个操作也是不需要执行的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下分析代码：</p><p></p><pre class="java" name="code">        boolean drawTop = false;
        boolean drawBottom = false;
        boolean drawLeft = false;
        boolean drawRight = false;

        float topFadeStrength = 0.0f;
        float bottomFadeStrength = 0.0f;
        float leftFadeStrength = 0.0f;
        float rightFadeStrength = 0.0f;

        // Step 2, save the canvas' layers
        int paddingLeft = mPaddingLeft;
        int paddingTop = mPaddingTop;

        final boolean offsetRequired = isPaddingOffsetRequired();
        if (offsetRequired) {
            paddingLeft += getLeftPaddingOffset();
            paddingTop += getTopPaddingOffset();
        }

        int left = mScrollX + paddingLeft;
        int right = left + mRight - mLeft - mPaddingRight - paddingLeft;
        int top = mScrollY + paddingTop;
        int bottom = top + mBottom - mTop - mPaddingBottom - paddingTop;

        if (offsetRequired) {
            right += getRightPaddingOffset();
            bottom += getBottomPaddingOffset();
        }

        final ScrollabilityCache scrollabilityCache = mScrollCache;
        int length = scrollabilityCache.fadingEdgeLength;

        // clip the fade length if top and bottom fades overlap
        // overlapping fades produce odd-looking artifacts
        if (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) {
            length = (bottom - top) / 2;
        }

        // also clip horizontal fades if necessary
        if (horizontalEdges &amp;&amp; (left + length &gt; right - length)) {
            length = (right - left) / 2;
        }

        if (verticalEdges) {
            topFadeStrength = Math.max(0.0f, Math.min(1.0f, getTopFadingEdgeStrength()));
            drawTop = topFadeStrength &gt;= 0.0f;
            bottomFadeStrength = Math.max(0.0f, Math.min(1.0f, getBottomFadingEdgeStrength()));
            drawBottom = bottomFadeStrength &gt;= 0.0f;
        }

        if (horizontalEdges) {
            leftFadeStrength = Math.max(0.0f, Math.min(1.0f, getLeftFadingEdgeStrength()));
            drawLeft = leftFadeStrength &gt;= 0.0f;
            rightFadeStrength = Math.max(0.0f, Math.min(1.0f, getRightFadingEdgeStrength()));
            drawRight = rightFadeStrength &gt;= 0.0f;
        }

        saveCount = canvas.getSaveCount();

        int solidColor = getSolidColor();
        if (solidColor == 0) {
            final int flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;

            if (drawTop) {
                canvas.saveLayer(left, top, right, top + length, null, flags);
            }

            if (drawBottom) {
                canvas.saveLayer(left, bottom - length, right, bottom, null, flags);
            }

            if (drawLeft) {
                canvas.saveLayer(left, top, left + length, bottom, null, flags);
            }

            if (drawRight) {
                canvas.saveLayer(right - length, top, right, bottom, null, flags);
            }
        } else {
            scrollabilityCache.setFadeColor(solidColor);
        }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来检查是否需要保存参数canvas所描述的一块画布的堆栈状态，并且创建额外的图层来绘制当前视图在滑动时的边框渐变效果。视图的边框是绘制在内容区域的边界位置上的，而视图的内容区域是需要排除成员变量mPaddingLeft、mPaddingRight、mPaddingTop和mPaddingBottom所描述的视图内边距的。此外，视图的边框有四个，分别位于视图的左、右、上以及下内边界上。因此，这段代码首先需要计算出当前视图的左、右、上以及下内边距的大小，以便得到边框所要绘制的区域。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;本来通过View类的成员变量mPaddingLeft、mPaddingRight、mPaddingTop和mPaddingBottom就可以得到当视图的左、右、上以及下内边距的大小的，但是有时候我们在定制一个视图的时候，可能会需要在视图的内边距上绘制其它额外的东西，这时候就有扩展视图的内边距的需求。如果有扩展视图的内边距的需求，那么就需要重写View类的成员函数isPaddingOffsetRequired，即将它的返回值设置为true，并且重载另外四个成员函数getLeftPaddingOffset、getRightPaddingOffset、getTopPaddingOffset和getBottomPaddingOffset来提供额外的左、右、上以及下内边距。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码经过计算后，就得到四个值left、right、top和bottom，它们分别表示当前视图可以用来绘制的内容区域，这个区域已经将内置的和扩展的内边距排除之外。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 计算好left、right、top和bottom这四个值之后，就相当于得到左、右、上以及下边框的起始位置了，但是我还需要知道边框的长度，才能确定左、右、上以及下边框所要绘制的区域。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;边框的长度length设置在View类的成员变量mScrollCache所指向的一个ScrollabilityCache对象的成员变量fadingEdgeLength中。但是，这个预先设置的边框长度length不一定适合当前视图使用。这是因为视图的大小是可以随时改变的，一旦发生了改变之后，原先设置的边框长度length可能就会显得过长。具体来说，就是当上下两个边框或者左右两个边框发生重叠时，就说明原先设置的边框长度过长了。在这种情况下，就要将边框长度length修改为当前视图的内容区域的高度和宽度的较小者的一半，以便可以保证上下两个边框或者左右两个边框不会发生重叠。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;左、右、上以及下边框都对应有一个强度值，强度值的取值范围为[0.0, 1.0]。如果一个边框的强度值等于0.0，那么它就是不可见的，这时候就不需要绘制它的渐变效果。另一方面，如果一个边框的强度值等于1.0，那么它的长度等于原来设置的长度。我们可以将这个强度值理解为一个缩放因子。左、右、上以及下边框的强度值可以分别通过调用View类的成员函数getLeftFadingEdgeStrength、getRightFadingEdgeStrength、getTopFadingEdgeStrength以及getBottomFadingEdgeStrength来获得。注意，只有在变量verticalEdges的值等于true的时候，这段代码才会计算上下两个边框的强度值topFadeStrength和bottomFadeStrength；同样，只有变量horizontalEdges的值等于true的时候，这代码才会计算左右两个边框的强度值leftFadeStrength和rightFadeStrength。&nbsp;</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;计算好左、右、上以及下边框的强度值leftFadeStrength、rightFadeStrength、topFadeStrength以及bottomFadeStrength之后，这段代码就会判断它们的值是否大于0。如果大于0，那么与它们所对应的四个变量drawLeft、drawRight、drawTop以及drawBottom的值就会等于true，表示需要绘制左、右、上以及下四个边框的渐变效果。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;View类的成员函数getSolidColor返回的是当前视图的背景颜色。如果当前视图的背景颜色是纯色的，即变量solidColor的值不等于0，那么这时候就会使用这个背景颜色来绘制边框的渐变效果，即调用变量scrollabilityCache所指向的一个ScrollabilityCache对象的成员函数setFadeColor来将将边框的渐变效果颜色设置为solidColor，这种情况是比较简单的。如果当前视图的背景颜色不是纯色的，即变量solidColor的值等于0，这种情况就比较复杂了，我们需要创建在参数canvas所描述的一块画布上来创建额外的图层来绘制边框的渐变效果，这样做是为了能够使用背景颜色来绘制边框的渐变效果。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数canvas所描述的一块画布上来创建额外的图层是通过调用它的成员函数saveLayer来实现的。我们注意到在调用参数canvas所指向的一个Canvas对象的成员函数saveLayer的时候，最后一个参数指定为Canvas.HAS_ALPHA_LAYER_SAVE_FLAG，这表示在将额外创建的图层合成到参数canvas所描述的一块画布上去，要给额外创建的图层设置一个透明度值。同时，我们还可以看出，当前视图的左、右、上和下边框所占据的范围分别为（left, top, left + length, bottom）、（right - length, top, right, bottom）、（left, top, right, top + length）和（left, bottom - length, right, bottom）。还有另外一个地方需要注意的是，在参数canvas所描述的一块画布上来创建额外的图层之前，这段代码首先会获得画布的当前堆栈状态，这是通过一个整数saveCount来描述的，并且这个整数是通过调用参数canvas所指向的一个Canvas对象的成员函数getSaveCount来获得的。这样，后面在额外创建的图层上绘制了边框的渐变效果之后，就可以通过前面得到的整数saveCount将恢复画布的堆栈状态，也就是将前面额外创建的图层合成到画布上来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们接着往下阅读代码：</p><pre class="java" name="code">        // Step 3, draw the content
        if (!dirtyOpaque) onDraw(canvas);

        // Step 4, draw the children
        dispatchDraw(canvas);</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码用来执行上述的第3和第4个操作，即绘制当前视图的内容，以及当前视图的子视图的内容，它们分别是通过调用View类的成员函数onDraw和dispatchDraw来实现的。本文主要关注当前视图的子视图的绘制过程，因此，在接下来的Step 9中，我们再详细分析View类的成员函数dispatchDraw的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;我们接着往下阅读代码：</p><p></p><pre class="java" name="code">        // Step 5, draw the fade effect and restore layers
        final Paint p = scrollabilityCache.paint;
        final Matrix matrix = scrollabilityCache.matrix;
        final Shader fade = scrollabilityCache.shader;
        final float fadeHeight = scrollabilityCache.fadingEdgeLength;

        if (drawTop) {
            matrix.setScale(1, fadeHeight * topFadeStrength);
            matrix.postTranslate(left, top);
            fade.setLocalMatrix(matrix);
            canvas.drawRect(left, top, right, top + length, p);
        }

        if (drawBottom) {
            matrix.setScale(1, fadeHeight * bottomFadeStrength);
            matrix.postRotate(180);
            matrix.postTranslate(left, bottom);
            fade.setLocalMatrix(matrix);
            canvas.drawRect(left, bottom - length, right, bottom, p);
        }

        if (drawLeft) {
            matrix.setScale(1, fadeHeight * leftFadeStrength);
            matrix.postRotate(-90);
            matrix.postTranslate(left, top);
            fade.setLocalMatrix(matrix);
            canvas.drawRect(left, top, left + length, bottom, p);
        }

        if (drawRight) {
            matrix.setScale(1, fadeHeight * rightFadeStrength);
            matrix.postRotate(90);
            matrix.postTranslate(right, top);
            fade.setLocalMatrix(matrix);
            canvas.drawRect(right - length, top, right, bottom, p);
        }

       canvas.restoreToCount(saveCount);</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码是用来绘制当前视图的左、右、上以及下边框的渐变效果。注意，只有左、右、上以及下边框所对应的四个变量drawLeft、drawRight、drawTop以及drawBottom的值等于true时，左、右、上以及下边框的渐变效果才需要绘制。同时，左、右、上以及下边框在绘制的时候，都会被设置一个缩放因子，即前面计算得到的左、右、上以及下边框的强度值leftFadeStrength、rightFadeStrength、topFadeStrength以及bottomFadeStrength。<br /><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;由于当前视图的左、右、上以及下边框的渐变效果是在参数canvas所描述的一块画布的额外创建的图层上绘制的，因此，在绘制完之后，这段代码需要调用参数canvas所指向的一个Canvas对象来恢复参数canvas所描述的一块画布在创建额外图层时的堆栈状态，即相当于是将前面所绘制的边框渐变效果合成到参数canvas所描述的一块画布来。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读最后一段代码：</p><p></p><pre class="java" name="code">        // Step 6, draw decorations (scrollbars)
        onDrawScrollBars(canvas);
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码用来执行上述的第6个操作，即调用View类的成员函数onDrawScrollBars来绘制当前视图的滚动条。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就主要关注当前视图的子视图的绘制过程，即View类的成员函数dispatchDraw的实现。注意，View类的成员函数dispatchDraw是一个空实现，它是由子类ViewGroup来重写的，也就是说，只有当一个视图描述的是一个视图容器时，它才会重写父类View的成员函数dispatchDraw。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 前面我们已经假设当前正在处理的视图是应用程序窗口的顶层视图，即它是一个类型为DecorView视图。DecorView类是从ViewGroup类继承下来的，并且在ViewGroup类中重写了父类View类的成员函数dispatchDraw。因此，接下来我们就继续分析ViewGroup的成员函数dispatchDraw的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 9.&nbsp;ViewGroup.dispatchDraw</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/ViewGroup.java中，它的实现比较长，我们分段来阅读：</p><p></p><pre class="java" name="code">public abstract class ViewGroup extends View implements ViewParent, ViewManager {
    ......

    @Override
    protected void dispatchDraw(Canvas canvas) {
        final int count = mChildrenCount;
        final View[] children = mChildren;
        int flags = mGroupFlags;</pre>&nbsp;&nbsp; &nbsp; &nbsp; ViewGroup类的成员变量mChildrenCount描述的是当前视图组的子视图的个数，另外一个成员变量mChildren是一个类型为View的数组，用来保存当前视图组的子视图。此外，ViewGroup类的成员变量mGroupFlags用来描述当前视图组的标志位。这段代码将上述ViewGroup类的三个成员变量分别保存在变量count、children和flags中，以便接下来可以访问。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们继续往下阅读代码：</p><p></p><pre class="java" name="code">        if ((flags &amp; FLAG_RUN_ANIMATION) != 0 &amp;&amp; canAnimate()) {
            ......

            for (int i = 0; i &lt; count; i++) {
                final View child = children[i];
                if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) {
                    ......
                    bindLayoutAnimation(child);
                    ......
                }
            }

            final LayoutAnimationController controller = mLayoutAnimationController;
            ......

            controller.start();

            ......

            if (mAnimationListener != null) {
                mAnimationListener.onAnimationStart(controller.getAnimation());
            }
        }</pre><p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来检查当前视图组的子视图是否需要显示动画。如果变量flags的FLAG_RUN_ANIMATION位等于1，并且ViewGroup类的成员函数canAnimate的返回值等于true，即当前当前视图组允许其子视图显示动画，那么这段代码接下来就要开始显示动画了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码首先检查当前视图组的每一个子视图child，如果它是可见的，那么就会调用ViewGroup类的另外一个成员函数bindLayoutAnimation来设置它的动画。设置完成子视图的动画之后，这段代码接下来再调用ViewGroup类的成员变量mLayoutAnimationController所指向的一个LayoutAnimationController对象的成员函数start来启动动画，并且调用ViewGroup类的成员变量mAnimationListener所指向的一个AnimationListener对象的成员函数onAnimationStart来通知那些注册到当前视图组的动画监听者，当前视图组开始显示动画了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读代码：</p><p></p><pre class="java" name="code">        int saveCount = 0;
        final boolean clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;
        if (clipToPadding) {
            saveCount = canvas.save();
            canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,
                    mScrollX + mRight - mLeft - mPaddingRight,
                    mScrollY + mBottom - mTop - mPaddingBottom);

        }
</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码检查变量flags的CLIP_TO_PADDING_MASK位是否不等于1。如果不等于1的话，那么就说明需要设置参数canvas所描述的一块画布的剪裁区域，使得这个裁剪区域不包含当前视图组的内边距。注意，当前视图组的内边距是通过从父类View继承下来的四个成员变量mPaddingLeft、mPaddingRight、mPaddingTop和mPaddingBottom来描述的。此外，当前视图组的区域是通过从父类继承下来的四个成员变量量mLeft、mRight、mTop和mBottom描述的。再结合当前视图的当前滚动位置mScrollX的mScrollY，就可以计算出参数canvas所描述的一块画布的剪裁区域。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在设置参数canvas所描述的一块画布的剪裁区域之前，这段代码会先调用参数canvas所指向的一个Canvas对象的成员函数save来保存它的堆栈状态，以便在绘制完成当前视图组的UI之后，可以恢复canvas所描述的一块画布的堆栈状态。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读代码：</p><p></p><pre class="java" name="code">        boolean more = false;
        final long drawingTime = getDrawingTime();

        if ((flags &amp; FLAG_USE_CHILD_DRAWING_ORDER) == 0) {
            for (int i = 0; i &lt; count; i++) {
                final View child = children[i];
                if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                    more |= drawChild(canvas, child, drawingTime);
                }
            }
        } else {
            for (int i = 0; i &lt; count; i++) {
                final View child = children[getChildDrawingOrder(count, i)];
                if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) {
                    more |= drawChild(canvas, child, drawingTime);
                }
            }
        }</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码用来绘制当前视图组的子视图。如果一个子视图child是可见的，即它的成员变量mViewFlags的VISIBLE位等于1，或者它有一个动画需要显示，即它的成员函数getAnimation的返回值不等于null，那么这个子视图就是需要绘制的。绘制一个子视图是通过调用ViewGroup类的成员函数drawChild来实现的。ViewGroup类的成员函数drawChild在绘制一个子视图的时候，如果这个子视图的动画还没有结束，那么它的返回值就等于true，并且会被设置到变量more中去。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 注意，当变量flags的FLAG_USE_CHILD_DRAWING_ORDER位等于0的时候，就表示当前视图组的子视图按照它们在数组children中的位置从小到在三类绘制，否则的话，就需要通过ViewGroup类的成员函数getChildDrawingOrder来决定这些子视图的绘制顺序。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们接着往下阅读代码：</p><p></p><pre class="java" name="code">        // Draw any disappearing views that have animations
        if (mDisappearingChildren != null) {
            final ArrayList&lt;View&gt; disappearingChildren = mDisappearingChildren;
            final int disappearingCount = disappearingChildren.size() - 1;
            // Go backwards -- we may delete as animations finish
            for (int i = disappearingCount; i &gt;= 0; i--) {
                final View child = disappearingChildren.get(i);
                more |= drawChild(canvas, child, drawingTime);
            }
        }</pre>&nbsp;&nbsp; &nbsp; &nbsp; ViewGroup类的成员变量mDisappearingChildren用来保存那些正在消失的子视图，但是这些子视图正在显示动画的过程中，因此，这些子视图也是需要绘制的，这段代码同样是通过调用ViewGroup类的成员函数drawChild来绘制它们。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp;我们继续往下阅读最后一段代码：</p><p></p><pre class="java" name="code">        if (clipToPadding) {
            canvas.restoreToCount(saveCount);
        }

        // mGroupFlags might have been updated by drawChild()
        flags = mGroupFlags;

        if ((flags &amp; FLAG_INVALIDATE_REQUIRED) == FLAG_INVALIDATE_REQUIRED) {
            invalidate();
        }

        if ((flags &amp; FLAG_ANIMATION_DONE) == 0 &amp;&amp; (flags &amp; FLAG_NOTIFY_ANIMATION_LISTENER) == 0 &amp;&amp;
                mLayoutAnimationController.isDone() &amp;&amp; !more) {
            // We want to erase the drawing cache and notify the listener after the
            // next frame is drawn because one extra invalidate() is caused by
            // drawChild() after the animation is over
            mGroupFlags |= FLAG_NOTIFY_ANIMATION_LISTENER;
            final Runnable end = new Runnable() {
               public void run() {
                   notifyAnimationListener();
               }
            };
            post(end);
        }
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码执行以下三个操作：<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 检查变量clipToPadding的值是否等于true。如果是的话，那么就说明前面设置过参数canvas所描述的一块画布的裁剪区域。由于现在已经在这块画布上绘制完成当前视图组的UI了，因此，就需要恢复参数canvas所描述的一块画布堆栈状态。这是通过调用参数canvas所指向的一个Canvas对象的成员函数restoreToCount来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 前面在绘制当前视图组的子视图的UI的时候，有可能会需要修改当前视图组的标志位，即修改ViewGroup类的成员变量mGroupFlags的值。如果修改后的mGroupFlags的FLAG_INVALIDATE_REQUIRED位等于1，那么就说明当前视图组需要重新发起一个绘制UI的请求。这是通过调用ViewGroup类的另外一个成员函数invalidate来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. 如果当前视图组的动画已经显示完成，并且当前视图组的子视图的动画也已经显示完成，再并且当前视图组注册有动画监听者，那么就是会调用ViewGroup类的另外一个成员函数notifyAnimationListener来通知这些动画监听者，当前视图组的动画已经显示结束。注意，ViewGroup类的成员函数notifyAnimationListener是以消息的形式来调用的，即ViewGroup类的成员函数dispatchDraw不是在动画一显示结束，就马上通知那些动画监听者。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析ViewGroup类的成员函数drawChild的实现，以便可以了解一个视图组的子视图的绘制过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 10. ViewGroup.drawChild</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewGroup.java中，它的实现比较长，我们分段来阅读：</p><pre class="java" name="code">public abstract class ViewGroup extends View implements ViewParent, ViewManager {
    ......

    protected boolean drawChild(Canvas canvas, View child, long drawingTime) {
        boolean more = false;

        final int cl = child.mLeft;
        final int ct = child.mTop;
        final int cr = child.mRight;
        final int cb = child.mBottom;

        final int flags = mGroupFlags;</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; 这段代码首先获得子视图child的区域（cl, ct, cr, cb），以及当前视图组的标志位flags，以便接下来可以使用。另外，变量more的值用来表示子视图child是否还在显示动画。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们接着往下阅读代码：</p><pre class="java" name="code">        Transformation transformToApply = null;
        final Animation a = child.getAnimation();
        ......

        if (a != null) {
            ......

            if (mChildTransformation == null) {
                mChildTransformation = new Transformation();
            }
            more = a.getTransformation(drawingTime, mChildTransformation);
            transformToApply = mChildTransformation;
            ......

        } else if ((flags &amp; FLAG_SUPPORT_STATIC_TRANSFORMATIONS) ==
                FLAG_SUPPORT_STATIC_TRANSFORMATIONS) {
            if (mChildTransformation == null) {
                mChildTransformation = new Transformation();
            }
            final boolean hasTransform = getChildStaticTransformation(child, mChildTransformation);
            if (hasTransform) {
                final int transformType = mChildTransformation.getTransformationType();
                transformToApply = transformType != Transformation.TYPE_IDENTITY ?
                        mChildTransformation : null;
                ......
            }
        }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来获得子视图child的变换矩阵transformToApply。获得了子视图child的变换矩阵transformToApply之后，我们就可以知道如何来显示它了。&nbsp;在两种情况下，子视图child会被设置一个变换矩阵。第一种情况子视图child正在显示动画的过程中，第二种情况是当前视图组给每一个子视图设置了一个变换矩阵。下面我们就分别讨论这两种情况。<p>&nbsp;&nbsp; &nbsp; &nbsp; 对于第一种情况，子视图child的成员函数getAnimation的返回值a不等于null，并且它所指向的一个Animation对象就是用来描述子视图child的动画的。获得了子视图的动画对象a之后，我们就可以调用它的成员函数getTransformation来继续执行它的动画了。如果该动画还需要继续执行，那么调用Animation对象a的成员函数getTransformation的返回值more就会等于true，并且会返回子视图child的接下来需要使用的变换矩阵，保存在ViewGroup类的成员变量mChildTransformation中。ViewGroup类的成员变量mChildTransformation最后又会保存在变量transformToApply中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 对于第二种情况，变量flags的FLAG_SUPPORT_STATIC_TRANSFORMATIONS位等于1，这时候调用ViewGroup类的成员函数getChildStaticTransformation就可以知道子视图child是否被设置了一个变换矩阵。如果设置了的话，那么ViewGroup类的成员函数getChildStaticTransformation的返回值hasTransform就会等于true。在这种情况下，ViewGroup类的成员变量mChildTransformation所描述的变换矩阵就是要应用在子视图child中的。不过有一个前提，即ViewGroup类的成员变量mChildTransformation所描述的变换矩阵不是一个单位矩阵，这是因为单位矩阵是没有变换效果的。如果ViewGroup类的成员变量mChildTransformation所描述的变换矩阵不是一个单位矩阵，那么它同样会被保存在变量transformToApply中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们继续往下阅读代码：</p><pre class="java" name="code">        // Sets the flag as early as possible to allow draw() implementations
        // to call invalidate() successfully when doing animations
        child.mPrivateFlags |= DRAWN;

        ......

        child.computeScroll();

        final int sx = child.mScrollX;
        final int sy = child.mScrollY;

        boolean scalingRequired = false;
        Bitmap cache = null;
        if ((flags &amp; FLAG_CHILDREN_DRAWN_WITH_CACHE) == FLAG_CHILDREN_DRAWN_WITH_CACHE ||
                (flags &amp; FLAG_ALWAYS_DRAWN_WITH_CACHE) == FLAG_ALWAYS_DRAWN_WITH_CACHE) {
            cache = child.getDrawingCache(true);
            if (mAttachInfo != null) scalingRequired = mAttachInfo.mScalingRequired;
        }

        final boolean hasNoCache = cache == null;</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码执行以下三个操作：<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 将子视图child的标志值mPrivateFlags的DRAWN设置为1，因为接下来它就会被绘制了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 计算子视图child的滚动位置，这是通过调用子视图child的成员函数computeScroll来实现的。计算好子视图child的滚动位置之后，我们就可以通过它的成员变量mScrollX和mScrollY来获得它在X轴和Y轴上的偏移了。这两个偏移值保存在变量sx和sy中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;3. 检查变量flags的FLAG_CHILDREN_DRAWN_WITH_CACHE位或者FLAG_ALWAYS_DRAWN_WITH_CACHE位是否等于1。如果其中的一个等于1的话，那么就说明子视图是使用缓冲方式来绘制，即它的UI来缓冲在一个Bitmap里面，通过调用子视图child的成员函数getDrawingCache就可以获得这个Bitmap，并且保存在变量cache中。同时，通过ViewGroup类的成员变量mAttachInfo所指向的一个AttachInfo对象的成员变量mScalingRequired还可以知道子视图是否要进行缩放。如果需要缩放，那么变量scalingRequired的值就会等于true。另外，如果子视图child有一个缓冲的Bitmap，那么变量hasNoCache的值就会等于false。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读代码：</p><pre class="java" name="code">        final int restoreTo = canvas.save();
        if (hasNoCache) {
            canvas.translate(cl - sx, ct - sy);
        } else {
            canvas.translate(cl, ct);
            if (scalingRequired) {
                // mAttachInfo cannot be null, otherwise scalingRequired == false
                final float scale = 1.0f / mAttachInfo.mApplicationScale;
                canvas.scale(scale, scale);
            }
        }

        float alpha = 1.0f;

        if (transformToApply != null) {
            ......

            alpha = transformToApply.getAlpha();
            
            ......
        }
        ......

        if ((flags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) {
            if (hasNoCache) {
                canvas.clipRect(sx, sy, sx + (cr - cl), sy + (cb - ct));
            } else {
                if (!scalingRequired) {
                    canvas.clipRect(0, 0, cr - cl, cb - ct);
                } else {
                    canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                }
            }
        }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码用来设置子视图child的偏移、Alpha通道以及裁剪区域：<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 如果子视图child不是以缓冲的方式来绘制的，那么它的偏移值就需要同时考虑它在X轴和Y轴上的起始位置（cl, ct）以及滚动值sx、sy；如果子视图child是以缓冲的方式来绘制的，那么就不需要考虑它在X轴和Y轴上的滚动位置sx和sy，而只需要考虑它在X轴和Y轴上的起始位置（cl, ct），这是因为它所缓冲的Bitmap已经包含了滚动信息。注意，在子视图child是以缓冲的方式来绘制的情况中，如果变量scalingRequired的值等于true，那么这段代码同时还需要为子视图child设置一个缩放因子，以便接下来可以同步缓冲的Bitmap的所表示的大小。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 如果子视图child此时被设置了一个变换矩阵transformToApply，那么一般它就会有一个Alpha值。例如，前面提到，当子视图child还处理动画显示的状态时，它就会有一个变换矩阵，而这个动画一般会有透明的效果，因此，就会有一个Alpha值。通过调用变量transformToApply所指向的一个Transformation对象的成员函数getAlpha就可以获得子视图child的Alpha值，保存在变量alpha中。如果子视图child此时没有被设置变换矩阵的话，那么它的Alpha值alpha就会等于1.0，表示不是透明的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 3. 如果变量flags的FLAG_CLIP_CHILDREN位等于1，那么就说明需要为子视图child设置一个剪裁区域。在设置子视图child的剪裁区域时，同样是需要考虑子视图child是否使用缓冲方式来绘制。如果不使用缓冲方式来会绘制，那么子视图child的剪裁区域就需要同时考虑它在X轴和Y轴上的起始位置（cl, ct）以及滚动值sx、sy；如果不是使用缓冲方式来会绘制，那么就不需要考虑它在X轴和Y轴上的滚动位置sx和sy。注意，在子视图child是以缓冲的方式来绘制的情况中，如果变量scalingRequired的值等于false，那么它的剪裁区域的宽度和高度就分别为（cr - cl）和（cb - ct），否则的话，它的剪裁区域的宽度和高度就等于上一次的缓冲Bitmap的宽度和宽度，这是因为对于后者来说，前面在设置子视图child的偏移时，已经同时设置过它的缩放因子了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 注意，在子视图child的偏移、Alpha通道以及裁剪区域之前，这段代码首先会保存在参数canvas所描述的一块画布的堆栈状态，以便在绘制完成子视图child的UI之后，可以恢复这块画布的堆栈状态来绘制其它子视图的UI。保存在参数canvas所描述的一块画布的堆栈状态是通过调用参数canvas所指向的一个Canvas对象的成员函数save来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们继续往下阅读代码：</p><pre class="java" name="code">        if (hasNoCache) {
            // Fast path for layouts with no backgrounds
            if ((child.mPrivateFlags &amp; SKIP_DRAW) == SKIP_DRAW) {
                ......
                child.dispatchDraw(canvas);
            } else {
                child.draw(canvas);
            }
        } else {
            final Paint cachePaint = mCachePaint;
            if (alpha &lt; 1.0f) {
                cachePaint.setAlpha((int) (alpha * 255));
                mGroupFlags |= FLAG_ALPHA_LOWER_THAN_ONE;
            } else if  ((flags &amp; FLAG_ALPHA_LOWER_THAN_ONE) == FLAG_ALPHA_LOWER_THAN_ONE) {
                cachePaint.setAlpha(255);
                mGroupFlags &amp;= ~FLAG_ALPHA_LOWER_THAN_ONE;
            }
            ......
            canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
        }</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这段代码就是用来绘制子视图child的UI的了，分为两种情况来考虑：<p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1. 以非缓冲的方式来绘制。这时候需要检查子视图child的标志值mPrivateFlags的SKIP_DRAW位是否等于1。如果等于1的话，那么就说明需要跳过子视图child的绘制，但是需要绘制子视图child的子视图，否则的话，就需要先绘制子视图child的UI，再绘制它的子视图的UI。绘制子视图child的子视图是通过调用它的成员函数dispatchDraw来实现的，而绘制子视图child本身及其子视图是通过调用它的成员函数draw来实现的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;2. 以缓冲的方式来绘制。这时候只需要将上一次的缓冲的Bitmap对象cache绘制到参数canvas所描述的一块画布上面就行了。在绘制之前，需要先设置用来绘制Bitmap对象cache的一个Paint对象的Alpha值，这个Paint对象保存在ViewGroup类的成员变量mCachePaint中。这个Alpha值保存在变量alpha中，如果它的值小于1.0，那么就说明子视图child有一个透明值，因此，就需要将它设置到ViewGroup类的成员变量mCachePaint所指向的一个Paint对象中去，并且将ViewGroup类的成员变量mGroupFlags的FLAG_ALPHA_LOWER_THAN_ONE位设置为1。另一方面，如果变量alpha的值大于等于1.0，那么就说明不需要设置子视图child的透明值，但是如果之前设置过子视图child的透明值，即ViewGroup类的成员变量mGroupFlags的FLAG_ALPHA_LOWER_THAN_ONE位等于1，那么还需要修改ViewGroup类的成员变量mCachePaint所指向的一个Paint对象是不透明的，即将它的透明值设置为255，并且将ViewGroup类的成员变量mGroupFlags的FLAG_ALPHA_LOWER_THAN_ONE位重置为0。最后，就可以调用参数canvas所指向的一个Canvas对象的成员函数drawBitmap来绘制子视图child的UI了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 我们继续往下阅读最后一段代码：</p><pre class="java" name="code">        canvas.restoreToCount(restoreTo);

        ......

        return more;
    }

    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 绘制完成子视图child的UI之后，就可以恢复参数canvas所描述的一块画布的堆栈状态了，这是通过调用参数canvas所指向的一个Canvas对象的成员函数restoreToCount来实现的。<p>&nbsp;&nbsp; &nbsp; &nbsp; ViewGroup类的成员函数drawChild最后就将变量more的值返回给调用者了，以便调用者可以知道当前正在绘制的子视图child是否还处于动画状态中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从上面的分析就可以知道，当子视图child不是以非缓冲模式来绘制，并且它需要绘制自己及其子视图时，它的成员函数draw就会被调用，这时候就会重复执行Step 8、Step 9和Step 10，直到所有子孙视图都绘制完成为止。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 这一步执行完成之后，应用程序窗口的UI就全部绘制到在前面的Step 2中所获得的一块画布上面去了，返回到前面的Step 1中，即ViewRoot类的成员函数draw中，接下来就会Java层的Surface类的成员函数unlockCanvasAndPost来请求SurfaceFlinger服务渲染这块画布里面所包含的一个图形缓冲区了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析Java层的Surface类的成员函数unlockCanvasAndPost的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 11.&nbsp;Surface.unlockCanvasAndPost</p><pre class="java" name="code">public class Surface implements Parcelable {
    ......

    /** unlock the surface and asks a page flip */
    public native   void unlockCanvasAndPost(Canvas canvas);
 
    ......
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/core/java/android/view/Surface.java中。<p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;Surface类的成员函数unlockCanvasAndPost是一个JNI方法，它是由C++层的函数Surface_unlockCanvasAndPost来实现的，如下所示：</p><pre class="cpp" name="code">static void Surface_unlockCanvasAndPost(
        JNIEnv* env, jobject clazz, jobject argCanvas)
{
    jobject canvas = env-&gt;GetObjectField(clazz, so.canvas);
    if (canvas != argCanvas) {
        doThrow(env, &quot;java/lang/IllegalArgumentException&quot;, NULL);
        return;
    }

    const sp&lt;Surface&gt;&amp; surface(getSurface(env, clazz));
    if (!Surface::isValid(surface))
        return;

    // detach the canvas from the surface
    SkCanvas* nativeCanvas = (SkCanvas*)env-&gt;GetIntField(canvas, no.native_canvas);
    int saveCount = env-&gt;GetIntField(clazz, so.saveCount);
    nativeCanvas-&gt;restoreToCount(saveCount);
    nativeCanvas-&gt;setBitmapDevice(SkBitmap());
    env-&gt;SetIntField(clazz, so.saveCount, 0);

    // unlock surface
    status_t err = surface-&gt;unlockAndPost();
    if (err &lt; 0) {
        doThrow(env, &quot;java/lang/IllegalArgumentException&quot;, NULL);
    }
}</pre><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/jni/android_view_Surface.cpp中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;参数clazz指向的是一个Java层的Surface对象，用来描述当前正在绘制的应用程序窗口的绘图表面，而参数argCanvas指向的是一个Java层的Canvas对象。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;参数clazz指向的是一个Java层的Surface对象的成员变量mCanvas所指向的一个Canvas对象canvas应当等于参数argCanvas指向的是一个Java层的Canvas对象，否则的话，函数就会抛出一个异常。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8303098">Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析</a>一文可以知道，每一个Java层的Surface对象在C++层都有一个对应的Surface对象。因此，函数t就可以通过调用另外一个函数getSurface来获得与参数clazz所指向的是一个Java层的Surface对象所对应的C++层的Surface对象surface。C++层的Surface类的静态成员函数isValid用来验证Surface对象surface是否已经连接到SurfaceFlinger服务中。如果还没有连接到，那么函数就会出错返回了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 通过了上述的合法性检查之后，函数接下来主要就是做两件事情：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. 恢复变量canvas所描述的一块画布的堆栈状态。变量canvas所描述的一块画布是在前面的Step 2中开始初始化的，每次应用程序窗口在上面绘制完成UI之后，我们都应该恢复它的堆栈状态，以便下一次使用时不会受上一次影响。变量canvas指向的是一个Java层的Canvas对象，函数首先找到与它所对应的一个C++层的SkCanvas对象nativeCanvas，然后就可以调用这个SkCanvas对象nativeCanvas的成员函数restoreToCount来恢复它所描述的一块画布的堆栈状态了。这块画布在绘制应用程序窗口UI前的堆栈状态保存在参数clazz所指向的一个Java层的Surface对象的成员变量mSaveCount中。因此，函数就先获得参数clazz所指向的一个Java层的Surface对象的成员变量mSaveCount的值，然后再以它为参数来调用SkCanvas对象nativeCanvas的成员函数restoreToCount，这样就可以恢复画布的堆栈状态了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. 请求SurfaceFlinger服务渲染Surface对象surface所描述的应用程序窗口的绘图表面。应用程序窗口的UI是绘制在SkCanvas对象nativeCanvas所描述的一块画布上的，而这块画布所使用的图形缓冲区是保存在Surface对象surface的内部的，因此，函数就调用Surface对象surface的成员函数unlockAndPost来请求SurfaceFlinger服务渲染这块图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 接下来，我们就继续分析C++层的Surface类的成员函数unlockAndPost的实现，以便可以了解用来绘制应用程序窗口UI的图形缓冲区是如何渲染的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 12. Surface.unlockAndPost</p><p></p><pre name="code" class="cpp">status_t Surface::unlockAndPost()
{
    if (mLockedBuffer == 0) {
        LOGE(&quot;Surface::unlockAndPost failed, no locked buffer&quot;);
        return INVALID_OPERATION;
    }

    status_t err = mLockedBuffer-&gt;unlock();
    LOGE_IF(err, &quot;failed unlocking buffer (%p)&quot;, mLockedBuffer-&gt;handle);

    err = queueBuffer(mLockedBuffer.get());
    LOGE_IF(err, &quot;queueBuffer (idx=%d) failed (%s)&quot;,
            getBufferIndex(mLockedBuffer), strerror(-err));

    mPostedBuffer = mLockedBuffer;
    mLockedBuffer = 0;
    return err;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/surfaceflinger_client/Surface.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面的Step 3可以知道，应用程序窗口当前正在使用的图形缓冲区保存在Surface类的成员变量mLockedBuffer中，因此，Surface类的成员函数unlockAndPost的目标就是要将它交给SurfaceFlinger服务来渲染，这是通过调用另外一个成员函数queueBuffer来实现的。在前面<a href="http://blog.csdn.net/luoshengyang/article/details/7932268">Android应用程序请求SurfaceFlinger服务渲染Surface的过程分析</a>一文中，我们已经分析过Surface类的成员函数queueBuffer的实现了，它主要就是向应用程序窗口的待渲染图形缓冲区队列中添加一个图形缓冲区，然后再请请求SurfaceFlinger服务来渲染这个图形缓冲区。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;在渲染成员变量mLockedBuffer所描述的一个图形缓冲区之前，Surface类的成员函数unlockAndPost还会调用它的成员函数unlock来执行一个“解锁”操作。从前面的Step 3可以知道，成员变量mLockedBuffer所描述的一个图形缓冲区在交给应用程序窗口使用之前，它会被执行一个“锁定”的操作，即它的成员函数lock会被调用，因此，这里执行的“解锁”操作是与前面的“锁定”操作相对应的。事实上，对成员变量mLockedBuffer所描述的一个图形缓冲区进行锁定，主要是为了获得这个图形缓冲区的地址，是否真的要对个图形缓冲区进行锁定，是由HAL层模块Gralloc的实现来决定的。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在请求SurfaceFlinger服务渲染了成员变量mLockedBuffer所描述的一个图形缓冲区之后，Surface类的成员函数unlockAndPost还会把成员变量mLockedBuffer所描述的一个图形缓冲区保存在另外一个成员变量mPostedBuffer中，表示这个图形缓冲区已经变成是正在渲染的图形缓冲区了，或者说是前端缓冲区了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 最后，Surface类的成员函数unlockAndPost就把成员变量mLockedBuffer的值设置为0，这样就可以将应用程序窗口下一次请求分配和使用的图形缓冲区保存在它里面。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;Surface类的成员变量mLockedBuffer指向的是一个GraphicBuffer对象，接下来我们就继续分析它的成员函数unlock的实现，以便可以了解它所描述的图形缓冲区的“解锁”过程。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; Step 13. GraphicBuffer.unlock</p><p></p><pre name="code" class="cpp">status_t GraphicBuffer::unlock()
{
    status_t res = getBufferMapper().unlock(handle);
    return res;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/libs/ui/GraphicBuffer.cpp中。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;从前面的Step 4可以知道，GraphicBuffer类的成员变量handle用来描述当前正在处理的图形缓冲区的句柄，而GraphicBuffer类的成员函数getBufferMapper返回的是一个GraphicBufferMapper对象。有了这个GraphicBufferMapper对象之后，就可以调用它的成员函数unlock解锁成员变量handle所描述的一个图形缓冲区了。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析GraphicBufferMapper类的成员函数unlock的实现。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;Step 14.&nbsp;GraphicBufferMapper.unlock<br /></p><p></p><pre name="code" class="cpp">status_t GraphicBufferMapper::unlock(buffer_handle_t handle)
{
    status_t err;
    if (sw_gralloc_handle_t::validate(handle) &lt; 0) {
        err = mAllocMod-&gt;unlock(mAllocMod, handle);
    } else {
        err = sw_gralloc_handle_t::unlock((sw_gralloc_handle_t*)handle);
    }
    LOGW_IF(err, &quot;unlock(...) failed %d (%s)&quot;, err, strerror(-err));
    return err;
}</pre>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/libs/ui/GraphicBufferMapper.cpp。<p></p><p>&nbsp;&nbsp; &nbsp; &nbsp; 从前面的Step 5可以知道，参数handle所描述的图形缓冲区是在HAL模块Gralloc中分配的，这个HAL模块Gralloc是由GraphicBufferMapper类的成员变量mAllocMod来描述的，因此，函数就终就会调用GraphicBufferMapper类的成员变量mAllocMod所描述的一个HAL模块Gralloc的成员函数unlock来解锁参数andle所描述的一个图形缓冲区。HAL模块Gralloc的成员函数unlock的实现可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/7747932">Android帧缓冲区（Frame Buffer）硬件抽象层（HAL）模块Gralloc的实现原理分析</a>一文，这里不再详述。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 至此，我们就分析完成Android应用程序窗口的渲染过程了，从中就可以看出：</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 1. 渲染Android应用程序窗口UI需要经过三步曲：测量、布局、绘制。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 2. Android应用程序窗口UI首先是使用Skia图形库API来绘制在一块画布上，实际地是绘制在这块画布里面的一个图形缓冲区中，这个图形缓冲区最终会被交给SurfaceFlinger服务，而SurfaceFlinger服务再使用OpenGL图形库API来将这个图形缓冲区渲染到硬件帧缓冲区中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;Android应用程序窗口的渲染过程分析完成之后，Android应用程序窗口的实现框架就分析完成了，重新学习请回到<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>一文中。</p><p>&nbsp;&nbsp; &nbsp; &nbsp; 在<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>这一系列文章中，我们主要是从单个应用程序窗口的角度来分析的。但是，Android系统在运行的过程中，需要管理的是一系列的应用程序窗口，并且这些应用程序窗口的类型可能各不相同，并且相互影响。因此，Android的窗口管理系统是非常复杂的。在接下来的一个系列的文章中，我们就将详细地分析Android窗口管理服务WindowManagerService的实现，以便可以从系统的角度来分析应用程序窗口的实现。敬请关注！</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2012-12-31 0:55:26 <a href="http://blog.csdn.net/luoshengyang/article/details/8372924">原文链接</a>
            </div>
            <div>
            阅读：5694 评论：17 <a href="http://blog.csdn.net/luoshengyang/article/details/8372924#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]2012年的Android之旅：梦想、学习、坚持、自信、淡定]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8452527</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8452527</guid>
        <author>Luoshengyang</author>
        <pubDate>2012-12-31 23:00:34</pubDate>
        <description><![CDATA[
            <p>&nbsp; &nbsp; &nbsp; &nbsp; 前段时间参加了2012年度IT博客大赛，进了前十强，写了一篇获奖感言，不过还没正式在CSDN发表出来。眼看2012年就要结束了，刚好借这个机会将2012年度IT博客大十强获奖感言发表出来，也算是对2012年博客的一个总结，关键字是“梦想”、“学习”、“坚持”、“自信”、“淡定”。希望大家一如既往地支持老罗的CSDN专栏《老罗的Android之旅》以及老罗的新书《Android系统源代码情景分析》。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;自2011年6月21日开博至今天2012年12月31日，在这560天里面，主要是做了以下三件事情：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. <a href="http://blog.csdn.net/Luoshengyang" target="_blank">发表了72篇原创博客，访问量1060200次，评论3153条</a>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. <a href="http://product.dangdang.com/product.aspx?product_id=22884086" target="_blank">出版了《Android系统源代码情景分析》一书，一共3大篇16章830页1570千字</a>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. <a href="http://contest.blog.51cto.com/3922687/1089254" target="_blank">被评为2012年度十大杰出博客</a>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 写博客之初，是没有出书的计划的，不过在各方面的巧合之下，就整理了博客上的文章，然后就出版了，不过也算是了却心愿，以后就可以专心地写博客了。下面就简单说一下从写博客以来的一些感受。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 梦想。APP刚刚火起来的那阵子，还没接触过移动开发。有一天听说我们的产品经理自己做了个APP，用来订阅自己感兴趣的视频。顿时倍受打击：连产品经理都会做APP了，作为一个码农，怎么还能对移动开发无动于衷呢？！于是就准备学习移动开发，做个APP来玩玩。但是后来想了一下，其实我更感兴趣的是移动操作系统，很想知道它和PC操作系统有什么区别。于是就带着“了解移动操作系统长什么样子”这个梦想踏上了研究Android的旅程。再啰嗦说一下梦想这个话题。再年轻一些的时候，会觉得谈梦想是一件很扯很遥远很虚无缥缈的事情。随着年纪的增大，年轻时的棱角随着生活中的各种遭遇和压力都慢慢地磨平了，只剩下每天重复的上下班。这时候才发现年轻时的梦想是多么的弥足珍贵：梦想原来是可以让人这么年轻而富有激情的！现在看达人秀的时候，更多的感动是来自那些选手对梦想的执着追求，而不是他们的表演。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;2. 学习。决定了要学习移动操作系统开发以后，接下来就是选平台了。当时iOS和Android都是红透半边天，WP还未成型。由于Android是开放源码的，因此，它就是学习移动操作系统的不二选择了。了解到Android是基于Linux内核来开发之后，就开始看Linux内核的书：《Linux Kernel Development》、《Understanding the Linux Kernel》、《Linux Device Drivers》和《Linux内核源代码情景分析》。这四本书每一本书都至少看过两遍。对Linux内核有了大概的了解之后，就开始学习Android应用开发，因为我觉学习一个新知识的最好切入点就是先知道它是怎么使用的。于是，接下来又看了两本讲Android应用开发的书：《Professional Android Application Development》和《Google Android SDK开发范例大全》。看完了之后，觉得还是有点云里雾里，于是又写了个Android小游戏——<a href="http://blog.csdn.net/luoshengyang/article/details/6589025" target="_blank">交互式人机对战五子棋</a>。说来和五子棋有缘，高中时经常和同学在几何簿上画着来玩玩五子棋，有时上课也偷偷玩；上大学学习C和Java时，也是拿五子棋来练手。在Android上开发的这个五子棋游戏虽小，但却五脏俱全：Activity、Service、Broadcast Receiver和Content Provider四大组件全用上了，异步任务和Binder进程间通信机制等也用上了。这为日后研究Android系统打下了坚实的基础。其实学习这个东西就是这样，它不是快餐，饿了就去吃，必须得老老实实地一步一步地打基础。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. 坚持。长期地坚持去做一件事情，真的很难。不过，当你下定决心持续地去做一件事情的时候，你的坚持就会变成一种习惯。习惯一旦养成，你不去做那件事情的时候，反而会觉得心里不舒服，好像少了什么似的。因为平时要上班，所以一天下来，其实也没多少时间去研究Android系统。这时候我就告诉自己，更加要坚持，并且给自己算了一笔数：工作日每天看20页书，周末每天看50页书，大概两周就可以看一本400～500页的书；一天看300行左右代码，一周就能看2000～3000行代码；一天写1个段落的博客，一周也能捣鼓出1篇来。另外，当坚持了一段时间之后，就会发现学习的速度比以前更快了，就好像有一种加速度一样，这时候就会发现事情越做越快。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4. 自信。自信是很重要的，尤其是在你做一件很有挑战性的事情的时候。如果没有自信，在碰到难以解决的困难时，或许就会放弃了。其实在很多时候，机遇都是偏爱那些有自信并且一直坚持着梦想的人。记得在研究Android系统的UI渲染服务SurfaceFlinger的时候，被一个20多行代码的函数难住了，百思不得其解。后来盯了两三天，联系了各种上下文，最后总算是把它弄明白了。我一直都相信潜意识这种东西：只要你相信你能解决一个问题，并且坚持住不放弃，潜意识就会帮助你去加工和组织各种原始信息。因此，自信很重要，它是一种软实力：有自信不一定能成功，但是没有自信要成功就难上加难。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5. 淡定。淡定是一种人生态度，它能使你不功利，不浮躁，从容地面对得与失，找到一条更合适自己长远发展的路。往往梦想都是一个比较长期的东西，不是短期内就能看到效益的。在坚持梦想的过程中，又可能要付出很多代价，例如，你没有时间找（陪）老婆或者女朋友，你赚的钱没有一起毕业的同学多，诸如此类的等等事情。这时候，你就更需要淡定：只要你判断你正在做的事情是值得的，你就淡定地面对别人的眼光和周围的环境。我发现写博客以来，自己变得越来越宅了，下班后和周末都更愿意呆在房间里，当渐渐地发现同学都在忙着晒结婚照或者小孩照的时候，自己还在单身着:(。这可能就是宅的代价吧，不过现在对这件事情还是比较淡定:)。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 上述5点感受总结来说就是：心怀梦想，带着自信和淡定，持之以恒，学习、学习，再学习！很讽刺的是，如果是五六年以前的自己看到上面的这些文字，我会觉得很扯，很空洞，没意义。人可能就是要非得亲自去经历一些事情，才能深刻地领会一些道理。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 最后，老罗和大多数人一样，出身草根，也就是俗称的屌丝，如今也是在平凡的职位上做着平凡的事情，但是老罗相信，虽不是官二代富二代，但是拼尽全力地去奋斗，就会有希望！在接下来的2013年里面，老罗仍然会坚持写Android方面的文章，第一目标是继续研究Android系统的UI架构，第二目标是研究Android系统的Dalvik虚拟机。希望大家一如既往地支持《老罗的Android之旅》，同时，如果大家觉得博客的内容有用，还请多多支持老罗的新书《Android系统源代码情景分析》！</p><p>&nbsp; &nbsp; &nbsp; &nbsp; <span style="color:#cc0000;"><span style="font-size:14px;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span></span>&nbsp;</p>
            <div>
                作者：Luoshengyang 发表于2012-12-31 23:00:34 <a href="http://blog.csdn.net/luoshengyang/article/details/8452527">原文链接</a>
            </div>
            <div>
            阅读：21025 评论：86 <a href="http://blog.csdn.net/luoshengyang/article/details/8452527#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android窗口管理服务WindowManagerService的简要介绍和学习计划]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8462738</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8462738</guid>
        <author>Luoshengyang</author>
        <pubDate>2013-1-7 0:56:55</pubDate>
        <description><![CDATA[
            <p>&nbsp; &nbsp; &nbsp; &nbsp; 在前一个系列文章中，我们从个体的角度来分析了Android应用程序窗口的实现框架。事实上，如果我们从整体的角度来看，Android应用程序窗口的实现要更复杂，因为它们的类型和作用不同，且会相互影响。在Android系统中，对系统中的所有窗口进行管理是窗口管理服务WindowManagerService的职责。在本文中，我们就将简要介绍WindowManagerService的职能以及制定学习计划。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我们知道，在Android系统中，同一时刻，只有一个Activity窗口是激活的，但是，对于WindowManagerService服务来说，这并不意味着它每次只需要管理一个Activity窗口，例如，在两个Activity窗口的切换过程中，前后两个Activity窗口实际上都是可见的。即使在只有一个Activity窗口是可见的时候，WindowManagerService服务仍然需要同时管理着多个窗口，这是因为可见的Activity窗口可能还会被设置了壁纸窗口（Wallpaper Winodw）或者弹出了子窗口（Sub Window），以及可能会出现状态栏（Status Bar）以及输入法窗口（Input Method Window），如图1所示。</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201301/06/1357404325_1912.jpg" alt="" /><br /></p><p style="text-align: center;">图1 Activity窗口及其子窗口、壁纸窗口、输入法窗口和状态栏的位置结构</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 因此，WindowManagerService服务是不可以假设同一时刻它只需要管理一个窗口的，它需要通过各个窗口在屏幕上的位置以及大小来决定哪些窗口需要显示的以及要显在哪里，这实际上就是要计算出各个窗口的可见区域。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8079456">Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析</a>一文可以知道，SurfaceFlinger服务在渲染整个屏幕的UI的时候，会对各个窗品的可见性进行计算，因此，WindowManagerService服务只要将它所管理的各个窗品的位置以及大小告诉SurfaceFlinger服务，后者可以帮帮它计算出各个窗口的可见区域了。注意，这里，这里所说的窗口位置包括窗口在X、Y和Z轴的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService服务大致按照以下方式来控制哪些窗口需要显示的以及要显在哪里：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;1. 每一个Activity窗口的大小都等于屏幕的大小，因此，只要对每一个Activity窗口设置一个不同的Z轴位置，然后就可以使得位于最上面的，即当前被激活的Activity窗口，才是可见的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;2. 每一个子窗口的Z轴位置都比它的父窗口大，但是大小要比父窗口小，这时候Activity窗口及其所弹出的子窗口都可以同时显示出来。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;3. 对于非全屏Activity窗口来说，它会在屏幕的上方留出一块区域，用来显示状态栏。这块留出来的区域称对于屏幕来说，称为装饰区（decoration），而对于Activity窗口来说，称为内容边衬区（Content Inset）。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;4. 输入法窗口只有在需要的时候才会出现，它同样是出现在屏幕的装饰区或者说Activity窗口的内容边衬区的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;5. 对于壁纸窗口，它出现需要壁纸的Activity窗口的下方，这时候要求Activity窗口是半透明的，这样就可以将它后面的壁纸窗口一同显示出来。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;6. 两个Activity窗口在切换过程，实际上就是前一个窗口显示退出动画而后一个窗口显示开始动画的过程，而在动画的显示过程，窗口的大小会有一个变化的过程，这样就导致前后两个Activity窗口的大小不再都等于屏幕的大小，因而它们就有可能同时都处于可见的状态。事实上，Activity窗口的切换过程是相当复杂的，因为即将要显示的Activity窗口可能还会被设置一个启动窗口（Starting Window）。一个被设置了启动窗口的Activity窗口要等到它的启动窗口显示了之后才可以显示出来。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;从以上六点就可以看出，窗口在X、Y和Z轴的位置及其大小的计算非常重要，它们共同决定了一个窗口是否是整体可见的，还是部分可见的，或者整体不可见的。在Android系统中，WindowManagerService服务是通过一个实现了WindowManagerPolicy接口的策略类来计算一个窗口的位置和大小的。例如，在Phone平台上，这个策略类就是PhoneWindowManager。这样做的好处就是对于不同的平台实现不同的策略类来达到不同的窗口控制模式。</p><p>&nbsp; &nbsp; &nbsp; 从上面的描述就可以看出，WindowManagerService服务除了要与Activity窗口所运行在的应用程序进程打交道之外，还需要与SurfaceFlinger服务以及窗口管理策略类PhoneWindowManager交互，如图2所示。</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/06/1357412404_2148.jpg" alt="" /><br /></p><p style="text-align: center;">图2 WindowManagerService服务与Activity窗口、SurfaceFlinger服务、PhoneWindowManager策略的关系图</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8170307">Android应用程序窗口（Activity）实现框架简要介绍和学习计划</a>的一系列文章中，我们已经分析过应用程序进程与WindowManagerService服务之间的交互过程了，因此，在这一系列文章中，我们就将主要分析WindowManagerService服务的实现，以及它与SurfaceFlinger服务、PhoneWindowManager策略类的交互过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 从总体上来看，WindowManagerService服务的实现是相当复杂的，例如，WindowManagerService类的核心成员函数performLayoutAndPlaceSurfacesLockedInner的代码有1200+行，比600-行代码的ViewRoot类的核心成员函数performTraversals还要恐怖。不过，WindowManagerService服务实现的复杂性是在预料之中的，毕竟它要管理的整个系统所有窗口的UI，而在任何一个系统中，窗口管理子系统都是极其复杂的。基于上述理由，采用硬碰硬的方式来分析WindowManagerService服务的实现是以卵击石，因此，这个系列的文章将对WindowManagerService服务进行分拆，然后再逐个击破，这是算法中的分而治之思想是一致的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 具体来说，我们将按照以下几个情景来分析WindowManagerService服务的实现：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. <a href="http://blog.csdn.net/luoshengyang/article/details/8479101">窗口大小和位置（X轴和Y轴）的计算过程</a>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. <a href="http://blog.csdn.net/luoshengyang/article/details/8498908">窗口的组织方式</a>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. <a href="http://blog.csdn.net/luoshengyang/article/details/8526644">输入法窗口的调整过程</a>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4. <a href="http://blog.csdn.net/luoshengyang/article/details/8550820">壁纸窗口的调整过程</a>。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5. 窗口Z轴位置的计算和调整过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 6. Activity窗口的启动窗口的显示过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 7. Activity窗口的切换过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 再次地，由于WindowManagerService服务的实现实在是太复杂，因此上述七个情景可能还不足于说明WindowManagerService服务的实现。如果出现这种情况，我们在分析的过程中会进行相应的调整。相信对WindowManagerService服务的实现进行分而治之的分析后，我们就可以对Android系统的UI架构有一个深刻的理解！敬请关注接下来的文章！</p><p><span style="text-align: center;"></span></p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2013-1-7 0:56:55 <a href="http://blog.csdn.net/luoshengyang/article/details/8462738">原文链接</a>
            </div>
            <div>
            阅读：2908 评论：12 <a href="http://blog.csdn.net/luoshengyang/article/details/8462738#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8479101</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8479101</guid>
        <author>Luoshengyang</author>
        <pubDate>2013-1-14 0:56:58</pubDate>
        <description><![CDATA[
            <p>&nbsp; &nbsp; &nbsp; &nbsp; 在Android系统中，Activity窗口的大小是由WindowManagerService服务来计算的。WindowManagerService服务会根据屏幕及其装饰区的大小来决定Activity窗口的大小。一个Activity窗口只有知道自己的大小之后，才能对它里面的UI元素进行测量、布局以及绘制。本文将详细分析WindowManagerService服务计算Activity窗口大小的过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 一般来说，Activity窗口的大小等于整个屏幕的大小，但是它并不占据着整块屏幕。为了理解这一点，我们首先分析一下Activity窗口的区域是如何划分的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我们知道，Activity窗口的上方一般会有一个状态栏，用来显示3G信号、电量使用等图标，如图1所示。</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/08/1357577722_3792.jpg" alt="" /><br /></p><p style="text-align: center;">图1 Activity窗口的Content区域示意图</p><p>&nbsp; &nbsp; &nbsp; &nbsp;从Activity窗口剔除掉状态栏所占用的区域之后，所得到的区域就称为内容区域（Content Region）。顾名思义，内容区域就是用来显示Activity窗口的内容的。我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为内容区域，而被剔除出来的区域所组成的区域就称为内容边衬区域（Content Insets）。Activity窗口的内容边衬区域可以用一个四元组（content-left, content-top, content-right, content-bottom）来描述，其中，content-left、content-right、content-top、content-bottom分别用来描述内容区域与窗口区域的左右上下边界距离。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;我们还知道，Activity窗口有时候需要显示输入法窗口，如图2所示。</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/08/1357578477_7744.jpg" alt="" /><br /></p><p style="text-align: center;">图2&nbsp;<span style="text-align: center;">Activity窗口的Visible区域示意图</span></p><p><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 这时候Activity窗口的内容区域的大小有可能没有发生变化，这取决于它的Soft Input Mode。我们假设<span style="text-align: center;">Activity窗口的内容区域没有发生变化，但是它在底部的一些区域被输入法窗口遮挡了，即它在底部的一些内容是不可见的。从Activity窗口剔除掉状态栏和输入法窗口所占用的区域之后，所得到的区域就称为可见区域（Visible Region）。同样，我们再抽象一下，假设Activity窗口的四周都有一块类似状态栏和输入法窗口的区域，那么将这些区域剔除之后，得到中间的那一块区域就称为可见区域，而被剔除出来的区域所组成的区域就称为可见边衬区域（Visible Insets）。Activity窗口的可见边衬区域可以用一个四元组（visible-left, <span style="text-align: center;">visible</span>-top, <span style="text-align: center;">visible</span>-right, <span style="text-align: center;">visible</span>-bottom）来描述，其中，<span style="text-align: center;">visible</span>-left、<span style="text-align: center;">visible</span>-right、<span style="text-align: center;">visible</span>-top、<span style="text-align: center;">visible</span>-bottom分别用来描述可见区域与窗口区域的左右上下边界距离。</span></span></p><p><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 在大多数情况下，Activity窗口的内容区域和可见区域的大小是一致的，而状态栏和输入法窗口所占用的区域又称为屏幕装饰区。理解了这些概念之后，我们就可以推断，WindowManagerService服务实际上就是需要根据屏幕以及可能出现的状态栏和输入法窗口的大小来计算出Activity窗口的整体大小及其内容区域边衬和可见区域边衬的大小。有了这三个数据之后，Activity窗口就可以对它里面的UI元素进行测量、布局以及绘制等操作了。</span></span></p><p><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8303098">Android应用程序窗口（Activity）的绘图表面（Surface）的创建过程分析</a>一文可以知道，应用程序进程是从ViewRoot类的成员函数performTraversals开始，向WindowManagerService服务请求计算一个Activity窗口的大小的，因此，接下来我们就从<span style="text-align: center;">ViewRoot类的成员函数</span><span style="text-align: center;">performTraversals开始分析一个Activity窗口大小的计算过程，如图3所示。</span></span></span></p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/09/1357660841_4551.jpg" alt="" /><br /></p><p style="text-align: center;">图3 Activity窗口大小的计算过程</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;这个过程可以分为11个步骤，接下来我们就详细分析每一个步骤。</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Step 1. ViewRoot.performTraversals</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中，它的实现很复杂，一共有600-行，不过大部分代码都是用来计算Activity窗口的大小的，我们分段来阅读：</p><p style="text-align: left;"></p><pre name="code" class="java">public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......
     
    private void performTraversals() {
        ......

        final View host = mView;
        ......
 
        int desiredWindowWidth;
        int desiredWindowHeight;
        int childWidthMeasureSpec;
        int childHeightMeasureSpec;
        ......

        Rect frame = mWinFrame;
        if (mFirst) {
            ......
 
            DisplayMetrics packageMetrics =
                 mView.getContext().getResources().getDisplayMetrics();
            desiredWindowWidth = packageMetrics.widthPixels;
            desiredWindowHeight = packageMetrics.heightPixels;
        } else {
            desiredWindowWidth = frame.width();
            desiredWindowHeight = frame.height();
            if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) {
                ......
                windowResizesToFitContent = true;
            }
        }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码用来获得Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight。<p></p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; 注意，Activity窗口当前的宽度和高度是保存ViewRoot类的成员变量mWinFrame中的。ViewRoot类的另外两个成员变量mWidth和mHeight也是用来描述Activity窗口当前的宽度和高度的，但是它们的值是由应用程序进程上一次主动请求WindowManagerService服务计算得到的，并且会一直保持不变到应用程序进程下一次再请求WindowManagerService服务来重新计算为止。Activity窗口的当前宽度和高度有时候是被WindowManagerService服务主动请求应用程序进程修改的，修改后的值就会保存在ViewRoot类的成员变量mWinFrame中，它们可能会与ViewRoot类的成员变量mWidth和mHeight的值不同。</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; 如果Activity窗口是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true，那么它的当前宽度desiredWindowWidth和当前高度desiredWindowHeight就等于屏幕的宽度和高度，否则的话，它的当前宽度desiredWindowWidth和当前高度desiredWindowHeight就等于保存在ViewRoot类的成员变量mWinFrame中的宽度和高度值。</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果Activity窗口不是第一次被请求执行测量、布局和绘制操作，并且Activity窗口主动上一次请求WindowManagerService服务计算得到的宽度mWidth和高度mHeight不等于Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight，那么就说明Activity窗口的大小发生了变化，这时候变量windowResizesToFitContent的值就会被标记为true，以便接下来可以对Activity窗口的大小变化进行处理。</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; 我们继续往下阅读代码：</p><p style="text-align: left;"></p><pre name="code" class="java">        boolean insetsChanged = false;
 
        if (mLayoutRequested) {
            ......
 
            if (mFirst) {
                host.fitSystemWindows(mAttachInfo.mContentInsets);
                ......
            } else {
                if (!mAttachInfo.mContentInsets.equals(mPendingContentInsets)) {
                    mAttachInfo.mContentInsets.set(mPendingContentInsets);
                    host.fitSystemWindows(mAttachInfo.mContentInsets);
                    insetsChanged = true;
                    ......
                }
                if (!mAttachInfo.mVisibleInsets.equals(mPendingVisibleInsets)) {
                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
                    ......
                }
                if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT
                        || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) {
                    windowResizesToFitContent = true;
 
                    DisplayMetrics packageMetrics =
                        mView.getContext().getResources().getDisplayMetrics();
                    desiredWindowWidth = packageMetrics.widthPixels;
                    desiredWindowHeight = packageMetrics.heightPixels;
                }
            }

            childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);
            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height); 
            ......

            host.measure(childWidthMeasureSpec, childHeightMeasureSpec);
 
            ......
        }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码用来在Activity窗口主动请求WindowManagerService服务计算大小之前，对它的顶层视图进行一次测量操作。<p></p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; 在分析这段代码之前，我们首先解释一下ViewRoot类的成员变量mAttachInfo和mPendingContentInsets、mPendingVisibleInsets。ViewRoot类的成员变量mAttachInfo指向的一个AttachInfo对象，这个AttachInfo对象用来描述Activity窗口的属性，例如，这个AttachInfo对象的成员变量mContentInsets和mVisibleInsets分别用来描述Activity窗口上一次主动请求WindowManagerService服务计算得到的内容边衬大小和可见边衬大小，即Activity窗口的当前内容边衬大小和可见边衬大小。ViewRoot类的成员变量mPendingContentInsets和mPendingVisibleInsets也是用来描述Activity窗口的内容边衬大小和可见边衬大小的，不过它们是由WindowManagerService服务主动请求Activity窗口设置的，但是尚未生效。</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; 我们分两种情况来分析这段代码。</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; 第一种情况是Activity窗口是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true，那么这段代码在测量Activity窗口的顶层视图host的大小之前，首先会调用这个顶层视图host的成员函数fitSystemWindows来设置它的四个内边距（mPaddingLeft，mPaddingTop，mPaddingRight，mPaddingBottom）的大小设置为Activity窗口的初始化内容边衬大小。这样做的目的是可以在Activity窗口的四周留下足够的区域来放置可能会出现的系统窗口，也就是状态栏和输入法窗口。</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; 第二种情况是Activity窗口不是第一次被请求执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于false，那么这段代码就会检查Activity窗口是否被WindowManagerService服务主动请求设置了一个新的内容边衬大小mPendingContentInsets和一个新的可见边衬大小mPendingVisibleInsets。如果是的话，那么就会分别将它们保存在ViewRoot类的成员变量mAttachInfo所指向的一个AttachInfo对象的成员变量mContentInsets和成员变量mVisibleInsets中。注意，如果Activity窗口被WindowManagerService服务主动请求设置了一个新的内容边衬大小mPendingContentInsets，那么这段代码同时还需要同步调用Activity窗口的顶层视图host的成员函数fitSystemWindows来将它的四个内边距（mPaddingLeft，mPaddingTop，mPaddingRight，mPaddingBottom）的大小设置为新的内容边衬大小，并且将变量insetsChanged的值设置为true，表明Activity窗口的内容边衬大小发生了变化。<br /></p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; 在第二种情况下，如果Activity窗口的宽度被设置为ViewGroup.LayoutParams.WRAP_CONTENT或者高度被设置为ViewGroup.LayoutParams.WRAP_CONTENT，那么就意味着Activity窗口的大小要等于内容区域的大小。但是由于Activity窗口的大小是需要覆盖整个屏幕的，因此，这时候就会Activity窗口的当前宽度desiredWindowWidth和当前高度desiredWindowHeight设置为屏幕的宽度和高度。也就是说，如果我们将Activity窗口的宽度和高度设置为ViewGroup.LayoutParams.WRAP_CONTENT，实际上就意味着它的宽度和高度等于屏幕的宽度和高度。这种情况也意味着Acitivity窗口的大小发生了变化，因此，就将变量windowResizesToFitContent的值设置为true。</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp; 经过上面的一系列处理之后，这段代码就会调用ViewRoot类的成员函数getRootMeasureSpec来根据Activity窗口的当前宽度和宽度测量规范以及高度和高度测量规范来计算得到它的顶层视图host的宽度测量规范childWidthMeasureSpec和高度测量规范childHeightMeasureSpec。有了这两个规范之后，就可以调用Activity窗口的顶层视图host的成员函数measure来执行大小测量的工作了。这个大小测量的过程可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8372924">Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析</a>一文。</p><p style="text-align: left;">&nbsp; &nbsp; &nbsp; &nbsp;我们继续往下阅读代码：</p><p style="text-align: left;"></p><pre name="code" class="java">        boolean windowShouldResize = mLayoutRequested &amp;&amp; windowResizesToFitContent
            &amp;&amp; ((mWidth != host.mMeasuredWidth || mHeight != host.mMeasuredHeight)
                || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;
                        frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() != mWidth)
                || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;
                        frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() != mHeight));

        final boolean computesInternalInsets =
                attachInfo.mTreeObserver.hasComputeInternalInsetsListeners();</pre><p>&nbsp; &nbsp; &nbsp; &nbsp;这段代码主要是做两件事情。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;第一件事情是检查是否需要处理Activity窗口的大小变化事件。如果满足以下条件，那么就需要处理，即将变量windowShouldResize的值设置为true：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;1. ViewRoot类的成员变量mLayoutRequest的值等于true，这说明应用程序进程正在请求对Activity窗口执行一次测量、布局和绘制操作；</p><p>&nbsp; &nbsp; &nbsp; &nbsp;2. 变量windowResizesToFitContent的值等于true，这说明前面检测到了Activity窗口的大小发生了变化；</p><p>&nbsp; &nbsp; &nbsp; &nbsp;3. 前面我们已经Activity窗口的顶层视图host的大小重新进行了测量。如果测量出来的宽度host.mMeasuredWidth和高度host.mMeasuredHeight和Activity窗口的当前宽度mWidth和高度mHeight一样，那么即使条件1和条件2能满足，那么也是可以认为是Activity窗口的大小是没有发生变化的。换句话说，只有当测量出来的大小和当前大小不一致时，才认为Activity窗口大小发生了变化。另一方面，如果测量出来的大小和当前大小一致，但是Activity窗口的大小被要求设置成WRAP_CONTENT，即设置成和屏幕的宽度desiredWindowWidth和高度desiredWindowHeight一致，但是WindowManagerService服务请求Activity窗口设置的宽度frame.width()和高度frame.height()与它们不一致，而且与Activity窗口上一次请求WindowManagerService服务计算的宽度mWidth和高度mHeight也不一致，那么也是认为Activity窗口大小发生了变化的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第二件事情是检查Activity窗口是否需要指定有额外的内容边衬区域和可见边衬区域。如果有的话，那么变量attachInfo所指向的一个AttachInfo对象的成员变量mTreeObserver所描述的一个TreeObserver对象的成员函数hasComputeInternalInsetsListerner的返回值ComputeInternalInsets就会等于true。Activity窗口指定额外的内容边衬区域和可见边衬区域是为了放置一些额外的东西。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我们继续往下阅读代码：</p><p></p><pre name="code" class="java">        if (mFirst || windowShouldResize || insetsChanged
                || viewVisibilityChanged || params != null) {

            if (viewVisibility == View.VISIBLE) {
                // If this window is giving internal insets to the window
                // manager, and it is being added or changing its visibility,
                // then we want to first give the window manager &quot;fake&quot;
                // insets to cause it to effectively ignore the content of
                // the window during layout.  This avoids it briefly causing
                // other windows to resize/move based on the raw frame of the
                // window, waiting until we can finish laying out this window
                // and get back to the window manager with the ultimately
                // computed insets.
                insetsPending = computesInternalInsets
                        &amp;&amp; (mFirst || viewVisibilityChanged);

                ......
            }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码以及接下来的两段代码都是在满足下面的条件之一的情况下执行的：<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. Activity窗口是第一次执行测量、布局和绘制操作，即ViewRoot类的成员变量mFirst的值等于true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. 前面得到的变量windowShouldResize的值等于true，即Activity窗口的大小的确是发生了变化。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. 前面得到的变量insetsChanged的值等于true，即Activity窗口的内容区域边衬发生了变化。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4.&nbsp;Activity窗口的可见性发生了变化，即变量viewVisibilityChanged的值等于true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5.&nbsp;Activity窗口的属性发生了变化，即变量params指向了一个WindowManager.LayoutParams对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在满足上述条件之一，并且Activity窗口处于可见状态，即变量viewVisibility的值等于View.VISIBLE，那么就需要检查接下来请求WindowManagerService服务计算大小时，是否要告诉WindowManagerService服务它指定了额外的内容区域边衬和可见区域边衬，但是这些额外的内容区域边衬和可见区域边衬又还有确定。这种情况发生在Activity窗口第一次执行测量、布局和绘制操作或者由不可见变化可见时。因此，当前面得到的变量computesInternalInsets等于true时，即Activity窗口指定了额外的内容区域边衬和可见区域边衬，那么就需要检查ViewRoot类的成员变量mFirst或者变量viewVisibilityChanged的值是否等于true。如果这些条件能满足，那么变量insetsPending的值就会等于true，表示Activity窗口有额外的内容区域边衬和可见区域边衬等待指定。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我们继续往下阅读代码：</p><p></p><pre name="code" class="java">            boolean contentInsetsChanged = false;
            boolean visibleInsetsChanged;
            ......
            try {
                ......
                relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);

                contentInsetsChanged = !mPendingContentInsets.equals(
                        mAttachInfo.mContentInsets);
                visibleInsetsChanged = !mPendingVisibleInsets.equals(
                        mAttachInfo.mVisibleInsets);
                if (contentInsetsChanged) {
                    mAttachInfo.mContentInsets.set(mPendingContentInsets);
                    host.fitSystemWindows(mAttachInfo.mContentInsets);
                    ......
                }
                if (visibleInsetsChanged) {
                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);
                    ......
                }
                    
                ......
            } catch (RemoteException e) {
            }

            ......

            attachInfo.mWindowLeft = frame.left;
            attachInfo.mWindowTop = frame.top;

            // !!FIXME!! This next section handles the case where we did not get the
            // window size we asked for. We should avoid this by getting a maximum size from
            // the window session beforehand.
            mWidth = frame.width();
            mHeight = frame.height();</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码主要就是调用ViewRoot类的另外一个成员函数relayoutWindow来请求WindowManagerService服务计算Activity窗口的大小以及内容区域边衬大小和可见区域边衬大小。计算完毕之后，Activity窗口的大小就会保存在ViewRoot类的成员变量mWinFrame中，而Activity窗口的内容区域边衬大小和可见区域边衬大小分别保存在ViewRoot类的成员变量mPendingContentInsets和mPendingVisibleInsets中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果这次计算得到的Activity窗口的内容区域边衬大小mPendingContentInsets和可见区域边衬大小mPendingVisibleInsets与上一次计算得到的不一致，即与ViewRoot类的成员变量mAttachInfo所指向的一个AttachInfo对象的成员变量mContentInsets和mVisibleInsets所描述的大小不一致，那么变量contentInsetsChanged和visibleInsetsChanged的值就会等于true，表示Activity窗口的内容区域边衬大小和可见区域边衬大小发生了变化。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 由于变量frame和ViewRoot类的成员变量mWinFrame引用的是同一个Rect对象，因此，这时候变量frame描述的也是Activity窗口请求WindowManagerService服务计算之后得到的大小。这段代码分别将计算得到的Activity窗口的左上角坐标保存在变量attachInfo所指向的一个AttachInfo对象的成员变量mWindowLeft和mWindowTop中，并且将计算得到的Activity窗口的宽度和高度保存在ViewRoot类的成员变量mWidth和mHeight中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我们继续往下阅读代码：</p><p></p><pre name="code" class="java">            boolean focusChangedDueToTouchMode = ensureTouchModeLocally(
                    (relayoutResult&amp;WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE) != 0);
            if (focusChangedDueToTouchMode || mWidth != host.mMeasuredWidth
                    || mHeight != host.mMeasuredHeight || contentInsetsChanged) {
                childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
                childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
                ......

                // Ask host how big it wants to be
                host.measure(childWidthMeasureSpec, childHeightMeasureSpec);
        
                // Implementation of weights from WindowManager.LayoutParams
                // We just grow the dimensions as needed and re-measure if
                // needs be
                int width = host.mMeasuredWidth;
                int height = host.mMeasuredHeight;
                boolean measureAgain = false;

                if (lp.horizontalWeight &gt; 0.0f) {
                    width += (int) ((mWidth - width) * lp.horizontalWeight);
                    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,
                            MeasureSpec.EXACTLY);
                    measureAgain = true;
                }
                if (lp.verticalWeight &gt; 0.0f) {
                    height += (int) ((mHeight - height) * lp.verticalWeight);
                    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,
                            MeasureSpec.EXACTLY);
                    measureAgain = true;
                }

                if (measureAgain) {
                    ......
                    host.measure(childWidthMeasureSpec, childHeightMeasureSpec);
                }

                mLayoutRequested = true;
            }
        }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码用来检查是否需要重新测量Activity窗口的大小。如果满足以下条件之一，那么就需要重新测量：<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. Activity窗口的触摸模式发生了变化，并且由此引发了Activity窗口当前获得焦点的控件发生了变化，即变量focusChangedDueToTouchMode的值等于true。这个检查是通过调用ViewRoot类的成员函数ensureTouchModeLocally来实现的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. Activity窗口前面测量出来的宽度host.mMeasuredWidth和高度host.mMeasuredHeight不等于WindowManagerService服务计算出来的宽度mWidth和高度mHeight。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3.&nbsp;Activity窗口的内容区域边衬大小和可见区域边衬大小发生了变化，即前面得到的变量contentInsetsChanged的值等于true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 重新计算了一次之后，如果Activity窗口的属性lp表明需要对测量出来的宽度width和高度height进行扩展，即变量lp所指向的一个WindowManager.LayoutParams对象的成员变量horizontalWeight和verticalWeight的值大于0.0，那么就需要对Activity窗口的顶层视图host的最大可用空间进行扩展后再进行一次测量工作。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我们继续往下阅读最后一段代码：</p><p></p><pre name="code" class="java">        final boolean didLayout = mLayoutRequested;
        ......
        if (didLayout) {
            ......
            host.layout(0, 0, host.mMeasuredWidth, host.mMeasuredHeight);
            ......
        }

        if (computesInternalInsets) {
            ViewTreeObserver.InternalInsetsInfo insets = attachInfo.mGivenInternalInsets;
            final Rect givenContent = attachInfo.mGivenInternalInsets.contentInsets;
            final Rect givenVisible = attachInfo.mGivenInternalInsets.visibleInsets;
            givenContent.left = givenContent.top = givenContent.right
                    = givenContent.bottom = givenVisible.left = givenVisible.top
                    = givenVisible.right = givenVisible.bottom = 0;
            attachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);
            Rect contentInsets = insets.contentInsets;
            Rect visibleInsets = insets.visibleInsets;
            if (mTranslator != null) {
                contentInsets = mTranslator.getTranslatedContentInsets(contentInsets);
                visibleInsets = mTranslator.getTranslatedVisbileInsets(visibleInsets);
            }
            if (insetsPending || !mLastGivenInsets.equals(insets)) {
                mLastGivenInsets.set(insets);
                try {
                    sWindowSession.setInsets(mWindow, insets.mTouchableInsets,
                            contentInsets, visibleInsets);
                } catch (RemoteException e) {
                }
            }
        }
          
        ......
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp; 经过前面漫长的操作后，Activity窗口的大小测量工作终于尘埃落定，这时候就可以对Activity窗口的内容进行布局了，前提是ViewRoot类的成员变量mLayoutRequest的值等于true。对Activity窗口的内容进行布局是通过调用它的顶层视图host的成员函数layout来实现的，这个过程可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8372924">Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析</a>一文。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 从前面的描述可以知道，当变量computesInternalInsets的值等于true时，就表示Activity窗口指定有额外的内容区域边衬和可见区域边衬，这时候就是时候把它们告诉给WindowManagerService服务了，以便WindowManagerService服务下次可以知道Activity窗口的真实布局。Activity窗口额外指定的内容区域边衬大小和可见区域边衬大小是通过调用变量attachInfo所指向的一个AttachInfo对象的成员变量mTreeObserver所描述的一个TreeObserver对象的成员函数dispatchOnComputeInternalInsets来计算的。计算完成之后，就会保存在变量attachInfo所指向的一个AttachInfo对象的成员变量mGivenInternalInsets中，并且会通过ViewRoot类的静态成员变量sWindowSession所指向一个Binder代理对象来设置到WindowManagerService服务中去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注意，如果ViewRoot类的成员变量mTranslator指向了一个Translator对象，那么就说明Activity窗口是运行兼容模式中，这时候就需要将前面计算得到的内容区域边衬大小和可见区域边衬大小转化到兼容模式下，然后才可以保存在变量attachInfo所指向的一个AttachInfo对象的成员变量mGivenInternalInsets中，以及设置到WindowManagerService服务中去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 另外，只有前面得到的变量insetsPending的值等于true，即Activity窗口正在等待告诉WindowManagerService服务它有额外指定的内容区域边衬和可见区域边衬，或者Activty窗口额外指定的内容区域边衬和可见区域边衬发生了变化，即Activty窗口上一次额外指定的内容区域边衬和可见区域边衬mLastGivenInsets不等于当前这次指定的内容区域边衬和可见区域边衬insets，Activity窗口额外指定的内容区域边衬和可见区域边衬才会被设置到WindowManagerService服务中去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; ViewRoot类的成员函数再接下来的工作就是绘制Activity窗口的UI了，这个过程同样可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8372924">Android应用程序窗口（Activity）的测量（Measure）、布局（Layout）和绘制（Draw）过程分析</a>一文。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 接下来，我们继续分析ViewRoot类的成员函数relayoutWindow的实现，以便可以了解它是如何请求WindowManagerService服务计算Activity窗口的大小的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 2.&nbsp;ViewRoot.relayoutWindow</p><p></p><pre name="code" class="java">public final class ViewRoot extends Handler implements ViewParent,
        View.AttachInfo.Callbacks {
    ......
     
    private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility,
            boolean insetsPending) throws RemoteException {

        float appScale = mAttachInfo.mApplicationScale;
        ......

        int relayoutResult = sWindowSession.relayout(
                mWindow, params,
                (int) (mView.mMeasuredWidth * appScale + 0.5f),
                (int) (mView.mMeasuredHeight * appScale + 0.5f),
                viewVisibility, insetsPending, mWinFrame,
                mPendingContentInsets, mPendingVisibleInsets,
                mPendingConfiguration, mSurface);
        ......
        
        if (mTranslator != null) {
            mTranslator.translateRectInScreenToAppWinFrame(mWinFrame);
            mTranslator.translateRectInScreenToAppWindow(mPendingContentInsets);
            mTranslator.translateRectInScreenToAppWindow(mPendingVisibleInsets);
        }
        return relayoutResult;
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/core/java/android/view/ViewRoot.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，ViewRoot类的静态成员变量sWindowSession是一个Binder代理对象，它引用了运行在WindowManagerService服务这一侧的一个Session对象，ViewRoot类的成员函数relayoutWindow通过调用这个Session对象的成员函数relayout来请求WindowManagerService服务计算Activity窗口的大小，其中，传递给WindowManagerService服务的参数包括：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;1. ViewRoot类的成员变量mWindow，用来标志要计算的是哪一个Activity窗口的大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp;Activity窗口的顶层视图经过测量后得到的宽度和高度。注意，传递给WindowManagerService服务的宽度和高度是已经考虑了Activity窗口所设置的缩放因子了的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;3.&nbsp;Activity窗口的可见状态，即参数viewVisibility。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;4. Activity窗口是否有额外的内容区域边衬和可见区域边衬等待告诉给WindowManagerService服务，即参数insetsPending。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;5.&nbsp;ViewRoot类的成员变量mWinFrame，这是一个输出参数，用来保存WindowManagerService服务计算后得到的Activity窗口的大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;6.&nbsp;ViewRoot类的成员变量mPendingContentInsets，这是一个输出参数，用来保存WindowManagerService服务计算后得到的Activity窗口的内容区域边衬大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;7.&nbsp;ViewRoot类的成员变量mPendingVisibleInsets，这是一个输出参数，用来保存WindowManagerService服务计算后得到的Activity窗口的可见区域边衬大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;8.&nbsp;ViewRoot类的成员变量mPendingConfiguration，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的配置信息。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;9. ViewRoot类的成员变量mSurface，这是一个输出参数，用来保存WindowManagerService服务返回来的Activity窗口的绘图表面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;得到了Activity窗口的大小以及内容区域边衬大小和可见区域边衬大小之后，如果Activity窗口是运行在兼容模式中，即ViewRoot类的成员变量mTranslator指向了一个Translator对象，那么就需要调用它的成员函数translateRectInScreenToAppWindow来对它们进行转换。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们继续分析Session类的成员函数relayout，以便可以了解WindowManagerService服务是如何计算一个Activity窗口的大小的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;Step 3.&nbsp;Session.relayout<br /></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final class Session extends IWindowSession.Stub
            implements IBinder.DeathRecipient {
        ......

        public int relayout(IWindow window, WindowManager.LayoutParams attrs,
                int requestedWidth, int requestedHeight, int viewFlags,
                boolean insetsPending, Rect outFrame, Rect outContentInsets,
                Rect outVisibleInsets, Configuration outConfig, Surface outSurface) {
            //Log.d(TAG, &quot;&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from &quot; + Binder.getCallingPid());
            int res = relayoutWindow(this, window, attrs,
                    requestedWidth, requestedHeight, viewFlags, insetsPending,
                    outFrame, outContentInsets, outVisibleInsets, outConfig, outSurface);
            //Log.d(TAG, &quot;&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to &quot; + Binder.getCallingPid());
            return res;
        }

        ......
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; Session类的成员函数relayout的实现很简单，它只是调用了WindowManagerService类的成员函数relayoutWindow来进一步计算参数window所描述的一个Activity窗品的大小，接下来我们就继续分析WindowManagerService类的成员函数relayoutWindow的实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 4.&nbsp;WindowManagerService.relayoutWindow</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    public int relayoutWindow(Session session, IWindow client,
            WindowManager.LayoutParams attrs, int requestedWidth,
            int requestedHeight, int viewVisibility, boolean insetsPending,
            Rect outFrame, Rect outContentInsets, Rect outVisibleInsets,
            Configuration outConfig, Surface outSurface) {
        ......
 
        synchronized(mWindowMap) {
            WindowState win = windowForClientLocked(session, client, false);
            ......

            win.mRequestedWidth = requestedWidth;
            win.mRequestedHeight = requestedHeight;
            ......

            final boolean scaledWindow =
                ((win.mAttrs.flags &amp; WindowManager.LayoutParams.FLAG_SCALED) != 0);

            if (scaledWindow) {
                // requested{Width|Height} Surface's physical size
                // attrs.{width|height} Size on screen
                win.mHScale = (attrs.width  != requestedWidth)  ?
                        (attrs.width  / (float)requestedWidth) : 1.0f;
                win.mVScale = (attrs.height != requestedHeight) ?
                        (attrs.height / (float)requestedHeight) : 1.0f;
            } else {
                win.mHScale = win.mVScale = 1;
            }

            ......

            win.mGivenInsetsPending = insetsPending;

            ......

            performLayoutAndPlaceSurfacesLocked();

            ......

            outFrame.set(win.mFrame);
            outContentInsets.set(win.mContentInsets);
            outVisibleInsets.set(win.mVisibleInsets);
 
            ......
        }

        return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0)
                | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
    }

    ......
}</pre><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 参数client是一个Binder代理对象，它引用了运行在应用程序进程这一侧中的一个W对象，用来标志一个Activity窗口。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，在应用程序进程这一侧的每一个W对象，在WindowManagerService服务这一侧都有一个对应的WindowState对象，用来描述一个Activity窗口的状态。因此，WindowManagerService类的成员函数relayoutWindow首先通过调用另外一个成员函数windowForClientLocked来获得与参数client所对应的一个WindowState对象win，以便接下来可以对它进行操作。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 本文我们只关注WindowManagerService类的成员函数relayoutWindow中与窗口大小计算有关的逻辑，计算过程如下所示：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 参数requestedWidth和requestedHeight描述的是应用程序进程请求设置Activity窗口中的宽度和高度，它们会被记录在WindowState对象win的成员变量mRequestedWidth和mRequestedHeight中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2.&nbsp;WindowState对象win的成员变量mAttr，它指向的是一个WindowManager.LayoutParams对象，用来描述Activity窗口的布局参数。其中，这个WindowManager.LayoutParams对象的成员变量width和height是用来描述Activity窗口的宽度和高度的。当这个WindowManager.LayoutParams对象的成员变量flags的WindowManager.LayoutParams.FLAG_SCALED位不等于0的时候，就说明需要给Activity窗口的大小设置缩放因子。缩放因子分为两个维度，分别是宽度缩放因子和高度缩放因子，保存在WindowState对象win的成员变量HScale和VScale中，计算方法分别是用应用程序进程请求设置Activity窗口中的宽度和高度除以Activity窗口在布局参数中所设置的宽度和高度。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. 参数insetsPending用来描述Activity窗口是否有额外的内容区域边衬和可见区域边衬未设置，它被记录在WindowState对象win的成员变量mGivenInsetsPending中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4. 调用WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked来计算Activity窗口的大小。计算完成之后，参数client所描述的Activity窗口的大小、内容区域边衬大小和可见区域边边衬大小就会分别保存在WindowState对象win的成员变量mFrame、mContentInsets和mVisibleInsets中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5. 将WindowState对象win的成员变量mFrame、mContentInsets和mVisibleInsets的值分别拷贝到参数出数outFrame、outContentInsets和outVisibleInsets中，以便可以返回给应用程序进程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 经过上述五个操作后，Activity窗口的大小计算过程就完成了，接下来我们继续分析WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked的实现，以便可以详细了解Activity窗口的大小计算过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 5.&nbsp;WindowManagerService.performLayoutAndPlaceSurfacesLocked</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final void performLayoutAndPlaceSurfacesLocked() {
        if (mInLayout) {
            ......
            return;
        }

        ......

        boolean recoveringMemory = false;
        if (mForceRemoves != null) {
            recoveringMemory = true;
            // Wait a little it for things to settle down, and off we go.
            for (int i=0; i&lt;mForceRemoves.size(); i++) {
                WindowState ws = mForceRemoves.get(i);
                Slog.i(TAG, &quot;Force removing: &quot; + ws);
                removeWindowInnerLocked(ws.mSession, ws);
            }
            mForceRemoves = null;
            ......
        }

        mInLayout = true;
        try {
            performLayoutAndPlaceSurfacesLockedInner(recoveringMemory);

            int i = mPendingRemove.size()-1;
            if (i &gt;= 0) {
                while (i &gt;= 0) {
                    WindowState w = mPendingRemove.get(i);
                    removeWindowInnerLocked(w.mSession, w);
                    i--;
                }
                mPendingRemove.clear();

                mInLayout = false;
                assignLayersLocked();
                mLayoutNeeded = true;
                performLayoutAndPlaceSurfacesLocked();

            } else {
                mInLayout = false;
                ......
            }
            ......
        } catch (RuntimeException e) {
            mInLayout = false;
            ......
        }
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;从WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked的名称可以推断出，它执行的操作绝非是计算窗口大小这么简单。计算窗口大小只是其中的一个小小功能点，它主要的功能是用来刷新系统的UI。在我们这个情景中，为什么需要刷新系统的UI呢？Activity窗口在其属性发生了变化，例如，可见性、大小发生了变化，又或者它新增、删除了子视图，都需要重新计算大小，而这些变化都是要求WindowManagerService服务重新刷新系统的UI的。事实上，刷新系统的UI是WindowManagerService服务的主要任务，在新增和删除了窗口、窗口动画显示过程、窗口切换过程中，WindowManagerService服务都需要不断地刷新系统的UI。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked主要是通过调用另外一个成员函数performLayoutAndPlaceSurfacesLockedInner来刷新系统的UI的，而在刷新的过程中，就会对系统中的各个窗口的大小进行计算。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;在调用成员函数performLayoutAndPlaceSurfacesLockedInner来刷新系统UI的前后，WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked还会执行以下两个操作：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;1. 调用前，检查系统中是否存在强制删除的窗口。有内存不足的情况下，有一些窗口就会被回收，即要从系统中删除，这些窗口会保存在WindowManagerService类的成员变量mForceRemoves所描述的一个ArrayList中。如果存在这些窗口，那么WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked就会调用另外一个成员函数removeWindowInnerLocked来删除它们，以便可以回收它们所占用的内存。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;2. 调用后，检查系统中是否有窗口需要移除。如果有的话，那么WindowManagerService类的成员变量mPendingRemove所描述的一个ArrayList的大小就会大于0。这种情况下，WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked就会调用另外一个成员函数removeWindowInnerLocked来移除这些窗口。注意，WindowManagerService类的成员函数removeWindowInnerLocked只是用来移除窗口，但是并没有回收这些窗口所占用的内存。等到合适的时候，例如，内存不足时，才会考虑回收这些窗口所占用的内存。移除一个窗口的操作也是很复杂的，除了要将窗口从WindowManagerService类的相关成员变量中移除之外，还要考虑重新调整输入法窗口和壁纸窗口，因为被移除的窗口可能要求显示壁纸和输入法窗口，当它被移除之后，就要将壁纸窗口和输入法窗口调整到合适的Z轴位置上去，以便可以交给下一个需要显示壁纸和输入法窗口的窗口使用。此外，在移除了窗口之后，WindowManagerService服务还需要重新计算现存的其它窗口的Z轴位置，以便可以正确地反映系统当前的UI状态，这是通过调用WindowManagerService类的成员函数assignLayersLocked来实现的。重新计算了现存的其它窗口的Z轴位置之后，又需要再次刷新系统的UI，即要对WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked进行递归调用，并且在调用前，将WindowManagerService类的成员变量mLayoutNeeded的值设置为true。由此就可见，系统UI的刷新过程是非常复杂的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;注意，为了防止在刷新系统UI的过程中被重复调用，WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked在刷新系统UI之前，即调用成员函数performLayoutAndPlaceSurfacesLockedInner之前，会将WindowManagerService类的成员变量mInLayout的值设置为true，并且在调用之后，重新将这个成员变量的值设置为false。这样，WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked就可以在一开始的时候检查成员变量mInLayout的值是否等于true，如果等于的话，那么就说明WindowManagerService服务正在刷新系统UI的过程中，于是就不用往下执行了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就继续分析WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLockedInner的实现，以便可以了解Activity窗口的大小计算过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;Step 6.&nbsp;WindowManagerService.performLayoutAndPlaceSurfacesLockedInner</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final void performLayoutAndPlaceSurfacesLockedInner(
            boolean recoveringMemory) {
        ......

        Surface.openTransaction();
        ......

        try {
            ......
            int repeats = 0;
            int changes = 0;
            
            do {
                repeats++;
                if (repeats &gt; 6) {
                    ......
                    break;
                }

                // FIRST LOOP: Perform a layout, if needed.
                if (repeats &lt; 4) {
                    changes = performLayoutLockedInner();
                    if (changes != 0) {
                        continue;
                    }
                } else {
                    Slog.w(TAG, &quot;Layout repeat skipped after too many iterations&quot;);
                    changes = 0;
                }

                // SECOND LOOP: Execute animations and update visibility of windows.
                ......
                
            } while (changes != 0);

            // THIRD LOOP: Update the surfaces of all windows.
                
            ......
        } catch (RuntimeException e) {
            ......
        }

        ......

        Surface.closeTransaction();

        ......

        // Destroy the surface of any windows that are no longer visible.
        ......

        // Time to remove any exiting tokens?
        ......

        // Time to remove any exiting applications?
        ......
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<br /><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLockedInner是一个巨无霸的函数，它一共有1200+行代码，承载了WindowManagerService服务的核心功能。对于这样一个巨无霸函数，要逐行地分析它的实现是很困难的，因为要理解各种上下文信息，才可以清楚地知道它的执行过程。这里我们就大概地分析它的实现框架，以后再逐步地分析它的具体实现：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 在一个最多执行7次的while循环中，做两件事情：第一件事情是计算各个窗品的大小，这是通过调用另外一个成员函数performLayoutLockedInner来实现的；第二件事情是执行窗口的动画，主要是处理窗口的启动窗口显示动画和窗口切换过程中的动画，以及更新各个窗口的可见性。注意，每一次while循环执行之后，如果发现系统中的各个窗口的相应布局属性不再发生变化，那么就不行执行下一次的while循环了，即该while循环可能不用执行7次就结束了。窗口的动画显示过程和窗口的可见性更新过程是相当复杂的，它们也是WindowManagerService服务最为核的地方，在后面的文章中，我们再详细分析。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. 经过第1点的操作之后，接下来就可以将各个窗口的属性，例如，大小、位置等属性，通知SurfaceFlinger服务了，也就是让SurfaceFlinger服务更新它里面的各个Layer的属性值，以便可以对这些Layer执行可见性计算、合成等操作，最后渲染到硬件帧缓冲区中去。SurfaceFlinger服务计算系统中各个窗口，即各个Layer的可见性，以便将它们合成、渲染到硬件帧缓冲区的过程可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8079456">Android系统Surface机制的SurfaceFlinger服务渲染应用程序UI的过程分析</a>一文。注意，各个窗口的属性更新操作是被包含在SurfaceFlinger服务的一个事务中的，即一个Transaction中，这样做是为了避免每更新一个窗口的一个属性就触发SurfaceFlinger服务重新计算各个Layer的可见性，以及对各个Layer进行合并和渲染的操作。启动SurfaceFlinger服务的一个事务可以通过调用Surface类的静态成员函数openTransaction来实现，而关闭SurfaceFlinger服务的一个事务可以通过调用Surface类的静态成员函数closeTransaction来实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;3. 经过第1点和第2点的操作之后，一次系统UI的刷新过程就完成了，这时候就会将系统中的那些不会再显示的窗口的绘图表面销毁掉，并且将那些已经完成退出了的窗口令牌，即将我们在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文中所提到的WindowToken移除掉，以及将那些已经退出了的Activity窗口令牌，即将我们在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文中所提到的AppWindowToken也移除掉。这一步实际执行的是窗口清理操作。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;上述三个操作是WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLockedInner的实现关键所在，理解了这三个操作，基本也就可以理解WindowManagerService服务刷新系统UI的过程了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们继续分析WindowManagerService类的成员函数performLayoutLockedInner的实现，以便可以继续了解Activity窗口的大小计算过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;Step 7.&nbsp;WindowManagerService.performLayoutLockedInner</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    final WindowManagerPolicy mPolicy = PolicyManager.makeNewWindowManager();
    ......

    /**
     * Z-ordered (bottom-most first) list of all Window objects.
     */
    final ArrayList&lt;WindowState&gt; mWindows = new ArrayList&lt;WindowState&gt;();
    ......

    private final int performLayoutLockedInner() {
        ......

        final int dw = mDisplay.getWidth();
        final int dh = mDisplay.getHeight();

        final int N = mWindows.size();
        int i;

        ......

        mPolicy.beginLayoutLw(dw, dh);

        int seq = mLayoutSeq+1;
        if (seq &lt; 0) seq = 0;
        mLayoutSeq = seq;

        // First perform layout of any root windows (not attached
        // to another window).
        int topAttached = -1;
        for (i = N-1; i &gt;= 0; i--) {
            WindowState win = mWindows.get(i);
            ......

            final AppWindowToken atoken = win.mAppToken;
            final boolean gone = win.mViewVisibility == View.GONE
                    || !win.mRelayoutCalled
                    || win.mRootToken.hidden
                    || (atoken != null &amp;&amp; atoken.hiddenRequested)
                    || win.mAttachedHidden
                    || win.mExiting || win.mDestroying;
            ......

            if (!gone || !win.mHaveFrame) {
                if (!win.mLayoutAttached) {
                    mPolicy.layoutWindowLw(win, win.mAttrs, null);
                    win.mLayoutSeq = seq;
                    ......
                } else {
                    if (topAttached &lt; 0) topAttached = i;
                }
            }
        }
        ......

        for (i = topAttached; i &gt;= 0; i--) {
            WindowState win = mWindows.get(i);

            // If this view is GONE, then skip it -- keep the current
            // frame, and let the caller know so they can ignore it
            // if they want.  (We do the normal layout for INVISIBLE
            // windows, since that means &quot;perform layout as normal,
            // just don't display&quot;).
            if (win.mLayoutAttached) {
                ......

                if ((win.mViewVisibility != View.GONE &amp;&amp; win.mRelayoutCalled)
                        || !win.mHaveFrame) {
                    mPolicy.layoutWindowLw(win, win.mAttrs, win.mAttachedWindow);
                    win.mLayoutSeq = seq;
                    ......
                }
            }
        }

        ......

        return mPolicy.finishLayoutLw();
    }

    ......
}</pre><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在分析WindowManagerService类的成员函数performLayoutLockedInner的实现之前，我们首先介绍WindowManagerService类的两个成员变量mPolicy和mWindows：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. mPolicy指向的是一个窗口管理策略类，它是通过调用PolicyManager类的静态成员函数makeNewWindowManager来初始化的，在Phone平台中，它指向的是便是一个PhoneWindowManager对象，主要是用来制定窗口的大小计算策略。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2.&nbsp;mWindows指向的是一个类型为WindowState的ArrayList，它里面保存的就是系统中的所有窗口，这些窗口是按照Z轴位置从小到大的顺序保存在这个ArrayList中的，也就是说，第i个窗口位于第i-1个窗口的上面，其中，i &gt; 0。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 理解了这两个成员变量的含义之后，我们就分析WindowManagerService类的成员函数performLayoutLockedInner的执行过程，主要是分三个阶段：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 准备阶段：调用PhoneWindowManager类的成员函数beginLayoutLw来设置屏幕的大小。屏幕的大小可以通过调用WindowManagerService类的成员变量mDisplay所描述的一个Display对象的成员函数getWidth和getHeight来获得。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. 计算阶段：调用PhoneWindowManager类的成员函数layoutWindowLw来计算各个窗口的大小、内容区域边衬大小以及可见区域边衬大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. 结束阶段：调用PhoneWindowManager类的成员函数finishLayoutLw来执行一些清理工作。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 按照父子关系来划分，系统中的窗口可以分为父窗口和子窗口两种。如果一个WindowState对象的成员变量mLayoutAttached的值等于false，那么它所描述的窗口就可以作为一个父窗口，否则的话，它所描述的窗口就是一个子窗口。由于子窗口的大小计算是依赖于其父窗口的，因此，在计算各个窗口的大小的过程中，即在上述的第2阶段中，按照以下方式来进行：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. &nbsp;先计算父窗口的大小。一般来说，能够作为父窗口的，是那些Activity窗口。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，如果一个窗口是Activity窗口，那么用来描述它的一个WindowState对象的成员变量mAppToken就不等于null，并且指向的是一个AppWindowToken对象。这个AppWindowToken对象主要是用来描述一个Activity，即与ActivityManagerService服务中的一个ActivityRecord对象对应。一个Activity窗口只有在两种情况下才会被计算大小：第一种情况是窗口不是处于不可见状态的；第二种情况是窗口从来还没有被计算过大小，即用来描述该Activity窗口的WindowState对象的成员变量mHaveFrame的值等于false，这种情况一般发生在窗口刚刚被添加到WindowManagerService的过程中。一个Activity窗口的不可见状态由它本身的状态、它所在的窗口结构树状态以及它所属的Activity的状态有关，也就是说，如果一个Activity窗口本身是可见的，但是由于它的父窗口、它所在的窗口组的根窗口或者它所属的Activity是不可见的，那么该Activity窗口也是不可见的。一个Activity窗口的不可见状态由以下因素决定：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1). 它本身处于不可见状态，即对应的WindowState对象的成员变量mViewVisibility的值等于View.GONE；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2). 它本身处于正在退出的状态，即对应的WindowState对象的成员变量mExiting的值等于true；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3).&nbsp;它本身处于正在销毁的状态，即对应的WindowState对象的成员变量mDestroying的值等于true；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4). 它的父窗口处于不可见状态，即对应的WindowState对象的成员变量mAttachedHidden的值等于true；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5). 它所在窗口结构树中的根窗口处于不可见状态，即对应的WindowState对象的成员变量mRootToken所描述的一个WindowToken对象的成员变量hidden的值等于true；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 6). 它所属的Activity处于不可见状态，即对应的WindowState对象的成员变量mAppToken所描述的一个AppWindowToken对象的成员变量hiddenRequested的值等于true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 除了上述六个因素之外，如果一个Activity窗口没有被它所运行在的应用程序进程主动请求WindowManagerService服务对它进行布局，即对应的WindowState对象的成员变量mRelayoutCalled的值等于false，那么此时也是不需要计算Activity窗口的大小的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;一个Activity窗口的大小一旦确定是需要计算大小之后，PhoneWindowManager类的成员函数layoutWindowLw就被调用来计算它的大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;2. 接着计算子窗口的大小。前面在计算父窗口的大小过程中，会记录位于系统最上面的一个子窗口在mWindows所描述的一个ArrayList的位置topAttached，接下来就可以从这个位置开始向下计算每一个子窗口的大小。一个子窗口在以下两种情况下，才会被计算大小：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;1).&nbsp;它本身处于可见状态，即对应的WindowState对象的成员变量mViewVisibility的值不等于View.GONE，并且它所运行在的应用程序进程主动请求WindowManagerService服务对它进行布局，即对应的WindowState对象的成员变量mRelayoutCalled的值等于true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;2). 它从来还没有被计算过大小，即用来描述该子窗口的WindowState对象的成员变量mHaveFrame的值等于false，这种情况一般发生在子窗口刚刚被添加到WindowManagerService的过程中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就分别分析PhoneWindowManager类的成员函数beginLayoutLw、layoutWindowLw和finishLayoutLw的实现，以便可以了解Activity窗口的大小计算过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;Step 8.&nbsp;PhoneWindowManager.beginLayoutLw</p><p></p><pre name="code" class="java">public class PhoneWindowManager implements WindowManagerPolicy {
    ......

    WindowState mStatusBar = null;
    ......

    // The current size of the screen.
    int mW, mH;
    // During layout, the current screen borders with all outer decoration
    // (status bar, input method dock) accounted for.
    int mCurLeft, mCurTop, mCurRight, mCurBottom;
    // During layout, the frame in which content should be displayed
    // to the user, accounting for all screen decoration except for any
    // space they deem as available for other content.  This is usually
    // the same as mCur*, but may be larger if the screen decor has supplied
    // content insets.
    int mContentLeft, mContentTop, mContentRight, mContentBottom;
    // During layout, the current screen borders along with input method
    // windows are placed.
    int mDockLeft, mDockTop, mDockRight, mDockBottom;
    // During layout, the layer at which the doc window is placed.
    int mDockLayer;
    
    static final Rect mTmpParentFrame = new Rect();
    static final Rect mTmpDisplayFrame = new Rect();
    static final Rect mTmpContentFrame = new Rect();
    static final Rect mTmpVisibleFrame = new Rect();
    ......

    public void beginLayoutLw(int displayWidth, int displayHeight) {
        mW = displayWidth;
        mH = displayHeight;
        mDockLeft = mContentLeft = mCurLeft = 0;
        mDockTop = mContentTop = mCurTop = 0;
        mDockRight = mContentRight = mCurRight = displayWidth;
        mDockBottom = mContentBottom = mCurBottom = displayHeight;
        mDockLayer = 0x10000000;

        // decide where the status bar goes ahead of time
        if (mStatusBar != null) {
            final Rect pf = mTmpParentFrame;
            final Rect df = mTmpDisplayFrame;
            final Rect vf = mTmpVisibleFrame;
            pf.left = df.left = vf.left = 0;
            pf.top = df.top = vf.top = 0;
            pf.right = df.right = vf.right = displayWidth;
            pf.bottom = df.bottom = vf.bottom = displayHeight;

            mStatusBar.computeFrameLw(pf, df, vf, vf);
            if (mStatusBar.isVisibleLw()) {
                // If the status bar is hidden, we don't want to cause
                // windows behind it to scroll.
                mDockTop = mContentTop = mCurTop = mStatusBar.getFrameLw().bottom;
                ......
            }
        }
    }
 
    ......
}</pre><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在分析PhoneWindowManager类的成员函数beginLayoutLw的实现之前，我们首先介绍PhoneWindowManager类的五组成员变量。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第一组成员变量是mW和mH，它们分别用来描述当前这轮窗口大小计算过程的屏幕宽度和高度。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第二组成员变量是mCurLeft、mCurTop、mCurRight和mCurBottom，它们组成一个四元组（mCurLeft, mCurTop, mCurRight, mCurBottom），用来描述当前这轮窗口大小计算过程的屏幕装饰区，它对应于前面所提到的Activity窗口的可见区域边衬。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第三组成员变量是mContentLeft、mContentTop、mContentRight和mContentBottom，它们组成一个四元组（mContentLeft, mContentTop, mContentRight, mContentBottom），也是用来描述当前这轮窗口大小计算过程的屏幕装饰区，不过它对应的是前面所提到的Activity窗口的内容区域边衬。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第四组成员变量是mDockLeft、mDockTop、mDockRight、mDockBottom和mDockLayer，其中，前四个成员变量组成一个四元组（mDockLeft, mDockTop, mDockRight, mDockBottom），用来描述当前这轮窗口大小计算过程中的输入法窗口所占据的位置，后一个成员变量mDockLayer用来描述输入法窗品的Z轴位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第五组成员变量是mTmpParentFrame、mTmpDisplayFrame、mTmpContentFrame和mTmpVisibleFrame，它们是一组临时Rect区域，用来作为参数传递给具体的窗口计算大小的，避免每次都创建一组新的Rect区域来作来参数传递窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 除了这五组成员变量之外，PhoneWindowManager类还有一个成员变量mStatusBar，它的类型为WindowState，用来描述系统的状态栏。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 理解了这些成员变量的含义之后，PhoneWindowManager类的成员函数beginLayoutLw的实现就容易理解了，它主要做了以下两件事情：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 初始化前面所提到的四组成员变量，其中，mW和mH设置为参数displayWidth和displayHeight所指定的屏幕宽度和高度，并且使得（mCurLeft, mCurTop, mCurRight, mCurBottom）、（mContentLeft, mContentTop, mContentRight, mContentBottom）和（mDockLeft, mDockTop, mDockRight, mDockBottom）这三个区域的大小等于屏幕的大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. 计算状态栏的大小。状态栏的大小一经确定，并且它是可见的，那么就会修改成员变量mCurLeft、mContentLeft和mDockLeft的值为状态栏的所占据的区域的下边界位置，这样就可以将（mCurLeft, mCurTop, mCurRight, mCurBottom）、（mContentLeft, mContentTop, mContentRight, mContentBottom）和（mDockLeft, mDockTop, mDockRight, mDockBottom）这三个区域限制为剔除状态栏区域之后所得到的屏幕区域。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 还有另外一个地方需要注意的是，输入法窗口的Z轴被初始化为0x10000000，这个值是相当大的了，可以保证输入法窗口作为顶层窗口出现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 这一步执行完成之后，返回到前面的Step 7中，即WindowManagerService类的成员函数performLayoutLockedInner，接下来就会调用PhoneWindowManager类的成员函数layoutWindowLw来计算系统中各个可见窗口的大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 9.&nbsp;PhoneWindowManager.layoutWindowLw</p><p></p><pre name="code" class="java">public class PhoneWindowManager implements WindowManagerPolicy {
    ......

    public void layoutWindowLw(WindowState win, WindowManager.LayoutParams attrs,
            WindowState attached) {
        // we've already done the status bar
        if (win == mStatusBar) {
            return;
        }
        ......

        final int fl = attrs.flags;
        final int sim = attrs.softInputMode;

        final Rect pf = mTmpParentFrame;
        final Rect df = mTmpDisplayFrame;
        final Rect cf = mTmpContentFrame;
        final Rect vf = mTmpVisibleFrame;

        if (attrs.type == TYPE_INPUT_METHOD) {
            pf.left = df.left = cf.left = vf.left = mDockLeft;
            pf.top = df.top = cf.top = vf.top = mDockTop;
            pf.right = df.right = cf.right = vf.right = mDockRight;
            pf.bottom = df.bottom = cf.bottom = vf.bottom = mDockBottom;
            // IM dock windows always go to the bottom of the screen.
            attrs.gravity = Gravity.BOTTOM;
            mDockLayer = win.getSurfaceLayer();
        } else {
            if ((fl &amp;
                    (FLAG_LAYOUT_IN_SCREEN | FLAG_FULLSCREEN | FLAG_LAYOUT_INSET_DECOR))
                    == (FLAG_LAYOUT_IN_SCREEN | FLAG_LAYOUT_INSET_DECOR)) {
                // This is the case for a normal activity window: we want it
                // to cover all of the screen space, and it can take care of
                // moving its contents to account for screen decorations that
                // intrude into that space.
                if (attached != null) {
                    // If this window is attached to another, our display
                    // frame is the same as the one we are attached to.
                    setAttachedWindowFrames(win, fl, sim, attached, true, pf, df, cf, vf);
                } else {
                    pf.left = df.left = 0;
                    pf.top = df.top = 0;
                    pf.right = df.right = mW;
                    pf.bottom = df.bottom = mH;
                    if ((sim &amp; SOFT_INPUT_MASK_ADJUST) != SOFT_INPUT_ADJUST_RESIZE) {
                        cf.left = mDockLeft;
                        cf.top = mDockTop;
                        cf.right = mDockRight;
                        cf.bottom = mDockBottom;
                    } else {
                        cf.left = mContentLeft;
                        cf.top = mContentTop;
                        cf.right = mContentRight;
                        cf.bottom = mContentBottom;
                    }
                    vf.left = mCurLeft;
                    vf.top = mCurTop;
                    vf.right = mCurRight;
                    vf.bottom = mCurBottom;
                }
            }

            ......
        }

        win.computeFrameLw(pf, df, cf, vf);

        // Dock windows carve out the bottom of the screen, so normal windows
        // can't appear underneath them.
        if (attrs.type == TYPE_INPUT_METHOD &amp;&amp; !win.getGivenInsetsPendingLw()) {
            int top = win.getContentFrameLw().top;
            top += win.getGivenContentInsetsLw().top;
            if (mContentBottom &gt; top) {
                mContentBottom = top;
            }
            top = win.getVisibleFrameLw().top;
            top += win.getGivenVisibleInsetsLw().top;
            if (mCurBottom &gt; top) {
                mCurBottom = top;
            }
            ......
        }
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第一个参数win描述的是当前要计算大小的窗口，第二个参数attrs描述的是窗口win的布局参数，第三个参数attached描述的是窗口win的父窗口，如果它的值等于null，就表示窗口win没有父窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; PhoneWindowManager类的成员函数layoutWindowLw会根据窗口win的是子窗口还是全屏窗口及其软键盘显示模式来决定它的大小如何计算。这里我们只关注输入法窗口和非全屏的Activity窗口的大小计算方式，其它类型的窗口大小计算方式是差不多的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 从前面的Step 8可以知道，系统的状态栏大小已经计算过了，因此，PhoneWindowManager类的成员函数layoutWindowLw如果发现参数win描述的正好是状态栏的话，它就什么也不做就返回了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在计算一个窗口的大小的时候，我们需要四个参数。第一个参数是父窗口的大小pf，第二个参数是屏幕的大小df，第三个参数是内容区域边衬大小cf，第四个参数是可见区域边衬大小vf。&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果参数win描述的是输入法窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于TYPE_INPUT_METHOD，那么上述四个用来计算窗口大小的区域pf、df、cf和vf就等于PhoneWindowManager类的成员变量mDockLeft、mDockTop、mDockRight和mDockBottom所组成的区域的大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果参数win描述的是一个非全屏的Activity窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量flags的FLAG_LAYOUT_IN_SCREEN位和FLAG_LAYOUT_INSET_DECOR位等于1，那么PhoneWindowManager类的成员函数layoutWindowLw就会继续检查参数attached的值是否不等于null。如果不等于null的话，那么就说明参数win所描述的一个非全屏的Activity窗口附加在其它窗口上，即它具有一个父窗口，这时候就会调用另外一个成员函数setAttachedWindowFrames来计算它的大小。&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 接下来我们就只关注参数win描述的是一个非全屏的、并且没有附加到其它窗口的Activity窗口的大小计算过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 首先，父窗口大小pf和屏幕大小df都会被设置为整个屏幕区域的大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 其次，可见区域边衬大小vf被设置为PhoneWindowManager类的成员变量mCurLeft、mCurTop、mCurRight和mCurBottom所组成的区域的大小。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第三，内容区域边衬大小cf的计算相对复杂一些，需要考虑窗口win的软键盘显示模式sim的值。如果变量sim的SOFT_INPUT_ADJUST_RESIZE位等于1，那么就意味着窗口win在出向输入法窗口的时候，它的内容要重新进行排布，避免被输入法窗口挡住，因此，这时候窗口win的内容区域大小就会等于PhoneWindowManager类的成员变量mContentLeft、mContentTop、mContentRight和mContentBottom所组成的区域的大小。另一方面，如果变量sim的SOFT_INPUT_ADJUST_RESIZE位等于0，那么就意味着窗口win在出向输入法窗口的时候，它的内容不需要重新进行排布，这时候它的内容区域大小就会等于PhoneWindowManager类的成员变量mDockLeft、mDockTop、mDockRight和mDockBottom所组成的区域的大小。注意，PhoneWindowManager类的成员变量mDockLeft、mDockTop、mDockRight和mDockBottom所组成的区域的大小并不是等于输入法窗口的大小的，而是包含了输入法窗口所占据的区域的大小，这就意味着输入法窗口与窗口win会有重叠的部分，或者说输入法窗口覆盖了窗口win的一部分。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 得到了用来计算窗口win四个参数pf、 df、cf和vf之后，就可以调用参数win所描述的一个WindowState对象的成员函数computeFrameLw来计算窗口win的具体大小了。计算的结果便得到了窗口win的大小，以及它的内容区域边衬大小和可见区域边衬大小。注意，窗口经过计算后得到的内容区域边衬大小和可见区域边衬大小并不一定是等于参数cf和vf所指定的大小的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 计算完成窗口win的大小之后，PhoneWindowManager类的成员函数layoutWindowLw还会检查窗口win是否是一个输入法窗口，并且它是否指定了额外的内容区域边衬和可见区域边衬。如果这两个条件都成立的话，那么就需要相应地调整PhoneWindowManager类的成员变量mContentBottom和mCurBottom的值，以便使得PhoneWindowManager类的成员变量是mContentLeft、mContentTop、mContentRight和mContentBottom所围成的内容区域和成员变量mCurLeft、mCurTop、mCurRight和mCurBottom所围成的可见区域不会覆盖到输入法窗口额外指定的内容区域边衬和可见区域边衬。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 接下来，我们就继续分析WindowState类的成员函数computeFrameLw的实现，以便可以了解Activity窗口的大小计算的具体过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 10.&nbsp;WindowState.computeFrameLw</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final class WindowState implements WindowManagerPolicy.WindowState {
        ......

        boolean mHaveFrame;
        ......

        // &quot;Real&quot; frame that the application sees.
        final Rect mFrame = new Rect();
        ......

        final Rect mContainingFrame = new Rect();
        final Rect mDisplayFrame = new Rect();
        final Rect mContentFrame = new Rect();
        final Rect mVisibleFrame = new Rect();


        public void computeFrameLw(Rect pf, Rect df, Rect cf, Rect vf) {
            mHaveFrame = true;

            final Rect container = mContainingFrame;
            container.set(pf);

            final Rect display = mDisplayFrame;
            display.set(df);

            if ((mAttrs.flags &amp; FLAG_COMPATIBLE_WINDOW) != 0) {
                container.intersect(mCompatibleScreenFrame);
                if ((mAttrs.flags &amp; FLAG_LAYOUT_NO_LIMITS) == 0) {
                    display.intersect(mCompatibleScreenFrame);
                }
            }

            final int pw = container.right - container.left;
            final int ph = container.bottom - container.top;

            int w,h;
            if ((mAttrs.flags &amp; mAttrs.FLAG_SCALED) != 0) {
                w = mAttrs.width &lt; 0 ? pw : mAttrs.width;
                h = mAttrs.height&lt; 0 ? ph : mAttrs.height;
            } else {
                w = mAttrs.width == mAttrs.MATCH_PARENT ? pw : mRequestedWidth;
                h = mAttrs.height== mAttrs.MATCH_PARENT ? ph : mRequestedHeight;
            }

            final Rect content = mContentFrame;
            content.set(cf);

            final Rect visible = mVisibleFrame;
            visible.set(vf);

            final Rect frame = mFrame;
            final int fw = frame.width();
            final int fh = frame.height();

            ......

            Gravity.apply(mAttrs.gravity, w, h, container,
                    (int) (mAttrs.x + mAttrs.horizontalMargin * pw),
                    (int) (mAttrs.y + mAttrs.verticalMargin * ph), frame);

            ......

            // Now make sure the window fits in the overall display.
            Gravity.applyDisplay(mAttrs.gravity, df, frame);

            // Make sure the content and visible frames are inside of the
            // final window frame.
            if (content.left &lt; frame.left) content.left = frame.left;
            if (content.top &lt; frame.top) content.top = frame.top;
            if (content.right &gt; frame.right) content.right = frame.right;
            if (content.bottom &gt; frame.bottom) content.bottom = frame.bottom;
            if (visible.left &lt; frame.left) visible.left = frame.left;
            if (visible.top &lt; frame.top) visible.top = frame.top;
            if (visible.right &gt; frame.right) visible.right = frame.right;
            if (visible.bottom &gt; frame.bottom) visible.bottom = frame.bottom;

            final Rect contentInsets = mContentInsets;
            contentInsets.left = content.left-frame.left;
            contentInsets.top = content.top-frame.top;
            contentInsets.right = frame.right-content.right;
            contentInsets.bottom = frame.bottom-content.bottom;

            final Rect visibleInsets = mVisibleInsets;
            visibleInsets.left = visible.left-frame.left;
            visibleInsets.top = visible.top-frame.top;
            visibleInsets.right = frame.right-visible.right;
            visibleInsets.bottom = frame.bottom-visible.bottom;

            if (mIsWallpaper &amp;&amp; (fw != frame.width() || fh != frame.height())) {
                updateWallpaperOffsetLocked(this, mDisplay.getWidth(),
                        mDisplay.getHeight(), false);
            }

            ......
        }

        ......
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<br /><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowState类的成员变量mHaveFrame用来描述一个窗口的大小是否计算过了。当WindowState类的成员函数computeFrameLw被调用的时候，就说明一个相应的窗口的大小得到计算了，因此，WindowState类的成员函数computeFrameLw一开始就会将成员变量mHaveFrame的值设置为true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 回忆一下，在前面的Step 9中提到，参数pf描述的是父窗口的大小，参数df描述的是屏幕的大小，参数cf描述的内容区域大小，参数vf描述的是可见区域大小，接下来我们就分析WindowState类的成员函数computeFrameLw是如何利用这些参数来计算一个窗口的大小的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowState类的成员变量mContainingFrame和mDisplayFrame描述的是当前正在处理的窗口的父窗口和屏幕的大小，它们刚好就分别等于参数pf和df的大小，因此，函数就直接将参数pf和df的值分别保存在WindowState类的成员变量mContainingFrame和mDisplayFrame中。如果当前正在处理的窗口运行在兼容模式，即WindowState类的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量flags的FLAG_COMPATIBLE_WINDOW位等于1，那么就需要将其父窗口的大小限制mContainingFrame在兼容模式下的屏幕区域中。兼容模式下的屏幕区域保存在WindowManagerService类的成员变量mCompatibleScreenFrame中，将父窗口的大小mContainingFrame与它执行一个相交操作，就可以将父窗品的大小限制兼容模式下的屏幕区域中。在当前正在处理的窗口运行在兼容模式的情况下，如果它的大小被限制在了兼容模式下的屏幕区域之中，即WindowState类的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量flags的FLAG_LAYOUT_NO_LIMITS位等于0，那么同样需要将屏幕大小mDisplayFrame限制在兼容模式下的屏幕区域mCompatibleScreenFrame，这也是通过执行一个相交操作来完成的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowState类的成员变量mContentFrame和mVisibleFrame描述的是当前正在处理的窗口的内容区域和可见区域大小，它们刚好就分别等于参数cf和vf的大小，因此，函数就直接将参数cf和vf的值分别保存在WindowState类的成员变量mContainingFrame和mDisplayFrame中。现在，就剩下窗口的大小还没有计算。一旦窗口大小确定下来之后，就可以继续计算窗口的内容区域边衬和可见区域边衬大小了。接下来我们就继续分析窗口大小的计算过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;WindowState类的成员变量mFrame描述的就是当前正在处理的窗品的大小，我们的目标就是计算它的值。一个窗口的大小是受以下因素影响的：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1. 是否指定了缩放因子。如果一个窗口的大小被指定了缩放因子，即WindowState类的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量flags的FLAG_SCALED位等于1，那么该窗口的大小就是在它的布局参数中指定的，即是由WindowState类的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量width和height所指定的。但是，如果在布局参数中指定的窗口宽度或者高度小于0，那么就会使用其父窗口的大小来作为当前窗口的大小。当前窗口的父窗口的宽度和高度分别保存在变量pw和ph中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2. 是否指定了等于父窗口的大小。如果一个窗口的大小被指定为其父窗口的大小，即WindowState类的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量width和height的值等于mAttrs.MATCH_PARENT，那么该窗口的大小就会等于其父窗口的大小，即等于变量pw和ph所描述的宽度和高度。另一方面，如果一个窗口的大小没有指定为其父窗口的大小的话，那么它的大小就会等于应用程序进程请求WindowManagerService所设置的大小，即等于WindowState类的成员变量mRequestedWidth和mRequestedHeight所描述的宽度和高度。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;经过上述2个操作之后，我们就初步地得到了窗口的宽度w和高度h，但是，它们还不是最终的窗口大小，还要进一步地根据窗口的Gravity属性来作调整，这个调整分两步进行：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 根据窗口的Gravity值，以及位置、初始大小和父窗口大小，来计算窗口的大小，并且保存在变量frame中，即保存在WindowState类的成员变量mFrame中，这是通过调用Gravity类的静态成员函数apply来实现的。其中，窗口的初始大小保存在变量w和h中，父窗口大小保存在变量container中，即WindowState类的成员变量mContainingFrame中，位置保存在WindowState类的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量x和y中。注意，如果窗口指定了相对父窗口的margin值，那么还需要相应的调整其位置值，即要在指定的位置值的基础上，再加上相对父窗口的margin值。一个窗口相对父窗口的margion是通过一个百分比来表示的，用这个百分比乘以父窗口的大小就可以得到绝对值。这个百分比又分为在水平方向和垂直方向两个值，分别保存在WindowState类的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量horizontalMargin和verticalMargin中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. 前面计算得到的窗口大小没有考虑在屏幕的大小，因此，接下来还需要继续调用Gravity类的静态成员函数applyDisplay来将前面计算得到的窗口大小限制在屏幕区域df中，即限制在WindowState类的成员变量mDisplayFrame所描述的区域中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 经过上述2个操作之后，窗口的最终大小就保存在变量frame中了，即WindowState类的成员变量mFrame中，接下来就可以计算窗品的内容区域边衬和可见区域边衬大小了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;内容区域边衬和可见区域边衬大小的计算很简单的，只要将窗口的大小frame，即WindowState类的成员变量mFrame所描述的区域，分别减去变量content和visible，即WindowState类的成员变量mContentFrame和mVisibleFrame所描述的区域，就可以得到窗口的内容区域边衬和可见区域边衬大小，它们分别保存在WindowState类的成员变量mContentInsets和mVisibleInsets中。注意，在计算窗口的内容区域边衬和可见区域边衬大小之前，首先要保证窗口的内容区域和可见区域包含在整个窗口区域中，这一点是由中间的8个if语句来保证的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 窗口上一次的大小保存在变量fw和fh中。如果当前正在处理的窗口是一个壁纸窗口，即WindowState类的成员变量mIsWallpaper的值等于true，并且该窗口的大小发生了变化，即变量fw和fh的所描述的窗口大小不等于变量frame描述的窗口大小，那么就需要调用WindowManagerService类的成员函数updateWallpaperOffsetLocked来更新壁纸的位置。在后面的文章中，我们再详细描述系统的壁纸窗口的位置是如何计算的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 这一步执行完成之后，一个窗口的大小就计算完成了。从计算的过程可以知道，整个窗口大小保存在WindowState类的成员变量mFrame中，而窗品的内容区域边衬大小和可见区域边衬大小分别保在WindowState类的成员变量mContentInsets和mVisibleInsets中。这些值最终会通过前面的Step 4返回给应用程序进程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 返回到前面的Step 7中，即WindowManagerService类的成员函数performLayoutLockedInner，接下来就会调用PhoneWindowManager类的成员函数finishLayoutLw来结束当前这轮窗口大小的计算工作。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 11.&nbsp;PhoneWindowManager.finishLayoutLw</p><p></p><pre name="code" class="java">public class PhoneWindowManager implements WindowManagerPolicy {
    ......

    public int finishLayoutLw() {
        return 0;
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;PhoneWindowManager类的成员函数finishLayoutLw是设计来结束一轮窗口大小的计算过程中，不过目前它什么也不做，只是一个空实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 至此，我们就分析完成Activity窗口的大小计算过程了。从这个计算过程中，我们就可以知道一个Activity窗口除了有一个整体大小之外，还有一个内容区域边衬大小和一个可见区域边衬大小。此外，我们还知道，一个Activity窗口的内容区域边衬大小和可见区域边衬大小是可能会受到与其所关联的输入法窗口的影响的，因为输入法窗口会叠加在该Activity窗口上面，这就涉及到了系统中的窗口的组织方式。在接下来的一篇文章中，我们就将继续分析WindowManagerService服务是如何组织系统中的窗口的。敬请关注！</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2013-1-14 0:56:58 <a href="http://blog.csdn.net/luoshengyang/article/details/8479101">原文链接</a>
            </div>
            <div>
            阅读：3760 评论：25 <a href="http://blog.csdn.net/luoshengyang/article/details/8479101#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android窗口管理服务WindowManagerService对窗口的组织方式分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8498908</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8498908</guid>
        <author>Luoshengyang</author>
        <pubDate>2013-1-21 1:01:38</pubDate>
        <description><![CDATA[
            <p>&nbsp; &nbsp; &nbsp; &nbsp; 我们知道，在Android系统中，Activity是以堆栈的形式组织在ActivityManagerService服务中的。与Activity类似，Android系统中的窗口也是以堆栈的形式组织在WindowManagerService服务中的，其中，Z轴位置较低的窗口位于Z轴位置较高的窗口的下面。在本文中，我们就详细分析WindowManagerService服务是如何以堆栈的形式来组织窗口的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 从前面<a href="http://blog.csdn.net/luoshengyang/article/details/6689748">Android应用程序启动过程源代码分析</a>一文可以知道，应用程序进程中的每一个Activity组件在Activity管理服务ActivityManagerService中都对应有一个ActivityRecord对象。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文又可以知道，Activity管理服务ActivityManagerService中每一个ActivityRecord对象在Window管理服务WindowManagerService中都对应有一个AppWindowToken对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 此外，在输入法管理服务InputMethodManagerService中，每一个输入法窗口都对应有一个Binder对象，这个Binder对象在Window管理服务WindowManagerService又对应有一个WindowToken对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 与输入法窗口类似，在壁纸管理服务WallpaperManagerService中，每一个壁纸窗口都对应有一个Binder对象，这个Binder对象在Window管理服务WindowManagerService也对应有一个WindowToken对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在Window管理服务WindowManagerService中，无论是AppWindowToken对象，还是WindowToken对象，它们都是用来描述一组有着相同令牌的窗口的，每一个窗口都是通过一个WindowState对象来描述的。例如，一个Activity组件窗口可能有一个启动窗口（Starting Window），还有若干个子窗口，那么这些窗口就会组成一组，并且都是以Activity组件在Window管理服务WindowManagerService中所对应的AppWindowToken对象为令牌的。从抽象的角度来看，就是在Window管理服务WindowManagerService中，每一个令牌（AppWindowToken或者WindowToken）都是用来描述一组窗口（WindowState）的，并且每一个窗口的子窗口也是与它同属于一个组，即都有着相同的令牌。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 上述的窗口组织方式如图1所示：</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/15/1358182870_5117.jpg" alt="" /><br /></p><p style="text-align: center;">图1 窗口在WindowManagerService服务中的组织方式</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 其中，Activity Stack是在ActivityManagerService服务中创建的，Token List和Window Stack是在WindowManagerService中创建的，而Binder for IM和Binder for WP分别是在InputMethodManagerService服务和WallpaperManagerService服务中创建的，用来描述一个输入法窗口和一个壁纸窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 图1中的对象的对应关系如下所示：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;1. ActivityRecord-J对应于AppWindowToken-J，后者描述的一组窗口是{WindowState-A,&nbsp;WindowState-B,&nbsp;WindowState-B-1}，其中，&nbsp;WindowState-B-1是WindowState-B的子窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp;ActivityRecord-K对应于AppWindowToken-K，后者描述的一组窗口是{WindowState-C,&nbsp;WindowState-C-1,&nbsp;WindowState-D,&nbsp;WindowState-D-1}，其中，&nbsp;WindowState-C-1是WindowState-C的子窗口，WindowState-D-1是WindowState-D的子窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;3.&nbsp;ActivityRecord-N对应于AppWindowToken-N，后者描述的一组窗口是{WindowState-E}，其中，&nbsp;WindowState-E是系统当前激活的Activity窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;4. Binder for IM对应于WindowToken-I，后者描述的一组窗口是{WindowState-I}，其中，&nbsp;WindowState-I是WindowState-E的输入法窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;5.&nbsp;Binder for WP对应于WindowToken-W，后者描述的一组窗口是{WindowState-W}，其中，&nbsp;WindowState-W是WindowState-E的壁纸窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;从图1还可以知道，Window Stack中的WindowState是按照它们所描述的窗口的Z轴位置从低到高排列的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;以上就是WindowManagerService服务组织系统中的窗口的抽象模型，接下来我们将分析AppWindowToken、WindowToken和WindowState的一些增加、移动和删除等操作，以便可以对这个抽象模型有一个更深刻的认识。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;1. &nbsp;增加AppWindowToken</p><p>&nbsp; &nbsp; &nbsp; &nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，一个Activity组件在启动的过程中，ActivityManagerService服务会调用调用WindowManagerService类的成员函数addAppToken来为它增加一个AppWindowToken，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  
  
    /** 
     * Mapping from a token IBinder to a WindowToken object. 
     */  
    final HashMap&lt;IBinder, WindowToken&gt; mTokenMap =  
            new HashMap&lt;IBinder, WindowToken&gt;();  
  
    /** 
     * The same tokens as mTokenMap, stored in a list for efficient iteration 
     * over them. 
     */  
    final ArrayList&lt;WindowToken&gt; mTokenList = new ArrayList&lt;WindowToken&gt;();  
    ......  
  
    /** 
     * Z-ordered (bottom-most first) list of all application tokens, for 
     * controlling the ordering of windows in different applications.  This 
     * contains WindowToken objects. 
     */  
    final ArrayList&lt;AppWindowToken&gt; mAppTokens = new ArrayList&lt;AppWindowToken&gt;();  
    ......  
  
    public void addAppToken(int addPos, IApplicationToken token,  
            int groupId, int requestedOrientation, boolean fullscreen) {  
        ......  
  
        synchronized(mWindowMap) {  
            AppWindowToken wtoken = findAppWindowToken(token.asBinder());  
            if (wtoken != null) {  
                ......  
                return;  
            }  
            wtoken = new AppWindowToken(token);  
            ......  
            mAppTokens.add(addPos, wtoken);  
            ......  
            mTokenMap.put(token.asBinder(), wtoken);  
            mTokenList.add(wtoken);  
  
            ...... 
        }  
    }  
  
    ......  
}  </pre>&nbsp; &nbsp; &nbsp; &nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService类有三个成员变量mTokenMap、mTokenList和mAppTokens，它们都是用来描述系统中的窗口的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;成员变量mTokenMap指向的是一个HashMap，它里面保存的是一系列的WindowToken对象，每一个WindowToken对象都是用来描述一个窗口的，并且是以描述这些窗口的一个Binder对象的IBinder接口为键值的。例如，对于Activity组件类型的窗口来说，它们分别是以用来描述它们的一个ActivityRecord对象的IBinder接口保存在成员变量mTokenMap所指向的一个HashMap中的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;成员变量mTokenList指向的是一个ArrayList，它里面保存的也是一系列WindowToken对象，这些WindowToken对象与保存在成员变量mTokenMap所指向的一个HashMap中的WindowToken对象是一样的。成员变量mTokenMap和成员变量mTokenList的区别就在于，前者在给定一个IBinder接口的情况下，可以迅速指出是否存在一个对应的WindowToken对象，而后者可以迅速遍历WindowManagerService服务中的WindowToken对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;成员变量mAppTokens指向的也是一个ArrayList，不过它里面保存的是一系列AppWindowToken对象，每一个AppWindowToken对象都是用来描述一个Activity组件窗口的，而这些AppWindowToken对象是以它们描述的窗口的Z轴坐标由小到大保存在这个ArrayList中的，这样我们就可以通过这个ArrayList来从上到下或者从下到上地遍历系统中的所有Activity组件窗口。由于这些AppWindowToken对象所描述的Activity组件窗口也是一个窗口，并且AppWindowToken类是从WindowToken继承下来的，因此，这些AppWindowToken对象还会同时被保存在成员变量mTokenMap所指向的一个HashMap和成员变量mTokenList所指向的一个ArrayList中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;理解了WindowManagerService类的这三个成员变量的含义之后，它的成员函数addAppToken的实现就好理解了，其中，参数token指向的便是用来描述正在启动的Activity组件所对应的一个ActivityRecord对象，而参数addPos用来描述该Activity组件在堆栈中的位置，这个位置同时也是接下来要创建的AppWindowToken对象在WindowManagerService类的mTokenList所描述的一个ArrayList中的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService类的成员函数addAppToken首先调用另外一个成员函数findAppWindowToken来在成员变量mTokenMap所描述的一个HashMap检查是否已经存在一个AppWindowToken。如果已经存在的话，那么WindowManagerService类的成员函数addAppToken就什么也不做就返回了，否则的话，就会使用参数token来创建一个AppWindowToken对象，并且会将该AppWindowToken对象分别保存在WindowManagerService类的成员变量mTokenMap、mTokenList和mAppTokens中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;2. 删除AppWindowToken</p><p>&nbsp; &nbsp; &nbsp; &nbsp;删除AppWindowToken是通过调用WindowManagerService类的成员函数removeAppTokensLocked来实现的，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  
  
    private void removeAppTokensLocked(List&lt;IBinder&gt; tokens) {
        // XXX This should be done more efficiently!
        // (take advantage of the fact that both lists should be
        // ordered in the same way.)
        int N = tokens.size();
        for (int i=0; i&lt;N; i++) {
            IBinder token = tokens.get(i);
            final AppWindowToken wtoken = findAppWindowToken(token);
            if (!mAppTokens.remove(wtoken)) {
                ......
                i--;
                N--;
            }
        }
    }
 
    ......  
}  </pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数removeAppTokensLocked可以同时删除一组AppWindowToken对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 参数tokens所描述的是一个IBinder接口列表，与这些IBinder接口所对应的AppWindowToken对象就是接下来要删除的。WindowManagerService类的成员函数removeAppTokensLocked通过一个for循环来依次调用另外一个成员函数findAppWindowToken，以便可以找到保存在列表tokens中的每一个IBinder接口所对应的AppWindowToken对象，然后将该AppWindowToken对象从WindowManagerService类的成员变量mAppTokens所描述的一个ArrayList中删除。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注意，WindowManagerService类的成员函数removeAppTokensLocked是在内部使用的，它只是把一个AppWindowToken对象从成员变量mAppTokens中删除，而没有从另外两个成员变量mTokenMap和mTokenList中删除。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. 移动AppWindowToken至指定位置</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 移动AppWindowToken至指定位置是通过调用WindowManagerService类的成员函数moveAppToken来实现的，如下所示：<br /></p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  
  
    public void moveAppToken(int index, IBinder token) {
        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                &quot;moveAppToken()&quot;)) {
            throw new SecurityException(&quot;Requires MANAGE_APP_TOKENS permission&quot;);
        }

        synchronized(mWindowMap) {
            ......
            final AppWindowToken wtoken = findAppWindowToken(token);
            if (wtoken == null || !mAppTokens.remove(wtoken)) {
                ......
                return;
            }
            mAppTokens.add(index, wtoken);
            ......

            final long origId = Binder.clearCallingIdentity();
            ......
            if (tmpRemoveAppWindowsLocked(wtoken)) {
                ......
                reAddAppWindowsLocked(findWindowOffsetLocked(index), wtoken);
                ......
                updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES);
                mLayoutNeeded = true;
                performLayoutAndPlaceSurfacesLocked();
            }
            Binder.restoreCallingIdentity(origId);
        }
    }
 
    ......  
}  </pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<br /><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 参数token描述的是要移动的AppWindowToken对象所对应的一个IBinder接口，而参数index描述的是该AppWindowToken对象要移动到的位置。注意，移动一个AppWindowToken对象到指定的位置是需要android.Manifest.permission.MANAGE_APP_TOKENS权限的。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数moveAppToken首先找到与参数token所对应的AppWindowToken对象，并且将该AppWindowToken对象从WindowManagerService类的成员变量mAppTokens所描述的一个ArrayList中移除，这样做的目的是为了接下来可以将该AppWindowToken对象移动至该ArrayList中的指定位置上，即参数index所描述的位置上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注意，上述操作只是将参数token所对应的AppWindowToken对象移动到了WindowManagerService类的成员变量mAppTokens所描述的一个ArrayList的指定位置上，接下来还需要同时将与该AppWindowToken对象所对应的WindowState对象移动至WindowManagerService服务内部的一个WindowState堆栈合适位置上去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 移动对应的WindowState对象的操作同样也是分两步执行的：第一步先调用WindowManagerService类的成员函数tmpRemoveAppWindowsLocked来将这些WindowState对象从原来的WindowState堆栈位置移除；第二步再调用WindowManagerService类的成员函数reAddAppWindowsLocked来将这些WindowState对象插入到WindowState堆栈的合适位置去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 对应的WindowState对象被移动到的合适位置是通过调用WindowManagerService类的成员函数findWindowOffsetLocked来获得的，它的实现如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  

    /**
     * Z-ordered (bottom-most first) list of all Window objects.
     */
    final ArrayList&lt;WindowState&gt; mWindows = new ArrayList&lt;WindowState&gt;();
    ......
  
    private int findWindowOffsetLocked(int tokenPos) {
        final int NW = mWindows.size();

        if (tokenPos &gt;= mAppTokens.size()) {
            int i = NW;
            while (i &gt; 0) {
                i--;
                WindowState win = mWindows.get(i);
                if (win.getAppToken() != null) {
                    return i+1;
                }
            }
        }

        while (tokenPos &gt; 0) {
            // Find the first app token below the new position that has
            // a window displayed.
            final AppWindowToken wtoken = mAppTokens.get(tokenPos-1);
            ......
            if (wtoken.sendingToBottom) {
                ......
                tokenPos--;
                continue;
            }
            int i = wtoken.windows.size();
            while (i &gt; 0) {
                i--;
                WindowState win = wtoken.windows.get(i);
                int j = win.mChildWindows.size();
                while (j &gt; 0) {
                    j--;
                    WindowState cwin = win.mChildWindows.get(j);
                    if (cwin.mSubLayer &gt;= 0) {
                        for (int pos=NW-1; pos&gt;=0; pos--) {
                            if (mWindows.get(pos) == cwin) {
                                ......
                                return pos+1;
                            }
                        }
                    }
                }
                for (int pos=NW-1; pos&gt;=0; pos--) {
                    if (mWindows.get(pos) == win) {
                        ......
                        return pos+1;
                    }
                }
            }
            tokenPos--;
        }

        return 0;
    }
 
    ......  
}  </pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<br /><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 参数tokenPos描述的是一个AppWindowToken对象在WindowManagerService类的成员变量mAppTokens所描述的一个ArrayList的位置，WindowManagerService类的成员函数findWindowOffsetLocked的目标就要找到与该AppWindowToken对象所对应的WindowState对象在WindowManagerService服务内部的一个WindowState堆栈的起始偏移位置。有了这个起始偏移位置之后，我们就可以将对应的所有WindowState对象有序地插入到该WindowState堆栈中去。WindowManagerService服务内部的WindowState堆栈是通过WindowManagerService类的成员变量mWindows来描述的。接下来我们就分两种情况来分析这个起始偏移位置的计算过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第一种情况是参数tokenPos的值大于WindowManagerService类的成员变量mAppTokens所描述的一个ArrayList的大小。这是一种异常情况，一般来说，参数tokenPos是指向mAppTokens列表的某一个位置的，不过这时候意味着它所描述的AppWindowToken对象的Z轴位置要大于mAppTokens列表的最上面的一个AppWindowToken对象的Z轴位置的。这也就是说，与参数tokenPos所描述的AppWindowToken对象所对应的WindowState对象的要位于与mAppTokens列表的最上面的一个AppWindowToken对象所对应的任一个WindoState对象的上面。因此，就需要找到与mAppTokens列表的最上面的一个AppWindowToken对象所对应的Z轴位置最大的一个WindoState对象在WindowState堆栈中的位置i，然后就可以知道与参数tokenPos所描述的AppWindowToken对象所对应的WindowState对象在WindowState堆栈的起始偏移位置为i+1。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如何找到mAppTokens列表的最上面的一个AppWindowToken对象所对应的Z轴位置最大的一个WindoState对象在WindowState堆栈中的位置i呢？从图1可以可得到一个结论：WindowManagerService服务内部中的所有WindowState对象都是按照Z轴从位置从小到大排列在WindowState堆栈中的，并且在mAppTokens列表中，位于上面的一个AppWindowToken对象所对应的那些WindowState对象的Z轴位置是一定大于位于下面的一个AppWindowToken对象所对应的那些WindowState对象的Z轴位置的。因此，我们只要从WindowState堆栈的顶端开始往下遍历，找到这样的一个WindowState对象，它是属于一个AppWindowToken对象的，即它的成员函数getAppToken的返回值不等于null，那么它在WindowState堆栈中的位置就是我们要找到的位置i。有了这个位置i之后，将它的值加上1，就可以得到参数t所描述的AppWindowToken对象所对应的WindowState对象在WindowState堆栈的起始偏移位置了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第二种情况是参数tokenPos的值小于WindowManagerService类的成员变量mAppTokens所描述的一个ArrayList的大小。根据前面得到的推论，我们只要在mAppTokens列表中找到一个AppWindowToken对象，它满足以下三个条件：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; A. 它在mAppTokens列表中的位置小于tokenPos；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; B. 它在WindowState堆栈中对应有WindowState对象；</p><p>&nbsp; &nbsp; &nbsp; &nbsp; C. 它不是将要置于WindowState堆栈的底部。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果一个AppWindowToken对象在WindowState堆栈中对应有WindowState对象，那么这些WindowState对象也会同时按照Z轴从小到大的顺序保存它的成员变量windows所描述的一个ArrayList中，这意味着如果一个AppWindowToken对象满足条件B，那么它的成员变量windows所描述的一个ArrayList的大小就大于0。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果一个AppWindowToken对象不是将要置于WindowState堆栈的底部，那么它的成员变量sendingToBottom的值就不等于true，这也意味这个AppWindowToken对象满足条件C。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果能找到满足上述条件的一个AppWindowToken对象wtoken，那么我们只要找到与它所对应的Z轴位置最大的WindowState对象在WindowManagerService服务内部的WindowState堆栈中的位置i，那么将它的值加1，就可以得到与参数tokenPos所描述的AppWindowToken对象所对应的WindowState对象在WindowState堆栈的起始偏移位置了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 那么如何找到与这个AppWindowToken对象wtoken对应的Z轴位置最大的WindowState对象在WindowManagerService服务内部的WindowState堆栈中的位置i呢？从前面的图1可以知道，一个AppWindowToken对象所对应的WindowState对象可以划分为两种类型：第一种类型是父窗口类型的；第二种是子窗口类型的。如果一个WindowState对象所描述的窗口是父窗口，那么它的子窗口就保存在它的成员变量mChildWindows所描述的一个ArrayList中，并且这些子窗口是按照Z轴位置从小到大的顺序排列的，同时，该WindowState对象也会保存在与它所对应的一个AppWindowToken对象的成员变量windows所描述的一个ArrayList中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 有了上述结论，并且假设存在一个能够满足上述三个条件的AppWindowToken对象wtoken，那么就可以从上到下遍历保存在它的成员变量windows所描述的一个ArrayList中的每一个WindowState对象win：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; I. 如果WindowState对象win所描述的一个窗口具有子窗口，那么就继续从上到下遍历这些子窗口，即从上到下遍历WindowState对象win的成员变量mChildWindows所描述的一个ArrayList。如果能找到一个WindowState对象cwin，它的成员变量mSubLayer的值大于等于0，那么该WindowState对象cwin在WindowManagerService服务内部的WindowState堆栈中的位置就是我们要得到的位置i。注意，如果WindowState对象cwin的成员变量mSubLayer的值小于0，那么它虽然是一个子窗口，但是它却是位于父窗口的后面的，即它的Z轴位置是小于父窗口的Z轴位置的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; II. 如果WindowState对象win所描述的一个窗口不具有子窗口，即它的成员变量mChildWindows所描述的一个ArrayList的大小等于0，那么它在WindowManagerService服务内部的WindowState堆栈中的位置就是我们要得到的位置i。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 得到了位置i之后，将它的值加1，那么就可以得到与参数tokenPos所描述的AppWindowToken对象所对应的WindowState对象在WindowState堆栈的起始偏移位置了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 回到WindowManagerService类的成员函数moveAppToken中，调整好参数token所描述的AppWindowToken对象所对应的WindowState对象在WindowState堆栈中的位置之后，即调用了成员函数reAddAppWindowsLocked之后，这时候系统中的窗口的布局就会发生了变化，即系统中的窗口的Z轴位置关系发生了变化，那么接下来就需要调用成员函数updateFocusedWindowLocked来重新计算系统中的窗口的Z轴位置，并且调用成员函数performLayoutAndPlaceSurfacesLocked来重新布局系统中的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4. 移动AppWindowToken至顶端</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 移动AppWindowToken至顶端是通过调用WindowManagerService类的成员函数moveAppTokensToTop来实现的，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  
  
    public void moveAppTokensToTop(List&lt;IBinder&gt; tokens) {
        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                &quot;moveAppTokensToTop()&quot;)) {
            throw new SecurityException(&quot;Requires MANAGE_APP_TOKENS permission&quot;);
        }

        final long origId = Binder.clearCallingIdentity();
        synchronized(mWindowMap) {
            removeAppTokensLocked(tokens);
            final int N = tokens.size();
            for (int i=0; i&lt;N; i++) {
                AppWindowToken wt = findAppWindowToken(tokens.get(i));
                if (wt != null) {
                    mAppTokens.add(wt);
                    if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
                        mToTopApps.remove(wt);
                        mToBottomApps.remove(wt);
                        mToTopApps.add(wt);
                        wt.sendingToBottom = false;
                        wt.sendingToTop = true;
                    }
                }
            }

            if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET) {
                moveAppWindowsLocked(tokens, mAppTokens.size());
            }
        }
        Binder.restoreCallingIdentity(origId);
    }
 
    ......  
}  </pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowManagerService类的成员函数moveAppTokensToTop可以同时将一组AppWindowToken移至顶端，同时需要调用者具有android.Manifest.permission.MANAGE_APP_TOKENS权限。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;参数tokens所描述的是一个IBinder接口列表，与这些IBinder接口所对应的AppWindowToken对象就是接下来要移至顶端的。在将保存在参数tokens中的IBinder接口所对应的AppWindowToken对象移至顶端之前，WindowManagerService类的成员函数首先会调用前面所描述的成员函数removeAppTokensLocked来删除这些AppWindowToken对象，然后再依次将它们添加到WindowManagerService类的成员变量mAppTokens所描述的一个ArrayList的末尾去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注意，WindowManagerService类的成员变量mNextAppTransition用来描述系统当前是否正在切换Activity窗口。如果是的话，那么它的值就不等于WindowManagerPolicy.TRANSIT_UNSET，这时候就需要：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;A. 将所有要移至顶端的AppWindowToken对象都保存在WindowManagerService类的另外一个成员变量mToTopApps所描述的一个ArrayList中去，并且将这些AppWindowToken对象的成员变量sendingToTop的值设置为true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;B.&nbsp;将所有要移至顶端的AppWindowToken对象所对应WindowState对象都移至WindowManagerService服务内部的一个WindowState堆栈的顶端去，这是通过调用另外一个成员函数moveAppWindowsLocked来实现的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;执行完成上述两个操作之后，与要移至顶端的AppWindowToken对象所对应的窗口就会位于窗口堆栈的最上面了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;5. 移动AppWindowToken至底端</p><p>&nbsp; &nbsp; &nbsp; &nbsp;移动AppWindowToken至顶端是通过调用WindowManagerService类的成员函数moveAppTokensToBottom来实现的，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  
  
    public void moveAppTokensToBottom(List&lt;IBinder&gt; tokens) {
        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                &quot;moveAppTokensToBottom()&quot;)) {
            throw new SecurityException(&quot;Requires MANAGE_APP_TOKENS permission&quot;);
        }

        final long origId = Binder.clearCallingIdentity();
        synchronized(mWindowMap) {
            removeAppTokensLocked(tokens);
            final int N = tokens.size();
            int pos = 0;
            for (int i=0; i&lt;N; i++) {
                AppWindowToken wt = findAppWindowToken(tokens.get(i));
                if (wt != null) {
                    mAppTokens.add(pos, wt);
                    if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
                        mToTopApps.remove(wt);
                        mToBottomApps.remove(wt);
                        mToBottomApps.add(i, wt);
                        wt.sendingToTop = false;
                        wt.sendingToBottom = true;
                    }
                    pos++;
                }
            }

            if (mNextAppTransition == WindowManagerPolicy.TRANSIT_UNSET) {
                moveAppWindowsLocked(tokens, 0);
            }
        }
        Binder.restoreCallingIdentity(origId);
    }
 
    ......  
}  </pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<br /><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowManagerService类的成员函数moveAppTokensToBottom可以同时将一组AppWindowToken移至底端。将一组AppWindowToken移至底端与将一组AppWindowToken移至顶端的实现是类似的，只不过是移动的方向相反而已。因此，WindowManagerService类的成员函数moveAppTokensToBottom的实现可以参考前面所分析的成员函数moveAppTokensToTop的实现，这里不再详述。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 6. 增加WindowToken</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 从图1可以知道，如果一个WindowState对象不是与一个AppWindowToken对象对应的，那么它就必须要与一个WindowToken对象对应。例如，用来描述输入法窗口和壁纸窗口的WindowState对象对应的就是WindowToken对象，而不是AppWindowToken对象，因为它们不是Activity类型的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 输入法窗口和壁纸窗口分别是由输入法管理服务InputMethodManagerService和壁纸管理服务WallpaperManagerService调用WindowManagerService类的成员函数addWindowToken来增加对应的WindowToken对象的，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  
  
    public void addWindowToken(IBinder token, int type) {
        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                &quot;addWindowToken()&quot;)) {
            throw new SecurityException(&quot;Requires MANAGE_APP_TOKENS permission&quot;);
        }

        synchronized(mWindowMap) {
            WindowToken wtoken = mTokenMap.get(token);
            if (wtoken != null) {
                Slog.w(TAG, &quot;Attempted to add existing input method token: &quot; + token);
                return;
            }
            wtoken = new WindowToken(token, type, true);
            mTokenMap.put(token, wtoken);
            mTokenList.add(wtoken);
            if (type == TYPE_WALLPAPER) {
                mWallpaperTokens.add(wtoken);
            }
        }
    }
 
    ......  
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 调用WindowManagerService类的成员函数addWindowToken需要具有android.Manifest.permission.MANAGE_APP_TOKENS权限。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 对于输入法窗口和壁纸窗口来说，参数token指向的是与它们所关联的一个Binder对象的IBinder接口，而参数type描述的是要在WindowManagerService服务内部增加WindowToken对象的窗口的类型。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数addWindowToken首先检查在成员变量mTokenMap所描述的一个HashMap检查是否已经存在一个WindowToken对象与参数token对应。如果已经存在的话，那么WindowManagerService类的成员函数addWindowToken就什么也不做就返回了，否则的话，就会使用参数token来创建一个WindowToken对象，并且会将该WindowToken对象分别保存在WindowManagerService类的成员变量mTokenMap和mTokenList中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 这里有两个地方需要注意：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; A. 由于这里增加的是WindowToken对象，而不是AppWindowToken对象，因此，与增加AppWindowToken不同，这里不需要将新创建的WindowToken对象保存在WindowManagerService类的成员变量mAppTokens中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; B. 如果参数type的值等于TYPE_WALLPAPER，那么就意味着新创建的WindowToken对象是用来描述壁纸窗口的，这时候还需要将新创建的WindowToken对象保存在WindowManagerService类的成员变量mWallpaperTokens所描述的一个ArrayList中，以方便管理壁纸窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 对于非输入法窗口、非壁纸窗口以及非Activity窗口来说，它们所对应的WindowToken对象是在它们增加到WindowManagerService服务的时候创建的。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，增加一个窗口WindowManagerService服务最终是通过调用WindowManagerService类的成员函数addWindow来实现的，接下来我们就主要分析与创建WindowToken相关的逻辑，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  
  
    public int addWindow(Session session, IWindow client,
            WindowManager.LayoutParams attrs, int viewVisibility,
            Rect outContentInsets, InputChannel outInputChannel) {
        ......

        synchronized(mWindowMap) {
            ......

            boolean addToken = false;
            WindowToken token = mTokenMap.get(attrs.token);
            if (token == null) {
                if (attrs.type &gt;= FIRST_APPLICATION_WINDOW
                        &amp;&amp; attrs.type &lt;= LAST_APPLICATION_WINDOW) {
                    ......
                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
                }
                if (attrs.type == TYPE_INPUT_METHOD) {
                    ......
                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
                }
                if (attrs.type == TYPE_WALLPAPER) {
                    ......
                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
                }
                token = new WindowToken(attrs.token, -1, false);
                addToken = true;
            }

            ......

            if (addToken) {
                mTokenMap.put(attrs.token, token);
                mTokenList.add(token);
            }
 
            ......
        }

        ......
    }
         
    ......  
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量token所指向的一个IBinder接口在WindowManagerService类的成员变量mTokenMap所描述的一个HashMap中没有一个对应的WindowToken对象，并且该WindowManager.LayoutParams对象的成员变量type的值不等于TYPE_INPUT_METHOD、TYPE_WALLPAPER，以及不在FIRST_APPLICATION_WINDOW和LAST_APPLICATION_WINDOW，那么就意味着这时候要增加的窗口就既不是输入法窗口，也不是壁纸窗口和Activity窗口，因此，就需要以参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量token所指向的一个IBinder接口为参数来创建一个WindowToken对象，并且将该WindowToken对象保存在WindowManagerService类的成员变量mTokenMap和mTokenList中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 7. 删除WindowToken</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;删除WindowToken是通过调用WindowManagerService类的成员函数removeWindowToken来实现的，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  
  
    public void removeWindowToken(IBinder token) {
        if (!checkCallingPermission(android.Manifest.permission.MANAGE_APP_TOKENS,
                &quot;removeWindowToken()&quot;)) {
            throw new SecurityException(&quot;Requires MANAGE_APP_TOKENS permission&quot;);
        }

        final long origId = Binder.clearCallingIdentity();
        synchronized(mWindowMap) {
            WindowToken wtoken = mTokenMap.remove(token);
            mTokenList.remove(wtoken);
            if (wtoken != null) {
                boolean delayed = false;
                if (!wtoken.hidden) {
                    wtoken.hidden = true;

                    final int N = wtoken.windows.size();
                    boolean changed = false;

                    for (int i=0; i&lt;N; i++) {
                        WindowState win = wtoken.windows.get(i);

                        if (win.isAnimating()) {
                            delayed = true;
                        }

                        if (win.isVisibleNow()) {
                            applyAnimationLocked(win,
                                    WindowManagerPolicy.TRANSIT_EXIT, false);
                            changed = true;
                        }
                    }

                    if (changed) {
                        mLayoutNeeded = true;
                        performLayoutAndPlaceSurfacesLocked();
                        updateFocusedWindowLocked(UPDATE_FOCUS_NORMAL);
                    }

                    if (delayed) {
                        mExitingTokens.add(wtoken);
                    } else if (wtoken.windowType == TYPE_WALLPAPER) {
                        mWallpaperTokens.remove(wtoken);
                    }
                }

                ......
            } else {
                Slog.w(TAG, &quot;Attempted to remove non-existing token: &quot; + token);
            }
        }
        Binder.restoreCallingIdentity(origId);
    }
         
    ......  
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 调用WindowManagerService类的成员函数removeWindowToken需要具有android.Manifest.permission.MANAGE_APP_TOKENS权限。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowManagerService类的成员函数removeWindowToken首先找到与参数token所描述的Binder接口所对应的WindowToken对象，接着再将该WindowToken对象从WindowManagerService类的成员变量mTokenMap和mTokenList中删除。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 删除了一个WindowToken对象之后，如果该WindowToken对象不是处于不可见的状态，即它的成员变量hidden的值不等于false，那么就意味着它所描述窗口口也有可能是可见的，那么WindowManagerService类的成员函数removeWindowToken就需要作以下两个检查：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; A. 如果该WindowToken对象所描述的窗口的其中一个处于动画显示过程，即用来描述该窗口的一个WindowState对象的成员函数isAnimating的返回值等于true，那么就需要该WindowToken对象的状态设置为正在退出状态，即将它保存在WindowManagerService类的成员变量mExitingTokens所描述的一个ArrayList中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; B.&nbsp;如果该WindowToken对象所描述的窗口是可见的，即用来描述该窗口的一个WindowState对象的成员函数isVisibleNow的返回值等于true，那么就需要调用WindowManagerService类的成员函数applyAnimationLocked来给它应用一个退出动画，该退出动画是通过调用WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked来实现的。当一个窗口退出了之后，系统当前获得焦点的窗口可能会发生变化，这时候就需要调用WindowManagerService类的成员函数updateFocusedWindowLocked来重新调整系统当前获得焦点的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注意，如果正在删除的WindowToken对象是用来描述壁纸窗口的，那么还需要将该WindowToken对象从WindowManagerService类的成员变量mWallpaperTokens所描述的一个ArrayList中删除。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 8. 增加WindowState</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，增加一个窗口WindowManagerService服务最终是通过调用WindowManagerService类的成员函数addWindow来实现的，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  

    /**
     * Mapping from an IWindow IBinder to the server's Window object.
     * This is also used as the lock for all of our state.
     */
    final HashMap&lt;IBinder, WindowState&gt; mWindowMap = new HashMap&lt;IBinder, WindowState&gt;();
    ......

    /**
     * Z-ordered (bottom-most first) list of all Window objects.
     */
    final ArrayList&lt;WindowState&gt; mWindows = new ArrayList&lt;WindowState&gt;();
    ......
  
    public int addWindow(Session session, IWindow client,  
            WindowManager.LayoutParams attrs, int viewVisibility,  
            Rect outContentInsets, InputChannel outInputChannel) {  
        ......  
  
        WindowState win = null;  
  
        synchronized(mWindowMap) {  
            ......  

            win = new WindowState(session, client, token,  
                    attachedWindow, attrs, viewVisibility);  
            ......  
  
            mWindowMap.put(client.asBinder(), win);  
            ......

            if (attrs.type == TYPE_INPUT_METHOD) {
                mInputMethodWindow = win;
                addInputMethodWindowToListLocked(win);
                ......
            } else if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
                mInputMethodDialogs.add(win);
                addWindowToListInOrderLocked(win, true);
                adjustInputMethodDialogsLocked();
                ......
            } else {
                addWindowToListInOrderLocked(win, true);
                if (attrs.type == TYPE_WALLPAPER) {
                    .......
                    adjustWallpaperWindowsLocked();
                } else if ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != 0) {
                    adjustWallpaperWindowsLocked();
                }
            }

            ......
        }

        ......
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类有两个成员变量mWindowMap和mWindows是用来保存系统中的WindowState对象。其中，成员变量mWindowMap指向的是一个HashMap，它的关键字是一个IBinder接口，一般这个IBinder接口指向的是一个Binder代理对象，引用了运行在应用程序进程这一侧的一个类型为W的Binder本地对象，用来描述一个窗口；成员变量mWindows指向的是一个ArrayList，保存在它里面的WindowState对象是按照其Z轴位置从小到大的顺序排列的。成员变量mWindowMap和mWindows的区别在于，前者给在定一个IBinder接口的情况下，可以快速找到与对应的WindowState对象，而后者用来从上到下或者下到上遍历系统的WindowState对象。由于系统中的WindowState对象是按照其Z轴位置从小到大的顺序排列在成员变量mWindows中的，因此，成员变量mWindows所指向的ArrayList就是我们在前面图1中所说的Window Stack。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 理解了WindowManagerService类有两个成员变量mWindowMap和mWindows的作用之后，WindowManagerService类的成员函数addWindow增加一个WindowState对象的过程就容易理解了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;参数client是一个Binder代理对象，引用了运行在应用程序进程这一侧的一个类型为W的Binder本地对象，用来描述要增加到WindowManagerService服务中的一个窗口。WindowManagerService类的成员函数addWindow首先创建一个WindowState对象win，接着再以参数client所描述的一个Binder代理对象的IBinder接口为关键字，将WindowState对象win保存在WindowManagerService类的成员变量mWindowMap中，最后还会根据要增加到WindowManagerService服务中的窗口的类型来调用不同的成员函数将WindowState对象win增加到WindowManagerService类的成员变量mWindows中：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; A. 如果要增加的是输入法窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于TYPE_INPUT_METHOD，那么就会调用成员函数addInputMethodWindowToListLocked来将WindowState对象win增加到WindowManagerService类的成员变量mWindows中去，并且会将WindowState对象win保存在WindowManagerService类的成员变量mInputMethodWindow中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; B.&nbsp;如果要增加的是输入法对话框，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于TYPE_INPUT_METHOD_DIALOG，那么就会调用成员函数addWindowToListInOrderLocked来将WindowState对象win增加到WindowManagerService类的成员变量mWindows中去，并且会将WindowState对象win保存在WindowManagerService类的成员变量mInputMethodDialogs中，以及调用成员函数adjustInputMethodDialogsLocked来调整刚才所添加的输入法窗口在窗口堆栈中的位置，使得它位于系统当前需要输入法窗口的窗口的上面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; C.&nbsp;&nbsp;如果要增加的是壁纸窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于TYPE_WALLPAPER，那么就会调用成员函数addWindowToListInOrderLocked来将WindowState对象win增加到WindowManagerService类的成员变量mWindows中去，并且会调用成员函数adjustWallpaperWindowsLocked来调整刚才所添加的壁纸窗口在窗口堆栈中的位置，使得它位于系统当前需要壁纸窗口的窗口的下面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; D . 如果要增加的既不是输入法窗口，也不是输入法对话框和壁纸窗口，那么就只会调用成员函数addWindowToListInOrderLocked来将WindowState对象win增加到WindowManagerService类的成员变量mWindows中去，但是如果要增加的窗口需要显示壁纸，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量flags的FLAG_SHOW_WALLPAPER位等于1，那么还会继续调用成员函数adjustWallpaperWindowsLocked来调整系统中的壁纸窗口在窗口堆栈中的位置，使得它位于刚才所添加的窗口的下面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在后面的两篇文章中，我们再详细分析WindowManagerService类的成员函数addInputMethodWindowToListLocked、adjustInputMethodDialogsLocked和adjustWallpaperWindowsLocked的实现，其中，前两者是与输入法窗口相关的，而后者是与壁纸窗口相关的。本文主要关注WindowManagerService类的成员函数addWindowToListInOrderLocked的实现，它会将一个指定的WindowState对象增加到窗口堆栈中的合适位置上去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 9. 增加WindowState到窗口堆栈</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 从前面的分析可以知道，将一个WindowState对象增加到WindowManagerService服务内部中的窗口堆栈，即WindowManagerService类的成员变量mWindows，是通过调用WindowManagerService类的成员函数addWindowToListInOrderLocked来实现的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService类的成员函数addWindowToListInOrderLocked的实现比较复杂，我们先列出它的框架，然后再详细分析它的实现，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  

    private void addWindowToListInOrderLocked(WindowState win, boolean addToToken) {
        final IWindow client = win.mClient;
        final WindowToken token = win.mToken;
        final ArrayList&lt;WindowState&gt; localmWindows = mWindows;

        final int N = localmWindows.size();
        final WindowState attached = win.mAttachedWindow;
        int i;
        if (attached == null) {
            //CASE 1：要增加的窗口win没有附加在其它窗口上
            int tokenWindowsPos = token.windows.size();
            if (token.appWindowToken != null) {
                //CASE 1.1：要增加的窗口win是一个Activity窗口
                int index = tokenWindowsPos-1;
                if (index &gt;= 0) {
                    //CASE 1.1.1：用来要增加的窗口win的令牌token已存在其它窗口
                    ......
                } else {
                    //CASE 1.1.2：用来要增加的窗口win的令牌token尚未存在任何窗口
                    ......
                }
            } else {
                //CASE 1.2：要增加的窗口win不是一个Activity窗口
                ......
            }
            if (addToToken) {
                token.windows.add(tokenWindowsPos, win);
            }
        } else {
            //CASE 2：要增加的窗口win附加在窗口attached上
            ......
        }

        if (win.mAppToken != null &amp;&amp; addToToken) {
            win.mAppToken.allAppWindows.add(win);
        }
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我们首先分析一下WindowManagerService类的成员函数addWindowToListInOrderLocked的几个本地变量的含义：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; A.&nbsp;<strong>token</strong>。本地变量token指向的是参数win所描述的一个WindowState对象的成员变量mToken所指向一个WindowToken对象，这个WindowToken对象用来描述WindowState对象win所对应的窗口令牌。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; B.<strong>&nbsp;localmWindows</strong>。本地变量localmWindows指向的是WindowManagerService类的成员变量mWindows所描述的一个ArrayList，即一个窗口堆栈，WindowManagerService类的成员函数addWindowToListInOrderLocked的目标就是要将参数win所描述的一个WindowState对象增加到该窗口堆栈的合适位置上去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; C.&nbsp;<strong>attached</strong>。本地变量attached指向的是参数win所描述的一个WindowState对象的成员变量mAttachedWindow 所指向的一个WindowState对象，如果它的值不等于null，那么就意味参数win所描述的窗口要附加在本地变量attached所描述的窗口上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; D.&nbsp;<strong>tokenWindowsPos</strong>。本地变量tokenWindowsPos用来描述与窗口令牌token所对应的窗口的数量。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; E.&nbsp;<strong>token.appWindowToken</strong>。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，如果一个WindowToken对象的成员变量appWindowToken的值不等于null，那么就意味着该WindowToken对象的实际类型为是AppWindowToken，即它所描述的是一个Activity窗口令牌，这种类型的令牌的特点是在ActivityManagerService服务的Activity组件堆栈中对应有一个ActivityRecord对象，如图1所示。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; F.&nbsp;<strong>index</strong>。本地变量index的值等于tokenWindowsPos-1，如果它的值大于等于0，那么就意味着窗口令牌tokent已经存在其它窗口，否则的话，就意味着窗口令牌tokent尚未存在任何窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 从这些本地变量的含义，我们就可以分情况来将参数win所描述的一个WindowState对象增加到WindowManagerService服务内部的窗口堆栈的合适位置上去：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>CASE 1</strong>：要增加的窗口win没有附加在其它窗口上</p><p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>----CASE 1.1</strong>：要增加的窗口win是一个Activity窗口</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>----CASE 1.1.1</strong>：用来要增加的窗口win的令牌token已存在其它窗口。这时候意味着窗口win需要保存在其它已经存在的窗口的附近，因此，我们只要找到这些已经存在的窗口在窗口堆栈中的位置，那么再根据其它属性，就可以将窗口win保存在已经存在的窗口的上面或者下面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>----CASE 1.1.2</strong>：用来要增加的窗口win的令牌token尚未存在任何窗口。虽然这时候窗口win在窗口堆栈中没有位置可以参考，但是它毕竟是一个Activity窗口，我们可以通过与它所对应的AppWindowToken对象在App Token List（即WindowManagerService类的成员变量mAppTokens所描述的一个ArrayList）中的位置来获得它窗口堆栈中的位置。回忆我们在前面第3节分析移动AppWindowToken至指定位置的操作时得到的结论：WindowManagerService服务内部中的所有WindowState对象都是按照Z轴从位置从小到大排列在WindowState堆栈中的，并且在mAppTokens列表中，位于上面的一个AppWindowToken对象所对应的那些WindowState对象的Z轴位置是一定大于位于下面的一个AppWindowToken对象所对应的那些WindowState对象的Z轴位置的。因此，我们只要找到用来描述窗口win的一个AppWindowToken对象（token.appWindowToken）的上一个或者下一个AppWindowToken对象所对应的窗口在窗口堆栈中的位置，那么就可以这个位置为参考，得到窗口win在窗口堆栈中的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>----CASE 1.2</strong>：要增加的窗口win不是一个Activity窗口。这时候既然要增加的窗口也没有附加在其它窗口上，那么就意味着要增加的窗口win在窗口堆栈中没有位置可以参考，因此，我们就需要根据它的Z轴位置来决定它在窗口堆栈的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>CASE 2</strong>：要增加的窗口win附加在窗口attached上。这时候就意味着要增加的窗口win要保存在窗口attached的上面，即窗口在窗口堆栈的位置要以窗口attached在窗口堆栈的位置为参考。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 从上面的分析就可以知道，<strong>CASE 1.1.1</strong>、<strong>CASE 1.1.2</strong>和<strong>CASE 2</strong>都有一个共同特点，即要增加的窗口win在窗口堆栈的位置有一个参考值，而在<strong>CASE 1.2</strong>中，要增加的窗口win在窗口堆栈的位置没有参考值，需要通过其Z轴位置来确定。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;在分析上述四种情况之前， 我们还需要再说明一下WindowManagerService类的成员函数addWindowToListInOrderLocked的参数addToToken的含义。参数addToToken是一个布尔变量，如果它的值等于true，那么就说明需要将参数win所描述的一个WindowState对象添加用来描述它的窗口令牌token的成员变量windows所描述的一个ArrayList中去。注意，窗口令牌token的成员变量windows所描述的一个ArrayList里面所保存的WindowState对象是按照Z轴位置从小到大的顺序来排列的，因此，在将WindowState对象win保存到这个ArrayList之前，首先要按照它的Z轴位置计算得到它在这个ArrayList中的位置tokenWindowsPos。另一方面，在参数addToToken的值等于true，并且参数win所描述的是一个Activity窗口，即它的成员变量mAppToken不等于null的情况下，还需要将参数win所描述的一个WindowState对象保存在用来描述它的窗口令牌，即一个AppWindowToken对象成员变量allAppWindows所描述的一个ArrayList中去，以便可以知道一个AppWindowToken对象对应的Activity窗口都有哪些。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;接下来，我们就分别分析这四种情况是如何将窗口win增加窗口堆栈中去的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;<strong>CASE 1.1.1</strong>对应的代码为：</p><p></p><pre name="code" class="java">                    if (win.mAttrs.type == TYPE_BASE_APPLICATION) {
                        // Base windows go behind everything else.
                        placeWindowBefore(token.windows.get(0), win);
                        tokenWindowsPos = 0;
                    } else {
                        AppWindowToken atoken = win.mAppToken;
                        if (atoken != null &amp;&amp;
                                token.windows.get(index) == atoken.startingWindow) {
                            placeWindowBefore(token.windows.get(index), win);
                            tokenWindowsPos--;
                        } else {
                            int newIdx =  findIdxBasedOnAppTokens(win);
                            if(newIdx != -1) {
                                //there is a window above this one associated with the same
                                //apptoken note that the window could be a floating window
                                //that was created later or a window at the top of the list of
                                //windows associated with this token.
                                ......
                                localmWindows.add(newIdx+1, win);
                                mWindowsChanged = true;
                            }
                        }
                    }</pre><p>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码又分为三种情况来将参数win所描述的一个WindowState对象添加到窗口堆栈中：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; A.&nbsp;参数win描述的窗口的类型为TYPE_BASE_APPLICATION。在一个令牌对应的所有窗口中，类型为TYPE_BASE_APPLICATION的窗口位于其它类型的窗口的下面。因此，这段代码就会调用WindowManagerService类的成员函数placeWindowBefore来将参数win所描述的一个WindowState对象保存窗口堆栈中，并且它是位于令牌token的窗口列表的第0个位置的WindowState对象的下面。这时候变量tokenWindowsPos的值会被设置为0，表示参数win所描述的一个WindowState对象要保存窗口令牌token的窗口列表的第0个位置上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; B. 参数win描述的一个WindowState对象的成员变量mAppToken的值不等于null，这意味着参数win描述的是一个Activity窗口，这时候如果窗口令牌atoken（与token描述的是同一个窗口令牌）的窗口列表的第index个位置（即最上面的一个位置） 的WindowState对象描述的是一个Activity启动窗口，即与窗口令牌atoken的成员变量startingWindow描述的是同一个窗口，那么就说明窗口令牌atoken的窗口列表的第index个位置的WindowState对象描述的是窗口win的启动窗口。由于一个窗口的启动窗口总是位于它的上面，因此，这段代码就会调用WindowManagerService类的成员函数placeWindowBefore来将参数win所描述的一个WindowState对象保存窗口堆栈中，并且它是位于令牌atoken的窗口列表的第index个位置的WindowState对象的下面。这时候变量tokenWindowsPos的值减少1，即相当于是等于index，表示参数win所描述的一个WindowState对象要插入在窗口令牌token的窗口列表的第index个位置上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; C. 参数win所描述的窗口的类型既不是TYPE_BASE_APPLICATION，而且它也没有启动窗口，那么这时候就需要将它保存在窗口令牌token的窗口列表的最上面一个窗口的上面。窗口令牌token的窗口列表的最上面一个窗口在窗口堆栈中的位置newIdx是通过调用WindowManagerService类的成员函数findIdxBaseOnAppTokens来获得的，这时候参数win所描述的一个WindowState对象就应该保存在窗口堆栈，即变量localmWindows所描述的一个ArrayList的第newIdx+1个位置上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>CASE 1.1.2</strong>对应的代码为：</p><p></p><pre name="code" class="java">                    // Figure out where the window should go, based on the
                    // order of applications.
                    final int NA = mAppTokens.size();
                    WindowState pos = null;
                    for (i=NA-1; i&gt;=0; i--) {
                        AppWindowToken t = mAppTokens.get(i);
                        if (t == token) {
                            i--;
                            break;
                        }

                        // We haven't reached the token yet; if this token
                        // is not going to the bottom and has windows, we can
                        // use it as an anchor for when we do reach the token.
                        if (!t.sendingToBottom &amp;&amp; t.windows.size() &gt; 0) {
                            pos = t.windows.get(0);
                        }
                    }
                    // We now know the index into the apps.  If we found
                    // an app window above, that gives us the position; else
                    // we need to look some more.
                    if (pos != null) {
                        // Move behind any windows attached to this one.
                        WindowToken atoken = mTokenMap.get(pos.mClient.asBinder());
                        if (atoken != null) {
                            final int NC = atoken.windows.size();
                            if (NC &gt; 0) {
                                WindowState bottom = atoken.windows.get(0);
                                if (bottom.mSubLayer &lt; 0) {
                                    pos = bottom;
                                }
                            }
                        }
                        placeWindowBefore(pos, win);
                    } else {
                        // Continue looking down until we find the first
                        // token that has windows.
                        while (i &gt;= 0) {
                            AppWindowToken t = mAppTokens.get(i);
                            final int NW = t.windows.size();
                            if (NW &gt; 0) {
                                pos = t.windows.get(NW-1);
                                break;
                            }
                            i--;
                        }
                        if (pos != null) {
                            // Move in front of any windows attached to this
                            // one.
                            WindowToken atoken = mTokenMap.get(pos.mClient.asBinder());
                            if (atoken != null) {
                                final int NC = atoken.windows.size();
                                if (NC &gt; 0) {
                                    WindowState top = atoken.windows.get(NC-1);
                                    if (top.mSubLayer &gt;= 0) {
                                        pos = top;
                                    }
                                }
                            }
                            placeWindowAfter(pos, win);
                            placeWindowAfter(pos, win);
                        } else {
                            // Just search for the start of this layer.
                            final int myLayer = win.mBaseLayer;
                            for (i=0; i&lt;N; i++) {
                                WindowState w = localmWindows.get(i);
                                if (w.mBaseLayer &gt; myLayer) {
                                    break;
                                }
                            }
                            ......
                            localmWindows.add(i, win);
                            mWindowsChanged = true;
                        }
                    }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码要能冠军WindowManagerService服务内部的一个AppWindowToken列表mAppTokens来在窗口堆栈中找到一个参数位置来保存参数win所描述的一个WindowState对象。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 最上面的一个for循环执行完成之后，我们假设变量pos的值不等于null，这时候它与变量i以及变量token的关系如图2所示：</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/19/1358526649_6728.jpg" alt="" /><br /></p><p style="text-align: center;">图2 窗口win位于窗口C的下面</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 这时候位于令牌token上面的令牌在窗口堆栈中对应有WindowState对象。注意，这时候第i+2个令牌在窗口堆栈中不对应有WindowState对象，而第i+3个令牌在窗口堆栈中对应有C和D两个WindowState对象，并且这两个WindowState对象所描述的窗口都不是即将要切换到窗口堆栈的底部的。由于第i+3个令牌位于令牌token的上面，并且这两个令牌之间的其它令牌在窗口堆栈中不对应有WindowState对象，因此，这时候参数win所描述的WindowState对象在窗口堆栈中的位置应该以第i+3个令牌所对应的Z轴位置最小的WindowState对象在窗口堆栈中的位置为参考，即以WindowState对象C在窗口堆栈中的位置为参考，而WindowState对象C也正好是变量pos所指向的WindowState对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;接下来，上述代码会继续检查WindowState对象C是否附加有SubLayer值小于0的窗口。如果有的话，那么就会将变量pos指向SubLayer值最小的那个WindowState对象，这是因为该WindowState对象是在WindowState对象C的最下面的，并且它与WindowState对象C是同属一个令牌的。最后，上述代码就会调用WindowManagerService类的成员函数placeWindowBefore来将参数win所描述的一个WindowState对象保存窗口堆栈中由变量pos所指向的那个WindowState对象的下面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;假设最上面的一个for循环执行完成之后，变量pos的值等于null，那么就说明位于令牌token上面的令牌在窗口堆栈中都没有对应有WindowState对象，或者说它们所对应的WindowState对象都是即将要切换到窗口堆栈的底部去的，这时候就需要通过位于令牌token上面的令牌来在窗口堆栈中找到一个参考位置来保存参数win所描述的WindowState对象，这是通过中间的while循环来实现的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;中间的while循环执行完成之后，假设变量pos的值不等于null，这时候它与变量i以及变量token的关系如图3所示：<br /></p><div style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/19/1358528940_9835.jpg" alt="" /></div><p></p><p style="text-align: center;">图3&nbsp;<span style="text-align: center;">窗口win位于窗口D的上面</span></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这时候位于令牌token上面的令牌在窗口堆栈中没有对应有WindowState对象。注意，这时候第i-1个令牌在窗口堆栈中不对应有WindowState对象，而第i-2个令牌在窗口堆栈中对应有C和D两个WindowState对象。由于第i-2个令牌位于令牌token的下面，并且这两个令牌之间的其它令牌在窗口堆栈中不对应有WindowState对象，因此，这时候参数win所描述的WindowState对象在窗口堆栈中的位置应该以第i-2个令牌所对应的Z轴位置最大的WindowState对象在窗口堆栈中的位置为参考，即以WindowState对象D在窗口堆栈中的位置为参考，而WindowState对象D也正好是变量pos所指向的WindowState对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;接下来，上述代码会继续检查WindowState对象D是否附加有SubLayer值大于等于0的窗口。如果有的话，那么就会将变量pos指向SubLayer值最大的那个WindowState对象，这是因为该WindowState对象是在WindowState对象D的最上面的，并且它与WindowState对象D是同属一个令牌的。最后，上述代码就会调用WindowManagerService类的成员函数placeWindowAfter来将参数win所描述的一个WindowState对象保存窗口堆栈中由变量pos所指向的那个WindowState对象的上面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;假设中间的while循环执行完成之后，变量pos的值等于null，这时候就说明在窗口堆栈中实在是找不到参考位置来保存参数win所描述的WindowState对象了，因此，就只能通过参数win所描述的WindowState对象的Z轴位置，即它的成员变量mBaseLayer的值来在窗口堆栈中找到一个合适的位置了，如最下面的for循环所示。由于窗口堆栈中的WindowState对象是按照它们的Z轴位置由小到大的顺序来排列的，因此，最下面的for循环只要从下到上找到一个Z轴位置比参数win所描述的WindowState对象的Z轴位置大的一个WindowState对象在窗口堆栈中的位置i，那么就可以将参数win所描述的WindowState对象插入在窗口堆栈的第i个位置上了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>CASE 1.2</strong>对应的代码为：</p><p></p><pre name="code" class="java">                // Figure out where window should go, based on layer.
                final int myLayer = win.mBaseLayer;
                for (i=N-1; i&gt;=0; i--) {
                    if (localmWindows.get(i).mBaseLayer &lt;= myLayer) {
                        i++;
                        break;
                    }
                }
                if (i &lt; 0) i = 0;
                ......
                localmWindows.add(i, win);
                mWindowsChanged = true;</pre>&nbsp; &nbsp; &nbsp; &nbsp; 由于这时候在窗口堆栈中是没有参考位置来保存参数win所描述的WindowState对象的，因此，这段代码就只能通过参数win所描述的WindowState对象的Z轴位置，即它的成员变量mBaseLayer的值来在窗口堆栈中找到一个合适的位置了，如这段代码中的for循环所示。由于窗口堆栈中的WindowState对象是按照它们的Z轴位置由小到大的顺序来排列的，因此，这段代码中的for循环只要从上到下找到一个WindowState对象，它的Z轴位置小于或者等于参数win所描述的WindowState对象的Z轴位置，那么该WindowState对象在窗口堆栈中的位置i就可以用插入参数win所描述的WindowState对象了。<br /><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>CASE 2</strong>对应的代码为：</p><p></p><pre name="code" class="java">            // Figure out this window's ordering relative to the window
            // it is attached to.
            final int NA = token.windows.size();
            final int sublayer = win.mSubLayer;
            int largestSublayer = Integer.MIN_VALUE;
            WindowState windowWithLargestSublayer = null;
            for (i=0; i&lt;NA; i++) {
                WindowState w = token.windows.get(i);
                final int wSublayer = w.mSubLayer;
                if (wSublayer &gt;= largestSublayer) {
                    largestSublayer = wSublayer;
                    windowWithLargestSublayer = w;
                }
                if (sublayer &lt; 0) {
                    // For negative sublayers, we go below all windows
                    // in the same sublayer.
                    if (wSublayer &gt;= sublayer) {
                        if (addToToken) {
                            token.windows.add(i, win);
                        }
                        placeWindowBefore(
                            wSublayer &gt;= 0 ? attached : w, win);
                        break;
                    }
                } else {
                    // For positive sublayers, we go above all windows
                    // in the same sublayer.
                    if (wSublayer &gt; sublayer) {
                        if (addToToken) {
                            token.windows.add(i, win);
                        }
                        placeWindowBefore(w, win);
                        break;
                    }
                }
            }
            if (i &gt;= NA) {
                if (addToToken) {
                    token.windows.add(win);
                }
                if (sublayer &lt; 0) {
                    placeWindowBefore(attached, win);
                } else {
                    placeWindowAfter(largestSublayer &gt;= 0
                                     ? windowWithLargestSublayer
                                     : attached,
                                     win);
                }
            }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码要将参数win所描述的WindowState对象附加在变量attached所描述的WindowState对象的上面或者下面，取决于它的成员变量mSubLayer的值是大于0还是小于0。我们分四种情况来考虑。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第一种情况是参数win所描述的WindowState对象的成员变量mSubLayer的值小于0，并且这时候在附加在窗口attached的WindowState对象中，存在一个WindowState对象，它的成员变量mSubLayer的值大于等于参数win所描述的WindowState对象的成员变量mSubLayer的值，如图4和图5所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201301/19/1358532524_5529.jpg" alt="" /><br /></p><p style="text-align: center;">图4 窗口win插入到窗口B的下面</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201301/19/1358532527_1862.jpg" alt="" /><br /></p><p style="text-align: center;">图5 窗口win插入在窗口attached的下面</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在图4和图5中，WindowState对象A和B均是附加在WindowState对象attached中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在图4中，WindowState对象A和B的成员变量mSubLayer的值均小于0，而WindowState对象win的成员变量mSubLayer的值比WindowState对象A的大，但是比WindowState对象B的小，这时候WindowState对象win在窗口堆栈中就应该位于WindowState对象B的下面，这是通过调用WindowManagerService类的成员函数placeWindowBefore来实现的。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在图5中，WindowState对象A和B的成员变量mSubLayer的值均大于0，由于WindowState对象win的成员变量mSubLayer的值小于0，这时候WindowState对象win在窗口堆栈中就应该位于WindowState对象attached的下面，这是通过调用WindowManagerService类的成员函数placeWindowBefore来实现的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第二种情况是参数win所描述的WindowState对象的成员变量mSubLayer的值大于0，并且这时候在附加在窗口attached的WindowState对象中，存在一个WindowState对象，它的成员变量mSubLayer的值大于参数win所描述的WindowState对象的成员变量mSubLayer的值，如图6所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201301/19/1358533060_9340.jpg" alt="" /><br /></p><p style="text-align: center;"><span style="text-align: center;">图6 窗口win插入在窗口B的下面</span><br /></p><p style="text-align: left;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 在图6中，WindowState对象A和B均是附加在WindowState对象attached中。其中，<span style="text-align: center;">WindowState对象A和B的成员变量mSubLayer的值均大于0，而<span style="text-align: center;">WindowState对象win的成员变量<span style="text-align: center;">mSubLayer的值比<span style="text-align: center;">WindowState对象</span></span>A的大，但是比<span style="text-align: center;">WindowState对象</span>B的小，这时候WindowState对象win在窗口堆栈中就应该位于WindowState对象B的下面，这是通过调用WindowManagerService类的成员函数placeWindowBefore来实现的。</span></span></span></p><p style="text-align: left;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 第三种情况是参数win所描述的WindowState对象的成员变量mSubLayer的值小于0，但是在附加在窗口attached的WindowState对象中，找不到一个WindowState对象，它的成员变量<span style="text-align: center;">mSubLayer的值比<span style="text-align: center;">WindowState对象的成员变量mSubLayer的值大，如图7所示：</span></span></span></span></span></p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201301/19/1358533462_5967.jpg" alt="" /><br /></p><p style="text-align: center;"><span style="text-align: center;">图7 窗口win插入在窗口attached的下面</span><br /></p><p style="text-align: left;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 在图7中，<span style="text-align: center;">WindowState对象A和B均是附加在WindowState对象attached中。其中，<span style="text-align: center;">WindowState对象A和B以及win的成员变量<span style="text-align: center;">mSubLayer的值均小于0，但是<span style="text-align: center;">WindowState对象win的成员变量</span><span style="text-align: center;">mSubLayer的值比<span style="text-align: center;">WindowState对象A和B的都要大，这时候<span style="text-align: center;">WindowState对象win在窗口堆栈中就应该位于WindowState对象attached的下面，这是通过调用WindowManagerService类的成员函数placeWindowBefore来实现的。</span></span></span></span></span></span></span></p><p style="text-align: left;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="text-align: center;">第四种情况是参数win所描述的WindowState对象的成员变量mSubLayer的值大于等于0，<span style="text-align: center;">但是在附加在窗口attached的WindowState对象中，找不到一个WindowState对象，它的成员变量</span><span style="text-align: center;">mSubLayer的值比WindowState对象的成员变量mSubLayer的值大，如图8和图9所示：</span></span></span></span></span></span></span></span></span></p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201301/19/1358534008_4472.jpg" alt="" /><br /></p><p style="text-align: center;"><span style="text-align: center;">图8 窗口win插入在窗口B的上面</span><br /></p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201301/19/1358534014_8069.jpg" alt="" /><br /></p><p style="text-align: center;"><span style="text-align: center;">图9 窗口win插入在窗口attached的上面</span><br /></p><p style="text-align: left;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在图8和图9中，WindowState对象A和B均是附加在WindowState对象attached中。</span></p><p style="text-align: left;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 在图8中，WindowState对象A和B的成员变量mSubLayer的值均大于0，并且WindowState对象win的<span style="text-align: center;">成员变量mSubLayer的值比<span style="text-align: center;">WindowState对象A和B的都要大，<span style="text-align: center;">这时候</span><span style="text-align: center;">WindowState对象win在窗口堆栈中就应该位于WindowState对象B的上面，这是通过调用WindowManagerService类的成员函数placeWindowAfter来实现的。</span></span></span></span></p><p style="text-align: left;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="text-align: center;">在图9中，WindowState对象A和B的成员变量mSubLayer的值均小于等于0，而WindowState对象win的</span><span style="text-align: center;">成员变量mSubLayer的值大于0，这时候WindowState对象win在窗口堆栈中就应该位于WindowState对象attached的上面，这是通过调用WindowManagerService类的成员函数placeWindowAfter来实现的。</span></span></span></span></span></p><p style="text-align: left;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;注意，在这四种情况中，如果参数addToToken的值等于true，那么都需要将参数win所描述的WindowState对象增加到与它所对应的窗口令牌token的窗口列表windows中去。</span></span></span></span></span></p><p style="text-align: left;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;10. 删除WindowState</span></span></span></span></span></p><p style="text-align: left;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style="text-align: center;">删除<span style="text-align: center;">WindowState</span>是通过调用WindowManagerService类的成员函数tmpRemoveWindowLocked来实现的，如下所示：</span></span></span></span></span></span></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub  
        implements Watchdog.Monitor {  
    ......  
  
    private int tmpRemoveWindowLocked(int interestingPos, WindowState win) {
        int wpos = mWindows.indexOf(win);
        if (wpos &gt;= 0) {
            if (wpos &lt; interestingPos) interestingPos--;
            ......
            mWindows.remove(wpos);
            mWindowsChanged = true;
            int NC = win.mChildWindows.size();
            while (NC &gt; 0) {
                NC--;
                WindowState cw = win.mChildWindows.get(NC);
                int cpos = mWindows.indexOf(cw);
                if (cpos &gt;= 0) {
                    if (cpos &lt; interestingPos) interestingPos--;
                    ......
                    mWindows.remove(cpos);
                }
            }
        }
        return interestingPos;
    }
  
    ......  
}  </pre><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="text-align: center;">WindowManagerService类的成员函数tmpRemoveWindowLocked将参数win所描述的窗口及其子窗口从<span style="text-align: center;">WindowManagerService服务内部的窗口堆栈中删除，即从&nbsp;<span style="text-align: center;">WindowManagerService类的成员变量mWindows所描述的一个ArrayList中删除。</span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 如果每一个被删除的窗口在窗口堆栈中的位置比参数interestingPos的值小，那么<span style="text-align: center;">WindowManagerService类的成员函数tmpRemoveWindowLocked</span>还会将<span style="text-align: center;">参数</span><span style="text-align: center;">interestingPos的值减少1，这相当于是计算当删除<span style="text-align: center;">参数win所描述的窗口及其子窗口之后，原来位于窗口堆栈中第<span style="text-align: center;">interestingPos个位置的窗口现在位于<span style="text-align: center;">窗口堆栈的位置，这个位置最终会作为<span style="text-align: center;">WindowManagerService类的成员函数tmpRemoveWindowLocked的返回值。</span></span></span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp;11. 在指定位置增加WindowState</span></span></span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp;在指定位置增加</span><span style="text-align: center;">WindowState</span><span style="text-align: center;">是通过调用WindowManagerService类的成员函数reAddWindowLocked来实现的，如下所示：</span></span></span></span></span></span></span></span></span></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final int reAddWindowLocked(int index, WindowState win) {
        final int NCW = win.mChildWindows.size();
        boolean added = false;
        for (int j=0; j&lt;NCW; j++) {
            WindowState cwin = win.mChildWindows.get(j);
            if (!added &amp;&amp; cwin.mSubLayer &gt;= 0) {
                ......
                mWindows.add(index, win);
                index++;
                added = true;
            }
            ......
            mWindows.add(index, cwin);
            index++;
        }
        if (!added) {
            ......
            mWindows.add(index, win);
            index++;
        }
        mWindowsChanged = true;
        return index;
    }

    ......
}</pre><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 参数win描述的即为要增加的WindowState对象，而参数index描述的即为要将参数win所描述的WindowState对象及其子WindowState对象要增加到窗口堆栈中的起始位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;由于参数win所描述的WindowState对象的子WindowState对象的成员变量mSubLayer的值可能会小于0，也可能大于0。大于0的子WindowState对象位于参数win所描述的WindowState对象的上面，而小于0的子WindowState对象位于参数win所描述的WindowState对象的下面。因此，<span style="text-align: center;">WindowManagerService类的成员函数reAddWindowLocked先增加那些小于0的子WindowState对象，接着再增加参数win所描述的WindowState对象，最后增加<span style="text-align: center;">那些大于0的</span><span style="text-align: center;">子WindowState对象。</span></span></p><p><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 假设<span style="text-align: center;">WindowManagerService类的成员函数reAddWindowLocked一共在窗口堆栈中增加了N个<span style="text-align: center;">WindowState对象，那么它的返回值就等于index + N，这样调用者就可以知道参数win所描述的WindowState对象及其子WindowState对象在<span style="text-align: center;">窗口堆栈中的最高位置是多少</span><span style="text-align: center;">。</span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 基于第9、第10和第11这三操作，可以组合成很多其它的WindowState操作，如接下来的第12、第13、第14和第15个操作所示。</span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 12. 将一个WindowState对象及其所有子<span style="text-align: center;">WindowState对象增加到窗口堆栈中</span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="text-align: center;">将一个WindowState对象及其所有子</span><span style="text-align: center;">WindowState对象增加到窗口堆栈中是通过调用<span style="text-align: center;">WindowManagerService类的成员函数reAddWindowToListInOrderLocked来实现的，如下所示：</span></span></span></span></span></span></span></span></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private void reAddWindowToListInOrderLocked(WindowState win) {
        addWindowToListInOrderLocked(win, false);
        // This is a hack to get all of the child windows added as well
        // at the right position.  Child windows should be rare and
        // this case should be rare, so it shouldn't be that big a deal.
        int wpos = mWindows.indexOf(win);
        if (wpos &gt;= 0) {
            ......
            mWindows.remove(wpos);
            mWindowsChanged = true;
            reAddWindowLocked(wpos, win);
        }
    }

    ......
}</pre><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 为了得到参数win所描述的WindowState对象的子WindowState对象在窗口堆栈中的起始位置，<span style="text-align: center;">WindowManagerService类的成员函数reAddWindowToListInOrderLocked首先将参数win所描述的WindowState对象增加到窗口堆栈中，这是通过调用前面所分析的成员函数addWindowToListInOrderLocked来实现的，目的是为了获得它在窗口堆栈的位置。有了这个位置之后，<span style="text-align: center;">WindowManagerService类的成员函数reAddWindowToListInOrderLocked就可以调用前面所分析的成员函数<span style="text-align: center;">reAddWindowLocked来将<span style="text-align: center;">WindowState对象及其所有子</span><span style="text-align: center;">WindowState对象增加到窗口堆栈中去了，不过在调用之前，要先将参数win所描述的WindowState对象从窗口中堆栈删除。</span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 13. 将一个WindowToken对象对应的所有WindowState对象及其子<span style="text-align: center;">WindowState对象</span>增加到窗口堆栈的指定位置上</span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="text-align: center;">将一个WindowToken对象对应的所有WindowState对象都增加到窗口堆栈中<span style="text-align: center;">是通过调用</span><span style="text-align: center;">WindowManagerService类的成员函数reAddAppWindowsLocked来实现的，如下所示：</span></span></span></span></span></span></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final int reAddAppWindowsLocked(int index, WindowToken token) {
        final int NW = token.windows.size();
        for (int i=0; i&lt;NW; i++) {
            index = reAddWindowLocked(index, token.windows.get(i));
        }
        return index;
    }

    ......
}</pre><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 与参数token所描述的<span style="text-align: center;">WindowToken对象所对应的WindowState对象保存在它的成员变量windows所描述的一个ArrayList中。通过遍历这个<span style="text-align: center;">ArrayList，就可以将与参数token所描述的<span style="text-align: center;">WindowToken对象所对应的WindowState对象及其子</span></span></span><span style="text-align: center;">WindowState对象</span><span style="text-align: center;">都增加到</span><span style="text-align: center;">窗口堆栈的指定的起始位置上去，这是通过调用前面所分析的成员函数reAddWindowLocked来实现的。</span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 参数index描述的便是最初指定的起始位置，每一次调用<span style="text-align: center;">WindowManagerService类的成员函数<span style="text-align: center;">reAddWindowLocked之后，它的值都便会被更新为下一个<span style="text-align: center;">WindowState对象及其子<span style="text-align: center;">WindowState对象要增加到窗口堆栈中的位置。</span></span></span></span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 最后，<span style="text-align: center;">WindowManagerService类的成员函数reAddAppWindowsLocked将与<span style="text-align: center;">参数token所描述的WindowToken对象所对应的WindowState对象在</span><span style="text-align: center;">窗口堆栈中的最高位置加1后的得到结果返回给调用者</span><span style="text-align: center;">。</span></span></span></span></span></span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp;14. 将一个AppWindowToken对象所对应的WindowState对象及其子&nbsp;<span style="text-align: center;">WindowState对象移动</span><span style="text-align: center;">到窗口堆栈的指定位置上</span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="text-align: center;">将一个AppWindowToken对象所对应的WindowState对象及其子&nbsp;</span><span style="text-align: center;">WindowState对象移动</span><span style="text-align: center;">到窗口堆栈的指定位置上<span style="text-align: center;">是通过调用</span><span style="text-align: center;">WindowManagerService类的成员函数moveAppWindowsLocked来实现的，如下所示：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private void moveAppWindowsLocked(AppWindowToken wtoken, int tokenPos,
            boolean updateFocusAndLayout) {
        // First remove all of the windows from the list.
        tmpRemoveAppWindowsLocked(wtoken);

        // Where to start adding?
        int pos = findWindowOffsetLocked(tokenPos);

        // And now add them back at the correct place.
        pos = reAddAppWindowsLocked(pos, wtoken);

        if (updateFocusAndLayout) {
            if (!updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
                assignLayersLocked();
            }
            mLayoutNeeded = true;
            performLayoutAndPlaceSurfacesLocked();
        }
    }

    ......
}</pre><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 参数wtoken描述的是要移动其所对应的WindowState对象的一个AppWindowToken对象，而参数tokenPos描述的是该AppWindowToken对象在WindowManagerService服务内部的AppWindowToken列表中的新位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span style="text-align: center;">WindowManagerService类的成员函数moveAppWindowsLocked首先调用前面所分析的成员函数tmpRemoveAppWindowsLocked来移除所有与参数wtoken所描述的AppWindowToken对象所对应的WindowState对象，接着再调用也是前面所分析的成员函数findWindowOffsetLocked来获得<span style="text-align: center;">与</span><span style="text-align: center;">参数wtoken所描述的AppWindowToken对象所对应的WindowState对象在窗口堆栈中的起始位置。有了这个起始位置之后，就可以也是前面所分析的成员函数reAddAppWindowsLocked来将<span style="text-align: center;">与</span><span style="text-align: center;">参数wtoken所描述的AppWindowToken对象所对应的WindowState对象及其子<span style="text-align: center;">WindowState对象移动到窗口堆栈上去了。</span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 最后，如果参数updateFocusAndLayout的值等于true，那么<span style="text-align: center;">WindowManagerService类的成员函数moveAppWindowsLocked还会更新系统当前获得焦点的窗口，以及重新计算系统中的所有窗口的Z轴位置以及重新布局<span style="text-align: center;">系统中的所有窗口，这三个操作分别是通过调用<span style="text-align: center;">WindowManagerService类的成员函数updateFocusedWindowLocked、assignLayersLocked和performLayoutAndPlaceSurfacesLocked来实现的。</span></span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 15.&nbsp;<span style="text-align: center;">将一组AppWindowToken对象所对应的WindowState对象及其子&nbsp;</span><span style="text-align: center;">WindowState对象移动</span><span style="text-align: center;">到窗口堆栈的指定位置上</span></span></span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="text-align: center;">将一组AppWindowToken对象所对应的WindowState对象及其子</span><span style="text-align: center;">WindowState对象移动</span><span style="text-align: center;">到窗口堆栈的指定位置上<span style="text-align: center;">是通过调用</span><span style="text-align: center;">WindowManagerService类的另外一个版本的成员函数moveAppWindowsLocked来实现的，如下所示：</span></span></span></span></span></span></span></span></span></span></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private void moveAppWindowsLocked(List&lt;IBinder&gt; tokens, int tokenPos) {
        // First remove all of the windows from the list.
        final int N = tokens.size();
        int i;
        for (i=0; i&lt;N; i++) {
            WindowToken token = mTokenMap.get(tokens.get(i));
            if (token != null) {
                tmpRemoveAppWindowsLocked(token);
            }
        }

        // Where to start adding?
        int pos = findWindowOffsetLocked(tokenPos);

        // And now add them back at the correct place.
        for (i=0; i&lt;N; i++) {
            WindowToken token = mTokenMap.get(tokens.get(i));
            if (token != null) {
                pos = reAddAppWindowsLocked(pos, token);
            }
        }

        if (!updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
            assignLayersLocked();
        }
        mLayoutNeeded = true;
        performLayoutAndPlaceSurfacesLocked();

        //dump();
    }

    ......
}</pre><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个操作与前面分析的第14个操作是类似，区别只在于前者是批量地移动一组<span style="text-align: center;">AppWindowToken对象所对应的WindowState对象及其子&nbsp;</span><span style="text-align: center;">WindowState对象，而后者是只移动一个<span style="text-align: center;">AppWindowToken对象所对应的WindowState对象及其子</span><span style="text-align: center;">WindowState对象，此外，前者总是会调用<span style="text-align: center;">WindowManagerService类的成员函数updateFocusedWindowLocked、assignLayersLocked和performLayoutAndPlaceSurfacesLocked来更新系统当前获得焦点的窗口、以及重新计算每一个窗口的Z轴位置，并且对这些窗口进行重新布局。</span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 至此，我们就分析完成WindowManagerService服务组织系统中的窗口的方式了。从分析的过程中，可以得到以下结论：</span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 1. WindowManagerService服务维护有一个AppWindowToken堆栈和一个WindowState堆栈，它们与ActivityManagerService服务维护的Actvity堆栈是有关相同的Z轴位置关系的。</span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 2.&nbsp;<span style="text-align: center;">ActivityManagerService服务中的每一个ActivityRecord对象在<span style="text-align: center;">WindowManagerService服务中都对应有一个AppWindowToken对象，而<span style="text-align: center;">WindowManagerService服务中的每一个AppWindowToken对象都对应有一组WindowState对象。</span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 3. 在WindowState堆栈中，<span style="text-align: center;">AppWindowToken堆栈中的第i+1个<span style="text-align: center;">AppWindowToken对象所对应的WindowState对象<span style="text-align: center;">都位于第<span style="text-align: center;">i个</span><span style="text-align: center;">AppWindowToken对象所对应的<span style="text-align: center;">WindowState对象的上面。</span></span></span></span></span></span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 4. 一个<span style="text-align: center;">WindowState对象可以附加在另外一个<span style="text-align: center;">WindowState对象上面，此外，一个<span style="text-align: center;">WindowState对象还可以有子<span style="text-align: center;">WindowState对象，它们都是与同一个<span style="text-align: center;">AppWindowToken对象或者WindowToken对象所对应的。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 5.&nbsp;<span style="text-align: center;">WindowManagerService服务有两个特殊的WindowToken，它们分别用来描述系统中的输入法窗口令牌和壁纸窗口令牌，其中，<span style="text-align: center;">输入法窗口位于需要输入法的窗口的上面，而<span style="text-align: center;">壁纸窗口位于需要壁纸的窗口的下面。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;"><span style="text-align: center;">&nbsp; &nbsp; &nbsp; &nbsp; 最后，我们可以将<span style="text-align: center;">WindowManagerService服务中的<span style="text-align: center;">AppWindowToken理解成一个Activity组件令牌，而将它所对应的WindowState对象理解成一个Activity窗口。有了这些概念之后，就为学习<span style="text-align: center;">WindowManagerService服务的各种实现打下坚实的基础。在接下来的两篇文章中，我们就会在本文的基础上，继续分析<span style="text-align: center;">WindowManagerService服务是如何管理系统中的<span style="text-align: center;">输入法窗口和壁纸窗口的，敬请关注！</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p><p style="text-align: center;"><span style="text-align: center;"><strong><span style="font-size:14px;color:#cc0000;">老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</span></strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2013-1-21 1:01:38 <a href="http://blog.csdn.net/luoshengyang/article/details/8498908">原文链接</a>
            </div>
            <div>
            阅读：2653 评论：11 <a href="http://blog.csdn.net/luoshengyang/article/details/8498908#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android窗口管理服务WindowManagerService对输入法窗口（Input Method Window）的管理分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8526644</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8526644</guid>
        <author>Luoshengyang</author>
        <pubDate>2013-1-28 0:57:09</pubDate>
        <description><![CDATA[
            <p>&nbsp; &nbsp; &nbsp; &nbsp; 在Android系统中，输入法窗口是一种特殊类型的窗口，它总是位于需要使用输入法的窗口的上面。也就是说，一旦WindowManagerService服务检测到焦点窗口需要使用输入法，那么它就会调整输入法窗口在窗口堆栈中的位置，使得输入法窗口位于在焦点窗口的上面，这样用户可以通过输入法窗口来录入字母或者文字。本文就将详细分析WindowManagerService服务是如何管理系统中的输入法窗口的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在Android系统中，除了输入法窗口之外，还有一种窗口称为输入法对话框，它们总是位于输入窗口的上面。Activity窗口、输入法窗口和输入法对话框的位置关系如图1所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201301/21/1358783161_4338.jpg" alt="" /><br /></p><p style="text-align: center;">图1 Activity窗口、输入法窗口和输入法对话框的位置关系</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService组织窗口的方式分析</a>一文中提到，WindowManagerService服务是使用堆栈来组织系统中的窗口的，因此，如果我们在窗口堆栈中观察Activity窗口、输入法窗口和输入法对话框，它们的位置关系就如图2所示：</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/22/1358786167_3555.jpg" alt="" /><br /></p><p style="text-align: center;">图2 Activity窗口、输入法窗口和输入法对话框在窗口堆栈中的位置关系</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 图2中的对象的关系如下所示：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 在ActivityManagerService服务内部的Activity组件堆栈顶端的ActivityRecord对象N描述的是系统当前激活的Activity组件。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. ActivityRecord对象N在WindowManagerService服务内部的窗口令牌列表顶端对应有一个AppWindowToken对象N。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3.&nbsp;AppWindowToken对象N在WindowManagerService服务内部的窗口堆栈中对应有一个WindowState对象N，用来描述系统当前激活的Activity组件窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4.&nbsp;WindowState对象N上面有一个WindowState对象IMW，用来描述系统中的输入法窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5.&nbsp;WindowState对象IMW上面有三个WindowState对象IMD-1、IMD-2和IMD-3，它们用来描述系统中的输入法对话框。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 6. 系统中的输入法窗口以及输入法对话框在WindowManagerService服务内部中对应的窗口令牌是由WindowToken对象IM来描述的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 7.&nbsp;WindowToken对象IM在InputMethodManagerService服务中对应有一个Binder对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 总的来说，就是图2描述了系统当前激活的Activity窗口上面显示输入法窗口，而输入法窗口上面又有一系列的输入法对话框的情景。WindowManagerService服务的职能之一就是要时刻关注系统中是否有窗口需要使用输入法。WindowManagerService服务一旦发现有窗口需要使用输入法，那么就会调整输入法窗口以及输入法对话框在窗口堆栈中的位置，使得它们放置在需要使用输入法的窗口的上面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 接下来，我们就首先分析两个需要调整输入法窗口以及输入法对话框在窗口堆栈中的位置的情景，然后再分析它们是如何在窗口堆栈中进行调整的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第一个需要调整输入法窗口以及输入法对话框在窗口堆栈中的位置的情景是增加一个窗口到WindowManagerService服务去的时候。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，增加一个窗口到WindowManagerService服务最终是通过调用WindowManagerService类的成员函数addWindow来实现的。接下来我们就主要分析这个函数中与输入法窗口以及输入法对话框调整相关的逻辑，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub    
        implements Watchdog.Monitor {  
    ......

    WindowState mInputMethodWindow = null;
    final ArrayList&lt;WindowState&gt; mInputMethodDialogs = new ArrayList&lt;WindowState&gt;();
    ......

    public int addWindow(Session session, IWindow client,
            WindowManager.LayoutParams attrs, int viewVisibility,
            Rect outContentInsets, InputChannel outInputChannel) {
        ......

        synchronized(mWindowMap) {
            ......

            WindowToken token = mTokenMap.get(attrs.token);
            if (token == null) {
                ......
                if (attrs.type == TYPE_INPUT_METHOD) {
                    ......
                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
                }
                ......
            }      
            ......

            win = new WindowState(session, client, token,
                    attachedWindow, attrs, viewVisibility);
            ......

            boolean imMayMove = true;

            if (attrs.type == TYPE_INPUT_METHOD) {
                mInputMethodWindow = win;
                addInputMethodWindowToListLocked(win);
                imMayMove = false;
            } else if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
                mInputMethodDialogs.add(win);
                addWindowToListInOrderLocked(win, true);
                adjustInputMethodDialogsLocked();
                imMayMove = false;
            } 
            ......

            boolean focusChanged = false;
            if (win.canReceiveKeys()) {
                focusChanged = updateFocusedWindowLocked(UPDATE_FOCUS_WILL_ASSIGN_LAYERS);
                if (focusChanged) {
                    imMayMove = false;
                }
            }

            if (imMayMove) {
                moveInputMethodWindowsIfNeededLocked(false);
            }
            
            ......
        }   
        
        ......
    }

    ......
}</pre><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果当前增加到WindowManagerService服务来的是一个输入法窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于TYPE_INPUT_METHOD，那么就要求与该输入法窗口所对应的类型为WindowToken的窗口令牌已经存在，否则的话，WindowManagerService类的成员函数addWindow就会直接返回一个错误码WindowManagerImpl.ADD_BAD_APP_TOKEN给调用者。这个类型为WindowToken的窗口令牌是InputMethodManagerService服务请求WindowManagerService服务创建的，即调用WindowManagerService类的成员函数addWindowToken来创建的，具体可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService组织窗口的方式分析</a>一文。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果当前增加到WindowManagerService服务来的是一个输入法窗口，那么就会将前面为它所创建的一个WindowState对象win保存在WindowManagerService类的成员变量mInputMethodWindow中，接着还会调用WindowManagerService类的成员函数addInputMethodWindowToListLocked来将该WindowState对象插入到窗口堆栈的合适位置去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果当前增加到WindowManagerService服务来的是一个输入法对话框，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于TYPE_INPUT_METHOD_DIALOG，那么就会将前面为它所创建的一个WindowState对象win添加到WindowManagerService类的成员变量mInputMethodDialogs所描述的一个ArrayList中去，并且先后调用WindowManagerService类的成员函数addWindowToListInOrderLocked和adjustInputMethodDialogsLocked来将该WindowState对象插入到窗口堆栈的合适位置去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在上述两种情况中，由于用来描述输入法窗口或者输入法对话框的WindowState对象已经被插入到了窗口堆栈中的合适位置，因此，接下来就不再需要考虑移动该输入法窗口或者输入法对话框了，这时候变量imMayMove的值就会被设置为false。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;另一方面，如果当前增加到WindowManagerService服务来的既不是一个输入法窗口，也不是一个输入法对话框，并且该窗口需要接收键盘事件，即前面所创建的WindowState对象win的成员函数canReceiveKeys的返回值为true，那么就可能会导致系统当前获得焦点的窗口发生变化，这时候就需要调用WindowManagerService类的成员函数updateFocusedWindowLocked来重新计算系统当前获得焦点的窗口。如果系统当前获得焦点的窗口发生了变化，那么WindowManagerService类的成员函数updateFocusedWindowLocked的返回值focusChanged就会等于true，同时系统的输入法窗口和输入法对话框在窗口堆栈中的位置也会得到调整，即位它们会位于系统当前获得焦点的窗口的上面，因此，这时候变量imMayMove的值也会被设置为false，表示接下来不再需要考虑移动系统中的输入法窗口或者输入法对话框在窗口堆栈中的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;最后，如果变量imMayMove的值保持为初始值，即保持为true，那么就说明当前增加的窗口可能会引发系统的输入法窗口和输入法对话框在窗口堆栈中的位置发生变化，因此，这时候就需要调用WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked来作检测，并且在发生变化的情况下，将系统的输入法窗口和输入法对话框移动到窗口堆栈的合适位置上去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;从上面的分析就可以知道，在增加一个窗口的过程中，可能需要调用WindowManagerService类的成员函数addInputMethodWindowToListLocked、addWindowToListInOrderLocked、adjustInputMethodDialogsLocked和moveInputMethodWindowsIfNeededLocked来移动系统的输入法窗口和输入法对话框，其中，WindowManagerService类的成员函数addWindowToListInOrderLocked在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService组织窗口的方式分析</a>一文已经分析过了，本文只要关注其余三个成员函数的实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;第二个需要调整输入法窗口以及输入法对话框在窗口堆栈中的位置的情景是一个应用程序进程请求WindowManagerService服务重新布局一个窗口的时候。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8479101">Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析</a>一文可以知道，应用程序进程请求WindowManagerService服务重新布局一个窗口最终是通过调用WindowManagerService类的成员函数relayoutWindow来实现的。接下来我们就主要分析这个函数中与输入法窗口以及输入法对话框调整相关的逻辑，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub    
        implements Watchdog.Monitor {  
    ......

    public int relayoutWindow(Session session, IWindow client,
            WindowManager.LayoutParams attrs, int requestedWidth,
            int requestedHeight, int viewVisibility, boolean insetsPending,
            Rect outFrame, Rect outContentInsets, Rect outVisibleInsets,
            Configuration outConfig, Surface outSurface) {
        ......

        synchronized(mWindowMap) {
            WindowState win = windowForClientLocked(session, client, false);
            ......

            int attrChanges = 0;
            int flagChanges = 0;
            if (attrs != null) {
                flagChanges = win.mAttrs.flags ^= attrs.flags;
                attrChanges = win.mAttrs.copyFrom(attrs);
            }
            ......

            boolean imMayMove = (flagChanges&amp;(
                    WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM |
                    WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE)) != 0;

            boolean focusMayChange = win.mViewVisibility != viewVisibility
                    || ((flagChanges&amp;WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE) != 0)
                    || (!win.mRelayoutCalled);
            ......

            if (viewVisibility == View.VISIBLE &amp;&amp;
                    (win.mAppToken == null || !win.mAppToken.clientHidden)) {
		displayed = !win.isVisibleLw();
                ......

                if ((attrChanges&amp;WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
                    // To change the format, we need to re-build the surface.
                    win.destroySurfaceLocked();
                    displayed = true;
                }
                ......

                if (win.mAttrs.type == TYPE_INPUT_METHOD
                        &amp;&amp; mInputMethodWindow == null) {
                    mInputMethodWindow = win;
                    imMayMove = true;
                }

                if (displayed) {
                    focusMayChange = true;
                }
             
                ......
            } else {
                ......

                if (win.mSurface != null) {
                    ......
                    // If we are not currently running the exit animation, we
                    // need to see about starting one.
                    if (!win.mExiting || win.mSurfacePendingDestroy) {
                        ......

                        if (!win.mSurfacePendingDestroy &amp;&amp; win.isWinVisibleLw() &amp;&amp;
                              applyAnimationLocked(win, transit, false)) {
                            focusMayChange = true;
                            win.mExiting = true;
                        } else if (win.isAnimating()) {
                            // Currently in a hide animation... turn this into
                            // an exit.
                            win.mExiting = true;
                        } else if (win == mWallpaperTarget) {
                            // If the wallpaper is currently behind this
                            // window, we need to change both of them inside
                            // of a transaction to avoid artifacts.
                            win.mExiting = true;
                            win.mAnimating = true;
                        } else {
                            if (mInputMethodWindow == win) {
                                mInputMethodWindow = null;
                            }
                            win.destroySurfaceLocked();
                        }
                    }
                }

                ......
            }

            if (focusMayChange) {
                ......
                if (updateFocusedWindowLocked(UPDATE_FOCUS_WILL_PLACE_SURFACES)) {
                    imMayMove = false;
                }
                ......
            }

            // updateFocusedWindowLocked() already assigned layers so we only need to
            // reassign them at this point if the IM window state gets shuffled
            boolean assignLayers = false;

            if (imMayMove) {
                if (moveInputMethodWindowsIfNeededLocked(false) || displayed) {
                    // Little hack here -- we -should- be able to rely on the
                    // function to return true if the IME has moved and needs
                    // its layer recomputed.  However, if the IME was hidden
                    // and isn't actually moved in the list, its layer may be
                    // out of data so we make sure to recompute it.
                    assignLayers = true;
                }
            }
            ......

            if (assignLayers) {
                assignLayersLocked();
            }

            ......
        }

        ......

        return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0)
                | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);
    }

    ......
}</pre><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;应用程序进程在请求WindowManagerService服务重新布局一个窗口的时候，这个窗口的一些布局参数可能会发生变化，而这些变化可能会同时引发系统的输入法窗口以及输入法对话框在窗口堆栈中的位置发生变化。如果系统的输入法窗口以及输入法对话框在窗口堆栈中的位置发生了变化，那么就需要调整它们在窗口堆栈中的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数relayoutWindow首先调用根据参数session和client来调用另外一个成员函数windowForClientLocked，以便可以获得用来描述要重新布局的窗口的一个WindowState对象win。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowState对象win的成员变量mAttrs指向的是一个WindowManager.LayoutParams对象，该WindowManager.LayoutParams对象的成员变量flags描述的是窗口上一次所设置的布局属性标志位，而参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量flags描述的是窗口当前被设置的布局属性标志位。WindowManagerService类的成员函数relayoutWindow通过对这两个标志位执行一个异或操作，就可以知道窗口的哪些布局属性标志位发生了变化，这些变化就记录在变量flagChanges中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowManagerService类的成员函数relayoutWindow在对WindowState对象win所描述的窗口进行布局之前，还要将参数attrs指的是一个WindowManager.LayoutParams对象的内容拷贝到&nbsp;WindowState对象win的成员变量mAttrs指向的是一个WindowManager.LayoutParams对象中去。在拷贝的过程中，如果发现这两个WindowManager.LayoutParams对象所描述的窗口布局属性有发生变化，那么这些变化就会记录在变量attrChanges中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在窗口的布局属性标志中，位WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE表示窗口是否可以获得焦点，另外一个位WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM是用来反转WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE位的作用的。一个窗口是否可以获得焦点意味着它是否需要与输入法窗口交互，即如果一个窗口是可以获得焦点的，那么就意味着它需要与输入法窗口交互，否则就不需要。当一个窗口的WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE位等于1，那么就表示窗口不可以获得焦点，即不需要与输入法窗口交互，但是如果该窗口的WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM位也等于1，那么就表示窗口仍然是需要与输入法窗口交互的。另一方面，如果一个窗口的WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM位等于1，但是该窗口的WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE位等于0，那么就表示窗口仍然是不可以与输入法窗口交互的。因此，当前面得到的变量flagChanges的WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE位或者WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM位发生了变化时，都意味着对WindowState对象win所描述的窗口进行重新布局会影响系统中的输入法窗口以及输入法对话框，即该窗口可能会由需要显示输入法窗口以及输入法对话框，到不需要显示输入法窗口以及输入法对话框，反之亦然。最后得到的变量imMayMove的值等于true就表示要移动系统中的输入法窗口以及输入法对话框在窗口堆栈中的位置。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 一个窗口由不可获得焦点到可以获得焦点，或者由可获得焦点到不可以获得焦点，即窗口布局属性标志中的WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE位发生了变化，那么就意味着要重新计算系统当前获得焦点的窗口。从前面分析增加窗口到WindowManagerService服务的情景可以知道，当系统当前获得焦点的窗口发生变化时，也意味着需要系统中的移动输入法窗口以及输入法对话框在窗口堆栈中的位置。除了窗口布局属性标志中的WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE位变化会引发系统当前获得焦点的窗口发生变化之外，还有另外两个因素会引发系统当前获得焦点的窗口发生变化。第一个因素是窗口的可见性发生变化。WindowState对象win的成员变量mViewVisibility描述的是窗口上一次布局时的可见性，而参数viewVisibility描述的是窗口当前的可见性，当它们的值不相等时，就意味着窗口的可见性发生了变化。第二个因素是窗口是第一次被应用程序进程请求WindowManagerService服务布局，这时候WindowState对象win的成员变量mRelayoutCalled的值就会等于false。最后得到的变量focusMayChange等于true，就表示需要重新计算系统当前获得焦点的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowState对象win所描述的窗口在此次重新布局中是否会引起移动系统中的输入法窗口以及输入法对话框在窗口堆栈中的位置，还取决于它在的可见性以及它的绘图表面属性等信息，接下来我们就按照&nbsp;WindowState对象win所描述的窗口当前是可见还是不可见来分别分析。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我们首先分析WindowState对象win所描述的窗口在此次重新布局中是可见的情景，即参数viewVisibility的值等于View.VISIBLE。注意，如果WindowState对象win所描述的是一个Activity窗口，而该Activity组件是不可见的，那么即使参数viewVisibility的值等于View.VISIBLE，那么WindowState对象win所描述的窗口在此次重新布局中也是认为不可见的。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，当WindowState对象win的成员变量mAppToken的值不等于null时，那么该WindowState对象win描述的是一个Activity窗口，而当该成员变量所指向的一个AppWindowToken对象的成员变量clientHidden的值等于false时，就表示对应的Activity组件是可见的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowState对象win所描述的窗口在上一次布局时的可见性可以调用它的成员函数isVisibleLw来获得。如果WindowState对象win所描述的窗口在上一次布局时是不可见的，那么现在就需要将它设置为可见的，即要将它显示出来，这时候变量displayed的值就会等于true。另一方面，如果WindowState对象win所描述的窗口的绘图表面的像素格式发生了变化，即变量attrChanges的WindowManager.LayoutParams.FORMAT_CHANGED位等于1，那么这时候就需要调用WindowState对象win的成员函数destroySurfaceLocked来销毁它所描述的窗口的绘图表面，以便接下来可以为它重新创建一个新的绘图表面，这时候也会将变量displayed的值设置为true，表示接下来是要显示WindowState对象win所描述的窗口的。如果最终得到的变量displayed的值设置为true，那么就相当于说明WindowState对象win所描述的窗口经历一个由不可见到可见的状态变化，因此就可能会导致系统当前获得焦点的窗口发生变化，这时候就会将变量focusMayChange的值设置为true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果WindowState对象win描述的是一个输入法窗口，即它的成员变量mAttrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于TYPE_INPUT_METHOD，并且系统中的输入法窗口尚未设置，即WindowManagerService类的成员变量mInputMethodWindow的值等于null，那么就说明接下来要显示的其实是输入法窗口，这情况会导致需要移动系统中的输入法窗口以及输入法对话框在窗口堆栈中的位置，因此，这时候除了需要将WindowState对象win保存在WindowManagerService类的成员变量mInputMethodWindow之外，还需要将变量imMayMove的值设置为true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我们接下来再分析WindowState对象win所描述的窗口在此次重新布局中是不可见的情景。一个窗口变得不可见了，就意味着可能要销毁它的绘图表面，取决于它的绘图表面是否存在，以及它的退出动画是否已经显示结束。WindowState对象win所描述的窗口的绘图表面保存在它的成员变量mSurface中，因此，当WindowState对象win的成员变量mSurface不等于null的时候，就意味着可能会销毁它所描述的绘图表面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果WindowState对象win的成员变量mExiting等于false时，那么就说明该WindowState对象win所描述的窗口的退出动画可能尚未开始，也可能已经结束。另一方面，如果WindowState对象win的成员变量mSurfacePendingDestroy的值等于true，那么就说明该WindowState对象win所描述的窗口的绘图表面正在等待销毁。这两种情况都需要进一步确定接下来是要开始WindowState对象win所描述的窗口的退出动画，还是要销毁WindowState对象win所描述的窗口的绘图表面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果WindowState对象win的成员变量mSurfacePendingDestroy的值等于false，那么同时也意味着它所描述的窗口还未开始显示退出动画，因而它的绘图表面就没有进入正在等待销毁的状态。在这种情况下，如果WindowState对象win所描述的窗口是可见的，即它的成员函数isWinVisibleLw的返回值等于true，那么就意味要开始该窗口的退出动画了，这是通过调用WindowManagerService类的成员函数applyAnimationLocked来实现的。WindowState对象win描述的窗口开始退出动画之后，就意味要重新计算系统当前获得焦点的窗口，因此，这时候就会将变量focusMayChange的值设置为true，同时还会将WindowState对象win的成员变量mExiting的值设置为true，表示它描述的窗口正在退出的过程中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果WindowState对象win所描述的窗口正在处于退出动画的过程中，即它的成员函数isAnimating的返回值等于true，那么这时候需要确保WindowState对象win的成员变量mExiting的值为true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果WindowState对象win所描述的窗口已经结束退出动画，但是它仍然是壁纸窗口的目标，即WindowManagerService类的成员变量mWallpaperTarget的值不等于null，并且它的值就等于WindowState对象win，那么这时候就需要等待壁纸窗口也退出之后，才销毁WindowState对象win所描述的窗口，因此，这时候就需要将WindowState对象win的成员变量mExiting和mAnimating的值设置为true，即假装它所描述的窗口还处于正在退出的过程，这样做是为了等待壁纸窗口退出完成。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果WindowState对象win所描述的窗口已经结束退出动画，并且它不是壁纸窗口的目标，那么这时候就需要调用它的成员函数destroySurfaceLocked来销毁它的绘图表面了。在销毁WindowState对象win所描述的窗口之前，还会判断它是否就是系统当前的输入法窗口，即WindowManagerService类的成员变量mInputMethodWindow的值是否等于win。如果等于的话，那么就说明系统当前的输入法窗口被销毁了，因此，就需要将WindowManagerService类的成员变量mInputMethodWindow的值设置为null。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 经过上面的一系列操作之后，如果最终得到的变量focusMayChange的值等于true，那么就说明需要重新计算系统当前获得焦点的窗口了，这是通过调用WindowManagerService类的成员函数updateFocusedWindowLocked来实现的。一旦WindowManagerService类的成员函数updateFocusedWindowLocked的返回值为true，那么就说明统当前获得焦点的窗口发生了变化，并且系统中的输入法窗口以及输入法对话框也移动到窗口堆栈中的正确位置了，因此，这时候就会将变量imMayMove的值设置为false。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;经过上面的一系列操作之后，如果最终得到的变量imMayMove的值等于true，那么就说明有可能需要移动系统中的输入法窗口以及输入法对话框在窗口堆栈中的位置，这是通过调用WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked来实现的。一旦系统中的输入法窗口以及输入法对话框在窗口堆栈中的位置发生了移动，那么WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked的返回值就等于true，这时候就需要将变量assignLayers的值设置为true，表示要重新计算系统中的窗口的Z轴位置，以便可以同步到SurfaceFlinger服务中去。注意，如果系统中的输入法窗口以及输入法对话框在窗口堆栈中的位置没有发生变化，但是前面得到的变量displayed的值等于true，那么也是需要将变量assignLayers的值设置为true的，因为这个变量displayed的值等于true意味着WindowState对象win所描述的窗口经历了从不可见到可见的状态变化，因此也需要重新计算系统中的窗口的Z轴位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;经过上面的一系列操作之后，如果最终得到的变量assignLayers的值等于true，那么就需要调用WindowManagerService类的成员函数assignLayersLocked来执行重新计算统中的窗口的Z轴位置的操作了。在后面的文章中，我们再详细分析WindowManagerService服务是如何计算系统中的窗口的Z轴位置的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;从上面的分析就可以知道，在布局一个窗口的过程中，可能需要调用WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked来移动系统的输入法窗口和输入法对话框。再结合前面增加窗口的情景，我们就可以知道，在WindowManagerService类中，与输入法窗口以及输入法对话框相关的成员函数有addInputMethodWindowToListLocked、adjustInputMethodDialogsLocked和moveInputMethodWindowsIfNeededLocked，它们的作用如下所示：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; A. 成员函数addInputMethodWindowToListLocked用来将输入法窗口插入到窗口堆栈的合适位置，即插入到需要显示输入法窗口的窗口的上面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; B. 成员函数adjustInputMethodDialogsLocked用来移动输入法对话框到窗口堆栈的合适位置，即移动到输入法窗口的上面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; C. 成员函数moveInputMethodWindowsIfNeededLocked用来检查是否需要移动输入法窗口以及输入法对话框。如果需要的话，那么就将它们移动到窗口堆栈的合适位置去，即将输入法窗口移动到需要显示输入法窗口的窗口的上面，而将输入法对话框移动到输入法窗口的上面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在分析这三个成员函数的实现之前，我们首先分析WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked和moveInputMethodDialogsLocked，它们是两个基本的操作，其中：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; D. &nbsp;成员函数findDesiredInputMethodWindowIndexLocked用来查找输入法窗口在窗口堆栈的正确位置，这个位置刚好就是在需要显示输入法窗口的窗口在窗口堆栈中的上一个位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; E.&nbsp;成员函数moveInputMethodDialogsLocked用来将移动输入法对话框移动到输入法窗口的上面去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 接下来我们开始分析上述五个函数的实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 计算输入法窗口在窗口堆栈中的位置</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;输入法窗口在窗口堆栈中的位置是通过调用WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked来获得的，它首先找到需要显示输入法的窗口在窗口堆栈中的位置，然后再将这个位置加1，就可以得到输入法窗口在窗口堆栈中的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中，它的实现比较长，我们分段来阅读：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    int findDesiredInputMethodWindowIndexLocked(boolean willMove) {
        final ArrayList&lt;WindowState&gt; localmWindows = mWindows;
        final int N = localmWindows.size();
        WindowState w = null;
        int i = N;
        while (i &gt; 0) {
            i--;
            w = localmWindows.get(i);
            ......

            if (canBeImeTarget(w)) {
                ......

                // Yet more tricksyness!  If this window is a &quot;starting&quot;
                // window, we do actually want to be on top of it, but
                // it is not -really- where input will go.  So if the caller
                // is not actually looking to move the IME, look down below
                // for a real window to target...
                if (!willMove
                        &amp;&amp; w.mAttrs.type == WindowManager.LayoutParams.TYPE_APPLICATION_STARTING
                        &amp;&amp; i &gt; 0) {
                    WindowState wb = localmWindows.get(i-1);
                    while (i &gt; 1 &amp;&amp; wb.mAppToken == w.mAppToken &amp;&amp; !canBeImeTarget(wb)) {
                        i--;
                        wb = localmWindows.get(i-1);
                    }
                    if (wb.mAppToken == w.mAppToken &amp;&amp; canBeImeTarget(wb)) {
                        i--;
                        w = wb;
                    }
                }
                break;
            }
        }

        mUpcomingInputMethodTarget = w;</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码从上到下遍历WindowManagerService服务内部的窗口堆栈，即WindowManagerService类的成员变量mWindows所描述的一个ArrayList。如果发现有一个窗口是可见的，并且需要显示输入法窗口，那么整个查找过程就会结束。检查一个窗口是否可见以及需要显示输入法窗口是通过调用WindowManagerService类的成员函数canBeImeTarget来实现的。最后得到的需要显示输入法的窗口就使用WindowState对象w中，这个WindowState对象w接下来还会保存在WindowManagerService类的成员变量mUpcomingInputMethodTarget中，表示它即将要成为输入法窗口的目标窗口。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 参数willMove表示调用者计算输入法窗口在窗口堆栈中的位置的目的。如果它的值等于true，那么就说明调用者获得了输入法窗口在窗口堆栈中的位置之后，接下来就会将输入法窗口移动到需要显示输入法窗口的窗口的上面去，否则的话，就说明调用者只是为了知道输入法窗口在窗口堆栈中的位置，而不打算移动输入法窗口。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在从上到下查找需要显示输入法的窗口的过程中，如果找到一个WindowState对象w，它所描述的窗口需要显示输入法窗口，但是这个窗口其实是一个Activity窗口的启动窗口，即该WindowState对象w的成员变量mAttrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于WindowManager.LayoutParams.TYPE_APPLICATION_STARTING，那么由于调用WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked的目的不是用来移动输入法窗口，而是用来查找输入法窗口在窗口堆栈中的确切位置，因此就不能前面所找到的启动窗口看作是一个需要输入法的窗口，因为这个启动窗口只是Activity窗口在显示过程中出现的一个临时窗口。在这种情况下，这段代码就会继续沿着窗口堆栈往下查找另外一个窗口，该窗口一方面是需要显示输入法窗口的，另一方面要与前面所找到的启动窗口对应的是同一个窗口令牌的。如果能找到这样的一个窗口，那么就会将用来描述它的一个WindowState对象wb保存在变量w中。如果找不到这样的一个窗口，那么这段代码就会继续沿着窗口堆栈往下查找另外一个需要显示输入法的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 我们继续往下阅读代码：</p><p></p><pre name="code" class="java">        if (willMove &amp;&amp; w != null) {
            final WindowState curTarget = mInputMethodTarget;
            if (curTarget != null &amp;&amp; curTarget.mAppToken != null) {

                // Now some fun for dealing with window animations that
                // modify the Z order.  We need to look at all windows below
                // the current target that are in this app, finding the highest
                // visible one in layering.
                AppWindowToken token = curTarget.mAppToken;
                WindowState highestTarget = null;
                int highestPos = 0;
                if (token.animating || token.animation != null) {
                    int pos = 0;
                    pos = localmWindows.indexOf(curTarget);
                    while (pos &gt;= 0) {
                        WindowState win = localmWindows.get(pos);
                        if (win.mAppToken != token) {
                            break;
                        }
                        if (!win.mRemoved) {
                            if (highestTarget == null || win.mAnimLayer &gt;
                                    highestTarget.mAnimLayer) {
                                highestTarget = win;
                                highestPos = pos;
                            }
                        }
                        pos--;
                    }
                }

                if (highestTarget != null) {
                    ......

                    if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
                        // If we are currently setting up for an animation,
                        // hold everything until we can find out what will happen.
                        mInputMethodTargetWaitingAnim = true;
                        mInputMethodTarget = highestTarget;
                        return highestPos + 1;
                    } else if (highestTarget.isAnimating() &amp;&amp;
                            highestTarget.mAnimLayer &gt; w.mAnimLayer) {
                        // If the window we are currently targeting is involved
                        // with an animation, and it is on top of the next target
                        // we will be over, then hold off on moving until
                        // that is done.
                        mInputMethodTarget = highestTarget;
                        return highestPos + 1;
                    }
                }
            }
        }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码用来处理一种特殊情况，即参数willMove的值等于true，并且前面找到了一个需要显示输入法的窗口w，但是当前输入法窗口已经存在一个目标窗口，并且该目标窗口正在切换的过程中。在这种情况下，调用WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked的函数就需要等到当前输入法窗口的目标窗口的切换过程结束之后，再将输入法窗口移动到窗口w的上面去，换句话说，就是要保持输入法窗口在它当前的目标窗口的上面，直到它当前的目标窗口的切换过程结束为止。这样WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked就需要找到当前输入法窗口的目标窗口在窗口堆栈中的位置，然后再将该位置加1后返回给调用者。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;当WindowManagerService类的成员变量mInputMethodTarget的值不等于null，并且它描述的是一个Activity窗口时，即它的成员变量mAppToken的值不等于null时，那么就说明当前输入法窗口已经存在一个目标窗口，而这个目标窗口就是使用WindowManagerService类的成员变量mInputMethodTarget所指向的一个WindowState对象来描述的。接下来这段代码就检查该目标窗口是否正在切换的过程中，即是否正在显示切换动画。如果是的话，那么WindowState对象curTarget的成员变量animating的值就会等于true，或者另外一个成员变量animation的值不等于null，这时候就需要在与该目标窗口所对应的窗口令牌token所描述的一组窗口中，找到一个Z轴位置最大的并且不是已经被移除的窗口。WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked的调用者最后就是需要将输入法窗口移动到这个Z轴位置最大的并且不是已经被移除的窗口的上面的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 一个窗口的Z轴位置是记录在用描述它的一个WindowState对象的成员变量mAnimLayer中的，而它是否是已经被移除是记录在这个WindowState对象的成员变量mRemoved中的，因此，如果在窗口令牌token所描述的一组WindowSate对象中，能找到一个WindowSate对象，它的成员变量mAnimLayer的值最大，并且它的成员变量mRemoved不等于true，那么这段代码就会将它保存在变量highestTarget中，并且将它描述的窗口在窗口堆栈中的位置保存在变量highestPos中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 经过前面的一系列计算之后，如果变量highestTarget的值不等于null，那么就说明我们碰到前面所说的特殊的情况，这时候又要分为两种情况来讨论。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第一种情况是当前输入法窗口的目标窗口即将要进入到切换过程，但是这个切换过程尚开始，即WindowManagerService类的成员变量mNextAppTransition的值不等于WindowManagerPolicy.TRANSIT_UNSET。这时候就需要将WindowManagerService类的成员变量mInputMethodTargetWaitingAnim的值设置为true，表示当前输入法窗口的目标窗口正在等待进入切换动画中，并且需要将WindowManagerService类的成员变量mInputMethodTarget修正为变量highestTarget所描述的一个WindowState对象，因为这个WindowState对象才是真正用来描述当前输入法窗口的目标窗口的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第二种情况是当前输入法窗口的目标窗口已经处于切换的过程了，即变量highestTarget所描述的一个WindowState对象的成员函数isAnimating的返回值为true，并且该目标窗口的Z轴位置大于前面所找到的需要显示输入法窗口的窗口的Z轴，即变量highestTarget所描述的一个WindowState对象的成员变量mAnimLayer的值大于变量w所描述的一个WindowState对象的成员变量mAnimLayer的值。这时候就需要将WindowState对象highestTarget所描述的窗口维持为当前输入法窗口的目标窗口，即将WindowManagerService类的成员变量mInputMethodTarget设置为变量highestTarget，直到WindowState对象highestTarget所描述的窗口的切换过程结束为止。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;上述两种情况最后都需要将WindowState对象highestTarget所描述的窗口在窗口堆栈中的位置highestPos加1，然后再返回给调用者，以便调用者接下来可以输入法窗口移动在窗口堆栈的第（highestPos+1）个位置上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果我们没有碰到前面所说的特殊的情况，那么WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked就会继续往下执行：</p><p></p><pre name="code" class="java">        if (w != null) {
            if (willMove) {
                ......
                mInputMethodTarget = w;
                if (w.mAppToken != null) {
                    setInputMethodAnimLayerAdjustment(w.mAppToken.animLayerAdjustment);
                } else {
                    setInputMethodAnimLayerAdjustment(0);
                }
            }
            return i+1;
        }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 如果变量w的值不等于null，那么就说明WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked在前面找到了一个需要显示输入法窗口的窗口。这个窗口是使用WindowState对象w来描述的，并且它在窗品堆栈中的位置记录在变量i中。这时候WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked就会执行以下三个操作：<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; A. 将WindowState对象w保存在WindowManagerService类的成员变量mInputMethodTarget中，以便WindowManagerService服务可以知道当前输入法窗口的目标窗口是什么。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; B. 检查WindowState对象w描述的窗口是否是Activity窗口，即检查WindowState对象w的成员变量mAppToken的值是否不等于null。如果WindowState对象w描述的窗口是Activity窗口的话，那么就需要根据WindowState对象w的成员变量mAppToken所描述的一个AppWindowToken对象的成员变量animLayerAdjustment来调整系统中的输入法窗口以及输入法对话框的Z轴位置，即在系统中的输入法窗口以及输入法对话框的现有Z轴位置的基础上再增加一个调整量，这个调整量就保存在WindowState对象w的成员变量mAppToken所描述的一个AppWindowToken对象的成员变量animLayerAdjustment中。这个调整的过程是通过调用WindowManagerService类的成员函数setInputMethodAnimLayerAdjustment来实现的。如果WindowState对象w描述的窗口不是Activity窗口，那么就不需要调整系统中的输入法窗口以及输入法对话框的Z轴位置，但是仍然需要调用WindowManagerService类的成员函数setInputMethodAnimLayerAdjustment来将系统中的输入法窗口以及输入法对话框的Z轴位置调整量设置为0，即将WindowManagerService类的成员变量mInputMethodAnimLayerAdjustment的值设置为0。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;C. 将变量i的值加1之后返回给调用者，以便调用者可以将系统中的输入法窗口移动到窗口堆栈中的第（i+1）个位置上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果变量w的值等于null，那么就说明WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked在前面没有找到一个需要显示输入法窗口的窗口，我们继续往下阅读它的代码，以便可以了解它是如何处理这种情况的：</p><p></p><pre name="code" class="java">        if (willMove) {
            ......
            mInputMethodTarget = null;
            setInputMethodAnimLayerAdjustment(0);
        }
        return -1;
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked对在前面没有找到一个需要显示输入法窗口的窗口的情况的处理很简单。它判断参数willMove的值是否等于true。如果等于true的话，那么就会将WindowManagerService类的成员变量mInputMethodTarget的值设置为null，并且调用WindowManagerService类的成员函数setInputMethodAnimLayerAdjustment来将系统中的输入法窗口以及输入法对话框的Z轴位置调整量设置为0。这实际上是用来通知WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked的调用者，系统当前没有需要显示输入法窗口的窗口。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 最后，WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked返回一个-1值给调用者，也是表明系统当前没有需要显示输入法窗口的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2.&nbsp;移动输入法对话框移动到输入法窗口的上面</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 系统中的输入法对话框是需要位于输入法窗口的上面的，因此，我们就需要有一个函数来将输入法对话框移动到输入法窗口的上面去。这个函数就是WindowManagerService类的成员函数moveInputMethodDialogsLocked，它的实现如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    void moveInputMethodDialogsLocked(int pos) {
        ArrayList&lt;WindowState&gt; dialogs = mInputMethodDialogs;

        final int N = dialogs.size();
        ......
        for (int i=0; i&lt;N; i++) {
            pos = tmpRemoveWindowLocked(pos, dialogs.get(i));
        }
        ......

        if (pos &gt;= 0) {
            final AppWindowToken targetAppToken = mInputMethodTarget.mAppToken;
            if (pos &lt; mWindows.size()) {
                WindowState wp = mWindows.get(pos);
                if (wp == mInputMethodWindow) {
                    pos++;
                }
            }
            ......
            for (int i=0; i&lt;N; i++) {
                WindowState win = dialogs.get(i);
                win.mTargetAppToken = targetAppToken;
                pos = reAddWindowLocked(pos, win);
            }
            ......
            return;
        }
        for (int i=0; i&lt;N; i++) {
            WindowState win = dialogs.get(i);
            win.mTargetAppToken = null;
            reAddWindowToListInOrderLocked(win);
            ......
        }
    }

    ......
}</pre><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在调用WindowManagerService类的成员函数moveInputMethodDialogsLocked之前，必须要保证系统中的输入法窗口已经被移动到窗口堆栈的正确位置，即已经被移动到需要显示输入法窗口的窗口的上面。这时候参数pos描述的或者是输入法窗口在窗口堆栈中的位置，或者是输入法窗口在窗口堆栈的位置的上一个位置，即输入法对话框在窗口堆栈中的起始位置。参数pos的值还可以小于0，这时候就表示系统当前没有需要显示输入法窗口的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在移动输入法对话框到输入法窗口的上面之前，首先要将输入法对话框从窗口堆栈中移除，以便接下来可以重新将它们插入到窗口堆栈中。系统中的输入法对话框都保存在WindowManagerService类的成员变量mInputMethodDialogs所描述的一个ArrayList中，通过调用WindowManagerService类的成员函数来tmpRemoveWindowLocked来移除保存在这个ArrayList中的每一个WindowState对象，就可以将系统中的输入法对话框从窗口堆栈中移除中。注意，将一个WindowState对象从窗口堆栈中移除之后，可能会影响参数pos的值。例如，如果参数pos的值大于被移除的WindowState对象原来在窗口堆栈中的位置值，那么在该WindowState对象被移除之后，参数pos的值就要相应地减少1，这样它才能正确地反映输入法窗口在窗口堆栈中的位置，或者输入法对话框在窗口堆栈中的起始位置。WindowManagerService类的成员函数来tmpRemoveWindowLocked在将一个WindowState对象从窗口堆栈中移除的过程中，会正确处理好参数pos的值，这一点可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService组织窗口的方式分析</a>一文。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 接下来，我们就分为两种情况来分析输入法对话框在窗口是如何移动到输入法窗口的上面去的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第一种情况是参数pos的值大于等于0，这表明系统当前存在一个需要显示输入法窗口的窗口，这个窗口是通过WindowManagerService类的成员变量mInputMethodTarget所指向的一个WindowState对象来描述的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 前面提到，参数pos描述的或者是输入法窗口在窗口堆栈中的位置，或者是输入法对话框在窗口堆栈中的起始位置，我们首先要将它统一描述为输入法对话框在窗口堆栈中的起始位置。这时候就需要检查保存在窗口堆栈的第pos个位置的WindowState对象wp，是否就是WindowManagerService类的成员变量mInputMethodWindow所指向的那个WindowState对象。如果是的话，那么就说明参数pos描述的或者是输入法窗口在窗口堆栈中的位置，这时候将它的值增加1，就可以让它表示为输入法对话框在窗口堆栈中的起始位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 得到了输入法对话框在窗口堆栈中的起始位置pos之后，接下来只需要调用WindowManagerService类的成员函数reAddWindowLocked来依次地将保存在WindowManagerService类的成员变量mInputMethodDialogs所描述的一个ArrayList中的第i个WindowState对象保存在窗口堆栈中的第（pos+i）个以位置上即可，这样就可以将输入法对话框都移动到输入法窗口的上面去了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;注意，在移动的过程中，用来描述每一个输入法对话框的每一个WindowState对象的成员变量mTargetAppToken的值设置为WindowManagerService类的成员变量mInputMethodTarget所描述的一个WindowState对象的成员变量mAppToken的值，以便可以将输入法对话框和输入法窗口的目标窗口设置为同一个窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;第二种情况是参数pos的值小于0，这表明系统当前不存在一个需要显示输入法窗口的窗口。这时候就需要根据输入法窗口自身的属性来将它们移动到窗口堆栈的合适的位置上去，这是通过调用WindowManagerService类的成员函数reAddWindowToListInOrderLocked来实现的。WindowManagerService类的成员函数reAddWindowToListInOrderLocked的实现可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService组织窗口的方式分析</a>一文，这里不再详细。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注意，在移动的过程中，用来描述每一个输入法对话框的每一个WindowState对象的成员变量mTargetAppToken的值会被设置为null，这是因为系统当前不存在一个需要显示输入法窗口的窗口，即这时候每一个输入法对话框都没有目标窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 理解了WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked和moveInputMethodDialogsLocked的实现之后，对WindowManagerService类的另外三个成员函数addInputMethodWindowToListLocked、adjustInputMethodDialogsLocked和moveInputMethodWindowsIfNeededLocked的实现就很有帮助，接下来我们就继续分析这三个成员函数的实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. 插入输入法窗口到需要显示输入法窗口的窗口上面</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;插入输入法窗口到窗口堆栈的合适位置，使得它位于需要显示输入法窗口的窗口上面，这是通过调用WindowManagerService类的成员函数addInputMethodWindowToListLocked来实现的，它的实现如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    void addInputMethodWindowToListLocked(WindowState win) {
        int pos = findDesiredInputMethodWindowIndexLocked(true);
        if (pos &gt;= 0) {
            win.mTargetAppToken = mInputMethodTarget.mAppToken;
            ......
            mWindows.add(pos, win);
            mWindowsChanged = true;
            moveInputMethodDialogsLocked(pos+1);
            return;
        }
        win.mTargetAppToken = null;
        addWindowToListInOrderLocked(win, true);
        moveInputMethodDialogsLocked(pos);
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 参数win描述的是要添加到窗口堆栈中去的输入法窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowManagerService类的成员函数addInputMethodWindowToListLocked首先调用另外一个成员函数findDesiredInputMethodWindowIndexLocked来计算输入法窗口在窗口堆栈中的位置，并且保存在变量pos。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果变量pos的值大于等于0，那么就说明WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked在窗口堆栈中找到了一个合适的位置来放置输入法窗口，于是接下来就会参数win所描述的输入法窗口插入在WindowManagerService类的成员变量mWIndows所描述的窗口堆栈的第pos个位置上。由于系统中的输入法对话框要保持在输入法窗口的上面，因此，WindowManagerService类的成员函数addInputMethodWindowToListLocked还需要继续调用另外一个成员函数moveInputMethodDialogsLocked来将系统中的输入法对话框在窗口堆栈中的起始位置设置为（pos+1）。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 还有一个地方需要注意的是，前面在调用WindowManagerService类的成员函数addInputMethodWindowToListLocked来计算输入法窗口在窗口堆栈中的位置的时候，已经将用来描述需要显示输入法窗口的Activity窗口的一个WindowState对象保存了WindowManagerService类的成员变量mInputMethodTarget中，因此，这里就需要这个WindowState对象的成员变量mAppToken所指向的一个AppWindowToken对象保存在用来描述输入法窗口的WindowState对象的win的成员变量mTargetAppToken中，以便WindowManagerService服务可以知道当前输入法窗口的目标窗口是什么。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果变量pos的值小于0，那么就说明WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked没有找一个需要输入法窗口的窗口，因此，这时候就需要调用另外一个成员函数addWindowToListInOrderLocked来将参数win所描述的输入法窗口插入到窗口堆栈中去。WindowManagerService类的成员函数addWindowToListInOrderLocked会根据要目标窗口所对应的窗口令牌在窗口令牌列表中的位置以及是否在窗口堆栈中存在其它窗口等信息来在窗口堆栈中找到一个合适的前位置来放置目标窗口，它的具体实现可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService组织窗口的方式分析</a>一文。将参数win所描述的输入法窗口插入到窗口堆栈中去之后，WindowManagerService类的成员函数addInputMethodWindowToListLocked还需要继续调用另外一个成员函数moveInputMethodDialogsLocked来调整系统中的输入法对话框。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注意，在调用WindowManagerService类的成员函数moveInputMethodDialogsLocked的时候，传递进去的参数pos的值等于-1，这时候WindowManagerService类的成员函数moveInputMethodDialogsLocked就不是直接调整输入法对话框在窗口堆栈中的位置的，而是调用另外一个成员函数reAddWindowToListInOrderLocked来调整的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 还有另外一个地方需要注意的是，由于前面在调用WindowManagerService类的成员函数findDesiredInputMethodWindowIndexLocked的时候，没有找到一个需要输入法窗口的窗口，因此，这里就需要将参数win所描述的一个WindowState对象的成员变量mTargetAppToken的值设置为null，以便WindowManagerService服务可以知道当前输入法窗口的没有目标窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4. 调整输入法对话框在窗口堆栈的位置</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 一旦系统中存在需要显示输入法窗口的窗口，那么就需要系统中的输入法对话框在窗口堆栈中的位置，使得它们放置在输入法窗品的上面，这是通过调用WindowManagerService类的成员函数adjustInputMethodDialogsLocked来实现的，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    void adjustInputMethodDialogsLocked() {
        moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(true));
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数adjustInputMethodDialogsLocked的实现很简单，它首先调用成员函数findDesiredInputMethodWindowIndexLocked来找到输入法窗口在窗口堆栈中的位置，然后再调用成员函数moveInputMethodDialogsLocked来将输入法对话框保存在这个位置之上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5.&nbsp;调整输入法窗口在窗口堆栈的位置</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 当系统中的窗口布局发生了变化之后，例如，当前获得焦点的窗口发生了变化，或者新增了一个窗口，那么都可能需要调整输入法窗口在窗口堆栈中的位置，以便它可以痊于需要显示输入法窗口的窗口的上面，这是通过调用WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked来实现的，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    boolean moveInputMethodWindowsIfNeededLocked(boolean needAssignLayers) {
        final WindowState imWin = mInputMethodWindow;
        final int DN = mInputMethodDialogs.size();
        if (imWin == null &amp;&amp; DN == 0) {
            return false;
        }

        int imPos = findDesiredInputMethodWindowIndexLocked(true);
        if (imPos &gt;= 0) {
            // In this case, the input method windows are to be placed
            // immediately above the window they are targeting.

            // First check to see if the input method windows are already
            // located here, and contiguous.
            final int N = mWindows.size();
            WindowState firstImWin = imPos &lt; N
                    ? mWindows.get(imPos) : null;

            // Figure out the actual input method window that should be
            // at the bottom of their stack.
            WindowState baseImWin = imWin != null
                    ? imWin : mInputMethodDialogs.get(0);
            if (baseImWin.mChildWindows.size() &gt; 0) {
                WindowState cw = baseImWin.mChildWindows.get(0);
                if (cw.mSubLayer &lt; 0) baseImWin = cw;
            }

            if (firstImWin == baseImWin) {
                // The windows haven't moved...  but are they still contiguous?
                // First find the top IM window.
                int pos = imPos+1;
                while (pos &lt; N) {
                    if (!(mWindows.get(pos)).mIsImWindow) {
                        break;
                    }
                    pos++;
                }
                pos++;
                // Now there should be no more input method windows above.
                while (pos &lt; N) {
                    if ((mWindows.get(pos)).mIsImWindow) {
                        break;
                    }
                    pos++;
                }
                if (pos &gt;= N) {
                    // All is good!
                    return false;
                }
            }

            if (imWin != null) {
                ......
                imPos = tmpRemoveWindowLocked(imPos, imWin);
                ......
                imWin.mTargetAppToken = mInputMethodTarget.mAppToken;
                reAddWindowLocked(imPos, imWin);
                ......
                if (DN &gt; 0) moveInputMethodDialogsLocked(imPos+1);
            } else {
                moveInputMethodDialogsLocked(imPos);
            }

        } else {
            // In this case, the input method windows go in a fixed layer,
            // because they aren't currently associated with a focus window.

            if (imWin != null) {
                ......
                tmpRemoveWindowLocked(0, imWin);
                imWin.mTargetAppToken = null;
                reAddWindowToListInOrderLocked(imWin);
                ......
                if (DN &gt; 0) moveInputMethodDialogsLocked(-1);;
            } else {
                moveInputMethodDialogsLocked(-1);;
            }

        }

        if (needAssignLayers) {
            assignLayersLocked();
        }

        return true;
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked首先检查系统中是否存在输入法窗口和输入法对话框，即检查WindowManagerService类的成员变量mInputMethodWindow的值是否等于null，并且WindowManagerService类的成员变量mInputMethodDialogs所描述的一个ArrayList的大小是否等于0。如果输入法窗口和输入法对话框都不存在的话，那么就不用调整它们在窗口堆栈中的位置了，否则的话，WindowManagerService类的成员变量mInputMethodWindow所指向的一个WindowState对象就会保存在变量imWin中，以便接下来可以通过它来描述系统中的输入法窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;在输入法窗口或者输入法对话框存在的情况下，WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked接下来就会继续调用另外一个成员函数findDesiredInputMethodWindowIndexLocked来找到输入法窗口在窗口堆栈中的位置，并且保存在变量imPos中。注意，变量imPos的值可能大于等于0，也可能等于-1。当变量imPos的值大于等于0的时候，就说明系统当前存在一个窗口需要显示输入法窗口，而当变量imPos的值等于-1的时候，就说明系统当前不存在一个窗口需要显示输入法窗口，或者系统中不存在输入法窗口。接下来我们分两种情况来分析WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked的实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第一种情况是变量imPos的值可能大于等于0。这时候可能需要调整输入法窗口在窗口堆栈中的位置，也可能不需要调整输入法窗口在窗口堆栈中的位置，取决于输入法窗口的位置是否已经在窗口堆栈的第imPos个位置上，以及是否所有与输入法相关的窗口都连续在放置在窗口堆栈中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 变量firstImWin描述的是当前位于窗口堆栈中Z轴位置最小的与输入法相关的窗口，它是通过变量imPos来获得的。另外一个变量baseImWin描述的是Z轴位置最小的与输入法相关的窗口。如果这两个变量描述的是同一个窗口，那么就说明输入法窗口的位置已经在窗口堆栈的第imPos个位置上，因此，就有可能不需要调整输入法窗品在窗口堆栈中的位置了。接下来我们就描述如何找到这个Z轴位置最小的与输入法相关的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果变量imWin的值不等于null，即WindowManagerService类的成员变量mInputMethodWindow的值不等于null，那么它所描述的窗口就是Z轴位置最小的与输入法相关的窗口，否则的话，Z轴位置最小的与输入法相关的窗口就是位于WindowManagerService类的成员变量mInputMethodDialogs所描述的一个ArrayList的第0个位置上的输入法对话框。这一步得到的Z轴位置最小的与输入法相关的窗口就保存在变量baseImWin中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果变量baseImWin所描述的窗口有子窗口，即它所指向的一个WindowState对象的成员变量mChildWindows所描述的一个ArrayList的大小大于0。这时候如果用来描述第一个子窗口的WindowState对象的成员变量mSubLayer的值小于0，那么就说明变量baseImWin所描述的窗口在所有与输入法相关的窗口中的Z轴位置还不是最小的，因为在它的下面还存在着Z轴位置更小的子窗口。在这种情况下，变量baseImWin就会指向这个Z轴位置最小的子窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 经过上面的一系列计算之后，如果变量firstImWin和变量baseImWin描述的是同一个窗口，那么还需要继续判断所有与输入法相关的窗口都连续在放置在窗口堆栈中。判断的方法如下所示：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;(1). 从窗口堆栈的第（imPos + 1）个位置开始往上查找一个非输入法相关的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;(2). 如果第(1)步能在窗口堆栈中大于等于（imPos+1）的位置pos上找到一个非输入法窗口，那么再继续从第pos个位置开始往上查找一个与输入法相关的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;(3). 如果第(2)步能在窗口堆栈中找到一个与输入法相关的窗口，那么就说明所有与输入法相关的窗口不是连续在放置在窗口堆栈中的，因为在它们中间有一个非输入法相关的窗口，否则的话，就说明所有与输入法相关的窗口都是连续在放置在窗口堆栈中的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在所有与输入法相关的窗口都是连续在放置在窗口堆栈中的情况下，WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked就会直接返回一个false值给调用者，表明不需要调整系统中的输入法窗口以及输入法对话框在窗口堆栈中的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在所有与输入法相关的窗口不是连续在放置在窗口堆栈中的情况下，就需要重新调整系统中的输入法窗口以及输入法对话框在窗口堆栈中的位置。这里又需要分两个情景来讨论。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第一个情景是变量imWin的值不等于null，这时候说明系统中存在一个输入法窗口，因此，就需要调整这个输入法窗口在窗口堆栈中的位置。调整的方法很简单：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; (1). 调用WindowManagerService类的成员函数tmpRemoveWindowLocked来从窗口堆栈中移除变量imWin所描述的输入法窗口。在移除的过程中，会同时计算输入法窗口在窗口堆栈中的新位置，这个位置还是保存在变量imPos中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; (2). 调用WindowManagerService类的成员函数reAddWindowLocked重新将变量imWin所描述的输入法窗口插入到窗口堆栈的第imPos个位置中。在插入之前，还会将变量imWin所描述的一个WindowState对象的成员变量mTargetAppToken与WindowManagerService类的成员变量mInputMethodTarget所描述的一个WindowState对象的成员变量mAppToken指向同一个AppWindowToken对象，这样WindowManagerService服务就可以知道imWin所描述的输入法窗口的目标窗口是什么。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; (3). 如果系统中还存在输入法对话框，那么就调用WindowManagerService类的成员函数moveInputMethodDialogsLocked来将它们放置在第（imPos+1）个位置上，目的是将它们放置在输入法窗口的上面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;第二个情景是变量imWin的值等于null，这时候说明系统中不存在输入法窗口。在这个情景下，系统中肯定会存在输入法对话框，否则的话，WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked在前面就会返回了。因此，WindowManagerService类的成员函数moveInputMethodWindowsIfNeededLocked接下来就会直接调用成员函数moveInputMethodDialogsLocked来将系统中的输入法对话框放置在在第imPos个位置上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;第二种情况是变量imPos的值等于-1。这时候说明系统中不存在需要显示输入法窗口的窗口。这里同样也需要分两个情景来分析。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第一个情景是变量imWin的值不等于null，这时候说明系统中存在一个输入法窗口，因此，就需要调整这个输入法窗口在窗口堆栈中的位置。调整的方法与前面第一种情况的第一个情景是类似的。不过由于事先不知道输入法窗口在窗口堆栈中的位置，因此，这里就会调用WindowManagerService类的成员函数reAddWindowToListInOrderLocked和moveInputMethodDialogsLocked来间接地调整输入法窗口和输入法对话框在窗口堆栈中的位置。注意，在调用WindowManagerService类的成员函数moveInputMethodDialogsLocked的时候，传进去的参数为-1。另外一个地方需要注意的是，在WindowManagerService类的成员函数reAddWindowToListInOrderLocked来间接地调整输入法窗口在窗口堆栈中的位置之前，会将量imWin所描述的一个WindowState对象的成员变量mTargetAppToken的值设置为null，这样WindowManagerService服务就可以知道imWin所描述的输入法窗口没有目标窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 第二情景是变量imWin的值等于null，这时候系统中不存在输入法窗口。这个情景与前面第一种情况的第二个情景也是类似的。由于系统中不存在输入法窗口，因此只需要调用WindowManagerService类的成员函数moveInputMethodDialogsLocked来间接地输入法对话框在窗口堆栈中的位置即可，即以参数-1来调用WindowManagerService类的成员函数moveInputMethodDialogsLocked。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 至此，我们就分析完成WindowManagerService服务对输入法窗口的基本操作了。从分析的过程中，我们可以得到以下两个结论：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; A. 系统中与输入法相关的窗口有两种，一种是输入法窗口，另一种是输入法对话框。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; B. 当Z轴位置最大的窗口需要使用输入法时，输入法窗口就会位于它的上面，而输入法对话框又会位于输入法窗口的上面。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在WindowManagerService服务中，还有一种类型的窗口与输入法窗口类似，它总是与Activity窗口粘在一起。不过，这种类型的窗口是位于Activity窗口的下面，刚好与输入法窗口相反，它就是壁纸窗口（Wallpaper）。在接下来的一篇文章中，我们就将继续分析WindowManagerService服务是如何管理系统中的壁纸窗口的。敬请关注！</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p>
            <div>
                作者：Luoshengyang 发表于2013-1-28 0:57:09 <a href="http://blog.csdn.net/luoshengyang/article/details/8526644">原文链接</a>
            </div>
            <div>
            阅读：2245 评论：15 <a href="http://blog.csdn.net/luoshengyang/article/details/8526644#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
    <item>
        <title><![CDATA[[原]Android窗口管理服务WindowManagerService对壁纸窗口（Wallpaper Window）的管理分析]]></title>
        <link>http://blog.csdn.net/luoshengyang/article/details/8550820</link>
        <guid>http://blog.csdn.net/luoshengyang/article/details/8550820</guid>
        <author>Luoshengyang</author>
        <pubDate>2013-2-4 0:56:36</pubDate>
        <description><![CDATA[
            <p>&nbsp; &nbsp; &nbsp; &nbsp; 在Android系统中，壁纸窗口和输入法窗口一样，都是一种特殊类型的窗口，而且它们都是喜欢和一个普通的Activity窗口缠绵在一起。大家可以充分地想象这样的一个3W场景：输入法窗口在上面，壁纸窗口在下面，Activity窗口夹在它们的中间。在前面一篇文章中，我们已经分析过输入法窗口是如何压在Activity窗口上面的了。在这篇文章中，我们就将继续分析壁纸窗口是如何贴在Activity窗口下面的。</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span><br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 一个Activity窗口如果需要显示壁纸，那么它必须满足以下两个条件：</p><p>&nbsp; &nbsp; &nbsp; &nbsp;1. 背景是半透明的，例如，它在AndroidManifest.xml文件中的android:theme属性设置为Theme.Translucent：</p><p></p><pre name="code" class="html">&lt;activity android:name=&quot;.WallpaperActivity&quot;
    android:theme=&quot;@android:style/Theme.Translucent&quot;&gt;
    ......
&lt;/activity&gt;</pre>&nbsp; &nbsp; &nbsp; &nbsp;2. 窗口属性中的WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER位设置为1：<p></p><p></p><pre name="code" class="java">public class WallpaperActivity extends Activity {
    ......

    @Override
    public void onCreate(Bundle savedInstanceState) { 
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
            
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER);
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;满足了以上两个条件之后，Activity窗口和壁纸窗口的位置关系就如图1所示：<p></p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201301/28/1359388310_7601.jpg" alt="" /></p><p style="text-align: center;">图1 Activity窗口和Wallpaper窗口的位置关系</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在前面<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService组织窗口的方式分析</a>一文中提到，WindowManagerService服务是使用堆栈来组织系统中的窗口的，因此，如果我们在窗口堆栈中观察Activity窗口和壁纸窗口，它们的位置关系就如图2所示：<br /></p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/29/1359389051_3027.jpg" alt="" /><br /></p><p style="text-align: center;">图2 Activity窗口和Wallpaper窗口在窗口堆栈中的位置关系</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;图2中的对象的关系如下所示：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 在ActivityManagerService服务内部的Activity组件堆栈顶端的ActivityRecord对象N描述的是系统当前激活的Activity组件。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. ActivityRecord对象N在WindowManagerService服务内部的窗口令牌列表顶端对应有一个AppWindowToken对象N。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. AppWindowToken对象N在WindowManagerService服务内部的窗口堆栈中对应有一个WindowState对象N，用来描述系统当前激活的Activity组件窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4. WindowState对象N下面有一个WindowState对象WP，用来描述系统中的壁纸窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5. 系统中的壁纸窗口在WindowManagerService服务内部中对应的窗口令牌是由WindowToken对象WP来描述的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 6. WindowToken对象WP在WallpaperManagerService服务中对应有一个Binder对象。&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;总的来说，就是图2描述了系统当前激活的Activity窗口需要显示壁纸的情景。WindowManagerService服务的职能之一就是要时刻关注系统中是否有窗口需要显示壁纸。WindowManagerService服务一旦发现有窗口需要显示壁纸，那么就会调整壁纸窗口在窗口堆栈中的位置，使得它放置在需要显示壁纸的窗口的下面。此外，需要显示壁纸的窗口还可以设置壁纸窗口在X轴和Y轴上的偏移位置，以便可以将壁纸窗口的某一部分指定为它的背景。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;接下来，我们就首先分析两个需要调整壁纸窗口在窗口堆栈中的位置的情景，然后再分析壁纸窗口在X轴和Y轴上的偏移位置的调整过程，最后分析壁纸窗口在窗口堆栈中的位置调整过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 一.&nbsp;调整壁纸窗口在窗口堆栈中的位置的情景</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;第一个需要调整壁纸窗口在窗口堆栈中的位置的情景是增加一个窗口到WindowManagerService服务去的时候。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8275938">Android应用程序窗口（Activity）与WindowManagerService服务的连接过程分析</a>一文可以知道，增加一个窗口到WindowManagerService服务最终是通过调用WindowManagerService类的成员函数addWindow来实现的。接下来我们就主要分析这个函数中与壁纸窗口调整相关的逻辑，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    public int addWindow(Session session, IWindow client,
            WindowManager.LayoutParams attrs, int viewVisibility,
            Rect outContentInsets, InputChannel outInputChannel) {
        ......

        synchronized(mWindowMap) {
            ......

            WindowToken token = mTokenMap.get(attrs.token);
            if (token == null) {
                ......

                if (attrs.type == TYPE_WALLPAPER) {
                    ......
                    return WindowManagerImpl.ADD_BAD_APP_TOKEN;
                }
                
                ......
            } 
            ......

            win = new WindowState(session, client, token,
                    attachedWindow, attrs, viewVisibility);
            ......

            if (attrs.type == TYPE_INPUT_METHOD) {
                ......
            } else if (attrs.type == TYPE_INPUT_METHOD_DIALOG) {
                ......
            } else {
                addWindowToListInOrderLocked(win, true);
                if (attrs.type == TYPE_WALLPAPER) {
                    ......
                    adjustWallpaperWindowsLocked();
                } else if ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != 0) {
                    adjustWallpaperWindowsLocked();
                }
            }
            ......

            assignLayersLocked();

            ......
        }

        ......
    }

    ......
}       </pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果当前增加到WindowManagerService服务来的是一个壁纸窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于TYPE_WALLPAPER，那么就要求与该壁纸窗口所对应的类型为WindowToken的窗口令牌已经存在，否则的话，WindowManagerService类的成员函数addWindow就会直接返回一个错误码WindowManagerImpl.ADD_BAD_APP_TOKEN给调用者。这个类型为WindowToken的窗口令牌是WallpaperManagerService服务请求WindowManagerService服务创建的，即调用WindowManagerService类的成员函数addWindowToken来创建的，具体可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService组织窗口的方式分析</a>一文。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果当前增加到WindowManagerService服务来的既不是一个输入法窗口，也不是一个输入法对话框，那么WindowManagerService类的成员函数addWindow就会调用另外一个成员函数addWindowToListInOrderLocked来将前面为它所创建的一个WindowState对象win增加到窗口堆栈的合适位置上去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果前面增加到窗口堆栈中的窗口是一个壁纸窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量type的值等于TYPE_WALLPAPER，或者是一个需要显示壁纸的窗口，即参数attrs所描述的一个WindowManager.LayoutParams对象的成员变量flags的值的FLAG_SHOW_WALLPAPER位等于1，那么就说明需要调整壁纸窗口在窗口堆栈中的位置，使得它位于需要显示壁纸的窗口的下面，这是通过调用WindowManagerService类的成员函数adjustWallpaperWindowsLocked来实现的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 最后，由于增加了一个窗口到窗口堆栈中，以及窗口堆栈的窗口位置发生了变化，因此，就需要重新各个窗口的Z轴位置，这是通过调用WindowManagerService类的成员函数assignLayersLocked来实现的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在这个情景中，主要涉及到了WindowManagerService类的三个成员函数addWindowToListInOrderLocked、adjustWallpaperWindowsLocked和assignLayersLocked，其中，成员函数addWindowToListInOrderLocked的实现可以参考前面前面<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService组织窗口的方式分析</a>一文，成员函数assignLayersLocked的实现在接下来的一篇文章中再分析，本文主要是关注成员函数adjustWallpaperWindowsLocked的实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;第二个需要调整壁纸窗口在窗口堆栈中的位置的情景是一个应用程序进程请求WindowManagerService服务重新布局一个窗口的时候。从前面<a href="http://blog.csdn.net/luoshengyang/article/details/8479101">Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析</a>一文可以知道，应用程序进程请求WindowManagerService服务重新布局一个窗口最终是通过调用WindowManagerService类的成员函数relayoutWindow来实现的。接下来我们就主要分析这个函数中与壁纸窗口调整相关的逻辑，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    public int relayoutWindow(Session session, IWindow client,
            WindowManager.LayoutParams attrs, int requestedWidth,
            int requestedHeight, int viewVisibility, boolean insetsPending,
            Rect outFrame, Rect outContentInsets, Rect outVisibleInsets,
            Configuration outConfig, Surface outSurface) {
        boolean displayed = false;
        ......

        synchronized(mWindowMap) {
            WindowState win = windowForClientLocked(session, client, false);
            ......

            int attrChanges = 0;
            ......
            if (attrs != null) {
                ......
                attrChanges = win.mAttrs.copyFrom(attrs);
            }
            ......

            boolean wallpaperMayMove = win.mViewVisibility != viewVisibility
                    &amp;&amp; (win.mAttrs.flags &amp; FLAG_SHOW_WALLPAPER) != 0;
            ......

            if (viewVisibility == View.VISIBLE &amp;&amp;
                    (win.mAppToken == null || !win.mAppToken.clientHidden)) {
                displayed = !win.isVisibleLw();
                ......

                if ((attrChanges&amp;WindowManager.LayoutParams.FORMAT_CHANGED) != 0) {
                    // To change the format, we need to re-build the surface.
                    win.destroySurfaceLocked();
                    displayed = true;
                }
                ......
            }
            ......

            boolean assignLayers = false; 
            ......

            if (wallpaperMayMove) {
                if ((adjustWallpaperWindowsLocked()&amp;ADJUST_WALLPAPER_LAYERS_CHANGED) != 0) {
                    assignLayers = true;
                }
            }
            ......

            if (assignLayers) {
                assignLayersLocked();
            }
            ......

            performLayoutAndPlaceSurfacesLocked();
            if (displayed &amp;&amp; win.mIsWallpaper) {
                updateWallpaperOffsetLocked(win, mDisplay.getWidth(),
                        mDisplay.getHeight(), false);
            }
            ......

        }

        ......

        return (inTouchMode ? WindowManagerImpl.RELAYOUT_IN_TOUCH_MODE : 0)  
                | (displayed ? WindowManagerImpl.RELAYOUT_FIRST_TIME : 0);  
    }  
  
    ......  
} </pre><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 应用程序进程在请求WindowManagerService服务重新布局一个窗口的时候，这个窗口的一些布局参数可能会发生变化，而这些变化可能会引发系统的壁纸窗口在窗口堆栈中的位置发生变化。如果系统的壁纸窗口在窗口堆栈中的位置发生了变化，那么就需要调整它们在窗口堆栈中的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数relayoutWindow首先调用根据参数session和client来调用另外一个成员函数windowForClientLocked，以便可以获得用来描述要重新布局的窗口的一个WindowState对象win。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowState对象win的成员变量mViewVisibility描述的是窗口上一次布局时的可见性，而参数viewVisibility描述的是窗口当前的可见性，当它们的值不相等时，就意味着窗口的可见性发生了变化。在窗口的可见性发生了变化的情况下，如果正在请求重新布局的是一个需要显示壁纸的窗口，即WindowState对象win的成员变量mAttrs所指向的是一个WindowManager.LayoutParams对象的成员变量flags的FLAG_SHOW_WALLPAPER位等于1，那么就说明可能需要调整壁纸窗口在窗口堆栈中的位置，以便它可以位于WindowState对象win所描述的窗口的下面，这时候变量wallpaperMayMove的值就会等于true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数relayoutWindow执行了一系列的其它操作之后，接下来就会判断变量wallpaperMayMove的值是否等于true。如果等于true的话，那么就会调用另外一个成员函数adjustWallpaperWindowsLocked来调整壁纸窗口在窗口堆栈中的位置，以便它可以位于需要显示壁纸的窗口的下面。WindowManagerService类的成员函数adjustWallpaperWindowsLocked的返回值是一个整数，当它的ADJUST_WALLPAPER_LAYERS_CHANGED位等于1的时候，就说明壁纸窗口在窗口堆栈的位置发生了变化，于是就会将变量assignLayers的值设置为true，以便接下来可以调用WindowManagerService类的成员函数assignLayersLocked来重新计算系统中各个窗品的Z轴位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 变量displayed用来描述WindowState对象win所描述的窗口在当前布局中是由不可见变为可见的。在满足以下的条件之下，WindowState对象win所描述的窗口是由不可见变为可见的：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 参数viewVisibility的值等于View.VISIBLE，即应用程序进程请求显示WindowState对象win所描述的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2.&nbsp;WindowState对象win描述的是一个Activity窗口，即它的成员变量mAppToken不等于null，并且它所指向的AppWindowToken对象的成员变量clientHidden的值等于false，即WindowState对象win的窗口所对应的Activity组件当前是可见的。注意，如果WindowState对象win描述的不是一个Activity窗口，即它的成员变量mAppToken等于null，那么就可以忽略条件2。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3.&nbsp;WindowState对象win所描述的窗口上一次是不可见的，即调用WindowState对象win的成员函数isVisibleLw的返回值等于false。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 此外，在满足条件1和条件2的情况下，如果WindowState对象win所描述的窗口的像素格式发生了变化，那么就需要将该窗口的绘图表面销毁掉，然后再重新创建一个，这时候也会认为该窗口由不可见变为了可见。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;参数attrs所指向的一个WindowManager.LayoutParams对象是用来保存WindowState对象win所描述的窗口在当前布局中所使用的布局参数的，而WindowState对象win的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象是用来保存WindowState对象win所描述的窗口在上一次布局所使用的布局参数的。在将参数attrs所指向的一个WindowManager.LayoutParams对象的内容拷贝到WindowState对象win的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的过程中，如果某些布局参数发生了变化，那么就会记录在变量attrChanges中。当变量attrChanges的WindowManager.LayoutParams.FORMAT_CHANGED位等于1时，就说明WindowState对象win所描述的窗口的像素格式发生了变化，因此，WindowManagerService类的成员函数relayoutWindow就会调用WindowState对象win的成员函数destroySurfaceLocked来销毁该窗口的绘图表面，并且将变量displayed的值设置为true。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数relayoutWindow调用另外一个成员函数performLayoutAndPlaceSurfacesLocked来对WindowState对象win所描述的窗口进行了布局之后，如果发现变量displayed的值等于true，并且WindowState对象win描述的是一个壁纸窗口，即它的成员变量mIsWallpaper的值等于true，那么还需要调用另外一个成员函数updateWallpaperOffsetLocked来重新计算该壁纸窗口在X轴和Y轴上的偏移位置，以便可以将它的某一部分区域指定在需要显示壁纸的窗口的背景。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在这个情景中，主要涉及到了WindowManagerService类的四个成员函数adjustWallpaperWindowsLocked、updateWallpaperOffsetLocked、performLayoutAndPlaceSurfacesLocked和assignLayersLocked，其中，成员函数performLayoutAndPlaceSurfacesLocked的实现框架可以参考前面<a href="http://blog.csdn.net/luoshengyang/article/details/8479101">Android窗口管理服务WindowManagerService计算Activity窗口大小的过程分析</a>一文，成员函数assignLayersLocked的实现如上所述在接下来的一篇文章中再分析，本文主要是关注成员函数adjustWallpaperWindowsLocked和updateWallpaperOffsetLocked的实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;从上面的分析就可以知道，在布局一个窗口的过程中，可能需要调用WindowManagerService类的成员函数updateWallpaperOffsetLocked和adjustWallpaperWindowsLocked来调整壁纸窗口在X轴和Y轴上的偏移位置和在窗口堆栈中的位置。接下来我们就分别分析壁纸窗口在X轴和Y轴上的偏移位置和在窗口堆栈中的位置的调整过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 二. 调整壁纸窗口在X轴和Y轴上的偏移位置</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 壁纸窗口的大小是可以大于屏幕大小的。在这种情况下，需要显示壁纸的Activity窗口就需要指定壁纸在X轴和Y轴上的偏移位置，以便可以将壁纸的某一部分作为窗口的背景。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 假设壁纸窗口的大小为（WallpaperWidth, WallpaperHeight），屏幕的大小为（DisplayWidth, DisplayHeight），并且壁纸在X轴和Y轴上的偏移位置为WallpaperX和WallpaperY，其中，WallpaperWidth &gt;&nbsp;DisplayWidth，WallpaperHeight &gt;&nbsp;DisplayHeight，0.0 &lt;= WallpaperX &lt;= 1.0，0.0 &lt;= WallpaperY &lt;= 1.0，如图3所示：</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/30/1359476847_8350.jpg" alt="" /><br /></p><p style="text-align: center;">图3 指定壁纸窗口在X轴和Y轴上的偏移位置</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;这时候壁纸窗口在X轴和Y轴上的偏移位置的绝对值XOffset和YOffset就分别等于（WallpaperWidth - DisplayWidth）* WallpaperX和（WallpaperHeight - DisplayHeight）* WallpaperY。这意味道着：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 当WallpaperX =&nbsp;WallpaperY = 0.0时，取壁纸窗口的左上角区域作为窗口背景。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2.&nbsp;当WallpaperX =&nbsp;WallpaperY = 0.5时，取壁纸窗口的中间区域作为窗口背景。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3.&nbsp;当WallpaperX =&nbsp;WallpaperY = 1.0时，取壁纸窗口的右下角区域作为窗口背景。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 除了使用WallpaperX和WallpaperY来描述壁纸窗口在X轴和Y轴上的偏移位置之外，WindowManagerService服务还使用WallpaperXStep和WallpaperYStep来描述壁纸窗口跨越了多少个虚拟屏幕。例如，假设一个Activity窗口在X轴上有3个虚拟屏幕，即它的实际宽度是屏幕宽度的3倍，而在Y轴上有一个屏幕，即它的实际高度刚好等于屏幕高度，并且壁纸窗口的宽度也刚好是屏幕宽度的3倍，而高度也刚好是等于屏幕高度，那么WallpaperXStep和WallpaperYStep的值就可以分别指定为0.5和0，这意味着：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 第1个虚拟屏幕取壁纸窗口的左边三分之一的区域作为窗口背景，相当于是将壁纸窗口在X轴和Y轴上的偏移位置WallpaperX和WallpaperY的值分别设置为0.0和0.0。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2.&nbsp;第2个虚拟屏幕取壁纸窗口的中间三分之一的区域作为窗口背景，相当于是将壁纸窗口在X轴和Y轴上的偏移位置WallpaperX和WallpaperY的值分别设置为0.5和0.0。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3.&nbsp;第3个虚拟屏幕取壁纸窗口的右边三分之一的区域作为窗口背景，相当于是将壁纸窗口在X轴和Y轴上的偏移位置WallpaperX和WallpaperY的值分别设置为1.0和0.0。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 一般地，如果一个Activity窗口在X轴上有N个虚拟屏幕，而在Y轴上有M个虚拟屏幕，那么它就会将壁纸窗口的WallpaperXStep和WallpaperYStep值分别设置为1.0 / (N - 1)和1.0 / (M - 1)。对于WindowManagerService服务来说，它并不关心壁纸窗口的WallpaperXStep和WallpaperYStep值，而只关心壁纸窗口的WallpaperX和WallpaperY值，因为通过后两者，它就可以知道怎么显示壁纸窗口了。壁纸窗口的WallpaperXStep和WallpaperYStep值是用来传递给提供壁纸的服务的。提供壁纸的服务一旦知道壁纸窗口的WallpaperXStep和WallpaperYStep值是多少，就可以知道当前需要显示避纸的窗口有多少个虚拟屏幕。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 上面提到的与壁纸窗口在X轴和Y轴上的偏移位置相关的六个状态WallpaperX、WallpaperY、WallpaperXStep、WallpaperYStep、XOffset和YOffset由WindowManagerService服务来统一维护，它们分别对应于WindowState类的六个成员变量mWallpaperX、mWallpaperY、mWallpaperXStep、mWallpaperYStep、mXOffset和mYOffset，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    float mLastWallpaperX = -1;
    float mLastWallpaperY = -1;
    float mLastWallpaperXStep = -1;
    float mLastWallpaperYStep = -1;
    ......

    private final class WindowState implements WindowManagerPolicy.WindowState {
        ......

        // If a window showing a wallpaper: the requested offset for the
        // wallpaper; if a wallpaper window: the currently applied offset.
        float mWallpaperX = -1;
        float mWallpaperY = -1;

        // If a window showing a wallpaper: what fraction of the offset
        // range corresponds to a full virtual screen.
        float mWallpaperXStep = -1;
        float mWallpaperYStep = -1;

        // Wallpaper windows: pixels offset based on above variables.
        int mXOffset;
        int mYOffset;

        ......
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 此外，WindowManagerService类还使用四个成员变量mLastWallpaperX、mLastWallpaperY、mLastWallpaperXStep和mLastWallpaperYStep来记录壁纸窗口上一次所使用的WallpaperX、WallpaperY、WallpaperXStep和WallpaperYStep值。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在Android系统中，提供壁纸功能的组件叫做WallpaperService，它是一个Service组件，是由壁纸管理服务WallpaperManagerService负责启动的。WallpaperService有两个内部类BaseIWindow和Engine，其中，BaseIWindow是一个实现了IWindow接口的Binder本地对象类，用来和WindowManagerService服务通信，而Engine是一个真正用来实现壁纸功能的类。当一个Activity窗口需要指定壁纸窗口的某一部分区域作为它的背景时，它就会通过WallpaperManager类来通知WallpaperService设置壁纸窗口在X轴和Y轴上的偏移位置，这个过程如图4所示：</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201301/30/1359478826_4476.jpg" alt="" /><br /></p><p style="text-align: center;">图4 壁纸窗口在X轴和Y轴上的偏移位置的设置过程</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 这个过程大概如下所示：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 1. 需要显示壁纸的Activity组件调用WallpaperManager类的成员函数setWallpaperOffsetSteps来设置壁纸窗口的WallpaperXStep和WallpaperYStep值。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 2.&nbsp;需要显示壁纸的Activity组件调用WallpaperManager类的成员函数setWallpaperOffsets来设置壁纸窗口的WallpaperX和WallpaperY值。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 3. 一个类型为Session的Binder代理对象的成员函数setWallpaperPosition会被调用来通知WindowManagerService服务来重新计算壁纸窗口在X轴和Y轴上的偏移位置，传递的参数包括在Step 1和Step 2中所设置的WallpaperXStep、WallpaperYStep、WallpaperX和WallpaperY四个值。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 4.&nbsp;WindowManagerService类的成员函数setWindowWallpaperPositionLocked会被调用来保存从前面Step 3传递过来的WallpaperXStep、WallpaperYStep、WallpaperX和WallpaperY值。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 5.&nbsp;WindowManagerService类的成员函数updateWallpaperOffsetLocked会被调用来计算壁纸窗口在X轴和Y轴上的偏移位置的绝对值XOffset和YOffset，是根据壁纸窗口的大小（WallpapperWidth, WallpaperHeight）、屏幕的大小（DisplayWidth, DisplayHeight），以及保存在前面Step 4中的WallpaperX和WallpaperY来计算的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 6. 在WallpaperService类内部的一个BaseIWindow对象的成员函数dispatchWallpaperOffsets会被调用来通知WallpaperService服务，壁纸窗口在X轴和Y轴上的偏移位置发生改变了，传递过来的参数包括壁纸窗口的XOffset、YOffset、WallpaperXStep和WallpaperYStep值。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 7.&nbsp;在WallpaperService类内部的一个Engine对象的成员函数doOffsetsChanged会被调用来处理壁纸窗口在X轴和Y轴上的偏移位置变化事件。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Step 8.&nbsp;Engine类的成员函数doOffsetsChanged会调用另外一个成员函数onOffsetsChanged来分发壁纸窗口在X轴和Y轴上的偏移位置变化事件。Engine类的成员函数onOffsetsChanged一般是由其子类来重写的，以便子类可以实现自己的壁纸效果。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 本文不打算详细这八个步骤，而主要关注Step 3、Step 4和Step 5这三步是如何计算壁纸窗口在X轴和Y轴上的偏移位置的，即主要关注Session类的成员函数setWallpaperPosition，以及WindowManagerService类的成员函数setWindowWallpaperPositionLocked和updateWallpaperOffsetLocked的实现。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Session类的成员函数setWallpaperPosition的实现如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    private final class Session extends IWindowSession.Stub
            implements IBinder.DeathRecipient {
        ......

        public void setWallpaperPosition(IBinder window, float x, float y, float xStep, float yStep) {
            synchronized(mWindowMap) {
                long ident = Binder.clearCallingIdentity();
                try {
                    setWindowWallpaperPositionLocked(
                            windowForClientLocked(this, window, true),
                            x, y, xStep, yStep);
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
            }
        }
 
        ......
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Session类的成员函数setWallpaperPosition首先调用WindowManagerService类的成员函数windowForClientLocked来找到与参数window所对应的一个WindowState对象，这个WindowState对象描述的是要改变壁纸窗口位置的窗口，接着再调用WindowManagerService类的另外一个成员函数setWindowWallpaperPositionLocked来执行设置壁纸窗口在X轴和Y轴的偏移位置的操作。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数setWindowWallpaperPositionLocked的实现如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    public void setWindowWallpaperPositionLocked(WindowState window, float x, float y,
            float xStep, float yStep) {
        if (window.mWallpaperX != x || window.mWallpaperY != y)  {
            window.mWallpaperX = x;
            window.mWallpaperY = y;
            window.mWallpaperXStep = xStep;
            window.mWallpaperYStep = yStep;
            if (updateWallpaperOffsetLocked(window, true)) {
                performLayoutAndPlaceSurfacesLocked();
            }
        }
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数setWindowWallpaperPositionLocked首先检查参数window所描述的WindowState对象上一次所设置的壁纸窗口的偏移位置与参数x和y所描述的偏移位置是否不一样。如果不一样的话，那么就会分别将参数x、y、xStep和yStep分别保存在参数window所描述的WindowState对象的成员变量mWallpaperX、mWallpaperY、mWallpaperXStep和mWallpaperYStep中，并且调用WindowManagerService类的成员函数updateWallpaperOffsetLocked来更新系统中的壁纸窗口的偏移位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果WindowManagerService类的成员函数updateWallpaperOffsetLocked的返回值等于true，那么就说明它更新了系统中的壁纸窗口的偏移位置，因此，就需要调用WindowManagerService类的成员函数performLayoutAndPlaceSurfacesLocked来刷新系统的UI。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 接下来我们继续分析WindowManagerService类的成员函数updateWallpaperOffsetLocked的实现，如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    final ArrayList&lt;WindowToken&gt; mWallpaperTokens = new ArrayList&lt;WindowToken&gt;();

    // If non-null, this is the currently visible window that is associated
    // with the wallpaper.
    WindowState mWallpaperTarget = null;
    ......

    boolean updateWallpaperOffsetLocked(WindowState changingTarget, boolean sync) {
        final int dw = mDisplay.getWidth();
        final int dh = mDisplay.getHeight();

        boolean changed = false;

        WindowState target = mWallpaperTarget;
        if (target != null) {
            if (target.mWallpaperX &gt;= 0) {
                mLastWallpaperX = target.mWallpaperX;
            } else if (changingTarget.mWallpaperX &gt;= 0) {
                mLastWallpaperX = changingTarget.mWallpaperX;
            }
            if (target.mWallpaperY &gt;= 0) {
                mLastWallpaperY = target.mWallpaperY;
            } else if (changingTarget.mWallpaperY &gt;= 0) {
                mLastWallpaperY = changingTarget.mWallpaperY;
            }
        }

        int curTokenIndex = mWallpaperTokens.size();
        while (curTokenIndex &gt; 0) {
            curTokenIndex--;
            WindowToken token = mWallpaperTokens.get(curTokenIndex);
            int curWallpaperIndex = token.windows.size();
            while (curWallpaperIndex &gt; 0) {
                curWallpaperIndex--;
                WindowState wallpaper = token.windows.get(curWallpaperIndex);
                if (updateWallpaperOffsetLocked(wallpaper, dw, dh, sync)) {
                    wallpaper.computeShownFrameLocked();
                    changed = true;
                    // We only want to be synchronous with one wallpaper.
                    sync = false;
                }
            }
        }

        return changed;
    }

    ......
}</pre><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 当WindowManagerService类的成员变量mWallpaperTarget的值不等于null时，它所指向的一个WindowState对象描述的是系统当前可见的并且需要显示壁纸的窗口。在这种情况下，要将这个WindowState对象当前正在使用的壁纸窗口在X轴和Y轴上的偏移位置分别保存在WindowManagerService类的成员变量mLastWallpaperX和mLastWallpaperY，以便接下来可以用来计算壁纸窗口在X轴和Y轴上的偏移位置的绝对值。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注意，如果WindowManagerService类的成员变量mWallpaperTarget所指向的一个WindowState对象的成员变量mWallpaperX（mWallpaperY）的值小于0，那么就说明这个WindowState对象所描述的窗口还没有设置过壁纸窗口在X轴上（Y轴上）的偏移位置，这时候就需要将参数changingTarget所指向的一个WindowState对象的成员变量mWallpaperX（mWallpaperY）的值保存在WindowManagerService类的成员变量mLastWallpaperX（mLastWallpaperY）中，前提也是它的值大于等于0，即它描述的是一个有效的偏移值。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowManagerService类的成员变量mWallpaperTokens保存的是一系列与壁纸相关的窗口令牌，与这些窗口令牌所对应的窗口就是系统当前所设置的壁纸窗口。WindowManagerService类的成员函数updateWallpaperOffsetLocked依次调用另外一个四参数版本的成员函数updateWallpaperOffsetLocked来更新系统当前所设置的每一个壁纸窗口在X轴和Y轴上的偏移位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注意，&nbsp;WindowManagerService类的四个参数版本的成员函数updateWallpaperOffsetLocked的最后一个参数sync是一个布尔值，用来表示在更新壁纸窗口在X轴和Y轴上的偏移位置的时候，是否需要同步等待提供壁纸窗口的服务处理完成壁纸窗口在X轴和Y轴上的偏移位置变化事件。参数sync本身也是由两个参数版本的成员函数updateWallpaperOffsetLocked的调用者传进来的，它的值即使等于true，两个参数版本的成员函数updateWallpaperOffsetLocked也只会同步等待提供第一个壁纸窗口的服务处理完成壁纸窗口在X轴和Y轴上的偏移位置变化事件。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的四个参数版本的成员函数updateWallpaperOffsetLocked的实现如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    boolean updateWallpaperOffsetLocked(WindowState wallpaperWin, int dw, int dh,
            boolean sync) {
        boolean changed = false;
        boolean rawChanged = false;
        float wpx = mLastWallpaperX &gt;= 0 ? mLastWallpaperX : 0.5f;
        float wpxs = mLastWallpaperXStep &gt;= 0 ? mLastWallpaperXStep : -1.0f;
        int availw = wallpaperWin.mFrame.right-wallpaperWin.mFrame.left-dw;
        int offset = availw &gt; 0 ? -(int)(availw*wpx+.5f) : 0;
        changed = wallpaperWin.mXOffset != offset;
        if (changed) {
            ......
            wallpaperWin.mXOffset = offset;
        }
        if (wallpaperWin.mWallpaperX != wpx || wallpaperWin.mWallpaperXStep != wpxs) {
            wallpaperWin.mWallpaperX = wpx;
            wallpaperWin.mWallpaperXStep = wpxs;
            rawChanged = true;
        }

        float wpy = mLastWallpaperY &gt;= 0 ? mLastWallpaperY : 0.5f;
        float wpys = mLastWallpaperYStep &gt;= 0 ? mLastWallpaperYStep : -1.0f;
        int availh = wallpaperWin.mFrame.bottom-wallpaperWin.mFrame.top-dh;
        offset = availh &gt; 0 ? -(int)(availh*wpy+.5f) : 0;
        if (wallpaperWin.mYOffset != offset) {
            ......
            changed = true;
            wallpaperWin.mYOffset = offset;
        }
        if (wallpaperWin.mWallpaperY != wpy || wallpaperWin.mWallpaperYStep != wpys) {
            wallpaperWin.mWallpaperY = wpy;
            wallpaperWin.mWallpaperYStep = wpys;
            rawChanged = true;
        }

        if (rawChanged) {
            try {
                ......
                if (sync) {
                    mWaitingOnWallpaper = wallpaperWin;
                }
                wallpaperWin.mClient.dispatchWallpaperOffsets(
                        wallpaperWin.mWallpaperX, wallpaperWin.mWallpaperY,
                        wallpaperWin.mWallpaperXStep, wallpaperWin.mWallpaperYStep, sync);
                if (sync) {
                    if (mWaitingOnWallpaper != null) {
                        long start = SystemClock.uptimeMillis();
                        if ((mLastWallpaperTimeoutTime+WALLPAPER_TIMEOUT_RECOVERY)
                                &lt; start) {
                            try {
                                ......
                                mWindowMap.wait(WALLPAPER_TIMEOUT);
                            } catch (InterruptedException e) {
                            }
                            ......
                            if ((start+WALLPAPER_TIMEOUT)
                                    &lt; SystemClock.uptimeMillis()) {
                                ......
                                mLastWallpaperTimeoutTime = start;
                            }
                        }
                        mWaitingOnWallpaper = null;
                    }
                }
            } catch (RemoteException e) {
            }
        }

        return changed;
    }

    ......
}</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的四个参数版本的成员函数updateWallpaperOffsetLocked首先计算参数wallpaper所描述的壁纸窗口在X轴和Y轴上的偏移位置，接着再向提供该壁纸窗口的服务发向一个壁纸窗口在X轴和Y轴上的偏移位置变化事件通知。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;参数wallpaper所描述的壁纸窗口在X轴和Y轴上的偏移位置的计算过程是一样的，这里我们只要结合前面的图3来分析壁纸窗口在X轴上的偏移位置的计算过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在图3中，壁纸窗口的WallpaperX、WallpaperXStep、WallpaperWidth和DisplayWidth值分别等于这里的mLastWallpaperX、mLastWallpaperXStep、wallpaperWin.mFrame.right - wallpaperWin.mFrame.left和dw。有了这些值之后，就可以计算得到参数wallpaper所描述的壁纸窗口在X轴上的偏移位置的绝对值XOffset了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果计算得到的XOffset、WallpaperX、WallpaperXStep的值与原来保存在参数wallpaper所指向的一个WindowState对象的成员变量mXOffset、mWallpaperX、mWallpaperXStep的值不相等，那么就会将计算得到的XOffset、WallpaperX、WallpaperXStep的值分别保存在这个WindowState对象的成员变量mXOffset、mWallpaperX、mWallpaperXStep，并且相应地将变量changed和rawChanged的值设置为true，表示参数wallpaper所描述的壁纸窗口在X轴上的偏移位置发生了变化。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 有四个地方需要注意：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 当mLastWallpaperX的值小于0的时候，那么就说明系统中的壁纸窗口还没有被设置一个有效的X轴偏移位置，这时候计算壁纸窗口在X轴上的偏移位置所采用的WallpaperX值就会取为0.5，即默认将壁纸窗口的中间区域指定为需要显示壁纸的窗口的背景。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. 当mLastWallpaperXStep的值小于0的时候，那么就说明需要显示壁纸的窗口还没有告诉WindowManagerService服务它有多少个虚拟屏幕，这时候就会将壁纸窗口的WallpaperXStep值设置为-1.0，用来告诉提供壁纸窗口的服务，需要显示壁纸的窗口没有指定虚拟屏幕的个数。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. 当壁纸窗口的宽度小于等于屏幕宽度的时候，即变量availw的值小于等于0的时候，那么就说明不需要设置壁纸窗口在X轴上的偏移位置，也就是说，这时候壁纸窗口在X轴上的偏移位置始终保持为0。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4.&nbsp;当壁纸窗口的宽度大于屏幕宽度的时候，即变量availw的值大于0的时候，壁纸窗口在X轴上的偏移值等于availw * wps，加上0.5是为了向上取整，向上取整后需要取反，因为负数才能正确表达出壁纸窗口相对屏幕的偏移。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 计算完成参数wallpaper所描述的壁纸窗口在X轴和Y轴上的偏移位置之后，如果变量rawChanged的值等于true，那么就说明参数wallpaper所描述的壁纸窗口在X轴和Y轴上的偏移位置发生了变化，这时候就需要向提供该壁纸窗口的服务发送一个事件通知，这是通过调用参数wallpaperWin所指向的一个WindowState对象的成员变量mClient所描述的一个实现了IWindow接口的Binder代理对象的成员函数dispatchWallpaperOffsets来实现的，同时传递给壁纸窗口的服务的参数有壁纸窗口当前所使用的WallpaperX、WallpaperY、WallpaperXStep和WallpaperYStep值，以及另外一个同步参数sync。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 当参数sync的值等于true的时候，就表示WindowManagerService服务需要等待提供壁纸窗口wallpaperWin的服务处理完成前面所发送的偏移位置变化事件通知，等待的最长时间为WALLPAPER_TIMEOUT。如果提供壁纸窗口wallpaperWin的服务不能在WALLPAPER_TIMEOUT时间内向WindowManagerService服务发送一个事件处理完成通知，那么WindowManagerService服务就会将这次事件通知发送时间start保存在WindowManagerService类的成员变量mLastWallpaperTimeoutTime中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果上一次发送的壁纸窗口偏移位置变化事件通知发生了超时，那么在上次发送这个事件通知起的WALLPAPER_TIMEOUT_RECOVERY时间内，是不允许再次发送壁纸窗口偏移位置变化事件通知的。这是因为在上一次事件通知超时的情况下，在短时间内再次发送相同的事件通知也是非常有可能是超时的，因此，就不允许短时间内重复发送相同的事件通知，避免出现雪崩现象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 关于互联网的雪崩现象，可以举一个常见的例子来说明。假设现在有一个Web页面正在现场直播一项非常热门的体育赛事，这时候就会有海量的用户访问这个页面。一旦访问量快要达到Web服务器的承受能力的时候，Web页面的打开速度就会越来越慢。Web页面打开速度变慢的时候，用户就会下意识地不断按F5刷新。越是不断地按F5刷新，Web页面的请求量就越大，而当请求量大于Web服务器的承受能力的时候，Web服务器就会宕机了，这个就是雪崩现象。为了避免雪崩现象，就需要在请求量快要达到Web服务器的承受能力的时候，避免用户发送更多的访问请求，以使得Web服务器有喘息的机会。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 废话少说了，当WindowManagerService服务在等待壁纸窗口wallpaper所属的服务处理它的偏移位置变化事件通知时，会将该壁纸窗口wallpaper保存在WindowManagerService类的成员变量mWaitingOnWallpaper中，用来表示WindowManagerService服务正在处于等待壁纸服务处理完成一个壁纸窗口偏移位置变化事件通知。一旦壁纸服务处理完成该事件通知，WindowManagerService类的成员变量mWaitingOnWallpaper的值就会被设置为null。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 壁纸服务处理壁纸窗口在X轴和Y轴上的偏移位置变化事件通知的过程就如图4的Step 6至Step 8所示。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 至此，我们就分析完成壁纸窗口在X轴和Y轴上的偏移位置的调整过程了，接下来我们就继续分析壁纸窗口在窗口堆栈中的位置调整过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 三. 调整壁纸窗口在窗口堆栈中的位置</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;调整壁纸窗口在窗口堆栈中的位置实际上就是将壁纸窗口放置在需要显示壁纸的窗口的下面，这是是通过调用WindowManagerService类的成员函数adjustWallpaperWindowsLocked来实现的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowManagerService类的成员函数adjustWallpaperWindowsLocked的实现框架如下所示：</p><p></p><pre name="code" class="java">public class WindowManagerService extends IWindowManager.Stub
        implements Watchdog.Monitor {
    ......

    int adjustWallpaperWindowsLocked() {
        int changed = 0;

        final int dw = mDisplay.getWidth();
        final int dh = mDisplay.getHeight();

        // First find top-most window that has asked to be on top of the
        // wallpaper; all wallpapers go behind it.
        final ArrayList&lt;WindowState&gt; localmWindows = mWindows;
        int N = localmWindows.size();
        WindowState w = null;
        WindowState foundW = null;
        int foundI = 0;
        WindowState topCurW = null;
        int topCurI = 0;
        int i = N;
        //Label #1:
        while (i &gt; 0) {
            //从上到下遍历窗口堆栈，查找需要显示壁纸的窗口foundW，foundI为窗口foundW在窗口堆栈中
            //的位置如果没有找到需要显示壁纸的窗口，并且系统中存在壁纸窗口，那么topCurW就指向Z轴
            //位置最大的壁纸窗口，topCurI为窗口topCurW在窗口堆栈中的位置，这时候foundW一定等于
            //null。
            ......
        }

        //Label #2:
        if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
            //如果系统当前正在窗口切换的过程中，并且系统当前存在一个需要显示壁纸的Activity窗口，
            //那么就认为当前正在执行的窗口切换涉及到了这个需要显示壁纸的Activity窗口，
            //因此，就暂时不要调整壁纸窗口的位置了，等到窗口切换过程完成了再说。
            //系统当前存在一个需要显示壁纸的Activity窗口，意味着mWallpaperTarget不等于null，
            //或者foundW不等于null。
            ......
        }

        if (mWallpaperTarget != foundW) {
            //上一次显示壁纸的窗口和接下来要显示壁纸的窗口发生了变化

            mLowerWallpaperTarget = null;
            mUpperWallpaperTarget = null;

            WindowState oldW = mWallpaperTarget;
            mWallpaperTarget = foundW;

            // Now what is happening...  if the current and new targets are
            // animating, then we are in our super special mode!
            if (foundW != null &amp;&amp; oldW != null) {
                boolean oldAnim = oldW.mAnimation != null
                        || (oldW.mAppToken != null &amp;&amp; oldW.mAppToken.animation != null);
                boolean foundAnim = foundW.mAnimation != null
                        || (foundW.mAppToken != null &amp;&amp; foundW.mAppToken.animation != null);
                     ......
               
                //Label #3:
                if (foundAnim &amp;&amp; oldAnim) {
                    //上一次显示壁纸的窗口oldW和接下来要显示壁纸的窗口foundW正在显示动画的
                    //过程中，那么就将Z轴位置较高的窗口保存在mUpperWallpaperTarget中，而将
                    //Z轴位置较低的窗口保存在mLowerWallpaperTarget中，并且将变量foundW指向
                    //Z轴位置较高的窗口，这样就可以在这两个窗口的动画显示过程中都能看到壁
                    //纸窗口.
                    ......
                }
            }
        ｝else if (mLowerWallpaperTarget != null) {
            //Label #4:
            //检查mUpperWallpaperTarget和mLowerWallpaperTarget所指向的窗口的动画显示过程
            //是否已经结束，如果已经结束，那么就将mUpperWallpaperTarget和
            //mLowerWallpaperTarget的值置null。
            // Is it time to stop animating?
            ......
         }

        boolean visible = foundW != null;
        //Label #5:
        if (visible) {
            //前面找到了一个需要显示壁纸的窗口foundW，并且存在其它窗口与它关联，这些关联的
            //窗口包括：
            //1. 在与该窗口所对应的窗口令牌的其它窗口
            //2. 该窗口所设置的启动窗口
            //3. 附加在该窗口的其它窗口
            //在上述这些关联的窗口中，如果存在一些Z轴位置比窗口foundW小，那么就将需要将壁纸
            //窗口放在Z轴位置最小的那个窗口下面，即将变量foundW指向Z轴位置最小的那个窗口。
            ......
        }
     
        //让变量foundW指向前面找到的需要显示壁纸的窗口的下一个窗口，
        //这时候变量foundI记录的仍是需要显示壁纸的窗口在窗口堆栈中的位置，
        //接下来会根据这两个变量来调整壁纸窗口在窗口堆栈中的位置
        if (foundW == null &amp;&amp; topCurW != null) {
            //前面提到，如果没有找到需要显示壁纸的窗口，并且系统中存在壁纸窗口，那么foundW一
            //定等于null，并且topCurW一定不等于null，这时候就不需要调整壁纸窗口在窗口堆栈中的
            //位置。为了与其它情况统一处理，这时候假设位于壁纸窗口上面的那个窗口就是需要显示
            //壁纸的窗口。因此，就会将foundI的值设置为(topCurI+1)，而将foundW的值设置为
            //topCurW。
            // There is no wallpaper target, so it goes at the bottom.
            // We will assume it is the same place as last time, if known.
            foundW = topCurW;
            foundI = topCurI+1;
        } else {
            //前面找到了需要显示壁纸的窗口，因此，就将它的下一个窗口保存在foundW中，变量foundI
            //的值不需要修改。
            // Okay i is the position immediately above the wallpaper.  Look at
            // what is below it for later.
            foundW = foundI &gt; 0 ? localmWindows.get(foundI-1) : null;
        }

        //如果前面找到的需要显示壁纸的窗口是可见的，并且当前正在显示壁纸的窗口设置了壁纸窗口
        //在X轴和Y轴上的偏移位置，那么就将用来描述壁纸窗口在X轴和Y轴上的偏移位置的WallpaperX、
        //WallpaperY、WallpaperXStep和WallpaperYStep值记录在mLastWallpaperX、
        //mLastWallpaperXStep、mLastWallpaperY和mLastWallpaperYStep中。
        if (visible) {
            if (mWallpaperTarget.mWallpaperX &gt;= 0) {
                mLastWallpaperX = mWallpaperTarget.mWallpaperX;
                mLastWallpaperXStep = mWallpaperTarget.mWallpaperXStep;
            }
            if (mWallpaperTarget.mWallpaperY &gt;= 0) {
                mLastWallpaperY = mWallpaperTarget.mWallpaperY;
                mLastWallpaperYStep = mWallpaperTarget.mWallpaperYStep;
            }
        }

        //Label #6:
        // Start stepping backwards from here, ensuring that our wallpaper windows
        // are correctly placed.
        int curTokenIndex = mWallpaperTokens.size();
        while (curTokenIndex &gt; 0) {
            //一切准备就绪，开始调整系统中的壁纸窗口在窗口堆栈的位置，算法如下所示。
            //对于从Z轴位置从高到低的每一个壁纸窗口wallpaper：
            //1. 如果它与变量foundW指向的不是同一个壁纸窗口，那么就说明它在窗口堆栈中
            //的位置不对，这时候就需要将它调整到窗口堆栈中的第foundI个位置上。
            //2. 如果它与变量foundW指向的是同一个壁纸窗口，那么就说明它在窗口堆栈中的
            //位置是正确，这时候就不需要对它进行调整，不过要让变量foundI的值减1，并且将
            //在窗口堆栈第(foundI - 1)个位置的窗口记录在变量foundW中。
            //注意，变量foundW一开始就指向Z轴位置最高的壁纸窗口，而变量foundI记录的是
            //位于Z轴位置最高的壁纸窗口上面的那个窗口在窗口堆栈中的位置。
            //上述算法实际上是用状态机的方法将系统中的所有壁纸窗口（假设数量为N）按照Z轴
            //位置从高到底的顺序放置在窗口堆栈中的第（foundI - 1）、（foundI - 2）、
            //（foundI - 3）、......、（foundI - N）个位置上。
            ......
        }

        return changed;
    }

    ......
}</pre><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;这个函数定义在文件frameworks/base/services/java/com/android/server/WindowManagerService.java中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员函数adjustWallpaperWindowsLocked是按照以下流程来调整壁纸窗口在窗口堆栈中的位置的：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 通过一个while循环来从上到下地遍历窗口堆栈，找到需要显示壁纸的窗口foundW，其中，foundI为窗口foundW在窗口堆栈中的位置。如果没有找到需要显示壁纸的窗口，并且系统中存在壁纸窗口，那么topCurW就指向Z轴位置最大的壁纸窗口，其中，topCurI为窗口topCurW在窗口堆栈中的位置。在这种情况下，变量foundW的值一定等于null的。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. 如果WindowManagerService类的成员变量mNextAppTransition的值不等于WindowManagerPolicy.TRANSIT_UNSET，那么就说明系统当前正在窗口切换的过程中。在这种情况下，如果系统当前存在一个需要显示壁纸的Activity窗口，即WindowManagerService类的成员变量mWallpaperTarget的值不等于null，或者前面得到的变量foundW的值不等于null，那么就认为当前正在执行的窗口切换操作涉及到了这个需要显示壁纸的Activity窗口。这时候就不需要调整壁纸窗口的位置，要等到窗口切换过程完成了之后再调整。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. 如果WindowManagerService类的成员变量mWallpaperTarget和前面得到的变量foundW指向的不是同一个WindowState对象，那么就说明上一次显示壁纸的窗口和接下来要显示壁纸的窗口发生了变化。在这种情况下，就会使用变量oldW来描述上一次显示壁纸的窗口，而接下来要显示壁纸的窗口通过WindowManagerService类的成员变量mWallpaperTarget以及变量foundW来描述。这时候如果检查发现上一次显示壁纸的窗口和接下来要显示壁纸的窗口都处于显示动画的过程中，那么就会将Z轴位置较高的窗口保存在WindowManagerService类的成员变量mUpperWallpaperTarget中，而将Z轴位置较低的窗口保存在WindowManagerService类的成员变量mLowerWallpaperTarget中，并且将变量foundW指向Z轴位置较高的窗口。这样就能保证在这两个窗口的动画显示过程中都能看到壁纸窗口，实际上就是保证在两个窗口的切换过程中看到壁纸窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4.&nbsp;如果WindowManagerService类的成员变量mWallpaperTarget和前面得到的变量foundW指向的是同一个WindowState对象，并且WindowManagerService类的成员变量mLowerWallpaperTarget的值不等于null，那么就说明需要检查系统的窗口切换过程完成了没有。如果已经完成，那么就需要将WindowManagerService类的成员变量mUpperWallpaperTarget和mLowerWallpaperTarget的值设置为null。由此可以，WindowManagerService类的成员变量mUpperWallpaperTarget和mLowerWallpaperTarget的作用就是用来记录两个处于切换状态的需要显示壁纸的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 5. 如果变量foundW的值不等于null，那么就说明前面找到了一个接下来要显示壁纸的窗口。在这种情况下，需要做两件事情。第一件事情是判断接下来要显示壁纸的窗口是否是可见的。如果是的话，那么就会将变量visible的值设置为true。第二件事情是在与接下来要显示壁纸的窗口相关联的窗口中，即与变量foundW所描述的窗口相关联的窗口中，找到一个Z轴位置最小的窗口，因为壁纸窗口最终是要放置在这个Z轴位置最小的窗口的下面，而不是最初找到的那个窗口的下面。与变量foundW所描述的窗口相关联的窗口包括：A. &nbsp;与变量foundW所描述的窗口具有相同窗口令牌的其它窗口；B. 与变量foundW所描述的窗口附加在同一个窗口的其它窗口；C. 为变量foundW所描述的窗口所设置的启动窗口；D.&nbsp;附加在变量foundW所描述的窗口上的其它窗口。一旦找到这样的一个窗口，那么就会让重新让变量foundW指向它。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 6. 再次重新调整变量foundW的值，让它指向位于前面所找到的需要显示壁纸的窗口的下面的一个窗口。注意，这个窗口有可能就是壁纸窗口。这时候变量foundI记录的然是前面所找到的需要显示壁纸的窗口在窗口堆栈中的位置。这样做的目的是为了接下来可以方便地调整壁纸窗口在窗口堆栈中的位置。但是如果变量foundW的值等于null，那么就说明前面根本没有找到需要显示壁纸的窗口。在这种情况下，如果变量topCurW的值不等于null，那么就说明系统中存在壁纸窗口。这种情况其实就不需要调整壁纸窗口在窗口堆栈中的位置了，但是为了接下来的逻辑可以统一处理，就假定位于壁纸窗口上面的那个窗口是需要显示壁纸的窗口。因此，就会将变量foundI的值设置为(topCurI+1)，而将变量foundW的值设置为topCurW。<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 7.&nbsp;如果前面所找到的需要显示壁纸的窗口是可见的，即变量visible的值等于true，并且当前正在显示壁纸的窗口设置了壁纸窗口在X轴和Y轴上的有效偏移位置，即WindowManagerService类的成员变量mWallpaperTarget所指向的一个WindowState对象的成员变量mWallpaperX和mWallpaperY的值大于等于0，那么就将用来描述壁纸窗口在X轴和Y轴上的偏移位置的WallpaperX、WallpaperY、WallpaperXStep和WallpaperYStep值记录在WindowManagerService类的成员变量mLastWallpaperX、mLastWallpaperY、mLastWallpaperXStep和mLastWallpaperYStep中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 8. 经过上面的一系列操作之后，现在一切准备就绪，因此就可以按照以下的算法来调整系统中的壁纸窗口在窗口堆栈的位置。对于从Z轴位置从高到低的每一个壁纸窗口wallpaper：(1). 如果它与变量foundW指向的不是同一个壁纸窗口，那么就说明它在窗口堆栈中的位置不对，这时候就需要将它调整到窗口堆栈中的第foundI个位置上；(2).&nbsp;如果它与变量foundW指向的是同一个壁纸窗口，那么就说明它在窗口堆栈中的位置是正确，这时候就不需要对它进行调整，不过要让变量foundI的值减1，并且将在窗口堆栈第(foundI - 1)个位置的窗口记录在变量foundW中；(3). 重复执行第(1)和第(2)步的操作，直到系统所有的壁纸窗口都检查完成为止。注意，在上述算法中，变量foundW一开始就指向Z轴位置最高的壁纸窗口，而变量foundI记录的是位于Z轴位置最高的壁纸窗口上面的那个窗口在窗口堆栈中的位置。每当Z轴位置最高的壁纸窗口在窗口堆栈中的位置调整完成之后，变量foundW就会指向Z轴位置次高的壁纸窗口，而变量foundI的值也会相应的地减少1。这个算法其实就是用状态机的方法来将系统中的所有壁纸窗口（假设数量为N）按照Z轴位置从高到底的顺序放置在窗口堆栈中的第（foundI - 1）、（foundI - 2）、（foundI - 3）、......、（foundI - N）个位置上。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 上述流程可能还是比较抽象，接下来我们就通过在标号为Label #1、Label #2、Label #3、Label #4、Label #5和Label #6处所忽略的代码来详细分析壁纸窗口在窗口堆栈中的位置的调整过程。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 标号为Label #1的代码如下所示：</p><p></p><pre name="code" class="java">        while (i &gt; 0) {
            i--;
            w = localmWindows.get(i);
            if ((w.mAttrs.type == WindowManager.LayoutParams.TYPE_WALLPAPER)) {
                if (topCurW == null) {
                    topCurW = w;
                    topCurI = i;
                }
                continue;
            }
            topCurW = null;
            if (w.mAppToken != null) {
                // If this window's app token is hidden and not animating,
                // it is of no interest to us.
                if (w.mAppToken.hidden &amp;&amp; w.mAppToken.animation == null) {
                    ......
                    topCurW = null;
                    continue;
                }
            }

            ......

            if ((w.mAttrs.flags&amp;FLAG_SHOW_WALLPAPER) != 0 &amp;&amp; w.isReadyForDisplay()
                    &amp;&amp; (mWallpaperTarget == w
                            || (!w.mDrawPending &amp;&amp; !w.mCommitDrawPending))) {
                ......

                foundW = w;
                foundI = i;
                if (w == mWallpaperTarget &amp;&amp; ((w.mAppToken != null
                        &amp;&amp; w.mAppToken.animation != null)
                        || w.mAnimation != null)) {
                    // The current wallpaper target is animating, so we'll
                    // look behind it for another possible target and figure
                    // out what is going on below.
                    ......
                    continue;
                }
                break;
            }
        }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码从上到下遍历保存在窗口堆栈中的窗口，目的是要找到一个Z轴位置最大的并且需要显示壁纸的窗口。一个窗口如果需要显示壁纸，那么用来描述它的一个WindowState对象w的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量flags的值的FLAG_SHOW_WALLPAPER位就不等于0。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 一个需要显示壁纸的窗口只有准备就绪显示并且UI也已经绘制完成之后，WindowManagerService服务才会将壁纸窗口放置在它的下面。&nbsp;一个需要显示壁纸的窗口如果已经准备就绪显示，那么用来描述它的一个WindowState对象w的成员函数isReadyForDisplay的返回值等于true。另一方面，如果一个窗口的UI还没有绘制，那么用来描述它的一个WindowState对象w的成员变量mDrawPending的值就会等于true。一个窗口的UI虽然绘制好了，但是还没有提交给SurfaceFlinger服务处理，即用来描述它的一个WindowState对象w的成员变量mCommitDrawPending的值等于true，那么它的UI也是认为还没有绘制完成的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在遍历的过程中，如果发现一个窗口w刚好就是当前正在显示壁纸的窗口mWallpaperTarget，那么就会继续检查该窗口是否正处于显示动画的过程中。如果是的话，那么就需要跳过该窗口，因为我们的目标是要找到另外一个接下来要显示壁纸的窗口。对于Activity窗口和非Activity窗口来说，判断它们是否是正处于显示动画的过程中的方法是不一样的。对于一个处于显示动画过程的Activity窗口来说，用来描述它的一个WindowState对象w的成员变量mAppToken的值不等于null，并且指向了一个AppWindowToken对象，并且这个AppWindowToken对象的成员变量animation的值不等于null。对于一个处于显示动画过程的非Activity窗口来说，用来描述它的一个WindowState对象w的成员变量mAnimation的值不等于null。这就是说，AppWindowToken类的成员变量animation和WindowState类的成员变量mAnimation都是用来描述一个动画对象的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;在遍历的过程中，有两种类型的窗口是需要跳过的。第一种类型的窗口是壁纸窗口，即用来描述它的一个WindowState对象w的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量type的值等于WindowManager.LayoutParams.TYPE_WALLPAPER。第二种类型的窗口是Activity窗口，但是与之所对应的Activity组件处于不可见状态，这意味着这种类型的窗口也是不可见的。前面提到，对于Activity窗口来说，用来描述它的一个WindowState对象w的成员变量mAppToken的值是不等于null的，并且指向了一个AppWindowToken对象。当这个AppWindowToken对象的成员变量hidden的值等于true的时候，就意味着对应的Activity组件是不可见的。有时候一个AppWindowToken对象的成员变量hidden的值虽然等于true，但是如果这个AppWindowToken对象的成员变量animation的值不等于null，那么隐含着对应的Activity组件其实还是可见的，因为它还处于显示动画的过程中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 遍历完成之后，有可能找到了接下来要显示壁纸的窗口，也有可能找不到接下来要显示壁纸的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 如果找到了接下来要显示壁纸的窗口，那么变量foundW的值就不等于null，并且指向了这个接下来要显示壁纸的窗口，另外一个变量foundI记录的是该窗口在窗口堆栈中位置。这时候变量topCurW的值一定等于null，但是变量topCurI的值却不一定等于0，它有可能指向了Z轴位置最大的那个壁纸窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 假设foundW的值不等于null，并且变量topCurI的值等于0.，那么窗口堆栈的状态就如图5所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201302/01/1359733798_5171.jpg" alt="" /><br /></p><p style="text-align: center;">图5 foundw != null &amp; topCurI == 0</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;假设foundW的值不等于null，并且变量topCurI的值大于0.，那么窗口堆栈的状态就如图6所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201302/02/1359738495_7566.jpg" alt="" /><br /></p><p style="text-align: center;">图6 foundW != null &amp; topCurI != 0</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;如果没有找到接下来要显示壁纸的窗口，那么变量foundW的值就等于null，并且另外一个变量foundI的值等于0。这时候变量topCurW的值始终等于null，而变量topCurI的值可能不等于0，取决于系统中是否存在壁纸窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 为了方便描述，我们假设系统中是存在壁纸窗口，那么这时候topCurI的值就不等于0，并且它记录的是Z轴位置最大的那个壁纸窗口在窗口堆栈中的位置，如图7所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201302/02/1359738512_3094.jpg" alt="" /><br /></p><p style="text-align: center;">图7 foundW == null &amp;&amp; topCurI != 0</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;标号为Label #2的代码如下所示：</p><p></p><pre name="code" class="java">      if (mNextAppTransition != WindowManagerPolicy.TRANSIT_UNSET) {
            // If we are currently waiting for an app transition, and either
            // the current target or the next target are involved with it,
            // then hold off on doing anything with the wallpaper.
            // Note that we are checking here for just whether the target
            // is part of an app token...  which is potentially overly aggressive
            // (the app token may not be involved in the transition), but good
            // enough (we'll just wait until whatever transition is pending
            // executes).
            if (mWallpaperTarget != null &amp;&amp; mWallpaperTarget.mAppToken != null) {
                ......
                return 0;
            }
            if (foundW != null &amp;&amp; foundW.mAppToken != null) {
                ......
                return 0;
            }
        }</pre>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;WindowManagerService类的成员变量mNextAppTransition的值不等于WindowManagerPolicy.TRANSIT_UNSET意味着系统当前正在窗口切换的过程中。这里说的窗口切换其实就是由Activity组件切换引起来的，即切换的是Activity窗口。如果正在切换的Activity窗口是是需要显示壁纸的，那么WindowManagerService类的成员函数adjustWallpaperWindowsLocked就要等到切换过程结束后，才能调整重新调整壁纸窗口在窗口堆栈中的位置。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 这里本来是要判断正在发生切换的Activity窗口是否是当前壁纸窗口的目标窗口或者前面所找到的接下来要显示壁纸的窗口的，但是却没有这样做。这段代码采取了一种比较激进的方法，即主要发现当前壁纸窗口的目标窗口是一个Activity窗口，或者前面所找到的接下来要显示壁纸的窗口是一个Activity窗口，那么就认为当前正在执行的窗口切换过程涉及到了壁纸窗口，因此，就要等到切换过程结束后，再来重新调整壁纸窗口在窗口堆栈中的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowManagerService类的成员变量mWallpaperTarget描述的就是当前壁纸窗口的目标窗口，当它的值不等于null时，并且它所指向的一个WindowState对象的成员变量mAppToken的值不等于null，那么就说明当前壁纸窗口的目标窗口是一个Activity窗口。同样，如果前面得到的变量foundW的值不等于null，并且它所指向的一个WindowState对象的成员变量mAppToken的值不等于null，那么就说明前面所找到的接下来要显示壁纸的窗口是一个Activity窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 标号为Label #3的代码如下所示：</p><p></p><pre name="code" class="java">                if (foundAnim &amp;&amp; oldAnim) {
                    int oldI = localmWindows.indexOf(oldW);
                    ......

                    if (oldI &gt;= 0) {
                        ......

                        // Set the new target correctly.
                        if (foundW.mAppToken != null &amp;&amp; foundW.mAppToken.hiddenRequested) {
                            ......
                            mWallpaperTarget = oldW;
                        }

                        // Now set the upper and lower wallpaper targets
                        // correctly, and make sure that we are positioning
                        // the wallpaper below the lower.
                        if (foundI &gt; oldI) {
                            // The new target is on top of the old one.
                            ......
                            mUpperWallpaperTarget = foundW;
                            mLowerWallpaperTarget = oldW;
                            foundW = oldW;
                            foundI = oldI;
                        } else {
                            // The new target is below the old one.
                            ......
                            mUpperWallpaperTarget = oldW;
                            mLowerWallpaperTarget = foundW;
                        }
                    }
                } </pre>&nbsp; &nbsp; &nbsp; &nbsp; 当变量foundAnim和oldAnim的值均等于true的时候，就说明当前正在显示壁纸的窗口oldW和接下来要显示壁纸的窗口foundW均处于显示动画的过程中，那么就分别将它们记录在WindowManagerService类的成员变量mLowerWallpaperTarget和mUpperWallpaperTarget中，其中，前者用来描述Z轴位置较低的窗口，而后者用来描述Z轴位置较高的的窗口。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;变量foundI和oldI记录的分别是窗口foundW和oldW在窗口堆栈中的位置。因此，当变量foundI的值大于变量oldI的值的时候，窗口foundW就是Z轴位置较高的的窗口，而窗口oldW就是Z轴位置较低的的窗口。相反，当变量foundI的值小于等于变量oldI的值的时候，窗口oldW就是Z轴位置较高的的窗口，而窗口foundW就是Z轴位置较低的的窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;这里有三个地方是需要注意的：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1.&nbsp;当前正在显示壁纸的窗口oldW其实就是WindowManagerService类的成员变量mWallpaperTarget所描述的那个窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2.&nbsp;变量foundW和foundI记录的始终都是Z轴位置较低的那个窗口及其在窗口堆栈的位置，因此，当变量foundI的值大于变量oldI的值的时候，要将变量foundW和foundI的值分别设置为oldW和oldI，这样做的目的是为了接下来可以将壁纸窗口放置在Z轴位置较低的窗口的下面，以便可以在两个窗口的动画显示过程中看到壁纸。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;3. 如果前面找到的接下来要显示壁纸的窗口是一个Activity窗口，即变量foundW所描述的一个WindowState对象的成员变量mAppToken的值不等于null，并且它所指向的一个AppWindowToken对象的成员变量hiddenRequested的值等于true，那么就说明与窗口foundW所对应的一个Activity组件已经被请求隐藏起来了。在这种情况下，当前正在显示壁纸的窗口就会仍然被当作是接下来壁纸窗口的目标窗口。由于此前我们已经将WindowManagerService类的成员变量mWallpaperTarget的值设置了为foundW，因此，这时候就需要将它的值修改为oldW。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;这段代码执行完成之后，窗口堆栈的状态就如图8所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201302/02/1359738954_6058.jpg" alt="" /><br /></p><p style="text-align: center;">图8&nbsp;mUpperWallpaperTarget、mLowerWallpaperTarget、foundW和foundI的关系</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;标号为Label #4的代码如下所示：</p><p></p><pre name="code" class="java">            // Is it time to stop animating?
            boolean lowerAnimating = mLowerWallpaperTarget.mAnimation != null
                    || (mLowerWallpaperTarget.mAppToken != null
                            &amp;&amp; mLowerWallpaperTarget.mAppToken.animation != null);
            boolean upperAnimating = mUpperWallpaperTarget.mAnimation != null
                    || (mUpperWallpaperTarget.mAppToken != null
                            &amp;&amp; mUpperWallpaperTarget.mAppToken.animation != null);
            if (!lowerAnimating || !upperAnimating) {
                ......
                mLowerWallpaperTarget = null;
                mUpperWallpaperTarget = null;
            }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码检查WindowManagerService类的成员变量mLowerWallpaperTarget和mUpperWallpaperTarget所描述的两个窗口的动画是否已经显示结束。如果已经显示结束，那么就会将这两个成员变量的值设置为null。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 注意，如果一个窗口的动画已经显示结束，那么用来描述它的一个WindowState对象的成员变量mAnimation的值就会等于null。另外，如果一个Activity窗口的动画已经显示结束，那么用来描述它的WindowState对象的成员变量mAppWindowToken所指向的一个AppWindowToken对象的成员变量animation的值也会等于null。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;标号为Label #5的代码如下所示：</p><p></p><pre name="code" class="java">        boolean visible = foundW != null;
        if (visible) {
            // The window is visible to the compositor...  but is it visible
            // to the user?  That is what the wallpaper cares about.
            visible = isWallpaperVisible(foundW);
            ......

            // If the wallpaper target is animating, we may need to copy
            // its layer adjustment.  Only do this if we are not transfering
            // between two wallpaper targets.
            mWallpaperAnimLayerAdjustment =
                    (mLowerWallpaperTarget == null &amp;&amp; foundW.mAppToken != null)
                    ? foundW.mAppToken.animLayerAdjustment : 0;

            final int maxLayer = mPolicy.getMaxWallpaperLayer()
                    * TYPE_LAYER_MULTIPLIER
                    + TYPE_LAYER_OFFSET;

            // Now w is the window we are supposed to be behind...  but we
            // need to be sure to also be behind any of its attached windows,
            // AND any starting window associated with it, AND below the
            // maximum layer the policy allows for wallpapers.
            while (foundI &gt; 0) {
                WindowState wb = localmWindows.get(foundI-1);
                if (wb.mBaseLayer &lt; maxLayer &amp;&amp;
                        wb.mAttachedWindow != foundW &amp;&amp;
                        wb.mAttachedWindow != foundW.mAttachedWindow &amp;&amp;
                        (wb.mAttrs.type != TYPE_APPLICATION_STARTING ||
                                wb.mToken != foundW.mToken)) {
                    // This window is not related to the previous one in any
                    // interesting way, so stop here.
                    break;
                }
                foundW = wb;
                foundI--;
            }
        } </pre>&nbsp; &nbsp; &nbsp; &nbsp; 当变量foundW的值不等于null时，就说明前面找到了一个接下来要显示壁纸的窗口。在这种情况下，需要做三件事件：<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 判断窗口foundW是否是可见的，这是通过调用WindowManagerService类的成员函数isWallpaperVisible来实现的。如果可见，那么变量visible的值就会等于true，否则就会等于false。后面在调整壁纸窗口在窗口堆栈中的位置时，会根据变量visible的值来决定要显示壁纸窗口还是隐藏壁纸窗口。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. 检查窗口foundW是否是一个Activity窗口。如果是的话，那么就会将用来描述它的一个WindowState对象的成员变量mAppToken所指向的一个AppWindowToken对象的成员变量animLayerAdjustment的值保存在WindowManagerService类的成员变量mWallpaperAnimLayerAdjustment中。在计算壁纸窗品的Z轴位置的时候，需要使用到WindowManagerService类的成员变量mWallpaperAnimLayerAdjustment，用来调整壁纸窗品的Z轴位置。在后面一篇文章分析窗口的Z轴位置的计算方法时，我们再详细分析壁纸窗口的Z轴位置是如何计算的。注意，如果这时候系统的壁纸窗口有两个目标窗口，即WindowManagerService类的成员变量mLowerWallpaperTarget的值不等于null，那么就说明壁纸窗口的目标窗口正在显示动画的过程中。在这种情况下，就不需要调整壁纸窗品的Z轴位置，即会将WindowManagerService类的成员变量mLowerWallpaperTarget的值设置为0。等到壁纸窗口的目标窗口结束动画显示过程之后，再来调整它的Z轴位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. 检查窗口foundW的下面是否存在一些关联的窗口。如果存在的话，就需要将壁纸窗口放置在这些关联的窗口中Z轴位置最低的窗口的下面。这段代码通过一个while循环从窗口foundW的下面一个窗口开始往下检查，直到找到一个没有关联的窗口为止。在检查的过程中，每碰到一个关联的窗口，那么就让变量foundW指向它，并且将变量foundI的值减少1。这样最终得到的变量foundW和foundI就是用来描述与窗口foundW有联的、Z轴位置最低的窗口及其在窗口堆栈中的位置。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 前面提到，窗口foundW所关联的窗口四种，即对于一个窗口wb来，如果它满足以下四个条件，那么它就与窗口foundW有关联：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; A. &nbsp;窗口wb与窗口foundW对应的是同一个窗品令牌，即分别用来描述窗口wb和窗口foundW的两个WindowState对象的成员变量mToken指向的是同一个WindowToken对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; B. &nbsp;窗口wb附加在窗口foundW上，即用来描述窗口wb的一个WindowState对象的成员变量mAttachedWindow与变量foundW指向的是同一个WindowState对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; C. &nbsp;窗口wb与窗口foundW附加在同一个窗口上，即分别用来描述窗口wb和窗口foundW的两个WindowState对象的成员变量mAttachedWindow指向的是同一个WindowState对象。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; D.&nbsp;窗口wb是窗口foundW的启动窗口，即用来描述窗口wb的一个WindowState对象的成员变量mAttrs所指向的一个WindowManager.LayoutParams对象的成员变量type的值等于TYPE_APPLICATION_STARTING。&nbsp;</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 此外，WindowManagerService类的成员变量mPolicy所指向的一个PhoneWindowManager对象会规定系统中的壁纸窗口的Z轴位置不能大于某一个值，也就是说，壁纸窗口的Z轴位置有一个最大值限制。这个限制值可以通过调用WindowManagerService类的成员变量mPolicy所指向的一个PhoneWindowManager对象的成员函数getMaxWallpaperLayer来获得。获得了这个限制值之后，还需要乘以一个窗口类型因子TYPE_LAYER_MULTIPLIER，最后再加一个窗口类型偏移值TYPE_LAYER_OFFSET，就可以得到壁纸窗口的最大Z轴位置限制值maxLayer。这时候如果在窗口foundW的下面找到一个窗口wb，它的Z轴位置大于等于maxLayer，即用来描述它的一个WindowState对象的成员变量mBaseLayer的值大于maxLayer，那么也会认为窗口wb是与窗口foundW有关联的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;我们通过图9和图10来说明查找与窗口foundW关联的、Z轴位置最小的窗口的过程：</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201302/02/1359743993_2494.jpg" alt="" /><br /></p><p style="text-align: center;">图9 查找与窗口foundW关联的窗口之前</p><p style="text-align: center;"><img width="614" src="http://img.my.csdn.net/uploads/201302/02/1359743999_6990.jpg" alt="" /><br /></p><p style="text-align: center;">图10 查找与窗口foundW关联的窗口之后<br /></p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;标号为Label #6的代码如下所示：</p><p></p><pre name="code" class="java">        // Start stepping backwards from here, ensuring that our wallpaper windows
        // are correctly placed.
        int curTokenIndex = mWallpaperTokens.size();
        while (curTokenIndex &gt; 0) {
            curTokenIndex--;
            WindowToken token = mWallpaperTokens.get(curTokenIndex);
            if (token.hidden == visible) {
                changed |= ADJUST_WALLPAPER_VISIBILITY_CHANGED;
                token.hidden = !visible;
                // Need to do a layout to ensure the wallpaper now has the
                // correct size.
                mLayoutNeeded = true;
            }

            int curWallpaperIndex = token.windows.size();
            while (curWallpaperIndex &gt; 0) {
                curWallpaperIndex--;
                WindowState wallpaper = token.windows.get(curWallpaperIndex);

                if (visible) {
                    updateWallpaperOffsetLocked(wallpaper, dw, dh, false);
                }

                // First, make sure the client has the current visibility
                // state.
                if (wallpaper.mWallpaperVisible != visible) {
                    wallpaper.mWallpaperVisible = visible;
                    try {
                        ......
                        wallpaper.mClient.dispatchAppVisibility(visible);
                    } catch (RemoteException e) {
                    }
                }

                wallpaper.mAnimLayer = wallpaper.mLayer + mWallpaperAnimLayerAdjustment;
                ......

                // First, if this window is at the current index, then all
                // is well.
                if (wallpaper == foundW) {
                    foundI--;
                    foundW = foundI &gt; 0
                            ? localmWindows.get(foundI-1) : null;
                    continue;
                }

                // The window didn't match...  the current wallpaper window,
                // wherever it is, is in the wrong place, so make sure it is
                // not in the list.
                int oldIndex = localmWindows.indexOf(wallpaper);
                if (oldIndex &gt;= 0) {
                    i......
                    localmWindows.remove(oldIndex);
                    mWindowsChanged = true;
                    if (oldIndex &lt; foundI) {
                        foundI--;
                    }
                }

                // Now stick it in.
                ......

                localmWindows.add(foundI, wallpaper);
                mWindowsChanged = true;
                changed |= ADJUST_WALLPAPER_LAYERS_CHANGED;
            }
        }</pre>&nbsp; &nbsp; &nbsp; &nbsp; 这段代码就是用来调整系统中的壁纸窗口在窗口堆栈中的位置的，目标就是要将它们放置在前面所找到的接下来要显示壁纸的窗口的下面。<p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; WindowManagerService类的成员变量mWallpaperTokens保存的是一系列WindowToken对象，它们描述的是系统中的壁纸窗口令牌。这些WindowToken对象都有一个成员变量windows，里面保存的是一系列WindowState对象，它们描述的是系统中的壁纸窗口。这段代码就目标就要通过两个嵌套的while循环来将这些WindowState对象调整到前面所找到的接下来要显示壁纸的窗口的下面去。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 在调整壁纸窗口在窗口堆栈中的位置的过程中，还会做以下四件事情：</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 1. 设置壁纸窗口令牌的可见性。也就是说，如果一个用来描述壁纸窗口令牌的WindowToken对象token的成员变量hidden的值不等于前面得到的变量visible的值，那么就说明该壁纸窗口令牌的可见性发生了变化。由于WindowToken类的成员变量hidden是用来表示壁纸窗口令牌的不可见状态的，而变量visible是用来表示接下来要显示壁纸的窗口是可见的，因此，当一个壁纸窗口令牌的可见性发生变化时，就要将用来描述它的WindowToken对象token的成员变量hidden的值设置为!visbile。壁纸窗口令牌的可见性发生了变化之后，需要重新刷新系统的UI，因此，就需要将WindowManagerService类的成员变量mLayoutNeeded 的值设置为true，并且将函数返回值changed的ADJUST_WALLPAPER_VISIBILITY_CHANGED位设置为1。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 2. 在前面所找到的接下来要显示壁纸的窗口是可见的情况下，即在变量visible的值等于true的情况下，重新计算每一个壁纸窗口wallpaper在X轴和Y轴上的偏移位置，这是通过调用WindowManagerService类的成员函数updateWallpaperOffsetLocked来实现的。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 3. 如果一个壁纸窗口之前是不可见的，现在变得可见了，或者之前是可见的，现在变得不可见了，具体就表现在用来描述该壁纸窗口的一个WindowState对象的成员变量mWallpaperVisible的值不等于变量visible的值，那么就需要该WindowState对象的成员变量mWallpaperVisible的值设置为visible，并且向提供该壁纸窗口的服务发送一个可见性变化事件通知。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 4. 调整每一个壁纸窗口的Z轴位置。一个壁纸窗口的Z轴位置保存在用来描述它的一个WindowState对象的成员变量mLayer中，用这个成员变量的值加上前面已经计算好的壁纸窗口的Z轴位置调整值，即保存在WindowManagerService类的成员变量mWallpaperAnimLayerAdjustment中的值，就可以得到一个壁纸窗口的最终Z轴位置值，并且保存WindowState对象的成员变量mAnimLayer中。</p><p>&nbsp; &nbsp; &nbsp; &nbsp; 前面在分析WindowManagerService类的成员函数adjustWallpaperWindowsLocked的实现框架时提到，在调整系统中的壁纸窗口在窗口堆栈中的位置之前，变量foundW描述的应该是Z轴位置最大的壁纸窗口，而变量foundI记录的是需要显示壁纸的窗口在窗口堆栈中的位置，如图11所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201302/02/1359747202_7531.jpg" alt="" /><br /></p><p style="text-align: center;">图11 调整壁纸窗口前的窗口堆栈状态</p><p>&nbsp; &nbsp; &nbsp; &nbsp;在图11中，接下来需要显示壁纸的是窗口A，在它下面依次是窗口B、C和D，并且系统中存在着三个壁纸窗口，它们的编号分别为1、2和3。假设窗口B和编号为3的壁纸窗口是同一个窗口，那么就说明编号为3的壁纸窗口已经在窗口堆栈中的正确位置了，因此，就不需要调整它在窗口堆栈中的位置了。这时候窗口堆栈中的状态如图12所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201302/02/1359747681_1079.jpg" alt="" /><br /></p><p style="text-align: center;">图12 处理完成编号为3的壁纸窗口后的窗口堆栈状态</p><p>&nbsp; &nbsp; &nbsp; &nbsp;在图12中，假设窗口C和编号为2的壁纸窗口不是同一个窗口，那么就需要将编号为2的壁纸窗口放置在窗口C的位置上，如图13所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201302/02/1359748144_5152.jpg" alt="" /><br /></p><p style="text-align: center;">图13 处理完成编号为2的壁纸窗口后的窗口堆栈状态</p><p>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在图13中，假设窗口C和编号为1的壁纸窗口也不是同一个窗口，那么就需要将编号为1的壁纸窗口放置在窗口C的位置上，如图14所示：</p><p style="text-align: center;"><img src="http://img.my.csdn.net/uploads/201302/02/1359748412_6472.jpg" alt="" /><br /></p><p style="text-align: center;">图14 处理完成编号为1的壁纸窗口的窗口堆栈状态</p><p>&nbsp; &nbsp; &nbsp; &nbsp;处理完成编号为1的壁纸窗口之后，系统中所有的壁纸窗口都调整到窗口A的下面去了，这样在下一次在刷新系统UI时，就可以将系统中的壁纸窗口作为窗口A的背景了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;至此，我们就分析完成壁纸窗口在窗口堆栈中的位置调整过程了，WindowManagerService服务对壁纸窗口的管理也分析完成了。结合前面<a href="http://blog.csdn.net/luoshengyang/article/details/8498908">Android窗口管理服务WindowManagerService对窗口的组织方式分析</a>和<a href="http://blog.csdn.net/luoshengyang/article/details/8526644">Android窗口管理服务WindowManagerService对输入法窗口（Input Method Window）的管理分析</a>这两篇文章，我们就可以对WindowManagerService服务在内部所维护的窗口堆栈有一个清晰的认识了。</p><p>&nbsp; &nbsp; &nbsp; &nbsp;当系统中的所有窗口都在窗口堆栈排列好之后，WindowManagerService服务就可以计算每一个窗口的Z轴坐标了，以便可以传递给SurfaceFlinger服务做可见性计算，从而正确地将系统的UI渲染出来。在接下来的一篇文章中，我们就将继续分析WindowManagerService服务计算窗口的Z轴坐标的过程，敬请关注！</p><p style="text-align: center;"><span style="font-size:14px;color:#cc0000;"><strong>老罗的新浪微博：<a href="http://weibo.com/shengyangluo" target="_blank">http://weibo.com/shengyangluo</a>，欢迎关注！</strong></span></p>
            <div>
                作者：Luoshengyang 发表于2013-2-4 0:56:36 <a href="http://blog.csdn.net/luoshengyang/article/details/8550820">原文链接</a>
            </div>
            <div>
            阅读：285 评论：2 <a href="http://blog.csdn.net/luoshengyang/article/details/8550820#comments" target="_blank">查看评论</a>
            </div>
        ]]>
        </description>
        <category></category>
    </item>
</channel>
</rss>
