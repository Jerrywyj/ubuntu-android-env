<!DOCTYPE html>
<!-- saved from url=(0062)http://hi.baidu.com/donghaozheng/item/51d16ce30a0f5a3a4cdcafe1 -->
<html id="customDoc" class="mod-with-msyahei" version="g42dymwpi--nx"> <body data-layershow="0">    <section class="mod-page-body"> <div class="mod-page-main wordwrap clearfix">  <div class="x-page-container">       <div class="mod-blogpage-wraper">   <div class="grid-80 mod-blogpage">     <div class="mod-text-content mod-post-content mod-cs-contentblock">    <div class="content-head clearfix">     <h2 class="title content-title">Linux Platform Device and Driver</h2>  </div>  <div id="content" class="content mod-cs-content text-content clearfix">                        从Linux 2.6起引入了一套新的驱动管理和注册机制:Platform_device和Platform_driver。<br>            Linux中大部分的设备驱动，都可以使用这套机制, 设备用Platform_device表示，驱动用Platform_driver进行注册。<br>            <br>            Linux platform driver机制和传统的device driver 机制(通过driver_register函数进行注册)相比，一个十分明显的优势在于platform机制将设备本身的资源注册进内核，由内核统一管理，在驱动程序中使用这些资源时通过platform device提供的标准接口进行申请并使用。这样提高了驱动和资源管理的独立性，并且拥有较好的可移植性和安全性(这些标准接口是安全的)。<br>            <br>            Platform机制的本身使用并不复杂，由两部分组成：platform_device和platfrom_driver。<br>            通过Platform机制开发发底层驱动的大致流程为:&nbsp;&nbsp;  定义 platform_device à 注册 platform_device à 定义 platform_driver à注册 platform_driver。<br>            <br>            首先要确认的就是设备的资源信息，例如设备的地址，中断号等。<br>            在2.6内核中platform设备用结构体platform_device来描述，该结构体定义在kernel\include\linux\platform_device.h中，<br>            struct platform_device {<br>            const char * name;<br>            u32&nbsp;&nbsp;  id;<br>            struct device dev;<br>            u32&nbsp;&nbsp;  num_resources;<br>            struct resource * resource;<br>            };<br>            <br>            该结构一个重要的元素是resource，该元素存入了最为重要的设备资源信息，定义在kernel\include\linux\ioport.h中，<br>            struct resource {<br>            const char *name;<br>            unsigned long start, end;<br>            unsigned long flags;<br>            struct resource *parent, *sibling, *child;<br>            };<br>            <br>            下面举s3c2410平台的i2c驱动作为例子来说明：<br>            /* arch/arm/mach-s3c2410/devs.c */<br>            /* I2C */<br>            static struct resource s3c_i2c_resource[] = {<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    [0] = {<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;     .start = S3C24XX_PA_IIC,<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;     .end = S3C24XX_PA_IIC + S3C24XX_SZ_IIC - 1,<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;     .flags = IORESOURCE_MEM,<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    },<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    [1] = {<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;     .start = IRQ_IIC, //S3C2410_IRQ(27)<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;     .end = IRQ_IIC,<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;     .flags = IORESOURCE_IRQ,<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    }<br>            };<br>            <br>            这里定义了两组resource，它描述了一个I2C设备的资源，第1组描述了这个I2C设备所占用的总线地址范围，IORESOURCE_MEM表示第1组描述的是内存类型的资源信息，第2组描述了这个I2C设备的中断号，IORESOURCE_IRQ表示第2组描述的是中断资源信息。设备驱动会根据flags来获取相应的资源信息。<br>            <br>            有了resource信息，就可以定义platform_device了：<br>            &nbsp;&nbsp;<br>            struct platform_device s3c_device_i2c = {<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    .name = "s3c2410-i2c",<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    .id = -1,<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    .num_resources = ARRAY_SIZE(s3c_i2c_resource),<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    .resource = s3c_i2c_resource,<br>            };<br>            定义好了platform_device结构体后就可以调用函数platform_add_devices向系统中添加该设备了，之后可以调用platform_driver_register()进行设备注册。要注意的是，这里的platform_device设备的注册过程必须在相应设备驱动加载之前被调用，即执行platform_driver_register之前,原因是因为驱动注册时需要匹配内核中所以已注册的设备名。<br>            <br>            s3c2410-i2c的platform_device是在系统启动时，在cpu.c里的s3c_arch_init()函数里进行注册的，这个函数申明为arch_initcall(s3c_arch_init);会在系统初始化阶段被调用。<br>            arch_initcall的优先级高于module_init。所以会在Platform驱动注册之前调用。(详细参考include/linux/init.h)<br>            <br>            s3c_arch_init函数如下：<br>            /* arch/arm/mach-3sc2410/cpu.c */<br>            static int __init s3c_arch_init(void)<br>            {<br>                int ret;<br>                ……<br>            /* 这里board指针指向在mach-smdk2410.c里的定义的smdk2410_board，里面包含了预先定义的I2C Platform_device等. */<br>                if (board != NULL) {<br>              &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;  struct platform_device **ptr = board-&gt;devices;<br>              &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;  int i;<br>              &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;  for (i = 0; i&nbsp;&nbsp;  board-&gt;devices_count; i++, ptr++) {<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;    ret = platform_device_register(*ptr);    //在这里进行注册<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;    if (ret) {<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;     printk(KERN_ERR "s3c24xx: failed to add board device %s (%d) @%p\n", (*ptr)-&gt;name, <br>            ret, *ptr);<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;    }<br>              &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;  }<br>              &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;  /* mask any error, we may not need all these board<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    * devices */<br>              &nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;  ret = 0;<br>                }<br>                return ret;<br>            }<br>            <br>            同时被注册还有很多其他平台的platform_device，详细查看arch/arm/mach-s3c2410/mach-smdk2410.c里的smdk2410_devices结构体。<br>            <br>            <br>            驱动程序需要实现结构体struct platform_driver，参考drivers/i2c/busses<br>            /* device driver for platform bus bits */<br>            static struct platform_driver s3c2410_i2c_driver = {<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    .probe = s3c24xx_i2c_probe,<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    .remove = s3c24xx_i2c_remove,<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    .resume = s3c24xx_i2c_resume,<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    .driver = {<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;     .owner = THIS_MODULE,<br>              &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;   &nbsp;&nbsp;     .name = "s3c2410-i2c",<br>              &nbsp;&nbsp;   &nbsp;&nbsp;    },<br>            };<br>            <br>            在驱动初始化函数中调用函数platform_driver_register()注册platform_driver，需要注意的是s3c_device_i2c结构中name元素和s3c2410_i2c_driver结构中driver.name必须是相同的，这样在platform_driver_register()注册时会对所有已注册的所有platform_device中的name和当前注册的platform_driver的driver.name进行比较，只有找到相同的名称的platfomr_device才能注册成功，当注册成功时会调用platform_driver结构元素probe函数指针，这里就是s3c24xx_i2c_probe,当进入probe函数后，需要获取设备的资源信息，常用获取资源的函数主要是：<br>            struct resource * platform_get_resource(struct platform_device *dev, unsigned int type, unsigned int num);<br>            根据参数type所指定类型，例如IORESOURCE_MEM，来获取指定的资源。<br>            <br>            struct int platform_get_irq(struct platform_device *dev, unsigned int num);<br>            获取资源中的中断号。<br>            <br>            <br>            <br>            下面举s3c24xx_i2c_probe函数分析,看看这些接口是怎么用的。<br>            前面已经讲了，s3c2410_i2c_driver注册成功后会调用s3c24xx_i2c_probe执行，下面看代码：<br>            /* drivers/i2c/busses/i2c-s3c2410.c */<br>            static int s3c24xx_i2c_probe(struct platform_device *pdev)<br>            {<br>                struct s3c24xx_i2c *i2c = &amp;s3c24xx_i2c;<br>                struct resource *res;<br>                int ret;<br>            <br>                /* find the clock and enable it */<br>            <br>                i2c-&gt;dev = &amp;pdev-&gt;dev;<br>                i2c-&gt;clk = clk_get(&amp;pdev-&gt;dev, "i2c");<br>                if (IS_ERR(i2c-&gt;clk)) {<br>              &nbsp;&nbsp;&nbsp;  dev_err(&amp;pdev-&gt;dev, "cannot get clock\n");<br>              &nbsp;&nbsp;&nbsp;  ret = -ENOENT;<br>              &nbsp;&nbsp;&nbsp;  goto out;<br>                }<br>                dev_dbg(&amp;pdev-&gt;dev, "clock source %p\n", i2c-&gt;clk);<br>                clk_enable(i2c-&gt;clk);<br>                /* map the registers */<br>                res = platform_get_resource(pdev, IORESOURCE_MEM, 0); /* 获取设备的IO资源地址 */<br>                if (res == NULL) {<br>              &nbsp;&nbsp;&nbsp;  dev_err(&amp;pdev-&gt;dev, "cannot find IO resource\n");<br>              &nbsp;&nbsp;&nbsp;  ret = -ENOENT;<br>              &nbsp;&nbsp;&nbsp;  goto out;<br>                }<br>                <br>                i2c-&gt;ioarea = request_mem_region(res-&gt;start, (res-&gt;end-res-&gt;start)+1, pdev-&gt;name); /* 申请这块IO Region */<br>                <br>                if (i2c-&gt;ioarea == NULL) {<br>              &nbsp;&nbsp;&nbsp;  dev_err(&amp;pdev-&gt;dev, "cannot request IO\n");<br>              &nbsp;&nbsp;&nbsp;  ret = -ENXIO;<br>              &nbsp;&nbsp;&nbsp;  goto out;<br>                }<br>                <br>                i2c-&gt;regs = ioremap(res-&gt;start, (res-&gt;end-res-&gt;start)+1); /* 映射至内核虚拟空间 */<br>                <br>                if (i2c-&gt;regs == NULL) {<br>              &nbsp;&nbsp;&nbsp;  dev_err(&amp;pdev-&gt;dev, "cannot map IO\n");<br>              &nbsp;&nbsp;&nbsp;  ret = -ENXIO;<br>              &nbsp;&nbsp;&nbsp;  goto out;<br>                }<br>                <br>                dev_dbg(&amp;pdev-&gt;dev, "registers %p (%p, %p)\n", i2c-&gt;regs, i2c-&gt;ioarea, res);<br>                <br>                /* setup info block for the i2c core */<br>                i2c-&gt;adap.algo_data = i2c;<br>                i2c-&gt;adap.dev.parent = &amp;pdev-&gt;dev;<br>                <br>                /* initialise the i2c controller */<br>                ret = s3c24xx_i2c_init(i2c);<br>                if (ret != 0)<br>              &nbsp;&nbsp;&nbsp;  goto out;<br>                /* find the IRQ for this unit (note, this relies on the init call to ensure no current IRQs pending */<br>                <br>                res = platform_get_resource(pdev, IORESOURCE_IRQ, 0); /* 获取设备IRQ中断号 */<br>                if (res == NULL) {<br>              &nbsp;&nbsp;&nbsp;  dev_err(&amp;pdev-&gt;dev, "cannot find IRQ\n");<br>              &nbsp;&nbsp;&nbsp;  ret = -ENOENT;<br>              &nbsp;&nbsp;&nbsp;  goto out;<br>                }<br>                <br>                ret = request_irq(res-&gt;start, s3c24xx_i2c_irq, IRQF_DISABLED, /* 申请IRQ */<br>              &nbsp;&nbsp;&nbsp;  pdev-&gt;name, i2c);<br>                <br>                ……<br>                return ret;<br>                <br>            }<br>            <br>            小思考：<br>            那什么情况可以使用platform driver机制编写驱动呢？<br>            我的理解是只要和内核本身运行依赖性不大的外围设备(换句话说只要不在内核运行所需的一个最小系统之内的设备),相对独立的,拥有各自独自的资源(addresses and IRQs)，都可以用platform_driver实现。如：lcd,usb,uart等，都可以用platfrom_driver写，而timer,irq等最小系统之内的设备则最好不用platfrom_driver机制，实际上内核实现也是这样的。<br>            <br>            参考资料：<br>            linux-2.6.24/Documentation/driver-model/platform.txt<br>            <br>            《platform _device和platform_driver注册过程》<br>            <a href="http://blog.chinaunix.net/u2/60011/showart.php?id=1018999" target="_blank">http://blog.chinaunix.net/u2/60011/showart.php?id=1018999</a><br>            <br>            <a href="http://www.eetop.cn/blog/html/45/11145-676.html" target="_blank">http://www.eetop.cn/blog/html/45/11145-676.html</a><br>            <br>                        <br>            <br>             </div>    <div class="mod-tagbox clearfix"> </div>    </div>                </div>  </div>  </div> </div> </section>                        </body></html>