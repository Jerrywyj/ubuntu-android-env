<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0071)http://blog.163.com/wxiongn@126/blog/static/11788203820111126103811200/ -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh" lang="zh">
<body onload="prettyPrint()" id="blog-163-com" class="nb-body nb-inr nb-prv">
  
    



  <div class="nb-wrap wsy" id="blog-163-com-main">  
  <div class="nb-are nb-cnt">
    <div class="wkg">
      <div class="c wc h clearfix " id="blog-163-com-container">
  <div class="nb-mdl lcr m-3 " id="-3">
  
    <div class="nb-mc lcr">
      <div class="c cc lcr nb-jsc">
<div class="nbw-ryt ztag clearfix js-auto-098">
  <div class="right bdwl bds0 bdc0"><div class="cnt ztag"></div></div>
  <div class="left">
     <div class="lcnt bdwr bds0 bdc0 ">
      
     <div class="mcnt ztag">
      <div class="nbw-bitm bdwb bds2 bdc0 ">
        <div class="multicntwrap">
	      <div class="multicnt">
	      	<div>
		      <h3 class="title pre fs1"><span class="tcnt">linux spi驱动分析整理</span>&nbsp;&nbsp;<span class="bgc0 fc07 fw0 fs0"></span></h3>
		      
		    </div>
	      </div>
        </div>

        <div>
        
        </div>

        <div class="nbw-blog-start"></div>
        <div class="bct fc05 fc11 nbw-blog ztag js-fs2"><div><b>声明：</b></div><div><b>该篇分析参考/拷贝于：</b></div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;http://www.embedu.org/Column/Column367.htm</b></div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;http://www.linuxidc.com/Linux/2011-11/46656.htm</b></div><div><b>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;http://www.arm9home.net/read.php?tid=10788等</b></div><div><b>经过个人的理解整理，不保证内容的正确性！欢迎指出错误的地方！</b></div><div><br></div><div>1、SPI总线：</div><div>&nbsp; &nbsp; &nbsp; &nbsp;SPI(同步外设接口)是由摩托罗拉公司开发的全双工同步串行总线,其接口由 MISO(串行数据输入),MOSI(串行数据输出),SCK(串行移位时钟),SS/CS(从使能信号)四种信号构成(当然了,现在芯片技术日新月异,SPI 模块的结构也在变化中,象 OMAP 系列中的 SPI 模块还支持 5 线的一种模式),SS /CS决定了唯一的与主设备通信的从设备,主设备通过产生移位时钟来发起通讯。通讯时,数据由 MOSI 输出,MISO 输入,数据在时钟的上升</div><div>或下降沿由 MOSI 输出,在紧接着的下降或上升沿由 MISO 读入,这样经过 8/16 次时钟的改变,完成 8/16 位数据的传输。</div><div><div style="text-align: center;"><img alt="linux spi驱动分析（转/整理） - だへ雄♂√ぷ - だへ雄♂√ぷ" style="margin-top: 0px; margin-right: 10px; margin-bottom: 0px; margin-left: 10px; float: none;" src="./spi_files/2547067064271884133.gif"></div>&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp;SPI 模块为了和外设进行数据交换,根据外设工作要求,其输出串行同步时钟极性(CPOL)和相位(CPHA)可以进行配置。如果 CPOL=0,串行同步时钟的空闲状态为低电平;如果CPOL=1,串行同步时钟的空闲状态为高电平。如果 CPHA=0,在串行同步时钟的第一个跳变沿(上升或下降)数据被采样;如果 CPHA=1,在串行同步时钟的第二个跳变沿(上升或下降)数据被采样。</div><div><div style="text-align: center;"><img alt="linux spi驱动分析（转/整理） - だへ雄♂√ぷ - だへ雄♂√ぷ" style="margin-top: 0px; margin-right: 10px; margin-bottom: 0px; margin-left: 10px; float: none;" src="./spi_files/2654309030398430019.jpg"></div><div>&nbsp;</div></div><div><div style="line-height: 22px;">2、LINUX驱动的分层与分离：</div><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;在面向对象的程序设计中,可以为某一类相似的事物定义一个基类,而具体的事物可以继承这个基类中的函数。Linux 内核中频繁使用到面向对象的设计思想。在设备驱动方面,往往为同类的设备设计了一个框架,而框架中的核心层则实现了该设备通用的一些功能。而且具体的设备不想使用核心层的函数,它可以重载之。这就是我们所说的在驱动设计中的分层思想。</div><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;此外,在驱动的设计中,我们还会使用分离的思想。如果一个设备的驱动和 host 的驱动休戚相关,那么,这就意味着这个普通的设备如果用在不同的 host 上,会采用 n 个版本的驱动。如果产品单一,也许感觉不到不使用分离思想来设计驱动的危害,但是我们想一下,这个世上被人们称道的多是什么?精品,艺术品!精品如何打造?注重细节,不只考虑单一需求!大家开发个东西不容易,怎么能随随便便就让它茫然众码矣呢,所以,何时何地,我们都要以打造精品的思想来要求自己,让自己的劳动力不浪费。</div><div style="line-height: 22px;">使用分离的思想来设计驱动的话,就够就是这样的:</div><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;外设驱动与主机控制器的驱动不相关,主机控制器的驱动不关心外设,而外设驱动也不关心主机,外设只是访问核心层的通用 API 进行数据传输,主机和外设之间可以进行任意的组合。相当于在控制器驱动和设备驱动之间增加一层核心层,对内对外都隐藏了对端的不确定性。仔细通读USB,SPI,PCI 的代码就会发现这种思想的体现。</div><div style="line-height: 22px;"><br></div><div style="line-height: 22px;">3、LINUX设备模型：</div><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;设备驱动模型中,主要包含总线、设备和驱动三个实体,总线将设备和驱动绑定,在系统每注册一个设备的时候,会寻找与之匹配的驱动,反之,在系统每注册一个驱动的时候,会寻找与之匹配的设备,而匹配由总线完成。</div><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;根据这个模型的需求,一个现实的 linux 设备和驱动通常都需要挂接在一种总线上,否则谁来管他们的匹配啊,注册驱动和注册设备都是由不同的 API 来完成的。对于本身依附于 PCI,USB,I2C,SPI 等的设备而言,这自然不是问题,但是在嵌入式系统里面,Controller 系统中集成的外设控制器,挂载在内存空间的外设确不依附于此类总线。就像 SPI 控制器,PCI 控制器等等都是这种情况。那如何处理呢？基于这一背景,Linux 发明了一种虚拟的总线称为 platform 总线,相应的设备称为 platform_device,而驱动称为 platform_driver。关于platform总线这里就不多说了，网上有很多资料。</div></div><div><div style="line-height: 22px;"><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; 使用 platform 总线在驱动中大体有以下几个好处:</div><div style="line-height: 22px;">a,使得设备被挂接在一个总线上,使配套的 sysfs 节点、设备电源管理都成为可能。</div><div style="line-height: 22px;">b, 隔离了 BSP 和驱动。BSP 中定义 platform 设备和设备使用的资源(可以使用platform_data 的形式来包括 platform 设备的设备),设备的具体配置信息。而在驱动中,只需要通过通用 API 去获取资源和数据,做到了板相关代码和驱动代码的分离,使得驱动具有更好的可扩展性和跨平台性。</div><div><br></div></div></div><div><br></div><div><div style="line-height: 22px;">4、LINUX SPI 核心层：</div><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;核心层代码负责这个框架中通用的部分，满足分层的思想，位于drivers/spi/spi.c。<span style="line-height: 22px;">主要承担的工作包括:注册 spi总线,提供基本 SPI 总线操作 API：</span></div><div style="line-height: 22px;">int spi_register_driver(struct spi_driver *sdrv)；</div><div style="line-height: 22px;">struct spi_device *spi_alloc_device(struct spi_master *master)；</div><div style="line-height: 22px;">int spi_add_device(struct spi_device *spi)；</div><div style="line-height: 22px;">struct spi_device *spi_new_device(struct spi_master *master,&nbsp;struct spi_board_info *chip)；</div><div style="line-height: 22px;">struct spi_master *spi_alloc_master(struct device *dev, unsigned size)；</div><div style="line-height: 22px;">int spi_register_master(struct spi_master *master)；</div><div style="line-height: 22px;">void spi_unregister_master(struct spi_master *master)；</div><div style="line-height: 22px;">int spi_sync(struct spi_device *spi, struct spi_message *message)；</div><div style="line-height: 22px;">int spi_write_then_read(struct spi_device *spi,&nbsp;const u8 *txbuf, unsigned n_tx,&nbsp;u8 *rxbuf, unsigned n_rx)；</div><div>spi_register_board_info(struct spi_board_info const *info, unsigned n)；</div><div style="line-height: 22px;">等......（具体查看/driver/spi/spi.c）</div><div style="line-height: 22px;">4.1、spi主机master</div><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;在 Linux 中,每一个类型的驱动都会有一个相应的结构体来描述,spi_master 就是用来描述 SPI 主机控制器驱动的,其主要成员是bus_num,cs,spi 模式和时钟设置用到的函数,数据传输用到的函数等。<span style="line-height: 22px;">一个 master 对应一个 spi 总线,或者说是一个 spi 接口：</span></div><div style="line-height: 22px;"><div style="line-height: 22px;">struct spi_master {</div><div style="line-height: 22px;">struct device &nbsp; dev;</div><div style="line-height: 22px;">s16 &nbsp; &nbsp; &nbsp; &nbsp; bus_num; //表示是SPI主机控制器的编号。由平台代码决定</div><div style="line-height: 22px;"><span style="line-height: 22px; text-indent: 69px;">u16 &nbsp; &nbsp; &nbsp; &nbsp; num_chipselect;&nbsp;</span>//控制器支持的片选数量，即能支持多少个spi设备</div><div style="line-height: 22px;"><span style="line-height: 22px; text-indent: 69px;">int &nbsp; &nbsp; &nbsp; &nbsp; (*setup)(struct spi_device *spi);&nbsp;</span>//针对设备设置SPI的工作时钟及数据传输模式等。在spi_add_device函数中调用。</div><div style="line-height: 22px;"><span style="line-height: 22px;">int &nbsp; &nbsp; &nbsp; &nbsp; (*transfer)(struct spi_device *spi,&nbsp;struct spi_message *mesg);&nbsp;</span>//实现数据的双向传输，可能会睡眠</div><div style="line-height: 22px;"><span style="line-height: 22px;">void &nbsp; &nbsp; &nbsp; (*cleanup)(struct spi_device *spi);&nbsp;//注销时调用</span></div><div style="line-height: 22px;">};</div><div><br></div></div><div style="line-height: 22px;"><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;SPI主机驱动中分配、注册和注销 SPI 主机驱动结构体将调用spi核心层API:<span style="line-height: 22px;">&nbsp;spi_alloc_master();</span><span style="line-height: 22px;">&nbsp;spi_register_master();&nbsp;</span><span style="line-height: 22px;">spi_unregister_master();</span></div><div style="line-height: 22px;">实际上在master的驱动中实现的就是spi_master中的初始化以及注册，其中最重要的就是transfer和setup这两个操作的实现。spi每次数据传输最终调用到的函数就是这里的transfer。该函数就对应着实际硬件上寄存器的控制。setup同理。</div><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;这里可能会有疑问,spi master controller 注册对应的驱动框架里的哪一层?按说,spi 主机控制器已经作为 platform 设备都注册过了。这里就需要用驱动设计里面的分层思想来解释。使用到 platform 总线 API 注册到 platform总线上的控制器设备和驱动,都是 common 的部分。specific 的部分,会在 platform driver注册后,在 probe 函数里面基于注册的 common 部分的资源信息来具体实现。称之为spi_master 的注册部分。</div></div><div><div style="line-height: 22px;"><br></div><div><div>4.2、spi从机slave</div></div><div><div><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;依附于spi总线的驱动都会有一个spi_driver结构体来描述，结构体中定义对应的操作函数指针：</div><div><div style="line-height: 22px;">struct spi_driver {</div><div style="line-height: 22px;">&nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; (*probe)(struct spi_device *spi);</div><div style="line-height: 22px;">&nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; (*remove)(struct spi_device *spi);</div><div style="line-height: 22px;">&nbsp; &nbsp; void &nbsp; &nbsp; &nbsp; (*shutdown)(struct spi_device *spi);</div><div style="line-height: 22px;">&nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; (*suspend)(struct spi_device *spi, pm_message_t mesg);</div><div style="line-height: 22px;">&nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; (*resume)(struct spi_device *spi);</div><div style="line-height: 22px;">&nbsp; &nbsp; struct device_driver &nbsp; &nbsp;driver;</div><div style="line-height: 22px;">};</div><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;依附于spi总线的设备都会有一个spi_device结构体来描述，结构中定义了设备的片选、模式、速率以及对应主机驱动的spi_master等。</div><div><div>struct spi_device {</div><div>&nbsp; &nbsp; struct device &nbsp; &nbsp; &nbsp; dev;</div><div>&nbsp; &nbsp; struct spi_master &nbsp; *master;</div><div>&nbsp; &nbsp; u32 &nbsp; &nbsp; &nbsp; &nbsp; max_speed_hz;</div><div>&nbsp; &nbsp; u8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;chip_select;</div><div>&nbsp; &nbsp; u8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;mode;</div><div>#define SPI_CPHA &nbsp; &nbsp;0x01 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* clock phase */</div><div>#define SPI_CPOL &nbsp; &nbsp;0x02 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* clock polarity */</div><div>#define SPI_MODE_0 &nbsp;(0|0) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* (original MicroWire) */</div><div>#define SPI_MODE_1 &nbsp;(0|SPI_CPHA)</div><div>#define SPI_MODE_2 &nbsp;(SPI_CPOL|0)</div><div>#define SPI_MODE_3 &nbsp;(SPI_CPOL|SPI_CPHA)</div><div>#define SPI_CS_HIGH 0x04 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* chipselect active high? */</div><div>#define SPI_LSB_FIRST &nbsp; 0x08 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* per-word bits-on-wire */</div><div>#define SPI_3WIRE &nbsp; 0x10 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* SI/SO signals shared */</div><div>#define SPI_LOOP &nbsp; &nbsp;0x20 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/* loopback mode */</div><div>&nbsp; &nbsp; u8 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;bits_per_word;</div><div>&nbsp; &nbsp; int &nbsp; &nbsp; &nbsp; &nbsp; irq;</div><div>&nbsp; &nbsp; void &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*controller_state;</div><div>&nbsp; &nbsp; void &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;*controller_data;</div><div>&nbsp; &nbsp; char &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;modalias[32];</div><div>};</div><div style="line-height: 22px;"><br></div></div></div></div><div style="line-height: 22px;"><br></div><div style="line-height: 22px;"><span style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;依附于Spi总线的设备驱动对应的总线类型为spi_bus_type，在内核的drivers/spi/spi.c中定义。</span></div><div><div>struct bus_type spi_bus_type = {&nbsp;</div><div>&nbsp; &nbsp; .name &nbsp; &nbsp; &nbsp; = "spi",</div><div>&nbsp; &nbsp; .dev_attrs &nbsp;= spi_dev_attrs,</div><div>&nbsp; &nbsp; .match &nbsp; &nbsp; &nbsp;= spi_match_device,</div><div>&nbsp; &nbsp; .uevent &nbsp; &nbsp; = spi_uevent,</div><div>&nbsp; &nbsp; .suspend &nbsp; &nbsp;= spi_suspend,</div><div>&nbsp; &nbsp; .resume &nbsp; &nbsp; = spi_resume,</div><div>};</div><div>EXPORT_SYMBOL_GPL(spi_bus_type);</div><div style="line-height: 22px;"><br></div></div><div style="line-height: 22px;"><span style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;</span><span style="line-height: 22px;">而</span><span style="line-height: 22px;">具体的spi外设信息linux spi 用 struct spi_board_info来描述，该结构体包含外设的片选号、总线号、模式以及传输速率等信息。在系统初始化时将会调用spi_register_board_info()来注册硬件信息。</span></div></div><div style="line-height: 22px;"><div style="line-height: 22px;"><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;spi设备驱动将会调用spi_register_driver();来注册一个spi_driver驱动，注册时最终会调用spi_bus_type中的match来使spi_driver和spi_device相匹配。设备驱动spi_driver是在驱动里定义的，但是spi_device呢？事实上上文提到的spi_master的注册会在spi_register_board_info之后，spi_master注册的过程中会调用scan_boardinfo扫描board_list，找到挂接在它上面的spi设备，然后创建并注册spi_device。</div><div style="line-height: 22px;"><br></div></div></div></div></div><div>5、LINUX SPI 控制器设备和驱动：</div><div>&nbsp; &nbsp; &nbsp; &nbsp;在嵌入式系统中，一般处理器中都集成了spi控制器。该控制器一般都为master。以下分析spi控制器master驱动。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;由设备模型可知，spi控制器的设备和驱动是要挂在总线上的。所以spi控制器驱动用到了platform虚拟总线。spi控制器platform设备在BSP的初始化中被注册，驱动一般放在driver/spi/下。</div><div><br></div><div><div>如，在 BSP 文件中添加相应的资源代码:</div><div>通常,会在 arch/***/mach-***/xxxx.c 中添加，例如：</div><div>static struct platform_device ***_spi_pdev1 = {</div><div>.name = “***_spi”,</div><div>.id = 1,</div><div>.resource = ***_spi_resources1,</div><div>.num_resources = ARRAY_SIZE(***_spi_resources1),</div><div>.dev = {</div><div>.platform_data = &amp;***_spi_pdata1,</div><div>},</div><div>};</div><div>然后会在 BSP 的 init 过程中使用 platform_device_register 将它注册进系统。若片上有n个spi控制器，可以在此定义n个platform_device。注册成功后即可在sys/bus/platform/devices下看到对应的***_spi.n。</div></div><div><div style="line-height: 22px;"><br></div><div style="line-height: 22px;">spi控制器驱动代码init时调用platform_driver_register：</div><div style="line-height: 22px;"><div style="line-height: 22px;">static int __init xxxx_spi_init(void)</div><div style="line-height: 22px;">{</div><div style="line-height: 22px;">&nbsp; &nbsp; return platform_driver_register(&amp;xxxx_spi_driver); //注册spi驱动器的platform驱动</div><div style="line-height: 22px;">}</div><div>注册成功后即可在sys/bus/platform/drivers下看到对应的***_spi。</div></div></div><div><div>platform_driver和platform_device匹配后，会调用驱动中的***_probe。然后根据传入的platform_device参数，构建一个用于描述SPI控制器的结构体spi_master，并注册。spi_register_master(master)。后续注册的spi_device需要选定自己的spi_master，并利用spi_master提供的传输功能传输spi数据。</div><div><span style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;仔细浏览代码可以发现,在 SPI 向 platform 总线注册的时候,象 platform_device 中的device_data 或 driver_data 都是空的,并没有将它赋值,这些都是在 probe 函数中完成的。</span></div></div><div><div style="line-height: 22px;"><div style="line-height: 22px;">&nbsp; &nbsp; &nbsp; &nbsp;在probe 函数里面的数据结构的设计和代码都是按照驱动框架的要求来实现的,主要包括 spi controller memory 的映射,IRQ 的注册,controller 的 reset 和对 register 进行初始化赋值。调用spi_alloc_master分配spi_master设备，对spi_master进行赋值等。最后,它将调用 spi_bitbang_start()来创建一个 work queue,由此 SPI 设备驱动可以向这个工作队列注册 transfer 方法。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;接下来就得实现spi_master结构中的transfer、setup、cleanup及中断处理等的方法。</div></div></div><div><br></div><div>6、LINUX SPI 外设驱动：</div><div>&nbsp; &nbsp; &nbsp; &nbsp;不同的spi外设在spi总线通信上的需求不尽相同，比如模式、时钟速率、片选脚等等。这些跟具体硬件相关的信息都用spi_board_info来描述。在系统初始化时调用spi_register_board_info来将板上所有的外设注册到board_list链表上。</div><div>以m25p80为参考：</div><div>在S5PC100对应的m25p10 BSP代码中：</div><div><div>static struct spi_board_info s3c_spi_devs[] __initdata = {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .modalias<span style="white-space:pre;"> </span> = "m25p10",&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .mode<span style="white-space:pre;"> </span>= SPI_MODE_0, &nbsp; &nbsp;//CPOL=0, CPHA=0 此处选择具体数据传输模式</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .max_speed_hz = 10000000, &nbsp; &nbsp;//最大的spi时钟频率</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* Connected to SPI-0 as 1st Slave */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .bus_num<span style="white-space:pre;"> </span> = 0, &nbsp; &nbsp;//设备连接在spi控制器0上</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .chip_select<span style="white-space:pre;"> </span> = 0, &nbsp; &nbsp;//片选线号，在S5PC100的控制器驱动中没有使用它作为片选的依据，而是选择了下文controller_data里的方法。</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .controller_data = &amp;smdk_spi0_csi[0],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; };</div><div>在这可以看到对m25p10这块flash芯片的spi通信模式等的初始化。注意spi_board_info结构中的modalias元素，在这的名字应和对应的spi设备驱动中spi_driver里的driver的name一致。因为spi_driver和spi_device在总线匹配时会对比这个名字，一样则匹配成功。</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; static struct s3c64xx_spi_csinfo smdk_spi0_csi[] = {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0] = {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .set_level = smdk_m25p10_cs_set_level,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .fb_delay = 0x3,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; };</div><div>&nbsp; &nbsp; &nbsp; &nbsp; static void smdk_m25p10_cs_set_level(int high) &nbsp; &nbsp;//spi控制器会用这个方法设置cs</div><div>&nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; u32 val;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val = readl(S5PC1XX_GPBDAT);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (high)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val |= (1&lt;&lt;3);//拉高片选脚</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; val &amp;= ~(1&lt;&lt;3);//拉低片选脚</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writel(val, S5PC1XX_GPBDAT);</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>spi的片选脚是可配置的，smdk_m25p10_cs_set_level()会被master控制器驱动调用，用来使能外设。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;spi_register_board_info(s3c_spi_devs, ARRAY_SIZE(s3c_spi_devs));//注册spi_board_info。这个代码会把spi_board_info注册要链表board_list上。</div></div><div><br></div><div><div>以linux内核中的/driver/mtd/devices/m25p80.c驱动为参考。</div><div>static struct spi_driver m25p80_driver = { //spi_driver的构建</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .driver = {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .name<span style="white-space:pre;"> </span>= "m25p80",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .bus<span style="white-space:pre;"> </span>= &amp;spi_bus_type,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .owner<span style="white-space:pre;"> </span>= THIS_MODULE,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .probe<span style="white-space:pre;"> </span>= m25p_probe,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; .remove<span style="white-space:pre;"> </span>= __devexit_p(m25p_remove),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; */</div><div>&nbsp; &nbsp; &nbsp; &nbsp; };</div><div>spi_register_driver(&amp;m25p80_driver);//spi driver的注册</div><div>在有匹配的spi device时，会调用m25p_probe</div><div>static int __devinit m25p_probe(struct spi_device *spi)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ……</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>根据传入的spi_device参数，可以找到对应的spi_master。接下来就可以利用spi子系统为我们完成数据交互了。可以参看m25p80_read函数。要完成传输，先理解下面几个结构的含义：（这两个结构的定义及详细注释参见include/linux/spi/spi.h）</div></div><div><div>&nbsp; &nbsp; &nbsp; &nbsp; spi_message：描述一次完整的传输，即cs信号从高-&gt;底-&gt;高的传输</div><div>&nbsp; &nbsp; &nbsp; &nbsp; spi_transfer：多个spi_transfer够成一个spi_message</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 举例说明：m25p80的读过程如下图</div><div><div style="text-align: center;"><img alt="linux spi驱动分析整理 - だへ雄♂√ぷ - だへ雄♂√ぷ" style="margin-top: 0px; margin-right: 10px; margin-bottom: 0px; margin-left: 10px; float: none;" src="./spi_files/2618280233379682036.jpg"></div>&nbsp;</div><div>可以分解为两个spi_ transfer一个是写命令，另一个是读数据。具体实现参见m25p80.c中的m25p80_read函数。下面内容摘取之此函数。</div><div><br></div><div>struct spi_transfer t[2]; &nbsp; &nbsp;//定义了两个spi_transfer</div><div>&nbsp; &nbsp; &nbsp; &nbsp; struct spi_message m; &nbsp; &nbsp; //定义了两个spi_message</div><div>&nbsp; &nbsp; &nbsp; &nbsp; spi_message_init(&amp;m); &nbsp; &nbsp; //初始化其transfers链表</div><div><br></div><div>t[0].tx_buf = flash-&gt;command;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; t[0].len = CMD_SIZE + FAST_READ_DUMMY_BYTE; &nbsp; &nbsp; //定义第一个transfer的写指针和长度</div><div>&nbsp; &nbsp; &nbsp; &nbsp; spi_message_add_tail(&amp;t[0], &amp;m); &nbsp; &nbsp;//添加到spi_message</div><div>&nbsp; &nbsp; &nbsp; &nbsp; t[1].rx_buf = buf;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; t[1].len = len; &nbsp; &nbsp; //定义第二个transfer的读指针和长度</div><div><br></div><div>spi_message_add_tail(&amp;t[1], &amp;m); &nbsp; &nbsp; //添加到spi_message</div><div>&nbsp; &nbsp; &nbsp; &nbsp; flash-&gt;command[0] = OPCODE_READ;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; flash-&gt;command[1] = from &gt;&gt; 16;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; flash-&gt;command[2] = from &gt;&gt; 8;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; flash-&gt;command[3] = from; &nbsp; &nbsp;//初始化前面写buf的内容</div><div><br></div><div>spi_sync(flash-&gt;spi, &amp;m); &nbsp; &nbsp; //调用spi_master发送spi_message</div><div><br></div><div>// spi_sync为同步方式发送，还可以用spi_async异步方式，那样的话，需要设置回调完成函数。</div><div><br></div><div>另外你也可以选择一些封装好的更容易使用的函数，这些函数可以在include/linux/spi/spi.h文件中找到，如：</div><div>extern int spi_write_then_read(struct spi_device *spi, const u8 *txbuf, unsigned n_tx, u8 *rxbuf, unsigned n_rx);</div></div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp;对于 SPI 的设备驱动,得益于 linux driver framework 设计者的功劳,这里我们只需要用到 spi.h 中定义的方法就可以了,不用去修改 spi 控制器的代码。一般的,我们的设备驱动框架是使用 spi_regiser_driver 向系统进行注册,就可以让系统用你指定的与.name 相匹配的硬件交互并执行你的读写请求,满足分离的思想。</div><div><br></div><div>7、linux spi 通用驱动spidev.c</div><div>&nbsp; &nbsp; &nbsp; &nbsp;/driver/spi/spidev.c是linux内核提供的一个spi通用驱动。如果不想写具体的spi芯片驱动，使用这个驱动能给我们带来很多便利，非常方便。在内核代码下的Documentation/spi/spidev是对spidev的描述。其中还提供一个spidev_test.c的测试程序。</div><div>&nbsp; &nbsp; &nbsp; &nbsp;使用很简单，只要在你的BSP代码中将spi_board_info的modalias定义为.modalias &nbsp; &nbsp;= "spidev"，这样设备启动后就可以在/dev看到spidev0.0字样. 0.0 就是bus_num.chip_select（对应BSP中的设置）</div><div>&nbsp; &nbsp; &nbsp; &nbsp;spidev注册成字符设备，可以方便的使用其提供的标准read/write/ioctl功能函数对设备进行读写设置操作。设备的全双工半双工都得以实现。具体使用可以细看spidev.c或借鉴spidev_test.c</div><div><br></div><div>         <p style="margin-bottom: 0cm;">下图是驱动加载成功后，<font face="DejaVu Serif, serif">sys</font>目录下的主要结构，由于目录非常复杂仅仅列出了主要的结构<font face="DejaVu Serif, serif">sys</font>目录下<font face="DejaVu Serif, serif">spi</font>子系统结构：</p></div><wbr><div style="text-align: center;"><img alt="linux spi驱动分析整理 - だへ雄♂√ぷ - だへ雄♂√ぷ" style="margin-top: 0px; margin-right: 10px; margin-bottom: 0px; margin-left: 10px; float: none;" src="./spi_files/2702722726392882642.gif"></div><div style="text-align: center;"><br></div><div>         <p style="margin-bottom: 0cm;"><font face="DejaVu Serif, serif">linux</font>下的设备模型包括几个主要的概念</p><p style="margin-bottom: 0cm;"><font face="DejaVu Serif, serif">sysfs </font>（<font face="DejaVu Serif, serif">dev</font>是用户空间接口，根据<font face="DejaVu Serif, serif">sysfs</font>下的<font face="DejaVu Serif, serif">class</font>目录由<font face="DejaVu Serif, serif">mdev</font>负责建立）</p><p style="margin-bottom: 0cm;"><font face="DejaVu Serif, serif">bus</font>总线，<font face="DejaVu Serif, serif">linux</font>下的设备都是建立在总线上的，<font face="DejaVu Serif, serif">platform</font>总线是一个虚拟的总线，所有的的片上设备基本上都接在这个虚拟总线上<font face="DejaVu Serif, serif">device</font>是设备</p> <p style="margin-bottom: 0cm;"><font face="DejaVu Serif, serif">device_driver</font>是设备驱动<font face="DejaVu Serif, serif">class</font>是类别，从功能角度对设备进行分类。</p> <p style="margin-bottom: 0cm;">注意，在<font face="DejaVu Serif, serif">sys/bus</font>目录下有<font face="DejaVu Serif, serif">platform</font>目录和<font face="DejaVu Serif, serif">spi</font>目录 </p> <p style="margin-bottom: 0cm;">这两个目录下面的设备分别代表什么呢？ </p> <p style="margin-bottom: 0cm;"><font face="DejaVu Serif, serif">platform</font>下的设备有<font face="DejaVu Serif, serif">s3c64xx-spi0</font>和<font face="DejaVu Serif, serif">s3c64xx-spi1</font>分别对应了<font face="DejaVu Serif, serif">s3c6410</font>上的<font face="DejaVu Serif, serif">spi0</font>和<font face="DejaVu Serif, serif">spi1</font>接口。&nbsp;</p></div><div><br></div><div><br></div><div>参考：</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;http://www.embedu.org/Column/Column367.htm</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;http://www.linuxidc.com/Linux/2011-11/46656.htm</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="font-family: &#39;DejaVu Serif&#39;, serif;">http://www.arm9home.net/read.php?tid=10788等</span></div></div>
        <div class="nbw-blog-end"></div>

        <div>
		</div>

        <div>
		</div>

		<div>
      	  <div>
		  	<div class="wumii-hook"></div><script type="text/javascript" id="wumiiRelatedItems"></script>
		  </div>
		</div>

        
		
        


        
      </div>
      
      
    </div>
   </div>
  </div>
</div>




</div>
      
      
    </div>
    
  </div>

</div>
      
      
      
      
      
      
    </div>
  </div>
  
</div>
    
  
  
  

    
    
  
  



    


</body></html>