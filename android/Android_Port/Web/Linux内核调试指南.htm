<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0063)http://www.360doc.com/content/10/1215/15/1378815_78374144.shtml -->
<html xmlns="http://www.w3.org/1999/xhtml" version="g42dymwpi--nx">
<body contenteditable="false" style="width:700px">
<div class="mainzt" style="width:700px">
<table class="index_main" border="0" cellpadding="0" cellspacing="0" style="width:700px">
<tbody style="width:700px">
<tr style="width:700px">
<td align="left" valign="top" width="320px">
<table border="0" cellpadding="0" cellspacing="0" class="mainbj6" id="docArtClass">
<tbody>
<tr>
<td>
<table border="0" cellpadding="0" cellspacing="0" style=" width:80%; text-align:center;">
<tbody>
<tr>
<td>
<table class="wenzhangcss" border="0" cellpadding="0" cellspacing="0" width="70%">
<tbody>
<tr><td style="height:29px;">
<div></div>
</td></tr>
<tr>
<td align="left" valign="top" width="700px" style=" height:200px;">
<span id="articlecontent">Linux内核调试指南<table>
<tbody><tr><td width="700px"><div class="toc">
<div id="toc__inside">
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97"><font color="#800080"><u>linux内核调试指南</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E4%B8%80%E4%BA%9B%E5%89%8D%E8%A8%80"><font color="#800080"><u>一些前言</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E4%BD%9C%E8%80%85%E5%89%8D%E8%A8%80"><font color="#800080"><u>作者前言</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%9F%A5%E8%AF%86%E4%BB%8E%E5%93%AA%E9%87%8C%E6%9D%A5"><font color="#800080"><u>知识从哪里来</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%92%B0%E5%86%99%E6%9C%AC%E6%96%87%E6%A1%A3"><font color="#800080"><u>为什么撰写本文档</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%B1%87%E7%BC%96%E7%BA%A7%E8%B0%83%E8%AF%95"><font color="#800080"><u>为什么需要汇编级调试</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><font color="#800080"><u>***第一部分：基础知识***</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E6%80%BB%E7%BA%B2%EF%BC%9A%E5%86%85%E6%A0%B8%E4%B8%96%E7%95%8C%E7%9A%84%E9%99%B7%E9%98%B1"><font color="#800080"><u>总纲：内核世界的陷阱</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%9A%84%E9%99%B7%E9%98%B1"><font color="#800080"><u>源码阅读的陷阱</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95%E7%9A%84%E9%99%B7%E9%98%B1"><font color="#800080"><u>代码调试的陷阱</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3%E7%9A%84%E9%99%B7%E9%98%B1"><font color="#800080"><u>原理理解的陷阱</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E5%BB%BA%E7%AB%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83"><font color="#800080"><u>建立调试环境</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E5%8F%91%E8%A1%8C%E7%89%88%E7%9A%84%E9%80%89%E6%8B%A9%E5%92%8C%E5%AE%89%E8%A3%85"><font color="#800080"><u>发行版的选择和安装</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E5%AE%89%E8%A3%85%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7"><font color="#800080"><u>安装交叉编译工具</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#bin%E5%B7%A5%E5%85%B7%E9%9B%86%E7%9A%84%E4%BD%BF%E7%94%A8"><font color="#800080"><u>bin工具集的使用</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#qemu%E7%9A%84%E4%BD%BF%E7%94%A8"><font color="#800080"><u>qemu的使用</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#initrd.img%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%88%B6%E4%BD%9C"><font color="#800080"><u>initrd.img的原理与制作</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#x86%E8%99%9A%E6%8B%9F%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BB%BA%E7%AB%8B"><font color="#800080"><u>x86虚拟调试环境的建立</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#arm%E8%99%9A%E6%8B%9F%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BB%BA%E7%AB%8B"><font color="#800080"><u>arm虚拟调试环境的建立</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#arm%E5%BC%80%E5%8F%91%E6%9D%BF%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E7%9A%84%E5%BB%BA%E7%AB%8B"><font color="#800080"><u>arm开发板调试环境的建立</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#gdb%E5%9F%BA%E7%A1%80"><font color="#800080"><u>gdb基础</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4"><font color="#800080"><u>基本命令</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#gdb%E4%B9%8Bgui"><font color="#800080"><u>gdb之gui</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#gdb%E6%8A%80%E5%B7%A7"><font color="#800080"><u>gdb技巧</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#gdb%E5%AE%8F"><font color="#800080"><u>gdb宏</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80--x86%E7%AF%87"><font color="#800080"><u>汇编基础--X86篇</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C"><font color="#800080"><u>用户手册</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#at_t%E6%B1%87%E7%BC%96%E6%A0%BC%E5%BC%8F"><font color="#800080"><u>AT&amp;T汇编格式</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96"><font color="#800080"><u>内联汇编</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E6%B1%87%E7%BC%96%E4%B8%8Ec%E5%87%BD%E6%95%B0%E7%9A%84%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8"><font color="#800080"><u>汇编与C函数的相互调用</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%B0%83%E7%94%A8%E9%93%BE%E5%BD%A2%E6%88%90%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><font color="#800080"><u>调用链形成和参数传递</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#c%E9%9A%BE%E7%82%B9%E7%9A%84%E6%B1%87%E7%BC%96%E8%A7%A3%E9%87%8A"><font color="#800080"><u>C难点的汇编解释</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E4%BC%98%E5%8C%96%E7%BA%A7%E5%88%AB%E7%9A%84%E5%BD%B1%E5%93%8D"><font color="#800080"><u>优化级别的影响</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80--arm%E7%AF%87"><font color="#800080"><u>汇编基础--ARM篇</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C1"><font color="#800080"><u>用户手册</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%B0%83%E7%94%A8%E9%93%BE%E5%BD%A2%E6%88%90%E5%92%8C%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%921"><font color="#800080"><u>调用链形成和参数传递</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E6%BA%90%E7%A0%81%E6%B5%8F%E8%A7%88%E5%B7%A5%E5%85%B7"><font color="#800080"><u>源码浏览工具</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%B0%83%E7%94%A8%E5%9B%BE%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7"><font color="#800080"><u>调用图生成工具</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#find_grep"><font color="#800080"><u>find + grep</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#wine_si"><font color="#800080"><u>wine + SI</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#global"><font color="#800080"><u>global</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#source-navigator"><font color="#800080"><u>Source-Navigator</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#vim_cscopectags"><font color="#800080"><u>vim + cscope/ctags</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#kscope"><font color="#800080"><u>kscope</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#lxr"><font color="#800080"><u>lxr</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#si%E7%AD%89%E4%B8%8Egdb%E7%9A%84%E7%89%B9%E7%82%B9"><font color="#800080"><u>SI等与gdb的特点</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%B0%83%E7%94%A8%E9%93%BE%E3%80%81%E8%B0%83%E7%94%A8%E6%A0%91%E5%92%8C%E8%B0%83%E7%94%A8%E5%9B%BE"><font color="#800080"><u>调用链、调用树和调用图</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%90%86%E6%83%B3%E8%B0%83%E7%94%A8%E9%93%BE"><font color="#800080"><u>理想调用链</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E8%B0%83%E7%94%A8"><font color="#800080"><u>函数指针调用</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%B0%83%E7%94%A8%E9%93%BE%E7%9A%84%E5%B1%82%E6%AC%A1"><font color="#800080"><u>调用链的层次</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E9%9D%9E%E7%90%86%E6%83%B3%E8%B0%83%E7%94%A8%E9%93%BE"><font color="#800080"><u>非理想调用链</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%B0%83%E7%94%A8%E6%A0%91%E4%B8%8E%E8%B0%83%E7%94%A8%E5%9B%BE"><font color="#800080"><u>调用树与调用图</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%A9%BF%E8%B6%8A%E7%9B%B2%E5%8C%BA"><font color="#800080"><u>穿越盲区</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%A9%BF%E8%B6%8Agdb%E7%9A%84%E7%9B%B2%E5%8C%BA"><font color="#800080"><u>穿越gdb的盲区</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%A9%BF%E8%B6%8A%E4%BA%A4%E5%8F%89%E7%B4%A2%E5%BC%95%E5%B7%A5%E5%85%B7%E7%9A%84%E7%9B%B2%E5%8C%BA"><font color="#800080"><u>穿越交叉索引工具的盲区</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E5%B7%A5%E7%A8%8B%E6%96%B9%E6%B3%95"><font color="#800080"><u>工程方法</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#bug_%E4%B8%8E_oops"><font color="#800080"><u>bug 与 OOPS</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9A%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90"><font color="#800080"><u>***第二部分：内核分析***</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3%E5%AD%90%E7%B3%BB%E7%BB%9F"><font color="#800080"><u>调试相关子系统</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#kgdb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><font color="#800080"><u>kgdb源码分析</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#sysrq"><font color="#800080"><u>sysrq</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#oprofile"><font color="#800080"><u>oprofile</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#kprobes"><font color="#800080"><u>kprobes</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90"><font color="#800080"><u>驱动分析</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%BD%BD%E5%85%A5%E6%A8%A1%E5%9D%97%E7%AC%A6%E5%8F%B7"><font color="#800080"><u>载入模块符号</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#seq_file.c%E7%9A%84%E5%88%86%E6%9E%90"><font color="#800080"><u>seq_file.c的分析</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#module.c%E7%9A%84%E5%88%86%E6%9E%90"><font color="#800080"><u>module.c的分析</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><font color="#800080"><u>中断处理过程</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#s3c24xx%E5%86%85%E5%AD%98%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%86%E6%9E%90"><font color="#800080"><u>s3c24xx内存初始化分析</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><font color="#800080"><u>虚拟地址空间</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%94%A8%E6%88%B7%E5%B1%82%E7%9A%84%E8%A7%82%E5%AF%9F%E7%AA%97"><font color="#800080"><u>用户层的观察窗</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E4%BA%A4%E4%BA%92%EF%BC%8C%E4%BB%8E%E5%86%85%E6%A0%B8%E5%B1%82%E5%88%86%E6%9E%90"><font color="#800080"><u>交互，从内核层分析</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%90%86%E8%A7%A3%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B"><font color="#800080"><u>理解设备模型</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><font color="#800080"><u>面向对象的实现</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%86%E5%B1%82"><font color="#800080"><u>设备模型的分层</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E5%A4%96%E5%9B%B4%E6%94%AF%E6%8C%81%E6%9C%BA%E5%88%B6"><font color="#800080"><u>外围支持机制</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><font color="#800080"><u>文件系统</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E5%85%B6%E4%BB%96%E5%B7%A5%E5%85%B7"><font color="#800080"><u>***第三部分：其他工具***</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#strace"><font color="#800080"><u>strace</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#ltrace"><font color="#800080"><u>ltrace</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#systemtap"><font color="#800080"><u>SystemTap</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#memwatch"><font color="#800080"><u>MEMWATCH</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#yamd"><font color="#800080"><u>YAMD</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#magic_sysrq"><font color="#800080"><u>Magic SysRq</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E9%99%84%E5%BD%95%EF%BC%9A%E7%A4%BE%E5%8C%BA%E4%BA%A4%E6%B5%81%E7%9B%B8%E5%85%B3"><font color="#800080"><u>附录：社区交流相关</u></font></a></div>
<ul class="toc">
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%A1%A5%E4%B8%81%E6%8F%90%E4%BA%A4%E7%9B%B8%E5%85%B3%E6%96%87%E6%A1%A3"><font color="#800080"><u>补丁提交相关文档</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E8%A1%A5%E4%B8%81%E5%88%B6%E4%BD%9C%E4%B8%8E%E6%8F%90%E4%BA%A4%E7%A4%BA%E8%8C%83"><font color="#800080"><u>补丁制作与提交示范</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#git%E4%BD%BF%E7%94%A8"><font color="#800080"><u>git使用</u></font></a></div>
</li>
</ul>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E9%99%84%E5%BD%95%EF%BC%9A%E5%86%85%E6%A0%B8%E5%8F%82%E8%80%83%E4%B9%A6%E7%B1%8D%E6%96%87%E7%AB%A0"><font color="#800080"><u>附录：内核参考书籍文章</u></font></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px"><a class="toc" href="http://wiki.zh-kernel.org/sniper#%E7%A7%81%E4%BA%BA%E5%A4%87%E5%BF%98"><u><font color="#800080">私人备忘</font></u></a></div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<h1><a id="linux内核调试指南" name="linux内核调试指南">linux内核调试指南</a></h1>
<h5><a id="大海里的鱼有很多，而我们需要的是鱼钩一只" name="大海里的鱼有很多，而我们需要的是鱼钩一只">大海里的鱼有很多，而我们需要的是鱼钩一只</a></h5>
<div class="level5" style="width:700px">
<p>本文档由大家一起自由编写，修改和扩充，sniper负责维护。引用外来的文章要注明作者和来处。本文档所有命令都是在ubuntu/debian
下的操作。选取的内核源码从文档开始编写时最新的内核版本–2.6.26开始，而且会随着linux的更新而不断更换新的版本。所以文档的内容可能前后不
一致。相信大家有能力克服这个问题。 </p>
<p>本文档的字符图示在linux环境下显示正常，在window下显示有细微的错乱。 </p>
<p>本文档唯一的更新网址是：<a class="urlextern" title="http://wiki.zh-kernel.org/sniper" href="http://wiki.zh-kernel.org/sniper" rel="nofollow"><u><font color="#800080">http://wiki.zh-kernel.org/sniper</font></u></a> 转载请保留此网址。 </p>
<p>有任何建议请发邮件：<a class="mail jsnocheck" title="s3c24xx@gmail.com" href="mailto:s3c24xx@gmail.com"><u><font color="#0000ff">s3c24xx@gmail.com</font></u></a> </p>
<p>有任何问题请到邮件列表提问：<a class="urlextern" title="http://zh-kernel.org/mailman/listinfo/linux-kernel" href="http://zh-kernel.org/mailman/listinfo/linux-kernel" rel="nofollow"><u><font color="#800080">http://zh-kernel.org/mailman/listinfo/linux-kernel</font></u></a> </p>
</div>
<h2><a id="一些前言" name="一些前言">一些前言</a></h2>
<h3><a id="作者前言" name="作者前言">作者前言</a></h3>
<div class="level3" style="width:700px">
<p>一个人默默地敲打这篇文章也有段时间了。在这个过程里，没有收到任何的赞誉，也没接到任何的板砖，没有任何的反馈。就这么敲打着，修理着。但是本人
从没怀疑这篇文档的价值，这是因为，本人就是这篇文档的亲身收益者。在这里把它“无私”奉献出来，乃是出于对于某类同道者锲而不舍孜孜以求的“德性”的认
同和“同情”，你的痛苦我表示感同身受，你的迷茫我愿意一起分担。一定有人能从个文档受益，这便已让我知足。其实，写这个文档并非是件苦差，而是字字都是
有感而发的，不吐不快的结果。这里的句句都是本人教训和经验的记录。 </p>
<p>谈到调试器，世上存在两种截然不同的看法。其中一种，是超级解霸的作者，他认为“程序不是写出来的，好程序绝对是调试出来的”。对于这个观点，虽然
本人学识浅陋，也很崇拜“
”他的为人，但是本人还是持着极不认同的态度。而第二种相反观点的人，便是linux之父linus了。他认为调试器只会“误人子弟”，只会导致人们迷于
表象而不去真正理解源码本身。并以此为由，长期没把kgdb内置到内核中。对于调试器调试bug会引入错误的修正这个观点，我认为还是有点道理的。但是他
以此为由而不把它集合到内核中，这个做法我就认为是毫无道理了。因为linus本人就说过：“我只使用GDB，而且我总是并不把它作为调试器来使用，只是
将其作为一个可以用来分析程序的分解器来使用。”既然他可以这样做，为什么就认定他人使用gdb的目的一定就是用来调试bug而不是另有所用呢？本人之所
以这样说，这是因为本人正也是使用gdb主要是用来辅助分析内核代码而不是主要用来调试错误的。这也正就是本文的主题。 </p>
<p>世上从不缺少解决问题的答案，缺少的是解决问题的方法。现在，linux的世界里已经不缺少牛书了，将尽一千页一本的满载答案的砖头书接踵而来，但
是渐渐地发现，看书看到后面就忘了前面，回到前面有忘了后面，甚至一个章节还没看完，那个子系统已经被完全重写了。慢慢地，就会怀疑“我是不是真的变老
了？真的不行了？”但是我们从没想过：“凭什么我们就如此受制于人？他就能搞懂，而我就不行呢？”。其实，我们需要的是一种重其意而忘其形的根本之道，需
要的是一种兵来将挡，火来水淹的通用解决方法。而绝不是淹没于牛人们的结论中。否则，遇到一个新的问题，就只能埋怨牛人的书还不够厚，以至于没把你需要的
东西也包括进去了。牛人一定有一套牛方法，而他在书中不详说，我不认为是他故意“留一手”，而是认为这是对自身觉得习以为常的事物的一种疏忽。牛人的研究
结果其实不是最重要的，他的研究方法和手段才是最重要的事情。而我，也渐渐地发现，调试器能带给我们很多有用的提示，使得我们能不断的寻找到思考的灵感和
方向，也使得学习变得非常的有趣性和有目的性。我想，利用调试器辅助源码分析，是不是正是很多牛人正在做的而没有说出来的事情呢？无论答案如何，本人还是
觉得，调试器是个好东西，不要轻易把它搁置在一旁。虽然很多高人也许已经是深安此道，甚至已经不需要它的提示了，但是它依然有益于我等功力尚浅的人。把这
种经验和技巧记录下来，让需要这项技巧的人少化时间去摸索，这绝对不是一件坏事。 </p>
<p>正是因为这个原因，随着文档慢慢地变大，也更加的觉得文档的题目起得有点不恰当了，题目起作“内核动态分析指南”更恰当点。文档的主旨是利用调试器动态分析内核，调试错误只是这个过程的副产品罢了。不过，这个新的名字实在是不够现在名字“刺眼”，所以也就没有启用它。 </p>
<p>说了这么多的废话和出格的话，无非是有两个目的：这个文章慢慢的变得这么长了，如果没有半句的“人”话，没有半句的现实世界中的语句。那估计本人不
是变成了机器人，阅读的人也会变成了机器人。顺便借这段文字交交朋友。另一个目的呢，是说不应拘束于工具，工具是死的，人是活的。如果某些工具确能带给我
们某些有益的提示，我们就可以去尝试它，取起优点而舍其糟粕。 </p>
<p>引用的原文： </p>
<p>Linus 谈调试器和内核如何发展： <a class="urlextern" title="http://www.bitscn.com/linux/kernel/200604/7493.html" href="http://www.bitscn.com/linux/kernel/200604/7493.html" rel="nofollow"><u><font color="#0000ff">http://www.bitscn.com/linux/kernel/200604/7493.html</font></u></a> </p>
</div>
<h3><a id="知识从哪里来" name="知识从哪里来">知识从哪里来</a></h3>
<div 
<div class="li" style="width:700px">
<p>1. 永远不要忘记的三大帮助命令 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">XXX -h(xxx –help)</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">man -a XXX</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">info XXX</div>
</li>
</ul>
<p>2. 如何安装帮助文档 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">$ sudo synaptic 界面出来后，在“组别”－&gt;“文档”选取你要的文档进行安装</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">或$ apt-cache search Documentation | grep XXX 搜索需要的文档进行安装</div>
</li>
</ul>
<p>3. 从软件/工具的官方网站阅读/下载文档 </p>
<p>4. 从irc获取帮助 irc.freenode.net </p>
<p>5. 从邮件列表获取帮助 mailist <a class="urlextern" title="http://lkml.org/" href="http://lkml.org/" rel="nofollow"><u><font color="#800080">http://lkml.org/</font></u></a> <a class="urlextern" title="http://marc.info/" href="http://marc.info/" rel="nofollow"><u><font color="#0000ff">http://marc.info/</font></u></a> </p>
<p>6. 发行版社区文档或社区 <a class="urlextern" title="https://help.ubuntu.com/community/" href="https://help.ubuntu.com/community/" rel="nofollow"><u><font color="#0000ff">https://help.ubuntu.com/community/</font></u></a> <a class="urlextern" title="http://wiki.ubuntu.org.cn/" href="http://wiki.ubuntu.org.cn/" rel="nofollow"><u><font color="#0000ff">http://wiki.ubuntu.org.cn/</font></u></a> </p>
<p>7. 利用google搜索文档或阅读他人文章 </p>
<p>8. 利用google搜索lkml </p>
<p><a class="urlextern" title="http://www.google.cn/advanced_search?hl=zh-CN" href="http://www.google.cn/advanced_search?hl=zh-CN" rel="nofollow"><u><font color="#0000ff">http://www.google.cn/advanced_search?hl=zh-CN</font></u></a> 网域那里填上lkml.org </p>
<p>9. 获取内核文档 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">源码本身</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">源码中的注释</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">内核源码附带的文档 Documentation</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">相关的教科书</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">论文 免费论文引擎 <a class="urlextern" title="http://citeseerx.ist.psu.edu/" href="http://citeseerx.ist.psu.edu/" rel="nofollow"><u><font color="#0000ff">http://citeseerx.ist.psu.edu/</font></u></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">内核子系统的官方网站</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">获取内核源码目录Documentation/DocBook/ 下已经编译好的书籍</div>
</li>
</ul>
<pre class="file">找到最新版本的文档<br>$ apt-cache search linux-doc  <br>安装最新的文档    <br>$ sudo apt-get install linux-doc-2.6.24    <br>阅读Documentation/DocBook/ 下已经编译好的书籍（html格式）<br>$ firefox /usr/share/doc/linux-doc-2.6.24/html/index.html         <br></pre>
<p>10. 买书 </p>
<p>11. 书籍最后面的参考书目 </p>
<p>12. 文章末尾的参考文章 </p>
</div>
<h3><a id="为什么撰写本文档" name="为什么撰写本文档">为什么撰写本文档</a></h3>
<div 
<div class="li" style="width:700px">
<p>todo:学习方法，学习曲线，参考书籍的特点和不足，本文档的任务 </p>
<p>内核学习曲线 </p>
<p>1.只读书不看源码 </p>
<p>参考书籍：Linux Kernel Development </p>
<p>2.参考源码读书(读书为主) </p>
<p>参考书籍：understanding the linux kernel </p>
<p>3.参考书读源码(看源码为主) </p>
<p>参考书籍：情景分析 </p>
<p>4.只看源码不/少读书(提交补丁为主) </p>
<p>参考：lkml,main-tree, mm-tree </p>
<p>linux内核分析方法： </p>
<p>按分析的对象分： </p>
<p>1.代码： 分析的对象是源代码 </p>
<p>2.数据： 分析的对象是内核运行时产生的数据 </p>
<p>按观察对象的状态分： </p>
<p>1.静态： 观察的目标对象是静止不动的 </p>
<p>2.动态： 观察的目标对象是动态变化的 </p>
<p>所以综合地看，分析方法的种类有： </p>
<p>1.静态代码： </p>
<p>最原始的方式，阅读源代码 </p>
<p>2.动态代码： </p>
<p>利用某些工具或手段，动态分析源代码。又分为 </p>
<p>a. 利用lxr, cscope, source insight等工具交叉索引源代码 </p>
<p>b. 利用git,web-git通过阅读增量patch等形式观察源码的进化 </p>
<p>c. 利用调试器跟随内核的运行动态观察内核正在运行的代码片段 </p>
<p>3.静态数据： </p>
<p>观察的对象是内核在运行时产生或收集汇总出来的数据。又分为 </p>
<p>a. 代码中printk语句打印出来的内核信息 </p>
<p>b. 系统出错产生的oops,panic信息 </p>
<p>c. 借助systemtap等类似工具提取的内核数据汇总 </p>
<p>4.动态数据： </p>
<p>借助内核调试器实时观察内核不断产生的数据 </p>
<p>可见内核调试器是最强大的内核分析工具，但它也不是“全功能”的工具。 </p>
<p>1. 主要地，本文档聚焦于描述如何利用gdb对内核进行源码级别和汇编级别的观察和调试。 </p>
<p>而这种调试的目的有两个: </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">确定bug产生的引入点。这部分内容放于本文档第一部分。 </div>
</li>
</ul>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">配合源码阅读工具(source insight,kscope等)，观察内核实时运行的状况，观察内核数据的产生和变化，以及观察各个函数的动态调用关系，从而以一种精确的动态的和验证性的方式来理解内核运作的原理。这部分内容放于本文档第二部分</div>
</li>
</ul>
<p>前者是调试器应用的主要价值，而后者却是本文档的兴趣所在。 </p>
<p>2. 因为需要观察用户层和内核层的交互，演示调试工具的全面功能等原因，本文档内容不完全局限于内核层。 </p>
<p>3. 另外，为了提供内核调试知识的全面叙述，我们对其他调试工具，其他调试的问题比如检测内存泄露等内容，也会进行说明。此部分内容放于本文档的第三部分。 </p>
</div>
<h3><a id="为什么需要汇编级调试" name="为什么需要汇编级调试">为什么需要汇编级调试</a></h3>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">逆向工程的需要</div>
</li>
</ul>
<p>例子1：NT 内核的进程调度分析笔记 <a class="urlextern" title="http://www.whitecell.org/list.php?id=11" href="http://www.whitecell.org/list.php?id=11" rel="nofollow"><u><font color="#0000ff">http://www.whitecell.org/list.php?id=11</font></u></a> </p>
<p>例子2: NT 下动态切换进程分析笔记 <a class="urlextern" title="http://www.whitecell.org/list.php?id=13" href="http://www.whitecell.org/list.php?id=13" rel="nofollow"><u><font color="#0000ff">http://www.whitecell.org/list.php?id=13</font></u></a> </p>
<p>在windows的世界里，内核源码和具体原理是不公开的。但很多牛人就凭一个破烂调试器阅读反汇编代码就能得到内部真相，可见调试器汇编级调试威力之大。但是在linux是源码公开的情况下，就没必要干那样的辛苦活了。但是因为以下原因，汇编级调试还是必要的。 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">汇编比C语言更低层</div>
</li>
</ul>
<p>有时(比如代码优化)情况下，因为C代码经过了编译器的处理，调试器在c源码调试这个级别下给出的信息是无法理解的，甚至看起来是错误的。但是如果
直接对调试器给出的反汇编代码进行分析，就不会受到那类问题的束缚。也就是说，进行汇编级别的调试能最大程度的利用调试器的功能。 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">汇编是C语义的解释</div>
</li>
</ul>
<p>当你对某句C语言不是很理解时，看看编译器是怎么想的，是个很不错的办法。 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">能锻炼汇编源码的阅读能力</div>
</li>
</ul>
<p>另一方面，内核中本来存在很多汇编源代码，进行汇编级调试也是锻炼阅读汇编源码能力的最有效方法。 </p>
<p>当然，汇编级调试虽然强大，但代价也是很昂贵。和源码级调试相比，分析汇编代码花的时间要多上几十倍。所以，在源码公开的情况下，应该以源码级调试为主，特殊情况下才需要汇编级调试。 </p>
</div>
<h2><a id="第一部分：基础知识" name="第一部分：基础知识">***第一部分：基础知识***</a></h2>
<h2><a id="总纲：内核世界的陷阱" name="总纲：内核世界的陷阱">总纲：内核世界的陷阱</a></h2>
<div 
<div class="li" style="width:700px">
<p>也是阅读理解其他任何大型代码会遇到的问题。下面各节的内容都是围绕这些小项展开的。如果有的内容不知所云，先看后面内容，再回头看这里。 </p>
<p>［先从其他地方复制过来，等待充实］ </p>
</div>
<h3><a id="源码阅读的陷阱" name="源码阅读的陷阱">源码阅读的陷阱</a></h3>
<div 
<div class="li" style="width:700px">
<p>源码不但是越来越大，更是越来越“刁”了。“刁”到了就是借助源码交叉索引工具也有它索引不到的地方。所以目前，即使是从源码阅读的角度而不是从调试的角度，只利用阅读工具不借助调试工具的话，源码都无法阅读。 </p>
<p>源码“刁”到源码解析工具都无法解析的因素有： </p>
<p>1. 汇编源码包括内嵌汇编 可能无法被你的源码阅读工具所解析 </p>
<p>2. 汇编代码和C代码之间的调用关系 无法被被源码阅读工具解析 </p>
<p>3. 利用函数指针的函数调用 无法被被源码阅读工具解析 </p>
<p>4. 宏“假函数” 可能无法被被源码阅读工具解析(SI不能解析，lxr能) </p>
<pre class="file">比如page_buffers()。定义是：<br>#define page_buffers(page)					\<br>	({							\<br>		BUG_ON(!PagePrivate(page));			\<br>		((struct buffer_head *)page_private(page));	\<br>	})<br></pre>
<p>5. 利用宏在编译时动态生成的函数体 无法被被源码阅读工具解析 </p>
<pre class="file">比如fs/buffer.c中有一大批类似函数。比如buffer_unwritten()<br>定义在buffer_head.h<br> 82 #define BUFFER_FNS(bit, name)                                           \<br>..省略<br> 91 static inline int buffer_##name(const struct buffer_head *bh)           \<br> 92 {                                                                       \<br> 93         return test_bit(BH_##bit, &amp;(bh)-&gt;b_state);                      \<br> 94 }<br>..<br>130 BUFFER_FNS(Unwritten, unwritten)<br>这类函数一般是短小的内嵌函数，用gdb调试时都看不出来。只能靠字符搜索再加上一点机灵。<br></pre>
<p>6. 函数/变量的某类c扩展属性标记， 可能导致该函数/变量无法被被源码阅读工具解析 </p>
<pre class="file">比如static struct vfsmount *bd_mnt __read_mostly;中的bd_mnt<br></pre>
<p>7. 其他语种的保留关键字，可能无法被你的源码阅读工具所解析 </p>
<pre class="file">如默认配置的SI无法解析struct class，当然，这个问题和内核无关。<br></pre>
<p>但是借助调试器，就能直接而轻易地解决上述源码解析工具难以解决的问题。 </p>
</div>
<h3><a id="代码调试的陷阱" name="代码调试的陷阱">代码调试的陷阱</a></h3>
<div 
<div class="li" style="width:700px">
<p>搭建调试环境 </p>
<p>gdb调试器的陷阱 </p>
<p>1. 宏“假函数” </p>
<p>2. 内嵌函数 </p>
<p>3. 代码优化 </p>
<p>4. 汇编码 </p>
<p>5. 进程切换 </p>
<p>6. 中断处理 </p>
<p>7. 系统调用 </p>
</div>
<h3><a id="原理理解的陷阱" name="原理理解的陷阱">原理理解的陷阱</a></h3>
<div 
<div class="li" style="width:700px">
<p>0. 链接器脚本和make语法 </p>
<pre class="file">下面这些杂七杂八的文件对内核整体原理的理解起着决定性的作用。<br><br>内核中的链接脚本<br>linux-2.6$ find ./ -name "*lds*"<br><br>内核中的重要宏文件<br>module_param* macros<br>include/linux/moduleparam.h<br><br>*__initcall Macros<br>include/linux/init.h<br><br>内核中的汇编文件<br>linux-2.6$ find ./ -name "*.S"<br><br>内核中的Makefile<br>linux-2.6$ find ./ -name "Makefile"<br><br>内核中的配置文件<br>linux-2.6$ find ./ -name "*config*"<br></pre>
<p>1. C与汇编代码的相互调用 </p>
<p>2. 各子系统间的接口互动 </p>
<p>3. 内核的设计思想及其代码编写和运行形式 </p>
<p>a) 基于对象的思想 </p>
<p>例子：文件系统，设备模型 </p>
<p>b) “发布—订阅”模型 </p>
<p>例子：notification chain </p>
</div>
<h2><a id="建立调试环境" name="建立调试环境">建立调试环境</a></h2>
<h3><a id="发行版的选择和安装" name="发行版的选择和安装">发行版的选择和安装</a></h3>
<h4><a id="为什么选debian" name="为什么选debian">为什么选debian</a></h4>
<div 
<div class="li" style="width:700px">
<p>［如题］ <a class="urlextern" title="http://www.debian.org/" href="http://www.debian.org/" rel="nofollow"><u><font color="#0000ff">http://www.debian.org/</font></u></a> <a class="urlextern" title="http://www.emdebian.org/" href="http://www.emdebian.org/" rel="nofollow"><u><font color="#0000ff">http://www.emdebian.org/</font></u></a> </p>
<p>为什么本人选择debian？因为：引用内容来之<a class="urlextern" title="http://www.debian.org" href="http://www.debian.org/" rel="nofollow"><u><font color="#0000ff">www.debian.org</font></u></a> </p>
<p>“Debian 计划 是一个致力于创建一个自由操作系统的合作组织。...屁话省略...屁话..N多屁话之后:
当然，人们真正需要的是应用软件，也就是帮助他们完成工作的程序: 从文档编辑，到电子商务，到游戏娱乐，到软件开发。Debian 带来了超过
18733 个 软件包 (为了能在您的机器上轻松的安装，这些软件包都已经被编译包装为一种方便的格式) — 这些全部都是 自由 软件。” </p>
<p>原因终于看到了，选择debian是因为本人比较懒，比较笨。而debian正好迎合了我这种人的需求。 </p>
<p>1. 它”带来了超过 18733 个
软件包”。18733这个数目非常不直观，而且或许是N年前的数据了。我们可以到debian的ftp看看，现在它可供安装的软件和工具达到了5个DVD
的容量。难以想象，在这5个DVD容量的工具库中，还会找不到我所想要的东西。 </p>
<p>2.
debian有一个非常出名的安装包管理机制。你需要做的就是，打开“立新得”软件，然后在一个小方框里写上你需要东西的相关信息，然后再点点一个叫做
“搜索”的小方块。接着，debian就会在它5个DVD大的工具库中寻找你想要的工具。在结果返回后，选择好你的工具，再点点一个叫做“应用”的小方
块，过一会，就可以使用你的工具了。 </p>
<p>再也没有了“缺少什么什么包”的烦人提示了，一切都这么简单，又这么强大。这，正是我想要的。 </p>
</div>
<h4><a id="debian与ubuntu" name="debian与ubuntu">debian与ubuntu</a></h4>
<div 
<div class="li" style="width:700px">
<p>[两者区别，版本外号，支持社区，source list等] 1.
ubuntu的易用性比debian要好。尤其是中文支持，还有ubuntu国内有活跃的社区。 2. 虽然ubuntu是基于debian的，apt
软件库也能获取到debian的软件，但它毕竟是不同的系统环境，理念不同，对于一些偏门或太旧或太新的软件时，ubuntu往往不支持，安装不了。比
如，gcc-3.4-arm-linux-gnu这个包，发行时间已久，ubuntu下安装不了，但在debian下则可以。 <a class="urlextern" title="http://www.ubuntu.com/community/ubuntustory/debian" href="http://www.ubuntu.com/community/ubuntustory/debian" rel="nofollow"><u><font color="#0000ff">http://www.ubuntu.com/community/ubuntustory/debian</font></u></a> </p>
<p>如不特别说明，本文档所有命令都是在ubuntu Hardy Heron8.04版本 和debian testing版本下的操作。 </p>
</div>
<h4><a id="从0安装debian" name="从0安装debian">从0安装debian</a></h4>
<div 
<div class="li" style="width:700px">
<p>［如果想领教古典linux相对于windows的特色，请安装一次debian吧。尽管和以前比，已经很智能了。但安装了debian，选了中文
环境，发现汉字都是歪歪倒倒的。而且没有汉字输入法，装了汉字输入法后，却用不了。不知道是我笨还是程序有bug.所以不得不用英文写下本烂文，怕把安装
过程给忘了。需要翻译回中文］ </p>
<p>How to install and configure a debian system from zero </p>
<p>1.install the system with one CD </p>
<p>Download CD iso file from debian official website, and burn it into a
CD. Note that, we can just download the first CD iso but not DVDs or
the whole serials of CDs, because the first CD has already contained all
the basis components of dedian system and many other most common
applications. We can use the first CD to install debian system, and then
to install some other needed programs from it if needed. In this way,
you can save much time spent on touching many inrelatived things. </p>
<p>2.install application &amp; tool from CD </p>
<p>ou can install some common apllications from the CD with the
following commnad: apt-get install expected-application. Why can we do
that without any more configuration? Why is it not need to has a ability
to access internet? Well, Let’s look at the file named sourse.list
which idenifying where to get software’s pakage?? deb cdrom:[Debian
GNU/Linux testing _Lenny_ - Official Snapshot i386 CD Binary-1
20080605-15:01]/ lenny main It means that system try to get somethig
from your CD, so obviously that you can get some the most common but not
all the tools available in debian official apllication repository. </p>
<p>3.try to access the internet </p>
<p>Thank to the first CD, we can do that easily. Fist, install the tool
ppp contained in CD and its’ configuration tool pppoeconfig. All these
steps are described in file ADSL（PPPOE）接入指南.txt </p>
<p>4.search any useful information through the internet </p>
<p>now, we have built a base debian system, but it is too simple. I want
to do some some thing, for example, to chat with some other people with
pidgin, but it is not contained in the first CD, which just downloaded
by you. And you may want to search some helps with google,etc. Just to
do it, google is a most useful tool. </p>
<p>5.search the internet updating source </p>
<p>I think you have get much thing through the google. But the most
important thing is to get a available update source for your system, and
change the source.list–that is /etc/apt/source.list. Now, I have got a
good one, and it seems good. Don’t forget to turn on the security entry
in the orgion file source.list. That file looks like following after my
updataion: </p>
<pre class="file">#deb cdrom:[Debian GNU/Linux testing _Lenny_ - Official Snapshot i386 CD Binary-1 20080605-15:01]/ lenny main<br>deb http://ftp.debian.org/debian/ lenny main contrib non-free <br>deb http://security.debian.org/ lenny/updates main<br>deb-src http://security.debian.org/ lenny/updates main<br></pre>
<p>You should note that the internet address is debian office’s, but It
takes some while to get it. And my searching tool is google. :) Oh, we
shoul run a command to update the new configuration to system before
using it, don’t ferget: apt-get update </p>
<p>6.get help from <acronym title="Internet Relay Chat">IRC</acronym> </p>
<p>Well, we have already been able to get some applications or tools
from internet with command apte-get or wget,etc.. But I think the first
thing to do is to get and install a very valuable tool named pidgin
which can bring you into <acronym title="Internet Relay Chat">IRC</acronym>
world. Because Many experiance and kind person live in channel #debian
of irc.freenode.net. You can get help from it very quickly. How to
configure pidgin? Sorry, I don’t like to answer such a problem , please
just to google it or try it by yourselft. I am not so kind as some guys
living in <acronym title="Internet Relay Chat">IRC</acronym> : ) </p>
<p>7.get and install synaptic </p>
<p>If you ever used ubuntu, you should agree that synaptic is good tool
to update you system. It can save you much time of searching tools,
typing commnad, or managing the downloaded tools. But Unfortunately,
such a important tool is not installed in the default system, and it is
not contained in the first CD. So, We can just to get it with command
“apt-get install synaptic”. After doing that successfully, I don’t want
to type that command anymore. It’s so tedious to me. </p>
<p>8.get more tools with the help of synaptic </p>
<p>synaptic is my GOD in the linux world. Without it, I will become
crazy. But now, I have owned it, so I can fly very freely in the
internet sky. Just to search any tools and to update your system. And
now, the CD used to install debian can be discarded, if you will never
reinstall or rescure the system with it in future. </p>
<p>Now, the sun has raise up, and you have found the road to reback to civilization. Why? Just to ask your google and synaptic. :) </p>
</div>
<h4><a id="debian重要命令" name="debian重要命令">debian重要命令</a></h4>
<div 
<div class="li" style="width:700px">
<p>［来源］《APT and Dpkg 快速参考表》 <a class="urlextern" title="http://i18n.linux.net.cn/others/APT_and_Dpkg.php" href="http://i18n.linux.net.cn/others/APT_and_Dpkg.php" rel="nofollow"><u><font color="#0000ff">http://i18n.linux.net.cn/others/APT_and_Dpkg.php</font></u></a> </p>
<p>Apt 不止是 apt-get </p>
<p><a class="urlextern" title="http://www.erwinwang.com/node/10" href="http://www.erwinwang.com/node/10" rel="nofollow"><u><font color="#0000ff">http://www.erwinwang.com/node/10</font></u></a> </p>
</div>
<h4><a id="中文环境设置" name="中文环境设置">中文环境设置</a></h4>
<h5><a id="debian的键盘设置更改" name="debian的键盘设置更改">debian的键盘设置更改</a></h5>
<div 
<div class="li" style="width:700px">
<p>默认安装的debian，键盘的设置可能有问题。比如“｜”打不出来。值得一提的是，这个设置甚至是和qemu的monitor模式相关联的。也就是说，qemu下有的字符也打不出来。如果有这个问题，按下面步骤设置 </p>
<p>System→Preferences→Keyboard→Layouts </p>
<p>然后通过“Add”增加China,并设置它为默认，或者同时把其他的删除掉。 </p>
</div>
<h5><a id="英文locale下使用中文输入法" name="英文locale下使用中文输入法">英文Locale下使用中文输入法</a></h5>
<div 
<div class="li" style="width:700px">
<p>说明，中文环境比英文环境有很多缺点。比如编译时编译器的提示都给汉化了，有如，minicom的中文汉化界面是错乱的，而且minicom无法设
置。本人一般是英文环境＋中文输入法。先安装好好中文环境，系统中就有了中文输入法和其他一些和中文有关的东西。然后转到英文环境下，按照下面做法更改
scim的配置文件即可。 </p>
<p>来自：<a class="urlextern" title="http://wiki.ubuntu.org.cn/index.php?title=%E8%8B%B1%E6%96%87Locale%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95&amp;variant=zh-cn" href="http://wiki.ubuntu.org.cn/index.php?title=%E8%8B%B1%E6%96%87Locale%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95&variant=zh-cn" rel="nofollow"><u><font color="#0000ff">http://wiki.ubuntu.org.cn/index.php?title=%E8%8B%B1%E6%96%87Locale%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95&amp;variant=zh-cn</font></u></a> </p>
<p>编辑 /etc/gtk-2.0/gtk.immodules(如果存在的话) 或者
/usr/lib/gtk-2.0/2.10.0/immodule-files.d/libgtk2.0-0.immodules 文件，在xim 的
local 增加 en 也就是说： </p>
<pre class="file">"xim" "X Input Method" "gtk20" "/usr/share/locale" "ko:ja:th:zh"<br>改成：<br>"xim" "X Input Method" "gtk20" "/usr/share/locale" "en:ko:ja:th:zh"<br>注意，一定要重启一下机器。<br></pre>
</div>
<h5><a id="pdf乱码的解决" name="pdf乱码的解决">pdf乱码的解决</a></h5>
<div 
<div class="li" style="width:700px">
<pre class="file">$sudo apt-get install xpdf-chinese-simplified xpdf-chinese-traditional poppler-data<br></pre>
<p>参考： </p>
<p><a class="urlextern" title="http://wiki.ubuntu.org.cn/PDF%E6%96%87%E6%A1%A3%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98" href="http://wiki.ubuntu.org.cn/PDF%E6%96%87%E6%A1%A3%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98" rel="nofollow"><u><font color="#0000ff">http://wiki.ubuntu.org.cn/PDF%E6%96%87%E6%A1%A3%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98</font></u></a> </p>
</div>
<h4><a id="建立编译环境" name="建立编译环境">建立编译环境</a></h4>
<div 
<div class="li" style="width:700px">
<pre class="file">$ sudo apt-get install build-essential autoconf automake1.9 cvs subversion libncurses5-dev git rar unrar p7zip-full cabextract<br></pre>
<p>其余的根据出错的提示，利用“立新得”搜索，然后进行安装。没有“立新得”界面程序的可以在终端下利用以下命令来搜索和安装。 </p>
<pre class="file">$ sudo apt-get update<br>$ apt-cache search XXX<br>$ sudo apt-get install XXX<br></pre>
<p>双硬盘系统切换设置， 私人备忘用 </p>
<pre class="file">title           Microsoft Windows XP Professional<br>root            (hd1,0)<br>savedefault<br>makeactive<br>map             (hd0) (hd1)<br>map             (hd1) (hd0)<br>chainloader     +1<br></pre>
</div>
<h3><a id="安装交叉编译工具" name="安装交叉编译工具">安装交叉编译工具</a></h3>
<h4><a id="交叉编译工具下载网址" name="交叉编译工具下载网址">交叉编译工具下载网址</a></h4>
<div 
<div class="li" style="width:700px">
<p>下面是几个交叉编译工具下载网址，需要手动安装时，对比一下编译器的名称可以找到合适的下载地址。debian维护有自己的已经打包成.deb形式安装包，在debian软件库中。 </p>
<pre class="file">http://www.codesourcery.com/gnu_toolchains/arm/download.html<br>（据说是arm公司推荐的）<br><br>Download Sourcery G++ Lite Edition for ARM<br><br>Target OS 	Download <br>EABI 	        Sourcery G++ Lite 2008q1-126<br>                All versions...<br>uClinux 	Sourcery G++ Lite 2008q1-152<br>                All versions...<br>GNU/Linux 	Sourcery G++ Lite 2008q1-126<br>                All versions...<br>SymbianOS 	Sourcery G++ Lite 2008q1-126<br>                All versions...<br><br>到底是选EABI还是GNU/LINUX呢？应该是后者....<br><br>点GNU/LINUX的连接进去，可看到<br><br>Download  	               MD5 Checksum<br>IA32 GNU/Linux Installer 	93eee13a08dd739811cd9b9b3e2b3212<br>IA32 Windows Installer 	       fac5b0cee1d9639c9f15e018e6d272ad<br><br>Documentation<br><br>Title 	                 	Format<br>Assembler (PDF) 	  	PDF<br>Binary Utilities (PDF) 		PDF<br>C Library (GLIBC) (PDF) 	PDF<br>Compiler (PDF) 			PDF<br>Debugger (PDF) 			PDF<br>Getting Started Guide (PDF) 	PDF<br>Linker (PDF) 			PDF<br>Preprocessor (PDF) 		PDF<br>Profiler (PDF) 			PDF<br><br>Advanced Packages<br><br>Expert users may prefer packages in these formats.<br><br>Download 		MD5 Checksum<br>IA32 GNU/Linux TAR 	4f11b0fa881864f220ab1bd84666108b<br>IA32 Windows TAR 	ed6d25fd68301e728a1fba4cd5cb913f<br>Source TAR 		2db28fb2aa80134e7d34d42b7039d866<br><br>   名字标识不是很明显，进去看才知道。比如，IA32 GNU/Linux Installer对应的安装包<br>名字叫arm-2008q1-126-arm-none-linux-gnueabi.bin<br>   为什么有个none？迷茫中..<br>---------------------------------<br>http://ftp.snapgear.org:9981/pub/snapgear/tools/arm-linux/<br>[DIR] Parent Directory                30-Sep-2003 15:44      -  <br>[   ] arm-linux-tools-20031127.tar.gz 26-Nov-2007 16:56   141M  <br>[   ] arm-linux-tools-20051123.tar.gz 24-Nov-2005 00:50   228M  <br>[   ] arm-linux-tools-20061213.tar.gz 13-Dec-2006 13:31   230M  <br>[   ] arm-linux-tools-20070808.tar.gz 30-Nov-2007 03:21   271M  <br>[   ] binutils-2.16.tar.gz            16-Nov-2005 15:44  15.6M  <br>[   ] binutils-2.17.tar.gz            06-Dec-2007 10:24  17.4M  <br>[   ] build-arm-linux-3.4.4           02-Aug-2006 14:32     6k  <br>[   ] build-arm-linux-4.2.1           30-Jul-2008 10:13     7k  <br>[   ] elf2flt-20060707.tar.gz         17-Jan-2008 22:23   101k  <br>[   ] elf2flt-20060708.tar.gz         30-Jul-2008 10:14   110k  <br>[   ] gcc-3.4.4.tar.bz2               16-Nov-2005 15:39  26.3M  <br>[   ] gcc-4.2.1.tar.bz2               06-Dec-2007 10:11  42.0M  <br>[   ] genext2fs-1.3.tar.gz            03-Sep-2003 10:23    19k  <br>[   ] glibc-2.3.3.tar.gz              16-Nov-2005 15:49  16.7M  <br>[   ] glibc-2.3.6.tar.gz              06-Dec-2007 10:39  17.9M  <br>[   ] glibc-linuxthreads-2.3.3.tar.gz 16-Nov-2005 15:49   303k  <br>[   ] glibc-linuxthreads-2.3.6.tar.gz 06-Dec-2007 10:39   320k  <br>--------------------------<br>http://www.handhelds.org/download/projects/toolchain/<br>[DIR] Parent Directory                                                   -   <br>[   ] README                                        28-Jul-2004 17:37  788   <br>[DIR] archive/                                      28-Jul-2004 17:34    -   <br>[   ] arm-linux-gcc-3.3.2.tar.bz2                   03-Nov-2003 10:23   71M  <br>[   ] arm-linux-gcc-3.4.1.tar.bz2                   29-Jul-2004 14:01   41M  <br>[DIR] beta/                                         28-Jul-2004 17:36    -   <br>[   ] crosstool-0.27-gcc3.4.1.tar.gz                28-Jul-2004 17:21  2.0M  <br>[   ] gcc-build-cross-3.3                           31-Oct-2003 15:43  5.1K  <br>[DIR] jacques/                                      24-Jul-2001 18:45    -   <br>[   ] kernel-headers-sa-2.4.19-rmk6-pxa1-hh5.tar.gz 12-Mar-2003 17:42  4.7M  <br>[DIR] monmotha/                                     13-Aug-2002 17:54    -   <br>[DIR] osx/                                          14-Dec-2003 11:45    -   <br>[DIR] pb/                                           22-Nov-2002 20:10    -   <br>[DIR] source/                                       18-Mar-2004 16:12    -   <br>------------------------------------<br>http://ftp.arm.linux.org.uk/pub/armlinux/toolchain/<br>[DIR] Parent Directory                                     -   <br>[   ] Oerlikon-DevKit-XScalev2.tar.gz 07-Feb-2003 22:30  3.7K  <br>[   ] cross-2.95.3.tar.bz2            20-Jul-2001 21:12   35M  <br>[   ] cross-3.0.tar.bz2               20-Jul-2001 22:27   39M  <br>[   ] cross-3.2.tar.bz2               23-Aug-2002 11:04   81M  <br>[   ] cross-3.2.tar.gz                23-Aug-2002 10:01   93M  <br>[DIR] src-2.95.3/                     14-Jan-2002 17:52    -   <br>[DIR] src-3.2/                        23-Aug-2002 10:53    -   <br>--------------------------------------------<br>http://linux.omap.com/pub/toolchain/<br>[DIR] Parent Directory                             -   <br>[   ] obsolete-gcc-3.3.2.t..&gt; 15-May-2004 12:18   76M  <br>---------------------------<br>http://www.uclinux.org/pub/uClinux/arm-elf-tools/<br>To install the Linux binaries, login as root and run "sh ./XXX-elf-tools-20030314.sh".<br><br>m68k-elf-20030314/arm-elf-20030314<br>    Get the m68k binaries or the ARM binaries. The source is here.<br><br>m68k-elf-20020410/arm-elf-20011219<br>    Get the m68k binaries or the ARM binaries. The source is here.<br><br>m68k-elf-20020218/arm-elf-20011219<br>    Get the m68k binaries or the ARM binaries. The source is here.<br><br>m68k/arm-elf-20011219<br>    Get the m68k binaries or the ARM binaries. The source is here.<br><br>    You can also get Bernhard Kuhn's RPMs here.<br><br>m68k-elf-20010716<br>    Get the binaries here and the source from here.<br><br>m68k-elf-20010712<br>    Get the binaries here and the source from here.<br><br>m68k-elf-20010610<br>    Get the binaries here and the source from here.<br><br>m68k-elf-20010228<br>    The binaries are in two files, the compilers and the g++ headers. The source is here. <br></pre>
</div>
<h4><a id="安装arm-linux-gnueabi-xxx_工具集" name="安装arm-linux-gnueabi-xxx_工具集">安装arm-linux-gnueabi-XXX 工具集</a></h4>
<div 
<div class="li" style="width:700px">
<p>debian有自己维护的一套交叉编译工具集 </p>
<p>[参考]<a class="urlextern" title="http://www.emdebian.org/tools/crosstools.html" href="http://www.emdebian.org/tools/crosstools.html" rel="nofollow"><u><font color="#0000ff">http://www.emdebian.org/tools/crosstools.html</font></u></a> </p>
<p>工具库： <a class="urlextern" title="http://www.emdebian.org/debian/pool/main/" href="http://www.emdebian.org/debian/pool/main/" rel="nofollow"><u><font color="#0000ff">http://www.emdebian.org/debian/pool/main/</font></u></a> </p>
<p>步骤： </p>
<p>1. 往/etc/apt/sources.list文件加入下面软件源 </p>
<pre class="file">deb http://buildd.emdebian.org/debian/ unstable main<br>deb-src http://buildd.emdebian.org/debian/ unstable main<br>deb http://buildd.emdebian.org/debian/ testing main<br>deb-src http://buildd.emdebian.org/debian/ testing main<br></pre>
<p>然后： </p>
<pre class="file">安装 emdebian-archive-keyring package <br>$ sudo apt-get install emdebian-archive-keyring<br>更新<br>$ sudo apt-get update<br></pre>
<p>2. 安装交叉编译器 </p>
<pre class="file">$ sudo apt-get install libc6-armel-cross libc6-dev-armel-cross binutils-arm-linux-gnueabi gcc-4.3-arm-linux-gnueabi g++-4.3-arm-linux-gnueabi<br></pre>
<p>注意，在ubuntu8.04下，只能安装4.2版。把上面文字中的4.3全部换为4.2即可。 </p>
<p>3. 安装交叉调试器 </p>
<pre class="file">$sudo apt-get install gdb-arm-linux-gnueabi<br></pre>
<p>注意: </p>
<p>a. 安装时使用名称：gdb-arm-linux-gnueabi，调用时使用命令名是：arm-linux-gnueabi-gdb </p>
<p>b. ubuntu下,arm-linux-gnueabi-gdb和gdb有冲突。 </p>
<p>解决方法： </p>
<p>需要使用arm-linux-gnueabi-gdb时先卸载gdb,记下卸载gdb时与gdb一起被卸载的软件名，然后安装arm-linux-
gnueabi-gdb。 想换回gdb时，在反操作。apt-install remove arm-linux-gnueabi-gdb 然后
apt-get install gdb以及之前和gdb一起被卸载包。可以写个脚本自动完成这些操作。本人环境下的脚本是： </p>
<p>脚本1. install-armgdb.sh </p>
<pre class="file">#! /bin/sh<br>sudo apt-get remove gdb<br>sudo apt-get install gdb-arm-linux-gnueabi<br></pre>
<p>脚本2. install-gdb.sh </p>
<pre class="file">#! /bin/sh<br>sudo apt-get remove gdb-arm-linux-gnueabi<br>sudo apt-get install apport apport-gtk apport-qt bug-buddy cgdb gdb python-apport xxgdb<br></pre>
</div>
<h4><a id="什么是eabi" name="什么是eabi">什么是EABI</a></h4>
<div 
<div class="li" style="width:700px">
<p>答： 来自AAPCS </p>
<p>ABI： Application Binary Interface: </p>
<p>1）. The specifications to which an executable must conform in order
to execute in a specific execution environment. For example, the Linux
ABI for the ARM Architecture. </p>
<p>2）. A particular aspect of the specifications to which independently
produced relocatable files must conform in order to be statically
linkable and executable. For example, the C++ ABI for the ARM
Architecture, the Run-time ABI for the ARM Architecture, the C Library
ABI for the ARM Architecture. </p>
<p>ARM-based … based on the ARM architecture … </p>
<p>EABI： An ABI suited to the needs of embedded (sometimes called free standing) applications. </p>
<p>参考： </p>
<p>ABI/EABI/OABI <a class="urlextern" title="http://blog.csdn.net/hongjiujing/archive/2008/07/21/2686556.aspx" href="http://blog.csdn.net/hongjiujing/archive/2008/07/21/2686556.aspx" rel="nofollow"><u><font color="#0000ff">http://blog.csdn.net/hongjiujing/archive/2008/07/21/2686556.aspx</font></u></a> </p>
<p>Re: 关于kernel ARM_EABI <a class="urlextern" title="http://zh-kernel.org/pipermail/linux-kernel/2008-January/002793.html" href="http://zh-kernel.org/pipermail/linux-kernel/2008-January/002793.html" rel="nofollow"><u><font color="#0000ff">http://zh-kernel.org/pipermail/linux-kernel/2008-January/002793.html</font></u></a> </p>
<p>Why ARM’s EABI matters <a class="urlextern" title="http://www.linuxdevices.com/articles/AT5920399313.html" href="http://www.linuxdevices.com/articles/AT5920399313.html" rel="nofollow"><u><font color="#0000ff">http://www.linuxdevices.com/articles/AT5920399313.html</font></u></a> </p>
<p>Why switch to EABI? <a class="urlextern" title="http://www.applieddata.net/forums/topic.asp?TOPIC_ID=2305" href="http://www.applieddata.net/forums/topic.asp?TOPIC_ID=2305" rel="nofollow"><u><font color="#0000ff">http://www.applieddata.net/forums/topic.asp?TOPIC_ID=2305</font></u></a> </p>
<p>ArmEabiPort <a class="urlextern" title="http://wiki.debian.org/ArmEabiPort" href="http://wiki.debian.org/ArmEabiPort" rel="nofollow"><u><font color="#0000ff">http://wiki.debian.org/ArmEabiPort</font></u></a> </p>
</div>
<h4><a id="安装arm-elf-xxx_工具集" name="安装arm-elf-xxx_工具集">安装arm-elf-XXX 工具集</a></h4>
<div 
<div class="li" style="width:700px">
<p>注：arm-elf-XXX 工具集是用于uclinux的 </p>
<p>1. 依据要求搜索下载相应的arm-elf-tools安装包。比如arm-elf-tools-20030315.sh </p>
<p>2. 安装： $ ./arm-elf-tools-20030315.sh </p>
<p>3. 如果，该安装包年代过老，比如arm-elf-tools-20030315.sh，会出现下面的错误提示 “tail: 无法打开“
43” 读取数据: 没有那个文件或目录。”。 这时需要修改安装包源码。方法：vi arm-elf-tools-20030315.sh,
搜索tail，在它后面加 -n .比如 把tail ${SKIP} ${SCRIPT} | gunzip | tar xvf
-改成如下：tail -n ${SKIP} ${SCRIPT} | gunzip | tar xvf - </p>
<p>4.如何卸载已安装的arm-elf-tools？ 答，重新安装一次，注意看终端提示。或直接vi arm-elf-tools-20030315.sh,看脚本的内容， </p>
</div>
<h3><a id="bin工具集的使用" name="bin工具集的使用">bin工具集的使用</a></h3>
<div 
<div class="li" style="width:700px">
<p>［该怎么称呼这类工具？待详述］ </p>
<pre class="file">arm-elf-addr2line   arm-elf-elf2flt     arm-elf-gdb         arm-elf-objdump     arm-elf-size<br>arm-elf-ar          arm-elf-flthdr      arm-elf-ld          arm-elf-protoize    arm-elf-strings<br>arm-elf-as          arm-elf-g++         arm-elf-ld.real     arm-elf-ranlib      arm-elf-strip<br>arm-elf-c++         arm-elf-gasp        arm-elf-nm          arm-elf-readelf     arm-elf-unprotoize<br>arm-elf-c++filt     arm-elf-gcc         arm-elf-objcopy     arm-elf-run  <br><br>arm-linux-gnueabi-addr2line  arm-linux-gnueabi-g++        arm-linux-gnueabi-gprof      arm-linux-gnueabi-readelf<br>arm-linux-gnueabi-ar         arm-linux-gnueabi-g++-4.2    arm-linux-gnueabi-ld         arm-linux-gnueabi-size<br>arm-linux-gnueabi-as         arm-linux-gnueabi-gcc        arm-linux-gnueabi-nm         arm-linux-gnueabi-strings<br>arm-linux-gnueabi-c++filt    arm-linux-gnueabi-gcc-4.2    arm-linux-gnueabi-objcopy    arm-linux-gnueabi-strip<br>arm-linux-gnueabi-cpp        arm-linux-gnueabi-gdb        arm-linux-gnueabi-objdump    <br>arm-linux-gnueabi-cpp-4.2    arm-linux-gnueabi-gdbtui     arm-linux-gnueabi-ranlib      <br></pre>
<p>如何获取这些工具的命令选项？ 看章节“知识从哪里来” 一般是用命 xxxxxx –help就能得到简单的命令选项列表 </p>
<p>下载arm-linux-gnueabi- 手册地址 <a class="urlextern" title="http://www.codesourcery.com/gnu_toolchains/arm/portal/release324" href="http://www.codesourcery.com/gnu_toolchains/arm/portal/release324" rel="nofollow"><u><font color="#0000ff">http://www.codesourcery.com/gnu_toolchains/arm/portal/release324</font></u></a> </p>
<p>然后搜索”arm”，便能找到处理器相关的特殊命令选项 </p>
</div>
<h4><a id="arm-linux-gnueabi-gcc" name="arm-linux-gnueabi-gcc">arm-linux-gnueabi-gcc</a></h4>
<div 
<div class="li" style="width:700px">
<p>查看arm处理器相关的编译选项 </p>
<p>$ vi arch/arm/Makefile </p>
<p>阅读Makefile文件，并联系源码根目录下的.config文件，便能知道arm-linux-gnueabi-gcc用了哪些编译选项。再到
手册中查找，便能知道这些选项是干什么用的，但手册中说的不是很详细。另外查找有用解释的方法的是，利用make ARCH=arm
CROSS_COMPILE=arm-linux-gnueabi-
menuconfig，找到与命令选项有关联的CONFIG_XXX的菜单项，看它的帮助说明.比如 </p>
<pre class="file">$ vi arch/arm/Makefile<br>....<br>ifeq ($(CONFIG_AEABI),y)<br>CFLAGS_ABI      :=-mabi=aapcs-linux -mno-thumb-interwork<br>else<br>CFLAGS_ABI      :=$(call cc-option,-mapcs-32,-mabi=apcs-gnu) $(call cc-option,-mno-thumb-interwork,)<br>endif<br>.. <br></pre>
<p>再查看CONFIG_AEABI的帮助文档 $ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
menuconfig 找到CONFIG_AEABI相关的菜单，看它的帮助文档，便能知道选项-mabi=aapcs-linux
-mno-thumb-interwork的整体效果怎样的。 </p>
<pre class="file">  ┌───────────────────── Use the ARM EABI to compile the kernel ──────────────────────┐<br>  │ CONFIG_AEABI:                                                                     │  <br>  │                                                                                   │  <br>  │ This option allows for the kernel to be compiled using the latest                 │  <br>  │ ARM ABI (aka EABI).  This is only useful if you are using a user                  │  <br>  │ space environment that is also compiled with EABI.                                │  <br>  │                                                                                   │  <br>  │ Since there are major incompatibilities between the legacy ABI and                │  <br>  │ EABI, especially with regard to structure member alignment, this                  │  <br>  │ option also changes the kernel syscall calling convention to                      │  <br>  │ disambiguate both ABIs and allow for backward compatibility support               │  <br>  │ (selected with CONFIG_OABI_COMPAT).                                               │  <br>  │                                                                                   │  <br>  │ To use this you need GCC version 4.0.0 or later.                                  │  <br>  │                                                                                   │  <br>  │ Symbol: AEABI [=n]                                                                │  <br>  │ Prompt: Use the ARM EABI to compile the kernel                                    │  <br>  │   Defined at arch/arm/Kconfig:554                                                 │  <br>  │   Location:                                                                       │  <br>  │     -&gt; Kernel Features      <br><br></pre>
<p>arm-linux-gnueabi-gcc的主要编译选项有如下几个。但是在编译内核时，这些选项是不需要手工去写的，而是通过make
menuconfig生成包含了编译选项配置信息的.config文件。在make编译内核时，再利用Makefile文件中的规则结合.config文
件提取出那些选项。 </p>
<pre class="file">太多了，手册吧<br></pre>
</div>
<h4><a id="arm-linux-gnueabi-gdb" name="arm-linux-gnueabi-gdb">arm-linux-gnueabi-gdb</a></h4>
<div 
<div class="li" style="width:700px">
<p>注意它的默认选项设置 </p>
<pre class="file">$ arm-linux-gnueabi-gdb<br>(gdb) show arm<br>abi:  The current ARM ABI is "auto" (currently "APCS").<br>apcs32:  Usage of ARM 32-bit mode is on.<br>disassembler:  The disassembly style is "std".<br>fpu:  The current ARM floating point model is "auto" (currently "fpa").<br>(gdb) <br></pre>
<p>但是，如果如果在命令后有参数vmlinux的话，它会自动识别出内核的abi，从而自动设置了gdb的abi。比如，在编译内核时，如果选了CONFIG_AEABI，则gdb的提示如下 </p>
<pre class="file">$ arm-linux-gnueabi-gdb vmlinux <br>...<br>(gdb) show arm<br>abi:  The current ARM ABI is "auto" (currently "AAPCS").  &lt;--注意<br>apcs32:  Usage of ARM 32-bit mode is on.<br>disassembler:  The disassembly style is "std".<br>fpu:  The current ARM floating point model is "auto" (currently "softvfp").<br></pre>
</div>
<h3><a id="qemu的使用" name="qemu的使用">qemu的使用</a></h3>
<div 
<div class="li" style="width:700px">
<p>参考手册 </p>
<p><a class="urlextern" title="http://bellard.org/qemu/user-doc.html" href="http://bellard.org/qemu/user-doc.html" rel="nofollow"><u><font color="#0000ff">http://bellard.org/qemu/user-doc.html</font></u></a> </p>
<p><a class="urlextern" title="http://wiki.debian.org.tw/index.php/QEMU" href="http://wiki.debian.org.tw/index.php/QEMU" rel="nofollow"><u><font color="#0000ff">http://wiki.debian.org.tw/index.php/QEMU</font></u></a> </p>
<p><a class="urlextern" title="http://www.h7.dion.ne.jp/~qemu-win/" href="http://www.h7.dion.ne.jp/~qemu-win/" rel="nofollow"><u><font color="#0000ff">http://www.h7.dion.ne.jp/~qemu-win/</font></u></a> </p>
<p><a class="urlextern" title="http://bellard.org/qemu/" href="http://bellard.org/qemu/" rel="nofollow"><u><font color="#0000ff">http://bellard.org/qemu/</font></u></a> </p>
<p>邮件列表 </p>
<p><a class="urlextern" title="http://lists.gnu.org/archive/html/qemu-devel/" href="http://lists.gnu.org/archive/html/qemu-devel/" rel="nofollow"><u><font color="#0000ff">http://lists.gnu.org/archive/html/qemu-devel/</font></u></a> </p>
<p>参考文章 </p>
<p>“QEMU安装使用全攻略” <a class="urlextern" title="http://forum.ubuntu.org.cn/viewtopic.php?p=248267&amp;sid=f4e95025bdaf6a24a218315d03ad9933" href="http://forum.ubuntu.org.cn/viewtopic.php?p=248267&sid=f4e95025bdaf6a24a218315d03ad9933" rel="nofollow"><u><font color="#0000ff">http://forum.ubuntu.org.cn/viewtopic.php?p=248267&amp;sid=f4e95025bdaf6a24a218315d03ad9933</font></u></a> </p>
<p>［补充命令］引用自<a class="urlextern" title="http://bbs.chinaunix.net/viewthread.php?tid=779540" href="http://bbs.chinaunix.net/viewthread.php?tid=779540" rel="nofollow"><u><font color="#0000ff">http://bbs.chinaunix.net/viewthread.php?tid=779540</font></u></a> </p>
<pre class="file">安装过程中，要求换盘：<br>在qemu中按ctrl+alt+2切换到qemu monitor模式 输入?或help可以查看可用命令及使用说明。<br>(在其他版本的qemu中，运行qemu加载OS后，这个shell就会自动变成qemu monitor模式)<br>change device filename -- change a removable media<br>看来它就是用来换盘的了 : change cdrom /rhel4/EL_disc2.iso<br><br>切换回安装界面ctrl+alt+1<br><br>monitor下还有几个常用的命令：<br>savevm filename 将整个虚拟机当前状态保存起来<br>loadvm filename 恢复 (最初我没用change换盘时,就是先savevm-&gt;重新运行qemu-&gt;loadvm )<br>sendkey keys 向VM中发送按键，例如你想在虚拟机里切换到另一个终端，按下了ctrl-alt-F2<br>不幸的是，切换的却是你的主系统，所以就需要用 sendkey了 sendkey ctrl-alt-f2<br>还有其他几个命令，自己看看啦。<br><br>经过N久终于装好了，现在可以启动试试：<br>[root@LFS distro]#qemu redhat.img -enable-audio -user-net -m 64<br>-user-net 相当于VMware的nat，主系统可以上，虚拟机就可以<br>-m 64     使用64M内存，缺省下使用128M<br><br>ctrl-alt-f 全屏<br>ctrl-alt   主机/虚拟机鼠标切换<br>qemu还有一些其他参数，输入qemu可以查看其相关说明<br></pre>
</div>
<h3><a id="initrd.img的原理与制作" name="initrd.img的原理与制作">initrd.img的原理与制作</a></h3>
<div 
<div class="li" style="width:700px">
<p>［扩展，原理，相关命令。下面的skyeye可能需要这部分知识］ </p>
<p>“Linux2.6 内核的 Initrd 机制解析” <a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-k26initrd/" href="http://www.ibm.com/developerworks/cn/linux/l-k26initrd/" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-k26initrd/</font></u></a> </p>
<p>“Introducing initramfs, a new model for initial RAM disks” <a class="urlextern" title="http://www.linuxdevices.com/articles/AT4017834659.html" href="http://www.linuxdevices.com/articles/AT4017834659.html" rel="nofollow"><u><font color="#0000ff">http://www.linuxdevices.com/articles/AT4017834659.html</font></u></a> </p>
<p>””深入理解 Linux 2.6 的 initramfs 機制 (上)“ <a class="urlextern" title="http://blog.linux.org.tw/~jserv/archives/001954.html" href="http://blog.linux.org.tw/~jserv/archives/001954.html" rel="nofollow"><u><font color="#0000ff">http://blog.linux.org.tw/~jserv/archives/001954.html</font></u></a> </p>
<p>MKINITRAMFS <a class="urlextern" title="http://www.manpage.org/cgi-bin/man/man2html?8+mkinitramfs" href="http://www.manpage.org/cgi-bin/man/man2html?8+mkinitramfs" rel="nofollow"><u><font color="#0000ff">http://www.manpage.org/cgi-bin/man/man2html?8+mkinitramfs</font></u></a> </p>
</div>
<h4><a id="安装与使用" name="安装与使用">安装与使用</a></h4>
<div 
<pre class="f style="width:700px">
<pre class="file">$ sudo apt-get install initramfs-tools <br>$ mkinitramfs /lib/modules/2.6.26/ -o initrd.img-2.6.26<br></pre>
</div>
<h3><a id="x86虚拟调试环境的建立" name="x86虚拟调试环境的建立">x86虚拟调试环境的建立</a></h3>
<div 
<p>参考 </p>
 style="width:700px">
<p>参考 </p>
<p>“debugging-linux-kernel-without-kgdb” <a class="urlextern" title="http://memyselfandtaco.blogspot.com/2008/06/debugging-linux-kernel-without-kgdb.html" href="http://memyselfandtaco.blogspot.com/2008/06/debugging-linux-kernel-without-kgdb.html" rel="nofollow"><u><font color="#0000ff">http://memyselfandtaco.blogspot.com/2008/06/debugging-linux-kernel-without-kgdb.html</font></u></a> </p>
<p>“使用 KGDB 调试 Linux 内核” <a class="urlextern" title="http://blog.chinaunix.net/u/8057/showart_1087126.html" href="http://blog.chinaunix.net/u/8057/showart_1087126.html" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u/8057/showart_1087126.html</font></u></a> </p>
<p>“透過虛擬化技術體驗 kgdb (1)” <a class="urlextern" title="http://blog.linux.org.tw/~jserv/archives/002045.html" href="http://blog.linux.org.tw/~jserv/archives/002045.html" rel="nofollow"><u><font color="#0000ff">http://blog.linux.org.tw/~jserv/archives/002045.html</font></u></a> </p>
</div>
<h4><a id="基于qemu和内核内置kgdb" name="基于qemu和内核内置kgdb">基于qemu和内核内置kgdb</a></h4>
<div 
<div class="li" style="width:700px">
<p>缺点：相对于下节的“基于qemu和qemu内置gdbstub”，这个方法配置麻烦。 </p>
<p>优点：真机远程调试时只能使用内置kgdb这个方法。 </p>
<p>［等待扩展，,,,］ </p>
<p>终极参考 </p>
<p>“Using kgdb and the kgdb Internals” <a class="urlextern" title="http://www.kernel.org/pub/linux/kernel/people/jwessel/kgdb/index.html" href="http://www.kernel.org/pub/linux/kernel/people/jwessel/kgdb/index.html" rel="nofollow"><u><font color="#0000ff">http://www.kernel.org/pub/linux/kernel/people/jwessel/kgdb/index.html</font></u></a> </p>
<p>参考文章 </p>
<p>“使用 KGDB 调试 Linux 内核” <a class="urlextern" title="http://blog.chinaunix.net/u/8057/showart_1087126.html" href="http://blog.chinaunix.net/u/8057/showart_1087126.html" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u/8057/showart_1087126.html</font></u></a> </p>
</div>
<h4><a id="基于qemu和qemu内置gdbstub" name="基于qemu和qemu内置gdbstub">基于qemu和qemu内置gdbstub</a></h4>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">参考文章</div>
</li>
</ul>
<p>“Debugging Linux Kernel Without KGDB Patch (Qemu + GDB)” <a class="urlextern" title="http://memyselfandtaco.blogspot.com/2008/06/debugging-linux-kernel-without-kgdb.html" href="http://memyselfandtaco.blogspot.com/2008/06/debugging-linux-kernel-without-kgdb.html" rel="nofollow"><u><font color="#0000ff">http://memyselfandtaco.blogspot.com/2008/06/debugging-linux-kernel-without-kgdb.html</font></u></a> </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">优缺点</div>
</li>
</ul>
<p>优点：相对上节，优点是操作简单，几乎不需要什么配置 </p>
<p>缺点：真机的远程调试，就只能利用内核的内置kgdb了 </p>
<p>说明： </p>
<p>如果长时间调试固定版本的内核，采取下面的把调试用内核安装的虚拟机内部就可以了。但是如果是要频繁地更换新内核或修改被调试内核，就需要采取把内
核挂在虚拟机外部的形式。也就是用 -kernel 在虚拟机外面挂个内核， 再利用-append 传递起内核启动参数等。［待研究］ </p>
<p>［太概过了，待扩展...］ </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">调试用内核的安装过程：</div>
</li>
</ul>
<p>1. 利用qemu安装一个系统. </p>
<p>2. 在真机中配置并编译一个用于安装到虚拟系统中的新内核，注意配置时的选择 </p>
<pre class="file">＊ 配置和启动<br>1. 内核选项<br>同时，为了能在系统运行时中断系统并出发远程 gdb，必须打开内核 Magic Sys-Rq 键选项 ：[后记，没实验去掉会怎样，估计没影响]<br>CONFIG_MAGIC_SYSRQ=y<br>打开内核符号调试：<br>CONFIG_DEBUG_INFO=y<br></pre>
<p>3. 在真机下编译好虚拟机新内核的源码 </p>
<p>4. 结束qemu，用以下命令在真机上挂载虚拟硬盘。然后把编译好的整个源码目录都拷贝到挂载好的虚拟硬盘上（真机上保留一份源码）。 </p>
<pre class="file">$ sudo mount -o loop,offset=32256 debian.img /mnt<br></pre>
<p>拷贝完后，在真机上卸载虚拟硬盘 </p>
<pre class="file">$ sudo umount /mnt<br></pre>
<p>5.启动虚拟机，进入旧系统，在新内核源码根目录下用以下命令给qemu的虚拟系统安装一个新的内核 </p>
<pre class="file">拷贝模块<br>$ make modules_install<br>安装内核<br><br>$ make install<br>制作initrd.img<br>$ cd /boot<br>$ mkinitramfs /lib/modules/2.6.26/ -o initrd.img-2.6.26<br>检查/boot/grub/menu.lst 文件内容是否妥当<br></pre>
<p>6.用以下命令重启虚拟系统，并选择进入新系统，确认新系统是否安装成功。 </p>
<pre class="file">$ shutdown -r now<br></pre>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">调试：</div>
</li>
</ul>
<p>1. 在真机新内核源码目录下建立一个文件 .gdbinit 内容是 </p>
<pre class="file">target remote localhost:1234<br>b start_kernel<br>＃c<br></pre>
<p>注意我把c注释掉是因为ddd和gdb有切换的需要。见”gdb技巧” </p>
<p>2. 用以下命令启动虚拟机 </p>
<pre class="file">qemu -hda debian.img -cdrom ../debian-testing-i386-CD-1.iso -m 500 -S -s<br></pre>
<p>3. 在真机新内核源码目录下运行 </p>
<pre class="file">gdb ./vmlinux<br></pre>
<p>[实验记录] </p>
<p>实验过了，.config中不选择kgdb，利用qemu照样能调试。也不能调试start_kernel以前的代码。比如head_32.S中的代码。 </p>
<pre class="file">CONFIG_HAVE_ARCH_KGDB=y<br># CONFIG_KGDB is not set<br></pre>
<p>但是不知CONFIG_HAVE_ARCH_KGDB是在menuconfig菜单的哪里。想试试把这项去了qemu还能不能调试。 </p>
<p>经测试，取消CONFIG_HAVE_ARCH_KGDB后，qemu也能进行调试。情况不变。看来qemu能完全脱离内核中的kgdb就能调试内核。 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">调试截图</div>
</li>
</ul>
<pre class="file">步骤2：<br>XXX@ubuntu:/new/myqemu/debian-x86$ qemu -hda debian.img -cdrom ../debian-testing-i386-CD-1.iso -m 500 -S -s<br><br>步骤3:<br>由下图我们注意到：“基于qemu和qemu内置gdbstub”这个方法的调试，最早只能从函数 start_kernel () 开始进行。<br>内核在start_kernel ()之前的初始化过程就无法观察了。这就是这个方法的最大缺点。但下节利用skyeye调试arm-linux的<br>方法就可以从第一个机器指令开始进行。<br><br>XXX@ubuntu:/storage/myqemu/new/linux-2.6.26$ gdb ./vmlinux <br>GNU gdb 6.8-debian<br>Copyright (C) 2008 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.  Type "show copying"<br>and "show warranty" for details.<br>This GDB was configured as "i486-linux-gnu"...<br>0x0000fff0 in ?? ()<br>Breakpoint 1 at 0xc037f5ca: file init/main.c, line 535.<br>(gdb) c<br>Continuing.<br><br>Breakpoint 1, start_kernel () at init/main.c:535<br>535	{<br>(gdb) <br><br>调试示意图：<br>给sys_read下断点<br>(gdb) b sys_read<br>Breakpoint 2 at 0xc017585e: file fs/read_write.c, line 360.<br>(gdb) <br><br>用快捷键 ctrl+x+2 打开tui,并按c继续运行，而后拦截到sys_read<br>   ┌──fs/read_write.c────────────────────────────────────────────────────────────────────────────────────────────────────────┐<br>   │354     {                                                                                                                │<br>   │355             struct file *file;                                                                                       │<br>   │356             ssize_t ret = -EBADF;                                                                                    │<br>   │357             int fput_needed;                                                                                         │<br>   │358                                                                                                                      │<br>   │359             file = fget_light(fd, &amp;fput_needed);                                                                     │<br>B+&gt;│360             if (file) {                                                                                              │<br>   │361                     loff_t pos = file_pos_read(file);                                                                │<br>   │362                     ret = vfs_read(file, buf, count, &amp;pos);                                                          │<br>   │363                     file_pos_write(file, pos);                                                                       │<br>   │364                     fput_light(file, fput_needed);                                                                   │<br>   │365             }                                                                                                        │<br>   │366                                                                                                                      │<br>   │367             return ret;                                                                                              │<br>   ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐<br>   │0xc017585a &lt;sys_read&gt;           push   %ebp                                                                              │<br>   │0xc017585b &lt;sys_read+1&gt;         mov    %esp,%ebp                                                                         │<br>   │0xc017585d &lt;sys_read+3&gt;         push   %esi                                                                              │<br>B+&gt;│0xc017585e &lt;sys_read+4&gt;         mov    $0xfffffff7,%esi                                                                  │<br>   │0xc0175863 &lt;sys_read+9&gt;         push   %ebx                                                                              │<br>   │0xc0175864 &lt;sys_read+10&gt;        sub    $0xc,%esp                                                                         │<br>   │0xc0175867 &lt;sys_read+13&gt;        mov    0x8(%ebp),%eax                                                                    │<br>   │0xc017586a &lt;sys_read+16&gt;        lea    -0xc(%ebp),%edx                                                                   │<br>   │0xc017586d &lt;sys_read+19&gt;        call   0xc0175f65 &lt;fget_light&gt;                                                           │<br>   │0xc0175872 &lt;sys_read+24&gt;        test   %eax,%eax                                                                         │<br>   │0xc0175874 &lt;sys_read+26&gt;        mov    %eax,%ebx                                                                         │<br>   │0xc0175876 &lt;sys_read+28&gt;        je     0xc01758b1 &lt;sys_read+87&gt;                                                          │<br>   │0xc0175878 &lt;sys_read+30&gt;        mov    0x24(%ebx),%edx                                                                   │<br>   │0xc017587b &lt;sys_read+33&gt;        mov    0x20(%eax),%eax                                                                   │<br>   └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>remote Thread 42000 In: sys_read                                                                    Line: 360  PC: 0xc017585e <br>(gdb) c<br>Continuing.<br><br>Breakpoint 2, sys_read (fd=3, buf=0xbfc781a4 "", count=512) at fs/read_write.c:360<br>(gdb) <br></pre>
</div>
<h3><a id="arm虚拟调试环境的建立" name="arm虚拟调试环境的建立">arm虚拟调试环境的建立</a></h3>
<h4><a id="利用qemu" name="利用qemu">利用qemu</a></h4>
<h5><a id="利用qemu安装debian_linux" name="利用qemu安装debian_linux">利用qemu安装debian linux</a></h5>
<div 
<div class="li" style="width:700px">
<p>目标： </p>
<p>本节在qemu虚拟机上安装一个基于arm的“桌面“系统，可以有X桌面，该虚拟系统能利用apt-get从debian的软件库下载数不完的用交
叉编译已经编译好的arm下的程序和工具。除了虚拟处理器是arm外，简直就是PC机。可以进行应用程序的本机(在虚拟机内进行)调试。但是，本人装的时
候，如果选了安装桌面环境，内核就启动失败，好像是提示文件系统出错。［成功的麻烦把过程贴出来］ </p>
<p>过程是: </p>
<p>Debian on an emulated ARM machine <a class="urlextern" title="http://www.aurel32.net/info/debian_arm_qemu.php" href="http://www.aurel32.net/info/debian_arm_qemu.php" rel="nofollow"><u><font color="#0000ff">http://www.aurel32.net/info/debian_arm_qemu.php</font></u></a> </p>
<p>下面是过程的提炼步骤,方便查看。 </p>
<p>1.创建虚拟硬盘 </p>
<p>$ qemu-img create -f qcow hda.img 40G </p>
<p>2.下载必要文件 </p>
<pre class="file">$ wget http://people.debian.org/~aurel32/arm-versatile/vmlinuz-2.6.18-6-versatile<br>$ wget http://people.debian.org/~aurel32/arm-versatile/initrd.img-2.6.18-6-versatile <br>$ wget http://ftp.de.debian.org/debian/dists/etch/main/installer-arm/current/images/rpc/netboot/initrd.gz <br></pre>
<p>2.安装系统 </p>
<pre class="file">qemu-system-arm -M versatilepb -kernel vmlinuz-2.6.18-6-versatile -initrd initrd.gz -hda hda.img -append "root=/dev/ram" <br>在安装过程中，为了节省时间，在这步choose a mirror of the debian archive<br>选http 回车 ;<br>debian archive mirror country 选taiwan 回车; <br>debian archive mirror 选ftp.tw.debian.org<br><br>安装好基本系统后，不要选择安装Desktop environment<br><br>安装完成后，它提示你把光盘拿掉并重启系统时，终止掉qemu。并用下一步的命令启动qemu.不要回车，否则又重新安装。<br></pre>
<p>3. 第一次启动系统 </p>
<pre class="file">$ qemu-system-arm -M versatilepb -kernel vmlinuz-2.6.18-6-versatile -initrd initrd.img-2.6.18-6-versatile -hda hda.img -append "root=/dev/sda1"<br></pre>
<p>4. 把旧的内核,intrd.img制作工具安装到虚拟机的系统内（操作在虚拟机内） </p>
<pre class="file">$ apt-get install initramfs-tools<br>$ wget http://people.debian.org/~aurel32/arm-versatile/linux-image-2.6.18-6-versatile_2.6.18.dfsg.1-18etch1+versatile_arm.deb<br>$ su -c "dpkg -i linux-image-2.6.18-6-versatile_2.6.18.dfsg.1-18etch1+versatile_arm.deb" <br></pre>
<p>5.其他更多的玩法请看原文<a class="urlextern" title="http://www.aurel32.net/info/debian_arm_qemu.php" href="http://www.aurel32.net/info/debian_arm_qemu.php" rel="nofollow"><u><font color="#0000ff">http://www.aurel32.net/info/debian_arm_qemu.php</font></u></a> </p>
<p>参考： </p>
<p>Debian ARM Linux on Qemu </p>
<p><a class="urlextern" title="http://909ers.apl.washington.edu/~dushaw/ARM/#SYSTEM" href="http://909ers.apl.washington.edu/~dushaw/ARM/#SYSTEM" rel="nofollow"><u><font color="#0000ff">http://909ers.apl.washington.edu/~dushaw/ARM/#SYSTEM</font></u></a> </p>
<p>Running Linux for ARM processors under QEMU </p>
<p><a class="urlextern" title="http://iomem.com/index.php?archives/2-Running-Linux-for-ARM-processors-under-QEMU.html&amp;serendipity" href="http://iomem.com/index.php?archives/2-Running-Linux-for-ARM-processors-under-QEMU.html&serendipity" rel="nofollow"><u><font color="#0000ff">http://iomem.com/index.php?archives/2-Running-Linux-for-ARM-processors-under-QEMU.html&amp;serendipity</font></u></a>[entrypage]=2 </p>
<p>Debian on an emulated ARM machine </p>
<p><a class="urlextern" title="http://www.aurel32.net/info/debian_arm_qemu.php" href="http://www.aurel32.net/info/debian_arm_qemu.php" rel="nofollow"><u><font color="#0000ff">http://www.aurel32.net/info/debian_arm_qemu.php</font></u></a> </p>
</div>
<h5><a id="利用qemu安装能进行内核调试的系统" name="利用qemu安装能进行内核调试的系统">利用qemu安装能进行内核调试的系统</a></h5>
<div 
<div class="li" style="width:700px">
<p>［暂时没法子，期待扩展。下面这个例子可以，但没尝试。估计这个方法与下节的利用skyeye的方法相比，没有优势。因为这个方法可能也是不能进行全程调试。但是下面网站的资料还是有一定参考价值的。］ </p>
<p>使用qemu-jk2410做為學習環境： </p>
<p><a class="urlextern" title="http://wiki.jk2410.org/wiki/%E4%BD%BF%E7%94%A8qemu-jk2410%E5%81%9A%E7%82%BA%E5%AD%B8%E7%BF%92%E7%92%B0%E5%A2%83" href="http://wiki.jk2410.org/wiki/%E4%BD%BF%E7%94%A8qemu-jk2410%E5%81%9A%E7%82%BA%E5%AD%B8%E7%BF%92%E7%92%B0%E5%A2%83" rel="nofollow"><u><font color="#0000ff">http://wiki.jk2410.org/wiki/%E4%BD%BF%E7%94%A8qemu-jk2410%E5%81%9A%E7%82%BA%E5%AD%B8%E7%BF%92%E7%92%B0%E5%A2%83</font></u></a> </p>
<p>另外：看看下面这个站点， </p>
<p>Firmware Linux： <a class="urlextern" title="http://landley.net/code/firmware/" href="http://landley.net/code/firmware/" rel="nofollow"><u><font color="#0000ff">http://landley.net/code/firmware/</font></u></a> </p>
</div>
<h4><a id="利用skyeye" name="利用skyeye">利用skyeye</a></h4>
<h5><a id="skyeye虚拟机的内核调试" name="skyeye虚拟机的内核调试">skyeye虚拟机的内核调试</a></h5>
<div 
<div class="li" style="width:700px">
<p>相对于利用qemu的方式，用skyeye虚拟机调试内核有个很重要的 </p>
<p>优点是： </p>
<p>调试可以从第一条机器指令开始。这对研究系统启动过程提供了极大的便利。 </p>
</div>
<h5><a id="skyeye的安装与使用" name="skyeye的安装与使用">skyeye的安装与使用</a></h5>
<div 
<div class="li" style="width:700px">
<p>该文非常好，好像没啥要扩充的 </p>
<p>SkyEye硬件模拟平台，第二部分: 安装与使用 </p>
<p><a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-skyeye/part2/" href="http://www.ibm.com/developerworks/cn/linux/l-skyeye/part2/" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-skyeye/part2/</font></u></a> </p>
<p>SkyEye User Manual <a class="urlextern" title="http://www.skyeye.org/wiki/UserManual" href="http://www.skyeye.org/wiki/UserManual" rel="nofollow"><u><font color="#0000ff">http://www.skyeye.org/wiki/UserManual</font></u></a> </p>
<p><a class="urlextern" title="http://skyeye.wiki.sourceforge.net/" href="http://skyeye.wiki.sourceforge.net/" rel="nofollow"><u><font color="#0000ff">http://skyeye.wiki.sourceforge.net/</font></u></a> </p>
<p>参考文档： </p>
<p>Linux-2.6.20 on XXX platform </p>
<p><a class="urlextern" title="http://skyeye.wiki.sourceforge.net/Linux" href="http://skyeye.wiki.sourceforge.net/Linux" rel="nofollow"><u><font color="#0000ff">http://skyeye.wiki.sourceforge.net/Linux</font></u></a> </p>
<p>uClinux-dist-20070130 on XXX platform </p>
<p><a class="urlextern" title="http://skyeye.wiki.sourceforge.net/uClinux" href="http://skyeye.wiki.sourceforge.net/uClinux" rel="nofollow"><u><font color="#0000ff">http://skyeye.wiki.sourceforge.net/uClinux</font></u></a> </p>
<p><a class="urlextern" title="http://www.linuxfans.org/bbs/thread-182101-1-1.html" href="http://www.linuxfans.org/bbs/thread-182101-1-1.html" rel="nofollow"><u><font color="#0000ff">http://www.linuxfans.org/bbs/thread-182101-1-1.html</font></u></a> </p>
<p>安装: </p>
<p>1. 安装主程序 </p>
<p>在ubuntu系统能进行在线安装,但版本是v1.2,不是最新的 </p>
<pre class="file">$sudo apt-get install skyeye<br></pre>
<p>2. 测试套件 </p>
<p>测试套件下载后解压开即可 </p>
<p>地址：<a class="urlextern" title="http://sourceforge.net/project/showfiles.php?group_id=85554" href="http://sourceforge.net/project/showfiles.php?group_id=85554" rel="nofollow"><u><font color="#0000ff">http://sourceforge.net/project/showfiles.php?group_id=85554</font></u></a> </p>
</div>
<h5><a id="快速试玩" name="快速试玩">快速试玩</a></h5>
<div 
<div class="li" style="width:700px">
<p>目的: </p>
<p>尽可能快的成功运行一个arm linux虚拟机。如果您化了很长时间也无法编译出一个能运行的内核，或写不出一个恰当的skyeye.conf时，在你的热情受到打击之前，我想这节是你急需的。 </p>
<p>操作步骤： </p>
<p>1.依照上节说明安装好主程序，下载并解压好测试套件 </p>
<p>2.进入测试套件的目录 skyeye-testsuite-1.2.5/linux/s3c2410/s3c2410x-2.6.14 </p>
<p>可以看到有三个文件initrd.img skyeye.conf vmlinux </p>
<p>3.运行虚拟机 </p>
<p>$skyeye -e vmlinux </p>
<p>注意下面的提示，说明平时要注意在启动命令前加上sudo </p>
<pre class="file">NOTICE: you should be root at first !!!<br>NOTICE: you should inmod linux kernel net driver tun.o!!!<br>NOTICE: if you don't make device node, you should do commands:<br>NOTICE:    mkdir /dev/net; mknod /dev/net/tun c 10 200<br>NOTICE: now the net simulation function can not support!!!<br>NOTICE: Please read SkyEye.README and try again!!!<br></pre>
<p>4.可以看到，一个2.6.14 版本的linux跑起来了，还带有一个lcd. </p>
</div>
<h5><a id="快速配置能调试的环境" name="快速配置能调试的环境">快速配置能调试的环境</a></h5>
<div 
<div class="li" style="width:700px">
<p>参考： </p>
<p><a class="urlextern" title="http://skyeye.wiki.sourceforge.net/linux_2_6_17_lubbock" href="http://skyeye.wiki.sourceforge.net/linux_2_6_17_lubbock" rel="nofollow"><u><font color="#0000ff">http://skyeye.wiki.sourceforge.net/linux_2_6_17_lubbock</font></u></a> </p>
<p>环境条件： </p>
<p>1. ubuntu hardy 8.04 </p>
<p>2. 安装了debian提供的交叉编译工具套件 arm-linux-gnueabi- (4.2版本) </p>
<p>目标： </p>
<p>这小节能得到基于pxa平台（类似s3c2410，也基于arm核心）的linux2.6.20内核的虚拟系统，具备调试功能。相比“基于qemu
和qemu内置gdbstub”该节，利用skyeye的调试有那节所没有的优点：调试时可以从内核运行的第一条指令开始［这就是模拟硬件调试？］。 </p>
<p>参考手册： </p>
<p>XScale PXA250开发手册 <a class="urlextern" title="http://soft.laogu.com/download/intelpxa250.pdf" href="http://soft.laogu.com/download/intelpxa250.pdf" rel="nofollow"><u><font color="#0000ff">http://soft.laogu.com/download/intelpxa250.pdf</font></u></a> </p>
<p>ARMv5 体系结构参考手册 <a class="urlextern" title="http://www.arm.com/community/university/eulaarmarm.html" href="http://www.arm.com/community/university/eulaarmarm.html" rel="nofollow"><u><font color="#0000ff">http://www.arm.com/community/university/eulaarmarm.html</font></u></a> </p>
<p>操作步骤： </p>
<p>1. 下载linux-2.6.20 (由于交叉编译器太新，如果利用linux-2.6.17则编译不过) </p>
<p>2. 修改文件include/asm-arm/arch-pxa/memory.h 第18行 </p>
<pre class="file">#define PHYS_OFFSET UL(0xa0000000)<br>为<br>#define PHYS_OFFSET UL(0xc0000000)<br></pre>
<p>3. 下载内核配置选项，放置于linux-2.6.20源码的根目录下 <a class="urlextern" title="http://skyeye.wiki.sourceforge.net/space/showimage/skyeye_2.6.17_lubbock.config" href="http://skyeye.wiki.sourceforge.net/space/showimage/skyeye_2.6.17_lubbock.config" rel="nofollow"><u><font color="#0000ff">http://skyeye.wiki.sourceforge.net/space/showimage/skyeye_2.6.17_lubbock.config</font></u></a> </p>
<p>这个下载好的配置文件已经帮我们做了的两件事 </p>
<p>首先，在block device菜单下配置了ramdisk和initrd的支持 </p>
<p>其次，把内核原来的启动参数改为 </p>
<pre class="file">root=/dev/ram0 console=ttyS0 initrd=0xc0800000,0x00800000 rw mem=64M<br></pre>
<p>4. 把下载到的skyeye_2.6.17_lubbock.config更名为.config </p>
<p>5. 编译内核 </p>
<pre class="file">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-<br></pre>
<p>6. 创建文件 skyeye.conf，内容如下： </p>
<pre class="file">cpu: pxa25x<br>mach: pxa_lubbock<br>mem_bank: map=I, type=RW, addr=0x40000000, size=0x0c000000<br>mem_bank: map=M, type=RW, addr=0xc0000000, size=0x00800000<br>mem_bank: map=M, type=RW, addr=0xc0800000, size=0x00800000, file=./initrd.img<br>mem_bank: map=M, type=RW, addr=0xc1000000, size=0x00800000<br>mem_bank: map=M, type=RW, addr=0xc1800000, size=0x02800000<br></pre>
<p>7. 从skyeye的测试套件中拷贝initrd.img到linux-2.6.20源码根目录下。该initrd.img的路径是： </p>
<pre class="file">skyeye-testsuite-1.2.5/linux/pxa/2.6.x/<br></pre>
<p>8. 运行内核看看,在linux-2.6.20源码根目录下运行下面的命令。可以看到，内核成功运行 </p>
<pre class="file">sudo skyeye -e vmlinux<br></pre>
<p>调试： </p>
<p>1. 在linux-2.6.20源码根目录下运行命令： </p>
<pre class="file">sudo skyeye -d -e vmlinux  <br></pre>
<p>2. 在源码根目录下新开一个终端，并运行： </p>
<pre class="file">arm-linux-gnueabi-gdb ./vmlinux<br></pre>
<p>gdb界面出来后 </p>
<pre class="file">(gdb) target remote:12345<br></pre>
<p>之后可以看到，下断点，查看汇编等一切调试功能和x86下都一样。 </p>
<p>3. ddd下如何调用arm-linux-gnueabi-gdb ? 答 </p>
<pre class="file">$ ddd --debugger arm-linux-gnueabi-gdb ./vmlinux<br></pre>
</div>
<h5><a id="为s3c2410配置2.6.26内核" name="为s3c2410配置2.6.26内核">为s3c2410配置2.6.26内核</a></h5>
<div 
<div class="li" style="width:700px">
<p>［启动过程中有若干错误提示，但内核能启动成功并运行。有待研究］ </p>
<p>目标： </p>
<p>得到一个基于s3c2410cpu的2.6.26最新稳定内核的虚拟系统，能进行全程的内核调试，即调试能从第一条机器指令开始进行。 </p>
<p>参考： </p>
<p><a class="urlextern" title="http://skyeye.wiki.sourceforge.net/Linux" href="http://skyeye.wiki.sourceforge.net/Linux" rel="nofollow"><u><font color="#0000ff">http://skyeye.wiki.sourceforge.net/Linux</font></u></a> </p>
<p><a class="urlextern" title="http://www.linuxfans.org/bbs/thread-182101-1-1.html" href="http://www.linuxfans.org/bbs/thread-182101-1-1.html" rel="nofollow"><u><font color="#0000ff">http://www.linuxfans.org/bbs/thread-182101-1-1.html</font></u></a> </p>
<p>环境条件： </p>
<p>1. ubuntu hardy 8.04 </p>
<p>2. 安装了debian提供的交叉编译工具套件 arm-linux-gnueabi- (4.2版本) </p>
<p>操作步骤： </p>
<p>1.依据“安装交叉编译工具”这节，安装好交叉编译工具 </p>
<p>2.修改源码 </p>
<pre class="file">将include/asm-arm/arch-s3c2410/map.h里的<br>#define S3C2410_CS6 (0x30000000)<br>改为<br>#define S3C2410_CS6 (0xc0000000)<br><br>将include/asm-arm/arch-s3c2410/memory.h里的<br>#define PHYS_OFFSET UL(0x30000000)<br>改为<br>#define PHYS_OFFSET UL(0xc0000000)<br></pre>
<p>3.把默认.config替换为s3c2410版本 </p>
<pre class="file">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- s3c2410_defconfig<br></pre>
<p>3.修改配置文件 </p>
<pre class="file">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig<br>进入[Device Driver] -&gt;[ Character Driver] -&gt; [Serial Driver] 等菜单下 ,<br>取消8250/16550 and compatible serial support的选择<br></pre>
<p>4.修改内核启动命令 </p>
<pre class="file">在Boot option --&gt; Default kernel command string 里输入<br>mem=32M console=ttySAC0 root=/dev/ram initrd=0xc0800000,0x00800000 ramdisk_size=2048 rw<br></pre>
<p>5.编译 </p>
<pre class="file">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-<br></pre>
<p>6.从skyeye的测试套件中拷贝相应的文件initrd.img和skyeye.conf到linux-2.6.26源码根目录下。这两个文件的位于 </p>
<pre class="file">skyeye-testsuite-1.25/linux/s3c2410/s3c2410x-2.6.14/中<br></pre>
<p>7.启动虚拟机 </p>
<pre class="file">XXX@ubuntu:~/dt/linux-2.6.26$ sudo skyeye -e vmlinux<br></pre>
<p>8.启动完成后那激动人心的logo如下 </p>
<pre class="file">Welcome to<br>     _      _____      __   __    _      _<br>    / \    /  __ \    /  \_/  \  | |    |_|                 <br>   / _ \   | |  | |  / /\   /\ \ | |     _ ____  _   _  _  _ <br>  / /_\ \  | |__| | / /  \_/  \ \| |    | |  _ \| | | |\ \/ /<br> / /___\ \ | |__\ \ | |       | || |___ | | |_| | |_| |/    \<br>/_/	 \_\| |   \_\|_|       |_||_____||_|_| |_|\____|\_/\_/<br>	   <br>ARMLinux for Skyeye <br>For further information please check:<br>http://www.skyeye.org/<br><br><br><br>BusyBox v1.4.1 (2007-02-10 01:19:06 CST) Built-in shell (ash)<br>Enter 'help' for a list of built-in commands.<br><br>/bin/ash: can't access tty; job control turned off<br>/ $ uname -a<br>Linux skyeye 2.6.26 #2 Sun Oct 5 19:56:57 CST 2008 armv4tl unknown<br>/ $ <br></pre>
<p>调试： </p>
<p>1. 在linux-2.6.26源码根目录下新建文件”.gdbinit”，内容是： </p>
<pre class="file">(gdb) target remote:12345<br></pre>
<p>2. 在linux-2.6.26源码根目录下命令： </p>
<pre class="file">sudo skyeye -d -e vmlinux  <br></pre>
<p>3. 在源码根目录下新开一个终端，并运行： </p>
<pre class="file">arm-linux-gnueabi-gdb ./vmlinux<br></pre>
<p>之后可以看到，下断点，查看汇编等一切调试功能和x86下都一样。 </p>
<p>4. ddd下如何调用arm-linux-gnueabi-gdb ? 答 </p>
<pre class="file">$ ddd --debugger arm-linux-gnueabi-gdb ./vmlinux<br></pre>
<p>截图： </p>
<pre class="file">步骤2:<br>XXX@ubuntu:~/桌面/test/linux-2.6.26_s3c2410$ sudo skyeye -d -e vmlinux <br>big_endian is false.<br>arch: arm<br>cpu info: armv4, arm920t, 41009200, ff00fff0, 2 <br>mach info: name s3c2410x, mach_init addr 0x805f030<br>lcd_mod:1<br>dbct info: Note: DBCT not compiled in. This option will be ignored<br>uart_mod:0, desc_in:, desc_out:, converter:<br>SKYEYE: use arm920t mmu ops<br>Loaded RAM   ./initrd.img<br>start addr is set to 0xc0008000 by exec file.<br>debugmode= 1, filename = skyeye.conf, server TCP port is 12345<br>------------------------<br>步骤3:<br>fqh@ubuntu:~/桌面/test/linux-2.6.26_s3c2410$ arm-linux-gnueabi-gdb vmlinux<br>GNU gdb 6.8-debian<br>Copyright (C) 2008 Free Software Foundation, Inc.<br>License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;<br>This is free software: you are free to change and redistribute it.<br>There is NO WARRANTY, to the extent permitted by law.  Type "show copying"<br>and "show warranty" for details.<br>This GDB was configured as "--host=i486-linux-gnu --target=arm-linux-gnueabi"...<br>stext () at arch/arm/kernel/head.S:80<br>80		msr	cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode<br>Current language:  auto; currently asm<br>(gdb) source extendinstr //载入辅助的gdb宏<br>--------------<br>用快捷键 ctrl+x+2 打开tui模式后的图示，可看到调试是从第一条指令开始的。这对研究系统启动过程提供了极大的便利。<br>   ┌──arch/arm/kernel/head.S────────────────────────────────────────────────────────────────────────────┐<br>  &gt;│80              msr     cpsr_c, #PSR_F_BIT | PSR_I_BIT | SVC_MODE @ ensure svc mode                 │<br>   │81                                                      @ and irqs disabled                         │<br>   │82              mrc     p15, 0, r9, c0, c0              @ get processor id                          │<br>   │83              bl      __lookup_processor_type         @ r5=procinfo r9=cpuid                      │<br>   │84              movs    r10, r5                         @ invalid processor (r5=0)?                 │<br>   │85              beq     __error_p                       @ yes, error 'p'                            │<br>   │86              bl      __lookup_machine_type           @ r5=machinfo                               │<br>   │87              movs    r8, r5                          @ invalid machine (r5=0)?                   │<br>   │88              beq     __error_a                       @ yes, error 'a'                            │<br>   │89              bl      __vet_atags                                                                 │<br>   │90              bl      __create_page_tables                                                        │<br>   └────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>  &gt;│0xc0008000 &lt;stext&gt;      msr    CPSR_c, #211    ; 0xd3                                               │<br>   │0xc0008004 &lt;stext+4&gt;    mrc    15, 0, r9, cr0, cr0, {0}                                             │<br>   │0xc0008008 &lt;stext+8&gt;    bl     0xc00082f8 &lt;__lookup_processor_type&gt;                                 │<br>   │0xc000800c &lt;stext+12&gt;   movs   r10, r5                                                              │<br>   │0xc0008010 &lt;stext+16&gt;   beq    0xc0008190 &lt;__error_p&gt;                                               │<br>   │0xc0008014 &lt;stext+20&gt;   bl     0xc0008358 &lt;__lookup_machine_type&gt;                                   │<br>   │0xc0008018 &lt;stext+24&gt;   movs   r8, r5                                                               │<br>   │0xc000801c &lt;stext+28&gt;   beq    0xc00081e8 &lt;__error_a&gt;                                               │<br>   │0xc0008020 &lt;stext+32&gt;   bl     0xc00083a0 &lt;__vet_atags&gt;                                             │<br>   │0xc0008024 &lt;stext+36&gt;   bl     0xc0008078 &lt;__create_page_tables&gt;                                    │<br>   │0xc0008028 &lt;stext+40&gt;   ldr    sp, [pc, #240]  ; 0xc0008120 &lt;__switch_data&gt;                         │<br>   └────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>remote Thread 42000 In: stext                                                  Line: 80   PC: 0xc0008000 <br>(gdb) b sys_read  //下断点<br>Breakpoint 1 at 0xc008cc4c: file fs/read_write.c, line 354.<br>(gdb) c<br><br>----------------<br>调试示意图<br>效果可能与你机器上看到的不一样。这个例子中，每个gdb单步指令都会自动显示backtrace。这是因为本人使用了章节“gdb宏”中的extendinstr宏。<br>   ┌──include/asm/thread_info.h──────────────────────────────────────────────────────────────────────────────────────────────┐<br>   │91       */                                                                                                              │<br>   │92      static inline struct thread_info *current_thread_info(void) __attribute_const__;                                 │<br>   │93                                                                                                                       │<br>   │94      static inline struct thread_info *current_thread_info(void)                                                      │<br>   │95      {                                                                                                                │<br>   │96              register unsigned long sp asm ("sp");                                                                    │<br>  &gt;│97              return (struct thread_info *)(sp &amp; ~(THREAD_SIZE - 1));                                                  │<br>   │98      }                                                                                                                │<br>   │99                                                                                                                       │<br>   │100     /* thread information allocation */                                                                              │<br>   │101     #ifdef CONFIG_DEBUG_STACK_USAGE                                                                                  │<br>   │102     #define alloc_thread_info(tsk) \                                                                                 │<br>   │103             ((struct thread_info *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, \                                       │<br>   │104                     THREAD_SIZE_ORDER))                                                                              │<br>   └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>   │0xc008d480 &lt;fget_light&gt;         mov    r12, sp                                                                           │<br>   │0xc008d484 &lt;fget_light+4&gt;       push   {r11, r12, lr, pc}                                                                │<br>   │0xc008d488 &lt;fget_light+8&gt;       sub    r11, r12, #4    ; 0x4                                                             │<br>   │0xc008d48c &lt;fget_light+12&gt;      bic    r3, sp, #8128   ; 0x1fc0                                                          │<br>  &gt;│0xc008d490 &lt;fget_light+16&gt;      bic    r3, r3, #63     ; 0x3f                                                            │<br>   │0xc008d494 &lt;fget_light+20&gt;      ldr    r3, [r3, #12]                                                                     │<br>   │0xc008d498 &lt;fget_light+24&gt;      mov    r12, #0 ; 0x0                                                                     │<br>   │0xc008d49c &lt;fget_light+28&gt;      ldr    r2, [r3, #560]                                                                    │<br>   │0xc008d4a0 &lt;fget_light+32&gt;      str    r12, [r1]                                                                         │<br>   │0xc008d4a4 &lt;fget_light+36&gt;      ldr    r3, [r2]                                                                          │<br>   │0xc008d4a8 &lt;fget_light+40&gt;      cmp    r3, #1  ; 0x1                                                                     │<br>   │0xc008d4ac &lt;fget_light+44&gt;      bne    0xc008d4d0 &lt;fget_light+80&gt;                                                        │<br>   │0xc008d4b0 &lt;fget_light+48&gt;      ldr    r2, [r2, #4]                                                                      │<br>   │0xc008d4b4 &lt;fget_light+52&gt;      ldr    r3, [r2]                                                                          │<br>   └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>remote Thread 42000 In: fget_light                                                                  Line: 97   PC: 0xc008d490 <br><br>Program received signal SIGHUP, Hangup.<br>0xc008d490 in fget_light (fd=1, fput_needed=0xc1c17ed4) at include/asm/thread_info.h:97<br>-------------------<br>#0  0xc008d490 in fget_light (fd=1, fput_needed=0xc1c17ed4) at include/asm/thread_info.h:97<br>#1  0xc008cc5c in sys_read (fd=1, buf=0xc1196800 "", count=512) at fs/read_write.c:359<br>#2  0xc000ac7c in rd_load_image (from=0xc02b43bc "/initrd.image") at init/do_mounts_rd.c:108<br>#3  0xc000bbe8 in initrd_load () at init/do_mounts_initrd.c:121<br>#4  0xc00094c0 in prepare_namespace () at init/do_mounts.c:384<br>#5  0xc0008a9c in kernel_init (unused=&lt;value optimized out&gt;) at init/main.c:878<br>#6  0xc0048484 in sys_waitid (which=&lt;value optimized out&gt;, upid=-1044283692, infop=0x0, options=0, ru=Cannot access memory at<br>address 0x4<br>) at kernel/exit.c:1689<br>Backtrace stopped: previous frame inner to this frame (corrupt stack?)<br>(gdb) <br></pre>
</div>
<h5><a id="使用最新的skyeye" name="使用最新的skyeye">使用最新的skyeye</a></h5>
<div 
<div class="li" style="width:700px">
<p>1. 新版本的改进 </p>
<p>在ubuntu下利用在线安装命令所安装的skyeye是旧的版本，新版本修正了旧版本的一些小问题。比如，旧版本在调试时会出现下面一些烦人的小提示。 </p>
<pre class="file">Can't send signals to this remote system.  SIGHUP not sent.<br><br>Program received signal SIGHUP, Hangup.<br></pre>
<p>但是，两个版本并不是完全兼容的，主要是skyeye.conf的处理上。不过，幸好这些都是很容易解决的问题。 </p>
<p>2. 新版本的安装 </p>
<p><a class="urlextern" title="http://sourceforge.net/project/showfiles.php?group_id=85554" href="http://sourceforge.net/project/showfiles.php?group_id=85554" rel="nofollow"><u><font color="#0000ff">http://sourceforge.net/project/showfiles.php?group_id=85554</font></u></a> </p>
<p>到上面的网站下载最新版本，目前是skyeye-1.2.6_rc1。解压后用下面命令编译就可以了 </p>
<pre class="file">$./configure<br>$ make STATIC=1<br></pre>
<p>然后把在源码根目录下生成的skyeye拷到内核目录下运行即可。这样系统中的老版本skyeye还照样可以使用。 </p>
<pre class="file">sudo ./skyeye -d -e vmlinux<br></pre>
<p>3. 新老版本的兼容问题 </p>
<p>主要是skyeye.conf的格式识别上。老版本要求load_address,load_address_mask不能写在
skyeye.conf文件内部，只能用-l选项指定。如果运行老版本时提示skyeye.conf出错，你就得去查查那里，并手动修改处理一下即可。 </p>
</div>
<h3><a id="arm开发板调试环境的建立" name="arm开发板调试环境的建立">arm开发板调试环境的建立</a></h3>
<h4><a id="基于串口" name="基于串口">基于串口</a></h4>
<div 
<div class="li" style="width:700px">
<p>为qq2440平台移植2.6.26或更新内核，并建立kgdb调试环境 </p>
<p>进行中... </p>
<p>[移植中的一些零碎的笔记] </p>
<p>1.内核版本 </p>
<p>使用linus的git，但是已知2.6.25中arm已经支持kgdb了。 </p>
<pre class="file">XXX@ubuntu:/storage/linus-git/linux-2.6$ git-describe <br>v2.6.27-rc9-2-g85ba94b<br></pre>
<p>2. </p>
<pre class="file">arm体系的默认配置文件在<br>arch/arm/configs<br><br>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- s3c2410_defconfig<br><br>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig<br>选取以下选现<br>CONFIG_DEBUG_INFO=y<br>CONFIG_KGDB=y<br>CONFIG_KGDB_SERIAL_CONSOLE=y<br><br>make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-<br><br>移植环境<br><br>windows：硬盘安装的真实系统(XP)<br>ubuntu: 运行在windows下的vmware虚拟机中<br>qq2440开发板:真实开发板,IP是192.168.1.230<br><br>第一天:(完成)<br>熟悉开发板，PC机，虚拟机的网络互连<br>理解内核启动过程<br><br>开发板与PC机(XP)PING不通的原因有<br><br>1. PC机开着防火<br>2. PC机上的VMWARE的网络设置有问题（先卸载确认）<br>3. 安全类软件造成，比如卡巴司机(先卸载，不行重装系统)<br><br><br>ubuntu的网络配置分两种情况，一种是平时上网用的，一种是和开发板通讯用的。<br><br><br>平时使用虚拟机ubuntu上网的配置：<br><br>连接方式选出NAT: used to share the host's IP address<br>虚拟系统启动后,桌面右上角的<br>wired connection-&gt;properties-&gt;configuration选automatic configuration(DHCP)<br><br><br><br>开发板挂载ubuntu虚拟系统中的nfs<br><br>1.虚拟机本身的网络设置不用动<br><br>2.虚拟系统如ubuntu的网卡设置改为桥接<br>edit virtual machine settings-&gt;virtual machine setting-&gt;hardware-&gt;ethernet<br>-&gt;bridged:connected directly to the physical network<br><br>3.虚拟系统启动后,桌面右上角的manual network configuration要改.<br>点左键-&gt;network settings-&gt;wired connection-&gt;properties:enable roaming mode不选，<br>connection settings<br>configuration:static IP address<br>IP address:192.168.1.111 与PC机IP，开发板IP同个网段<br>subnet mask:255.255.255.0<br>gateway address:空<br><br>PC机网络信息：<br><br>Ethernet adapter 本地连接：<br><br>        Connection-specific DNS Suffix  . :<br>        IP Address. . . . . . . . . . . . : 192.168.1.100  <br>        Subnet Mask . . . . . . . . . . . : 255.255.255.0<br>        Default Gateway . . . . . . . . . :<br><br>开发板的网络信息：<br><br>[root@(none) /]# ifconfig<br>eth0      Link encap:Ethernet  HWaddr 08:00:3E:26:0A:5B  <br>          inet addr:192.168.1.230  Bcast:192.168.1.255  Mask:255.255.255.0<br>          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1<br>          RX packets:1011 errors:0 dropped:0 overruns:0 frame:0<br>          TX packets:610 errors:0 dropped:0 overruns:0 carrier:0<br>          collisions:0 txqueuelen:1000 <br>          RX bytes:111858 (109.2 KiB)  TX bytes:57276 (55.9 KiB)<br>          Interrupt:53 Base address:0x300 <br><br>windows打开ubuntu中的samba共享目录的方法<br><br>\\192.168.1.111<br><br><br>ubuntu中nfs服务的安装和启用<br><br>$ sudo apt-get install nfs-common<br>$ sudo apt-get install nfs-kernel-server<br><br><br>$ sudo vi /etc/exports<br>/new/root_nfs *(rw,sync)<br><br>$ sudo /etc/init.d/nfs-kernel-server start<br><br>4. 檢查<br><br>$ showmount -e localhost<br>开发板挂载nfs成功后可看到显示结果是<br>All mount points on localhost:<br>192.168.1.230:/new/root_nfs<br><br><br>开发板挂载ubuntu中的nfs<br>(此时运行的文件系统还是在开发板上)<br><br>mount -t nfs -o nolock 192.168.1.111:/new/root_nfs /tmp/fuck<br><br>192.168.1.111：ubuntu的IP<br>/tmp/fuck:开发板中的挂载点<br><br><br>[root@(none) /]# mount -t nfs -o nolock 192.168.1.111:/new/root_nfs /tmp/fuck<br>[root@(none) /]# cd /tmp/fuck/<br>[root@(none) fuck]# ls<br>bin              lib              proc             usr<br>dev              linuxrc          sbin             var<br>etc              mnt              shanghaitan.mp3  www<br>home             opt              tmp<br>-----<br><br>通过nfs启动开发板<br>(挂载的文件系统是在ubuntu虚拟系统上)<br><br>下面文字来自于：Embedded Linux Primer: A Practical, Real-World Approach<br><br>ip=192.168.1.139:192.168.1.1:192.168.1.1:255.255.255.0:coyote1:eth0:off<br>ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;PROTO&gt;<br> <br>Here, client-ip is the target's IP address; server-ip is the address of the NFS server; gw-ip is the gateway (router), in case the server-ip is on a different subnet; and netmask defines the class of IP addressing. hostname is a string that is passed as the target hostname; device is the Linux device name, such as eth0; and PROTO defines the protocol used to obtain initial IP parameters.<br><br>本人的实际操作的命令参数是：<br><br>param set linux_cmd_line "console=ttySAC0 root=/dev/nfs nfsroot=192.168.1.111:/new/root_nfs ip=192.168.1.130:192.168.1.111:192.168.1.111:255.255.255.0:sbc2440.arm9.net:eth0:off"<br><br>注意把编辑器的换行功能去掉后，再复制上面的命令。<br><br>192.168.1.130是开发板的IP，系统启动后，用ifconfig就会显示这个IP地址。可以随意设置，当然要满足和PC机，ubuntu的IP在同个网段，而且不能冲突的先前条件。<br><br>130:192.168.1.111：nfs的server,也就是ubuntu的IP<br>按住空格健重启开发板,出现：<br><br>+---------------------------------------------+<br>| S3C2440A USB Downloader ver R0.03 2004 Jan  |<br>+---------------------------------------------+<br>USB: IN_ENDPOINT:1 OUT_ENDPOINT:3<br>FORMAT: &lt;ADDR(DATA):4&gt;+&lt;SIZE(n+10):4&gt;+&lt;DATA:n&gt;+&lt;CS:2&gt;<br>NOTE: Power off/on or press the reset button for 1 sec<br>      in order to get a valid USB device address.<br><br>NAND device: Manufacture ID: 0xec, Chip ID: 0x76 (Samsung K9D1208V0M)<br>Found saved vivi parameters.<br>Press Return to start the LINUX/Wince now, any other key for vivi<br>type "help" for help.<br>Supervivi&gt; menu                   <br><br>##### FriendlyARM BIOS for 2440 #####<br>[x] bon part 0 320k 2368k <br>[v] Download vivi <br>[k] Download linux kernel <br>[y] Download root_yaffs image <br>[c] Download root_cramfs image <br>[n] Download Nboot <br>[e] Download Eboot <br>[i] Download WinCE NK.nb0 <br>[w] Download WinCE NK.bin <br>[d] Download &amp; Run <br>[f] Format the nand flash <br>[p] Partition for Linux <br>[b] Boot the system <br>[s] Set the boot parameters <br>[t] Print the TOC struct of wince <br>[q] Goto shell of vivi <br>Enter your selection: s //&lt;--<br><br>##### Parameter Menu #####<br>[r] Reset parameter table to default table <br>[s] Set parameter <br>[v] View the parameter table  <br>[w] Write the parameter table to flash memeory <br>[q] Quit                           <br>Enter your selection: s //&lt;--<br><br>Enter the parameter's name(mach_type, media_type, linux_cmd_line, etc): linux_cmd_line<br><br>Enter the parameter's value(if the value contains space, enclose it with "): "console=ttySAC0 root=/dev/nfs nfsroot=192.168.1.111:/new/root_nfs ip=192.168.1.130:192.168.1.111:192.168.1.111:255.255.255.0:sbc2440.arm9.net:eth0:off"<br><br>Change linux command line to "console=ttySAC0 root=/dev/nfs nfsroot=192.168.1.111:/new/root_nfs ip=192.168.1.130:192.168.1.111:192.168.1.111:255.255.255.0:sbc2440.arm9.net:eth0:off"<br><br>##### Parameter Menu #####<br>[r] Reset parameter table to default table <br>[s] Set parameter <br>[v] View the parameter table  <br>[w] Write the parameter table to flash memeory <br>[q] Quit <br><br>Enter your selection: w  //&lt;--<br>Found block size = 0x0000c000<br>Erasing...    ... done<br>Writing...    ... done<br>Written 49152 bytes<br>Saved vivi private data<br><br>第二天：(完成)<br>文件系统制作<br>理解系统启动过程<br><br>先实验在skyeye下能不能成功，学习一下文件系统的制作。而后再下载到开发板实验<br>dd if=/dev/zero of=./test.image bs=1k count=8192  <br>块大小单位：1k,8120块，8M<br>mke2fs ./test.image<br>格式化<br>mkdir fuckroot<br>tar -xzvf root_mini.tgz<br>sudo mount -o loop test.image ./fuckroot/<br>cp -r root_mini/* fuckroot/ <br>sudo umount fuckroot/<br>可以将文件系统映像压缩后再使用：<br>gzip -v9 test.image &gt; test.image.gz<br>本人这个文件系统解压后的大小是6.4M,制作成8M大的test.image，压缩成test.image.gz后只有2.9M大。<br>但是利用skyeye启动时，解压花的时间比较长。<br><br><br>命令行中的ramdisk_size太小，修改.<br>mem=32M console=ttySAC0 root=/dev/ram initrd=0xc0800000,0x00800000 ramdisk_size=8192 rw initcall_debug<br><br>ramdisk_size=N<br>This parameter tells the RAM disk driver to set up RAM disks of N k size. <br><br>问题，文件系统没创建console设备节点：<br>RAMDISK: Loading 8192KiB [1 disk] into ram disk... done.<br>VFS: Mounted root (ext2 filesystem).<br>Freeing init memory: 132K<br>Warning: unable to open an initial console.<br><br>创建rootfs过程中，在/dev目录下手动创建如下节点：<br>mknod -m 660 null c 1 3<br>mknod -m 660 console c 5 1<br><br>结果：<br>VFS: Mounted root (ext2 filesystem).<br>Freeing init memory: 132K<br>hwclock: Could not access RTC: No such file or directory<br>mknod: /dev/pts/0: No such file or directory<br>mount: Mounting none on /tmp failed: Invalid argument<br>mount: Mounting none on /var failed: Invalid argument<br>/etc/init.d/rcS: /etc/init.d/rcS: 44: cannot create /dev/vc/0: Directory nonexistent<br>/etc/init.d/rcS: /etc/init.d/rcS: 45: cannot create /dev/vc/0: Directory nonexistent<br>/etc/rc.d/init.d/httpd: /etc/rc.d/init.d/httpd: 16: /sbin/boa: not found<br>/etc/init.d/rcS: /etc/init.d/rcS: 48: cannot create /dev/vc/0: Directory nonexistent<br>/etc/init.d/rcS: /etc/init.d/rcS: 49: cannot create /dev/vc/0: Directory nonexistent<br>/etc/rc.d/init.d/leds: /etc/rc.d/init.d/leds: 16: /etc/init.d/rcS: /etc/init.d/rcS: 52: cannot create /dev/vc/0: Directory nonexistent<br>/etc/init.d/rcS: /etc/init.d/rcS: 53: cannot create /dev/vc/0: Directory nonexistent<br>                        <br>/sbin/led-player: not found<br>SIOCSIFADDR: No such device<br>SIOCGIFFLAGS: No such device<br>/etc/init.d/rcS: /etc/init.d/rcS: 59: /sbin/madplay: not found<br><br>Please press Enter to activate this console. <br>-sh: can't access tty; job control turned off<br>id: unknown uid 0<br>[@FriendlyARM /]# ls<br>bin         home        lost+found  sbin        var<br>dev         lib         mnt         tmp         www<br>etc         linuxrc     proc        usr<br>[@FriendlyARM /dev]# ls<br>console  dsp      fb0      mixer    null     sda1     tty1     video0<br><br>还有一堆提示，但总算系统能跑了。<br><br>现在我的心头大患是udev的问题，因为2.6.26内核中没有devfs了。但有下面这篇文章参考<br>udev轻松上路<br>http://www.linuxforum.net/forum/showflat.php?Cat=&amp;Board=embedded&amp;Number=628054&amp;page=0&amp;view=collapsed&amp;sb=5&amp;o=0&amp;fpart=<br><br>第三天：(完成)<br>移植内核2.6.27-rc9到qq2440开发板，实现基本功能，能挂载板上文件系统.<br><br>步骤：<br>1.使用vivi修改mach_type参数<br>2.修改时钟频率<br>3.修改源码正确分区<br>4.禁止nand的ECC校验<br><br>分述：<br>问题1.表现<br>Uncompressing Linux................................................................................................................. done, booting the kernel.<br><br>Error: unrecognized/unsupported machine ID (r1 = 0x0000030e).<br><br>Available machine support:<br><br>ID (hex)        NAME<br>000000c1        SMDK2410<br>0000015b        IPAQ-H1940<br>0000039f        Acer-N35<br>00000290        Acer-N30<br>0000014b        Simtec-BAST<br>000002a8        Nex Vision - Otom 1.1<br>00000400        AML_M5900<br>000001db        Thorcom-VR1000<br>00000454        QT2410<br>000003fe        SMDK2413<br>000003f1        SMDK2412<br>00000377        S3C2413<br>00000474        VSTMS<br>000002de        Simtec-Anubis<br>0000034a        Simtec-OSIRIS<br>00000250        IPAQ-RX3715<br>0000016a        SMDK2440<br>000002a9        NexVision - Nexcoder 2440<br>0000043c        SMDK2443<br><br>Please check your kernel config and/or bootloader.<br>解决方法：<br>##### Parameter Menu #####<br>[r] Reset parameter table to default table <br>[s] Set parameter <br>[v] View the parameter table  <br>[w] Write the parameter table to flash memeory <br>[q] Quit <br>Enter your selection: s<br>Enter the parameter's name(mach_type, media_type, linux_cmd_line, etc): mach_type<br>Enter the parameter's value(if the value contains space, enclose it with "): 362 //&lt;---<br>Change 'mach_type' value. 0x0000030e(782) to 0x0000016a(362)<br>问题2.表现<br>Uncompressing Linux................................................................................................................. done, booting the kernel.<br>8?'·{e#???;?·7'0??3G?#?G'?乱码<br>解决方法：<br>static void __init smdk2440_map_io(void)<br>{<br>	s3c24xx_init_io(smdk2440_iodesc, ARRAY_SIZE(smdk2440_iodesc));<br>	s3c24xx_init_clocks(12000000);//修改处，原为16934400<br>	s3c24xx_init_uarts(smdk2440_uartcfgs, ARRAY_SIZE(smdk2440_uartcfgs));<br>}<br>问题3.表现<br>VFS: Cannot open root device "mtdblock2" or unknown-block(31,2)<br>Please append a correct "root=" boot option; here are the available partitions:<br>1f00         16 mtdblock0 (driver?)<br>1f01       2048 mtdblock1 (driver?)<br>1f02       4096 mtdblock2 (driver?)<br>1f03       2048 mtdblock3 (driver?)<br>1f04       4096 mtdblock4 (driver?)<br>1f05      10240 mtdblock5 (driver?)<br>1f06      24576 mtdblock6 (driver?)<br>1f07      16384 mtdblock7 (driver?)<br>Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(31,2)<br>解决：<br>依据nand分区修改源码：<br>static struct mtd_partition smdk_default_nand_part[] = {<br>	[0] = {<br>		.name	= "vivi",<br>		.size	= 0x00030000,<br>		.offset	= 0,<br>	},<br><br>	[1] = {<br>		.name	= "kernel",<br>		.offset = 0x00050000,<br>		.size	= 0x00200000,<br>	},<br>	[2] = {<br>		.name	= "root",<br>		.offset = 0x00250000,<br>		.size	= 0x03dac000,<br>	},<br>};<br>问题4.表现<br>Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(31,2)<br>导致上面panic的原因是没有禁止Flash ECC校验<br>解决：<br>s3c2410_nand_init_chip()<br>..<br>	if (set-&gt;disable_ecc)<br>		chip-&gt;ecc.mode	= NAND_ECC_NONE;<br>	chip-&gt;ecc.mode	= NAND_ECC_NONE;//&lt;-在函数最后加上<br><br>启动信息：<br>Copy linux kernel from 0x00050000 to 0x30008000, size = 0x00200000 ... done<br>zImage magic = 0x016f2818<br>Setup linux parameters at 0x30000100<br>linux command line is: "noinitrd root=/dev/mtdblock2 init=/linuxrc console=ttySAC0"<br>MACH_TYPE = 362<br>NOW, Booting Linux......<br>Uncompressing Linux................................................................................................................. done, booting the kernel.<br>Linux version 2.6.27-rc9 (fqh@ubuntu-sniper) (gcc version 4.2.4 (Debian 4.2.4-3)) #8 Sat Oct 11 03:17:21 CST 2008<br>CPU: ARM920T [41129200] revision 0 (ARMv4T), cr=c0007177<br>Machine: SMDK2440<br>ATAG_INITRD is deprecated; please update your bootloader.<br>Memory policy: ECC disabled, Data cache writeback<br>CPU S3C2440A (id 0x32440001)<br>S3C244X: core 405.000 MHz, memory 101.250 MHz, peripheral 50.625 MHz<br>S3C24XX Clocks, (c) 2004 Simtec Electronics<br>CLOCK: Slow mode (1.500 MHz), fast, MPLL on, UPLL on<br>CPU0: D VIVT write-back cache<br>CPU0: I cache: 16384 bytes, associativity 64, 32 byte lines, 8 sets<br>CPU0: D cache: 16384 bytes, associativity 64, 32 byte lines, 8 sets<br>Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 16256<br>Kernel command line: noinitrd root=/dev/mtdblock2 init=/linuxrc console=ttySAC0<br>irq: clearing pending ext status 00000200<br>irq: clearing subpending status 00000002<br>PID hash table entries: 256 (order: 8, 1024 bytes)<br>timer tcon=00000000, tcnt a4ca, tcfg 00000200,00000000, usec 00001e57<br>Console: colour dummy device 80x30<br>console [ttySAC0] enabled<br>Dentry cache hash table entries: 8192 (order: 3, 32768 bytes)<br>Inode-cache hash table entries: 4096 (order: 2, 16384 bytes)<br>Memory: 64MB = 64MB total<br>Memory: 61140KB available (3224K code, 335K data, 144K init)<br>Calibrating delay loop... 201.93 BogoMIPS (lpj=504832)<br>Mount-cache hash table entries: 512<br>CPU: Testing write buffer coherency: ok<br>net_namespace: 440 bytes<br>NET: Registered protocol family 16<br>S3C2410 Power Management, (c) 2004 Simtec Electronics<br>S3C2440: Initialising architecture<br>S3C2440: IRQ Support<br>S3C24XX DMA Driver, (c) 2003-2004,2006 Simtec Electronics<br>DMA channel 0 at c4800000, irq 33<br>DMA channel 1 at c4800040, irq 34<br>DMA channel 2 at c4800080, irq 35<br>DMA channel 3 at c48000c0, irq 36<br>S3C244X: Clock Support, DVS off<br>SCSI subsystem initialized<br>usbcore: registered new interface driver usbfs<br>usbcore: registered new interface driver hub<br>usbcore: registered new device driver usb<br>NET: Registered protocol family 2<br>IP route cache hash table entries: 1024 (order: 0, 4096 bytes)<br>TCP established hash table entries: 2048 (order: 2, 16384 bytes)<br>TCP bind hash table entries: 2048 (order: 1, 8192 bytes)<br>TCP: Hash tables configured (established 2048 bind 2048)<br>TCP reno registered<br>NET: Registered protocol family 1<br>NetWinder Floating Point Emulator V0.97 (extended precision)<br>JFFS2 version 2.2. (NAND) (SUMMARY)  ?? 2001-2006 Red Hat, Inc.<br>msgmni has been set to 119<br>io scheduler noop registered<br>io scheduler anticipatory registered (default)<br>io scheduler deadline registered<br>io scheduler cfq registered<br>Console: switching to colour frame buffer device 30x40<br>fb0: s3c2410fb frame buffer device<br>lp: driver loaded but no devices found<br>ppdev: user-space parallel port driver<br>Serial: 8250/16550 driver4 ports, IRQ sharing enabled<br>s3c2440-uart.0: s3c2410_serial0 at MMIO 0x50000000 (irq = 70) is a S3C2440<br>s3c2440-uart.1: s3c2410_serial1 at MMIO 0x50004000 (irq = 73) is a S3C2440<br>s3c2440-uart.2: s3c2410_serial2 at MMIO 0x50008000 (irq = 76) is a S3C2440<br>brd: module loaded<br>loop: module loaded<br>dm9000 Ethernet Driver, V1.31<br>Uniform Multi-Platform E-IDE driver<br>Driver 'sd' needs updating - please use bus_type methods<br>S3C24XX NAND Driver, (c) 2004 Simtec Electronics<br>s3c2440-nand s3c2440-nand: Tacls=3, 29ns Twrph0=7 69ns, Twrph1=3 29ns<br>NAND device: Manufacturer ID: 0xec, Chip ID: 0x76 (Samsung NAND 64MiB 3,3V 8-bit)<br>NAND_ECC_NONE selected by board driver. This is not recommended !!<br>Scanning device for bad blocks<br>Bad eraseblock 562 at 0x008c8000<br>Bad eraseblock 566 at 0x008d8000<br>Creating 3 MTD partitions on "NAND 64MiB 3,3V 8-bit":<br>0x00000000-0x00030000 : "vivi"<br>0x00050000-0x00250000 : "kernel"<br>0x00250000-0x03ffc000 : "root"<br>usbmon: debugfs is not available<br>s3c2410-ohci s3c2410-ohci: S3C24XX OHCI<br>s3c2410-ohci s3c2410-ohci: new USB bus registered, assigned bus number 1<br>s3c2410-ohci s3c2410-ohci: irq 42, io mem 0x49000000<br>usb usb1: configuration #1 chosen from 1 choice<br>hub 1-0:1.0: USB hub found<br>hub 1-0:1.0: 2 ports detected<br>usbcore: registered new interface driver libusual<br>usbcore: registered new interface driver usbserial<br>usbserial: USB Serial support registered for generic<br>usbcore: registered new interface driver usbserial_generic<br>usbserial: USB Serial Driver core<br>usbserial: USB Serial support registered for FTDI USB Serial Device<br>usbcore: registered new interface driver ftdi_sio<br>ftdi_sio: v1.4.3:USB FTDI Serial Converters Driver<br>usbserial: USB Serial support registered for pl2303<br>usbcore: registered new interface driver pl2303<br>pl2303: Prolific PL2303 USB to serial adaptor driver<br>mice: PS/2 mouse device common for all mice<br>S3C24XX RTC, (c) 2004,2006 Simtec Electronics<br>s3c2440-i2c s3c2440-i2c: slave address 0x10<br>s3c2440-i2c s3c2440-i2c: bus frequency set to 98 KHz<br>s3c2440-i2c s3c2440-i2c: i2c-0: S3C I2C adapter<br>S3C2410 Watchdog Timer, (c) 2004 Simtec Electronics<br>s3c2410-wdt s3c2410-wdt: watchdog inactive, reset disabled, irq enabled<br>TCP cubic registered<br>NET: Registered protocol family 17<br>RPC: Registered udp transport module.<br>RPC: Registered tcp transport module.<br>drivers/rtc/hctosys.c: unable to open rtc device (rtc0)<br>VFS: Mounted root (cramfs filesystem) readonly.<br>Freeing init memory: 144K<br>hwclock: Could not access RTC: No such file or directory<br>mknod: /dev/pts/0: Read-only file system<br>ln: /dev/video0: Read-only file system<br>ln: /dev/fb0: Read-only file system<br>ln: /dev/tty1: Read-only file system<br>ln: /dev/dsp: Read-only file system<br>ln: /dev/mixer: Read-only file system<br>ln: /dev/sda1: Read-only file system<br>/etc/init.d/rcS: /etc/init.d/rcS: 44: cannot create /dev/vc/0: Read-only file system<br>/etc/init.d/rcS: /etc/init.d/rcS: 45: cannot create /dev/vc/0: Read-only file system<br>/etc/rc.d/init.d/httpd: /etc/rc.d/init.d/httpd: 16: /sbin/boa: not found<br>/etc/init.d/rcS: /etc/init.d/rcS: 48: cannot create /dev/vc/0: Read-only file system<br>/etc/init.d/rcS: /etc/init.d/rcS: 49: cannot create /dev/vc/0: Read-only file system<br>/etc/rc.d/init.d/leds: /etc/rc.d/init.d/leds: 16: /sbin/led-player: not found<br>/etc/init.d/rcS: /etc/init.d/rcS: 52: cannot create /dev/vc/0: Read-only file system<br>/etc/init.d/rcS: /etc/init.d/rcS: 53: cannot create /dev/vc/0: Read-only file system<br>                        <br>SIOCSIFADDR: No such device<br>SIOCGIFFLAGS: No such device<br>/etc/init.d/rcS: /etc/init.d/rcS: 59: /sbin/madplay: not found<br><br>Please press Enter to activate this console. <br>-sh: can't access tty; job control turned off<br>id: unknown uid 0<br>[@FriendlyARM /]# uname -a<br>Linux FriendlyARM 2.6.27-rc9 #8 Sat Oct 11 03:17:21 CST 2008 armv4tl unknown<br>[@FriendlyARM /]# <br><br>第四天：<br>实现XP下虚拟机中的ubuntu利用gdb通过串口调试开发板上的2.6.27-rc9内核<br>问题，开发板只有一个串口，给gdb占用了，怎么操作开发板？<br><br>第五天：<br>实现硬盘安装的ubuntu系统利用gdb通过串口调试开发板上的内核。<br><br>第六天：<br>移植cs8900a网卡驱动。<br>实现开发板从硬盘ubuntu的nfs启动。<br>实现硬盘安装的ubuntu系统利用gdb通过网口调试开发板上的内核。<br><br>参考：<br> ubuntu8.04+skyeye1.2.4搭建linux2.6.24+s3c2410的模拟arm-linux开发环境<br>http://www.google.cn/search?complete=1&amp;hl=zh-CN&amp;newwindow=1&amp;client=firefox-a&amp;rls=org.mozilla:zh-CN:official&amp;hs=R4b&amp;q=cs8900+s3c2440+%E9%A9%B1%E5%8A%A8&amp;start=20&amp;sa=N<br><br>http://blog.chinaunix.net/u2/72751/showart_1130655.html<br>http://www.akae.cn/bbs/redirect.php?tid=6929&amp;goto=lastpost<br></pre>
</div>
<h4><a id="基于网口" name="基于网口">基于网口</a></h4>
<h2><a id="gdb基础" name="gdb基础">gdb基础</a></h2>
<h3><a id="基本命令" name="基本命令">基本命令</a></h3>
<div 
<div class="li" style="width:700px">
<p>推荐这篇，内容很全: gdb 使用手册 <a class="urlextern" title="http://blog.chinaunix.net/u/11240/showart.php?id=340632" href="http://blog.chinaunix.net/u/11240/showart.php?id=340632" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u/11240/showart.php?id=340632</font></u></a> </p>
<p>终极参考： Debugging with GDB <a class="urlextern" title="http://sourceware.org/gdb/current/onlinedocs/gdb.html#SEC_Top" href="http://sourceware.org/gdb/current/onlinedocs/gdb.html#SEC_Top" rel="nofollow"><u><font color="#0000ff">http://sourceware.org/gdb/current/onlinedocs/gdb.html#SEC_Top</font></u></a> </p>
</div>
<h3><a id="gdb之gui" name="gdb之gui">gdb之gui</a></h3>
<div 
<div class="li" style="width:700px">
<p>网址： </p>
<p>cgdb:<a class="urlextern" title="http://cgdb.sourceforge.net/" href="http://cgdb.sourceforge.net/" rel="nofollow"><u><font color="#0000ff">http://cgdb.sourceforge.net/</font></u></a> </p>
<p>kgdb:<a class="urlextern" title="http://www.kdbg.org/screenshot.php" href="http://www.kdbg.org/screenshot.php" rel="nofollow"><u><font color="#0000ff">http://www.kdbg.org/screenshot.php</font></u></a> </p>
<p>ddd:<a class="urlextern" title="http://www.gnu.org/software/ddd/" href="http://www.gnu.org/software/ddd/" rel="nofollow"><u><font color="#0000ff">http://www.gnu.org/software/ddd/</font></u></a> </p>
<p>insight:<a class="urlextern" title="http://sourceware.org/insight/" href="http://sourceware.org/insight/" rel="nofollow"><u><font color="#0000ff">http://sourceware.org/insight/</font></u></a> </p>
<p>这些工具在ubuntu下都有编译好的.deb安装包，利用“立新得”就直接搜索然后在线安装。 </p>
<p>这篇短文是我的浅陋之见，我接触这些gui的时间也不久。错误难免。 虚拟机：qemu </p>
<p>内核内置kgdb </p>
<p>developer machine: 运行gdb </p>
<p>除了只用命令行gdb外，还可以用gdb的gui,有 </p>
<p>1.cgdb
缺点：界面简陋，自动化程度低，只是把terminal分为两部分，上面部分显示源码，下面打命令。由于没有显示反汇编的窗体，不适合要求使用到
stepi命令的场合。优点：运行快，锻炼手指头. 最大的优点是，它有完美的代码着色功能。其他几款调试器中都没有。 </p>
<p>2.ddd: 缺点：与kdbg相比，界面凌乱。优点：代码显示效果比kdbg好，c和反汇编代码分开在两个窗口。
可以随时暂停程序的运行。data windows 这个功能非常强大灵活。提示 ddd –tty 2&gt;/dev/null ./vmlinux
; remote target localhost:1234 </p>
<p>3. kdbg:
缺点：功能比ddd弱。字体太小，c和反汇编代码交错显示，反汇编代码折叠隐藏在C代码之间，要显示反汇编代码要手动展开，不可忍受。太过界面化，居然找
不到是在哪里手动打gdb命令。致命缺点是，内核跑起来后，如果没有断点拦截，就没法把内核的运行暂停下来，kdbg成了没事姥，源码窗口的显示不更新。
另一个致命缺点是，如果没有源码只有二进制文件，虽然可以下断点，但无法显示反汇编代码，没意义。据说kdbg是用来调试kde程序的，实际上也能调试内
核。优点：窗口可以整合到一块，稳定。有变化的寄存器会显示红色。提示 kdbg -r localhost:1234 ./vmlinux </p>
<p>4. insight:
和ddd都是基于TCL/TK，比较相似。优点：源码显示功能最强，可以选择C和反汇编代码分开和交叉显示。可以选择反汇编代码使用intel还是
at&amp;t格式。可以列出当前有哪些源文件，当前文件有哪些函数。变化的寄存器有改变颜色的功能，ddd则没有。缺点：和ddd一样，小窗口无法整
合到到窗口中，但比ddd差的是，主窗口最大化后小窗口无法保持置顶。相对ddd的大劣势是没有一个强大的data
windows。感觉界面比ddd强大，但灵活性比ddd差点。对于调试内核来说，还有一个和kdbg相同的大缺点，内核只能通过断点暂停运行，而ddd
下还可以用ctrl+c暂停内核。另外它有个SB错误，显示backtrace的窗口,标题居然是stack. 提示: insight
./vmlinux </p>
<p>5. xxgdb: 古董级别。没事干的时候可以玩玩 </p>
<p>6. 其实，gdb自带了一个基于curses的gui。启动方式是gdbtui xxx; 或者在gdb启动之后用命令layout启动gui。很好用，可以至多同时显示三个分窗口。要是代码有着色功能就好了。 </p>
<p>针对内核调试的总结： </p>
<p>1. kdbg不适合调试内核 </p>
<p>3. 如果想复习gdb强大的命令，选cgdb或纯gdb。 </p>
<p>4. 如果想学习汇编，insight是不二选择。 </p>
<p>5 如果倾向于把调试器当作浏览器使用，作为source
insight等工具的辅助工具，在内核运行中拦截函数，分析函数的调用关系，不需要反汇编的话，则cgdb是不错的选择 .(source
insight等源码分析工具有个共同的缺点，因为体系和内核配置不同，一个函数有很多的定义，借助调试器可以在内核运行的时候找出实际调用的那个) </p>
<p>6.insight和ddd很接近，各有千秋。但如果侧重于追溯数据结构体间的联系，ddd更好一点，因为它有data
window，它的强项是数据和数据结构关系分析并用图像方式显示出来（What is DDD? Data Display
Debugger)。如果侧重于分析汇编指令是怎么在cpu中跑的，推荐用insight，因为它汇编代码显示功能更细致。 </p>
<p>7.可惜目前在ubuntu8.04下,ddd+qemu组合用来调试驱动时有bug：驱动函数被拦截时如果正在qemu的系统下操作，鼠标就会冻结在qemu的屏幕中。其实调试单个驱动，用gdb就足够了。ddd等gui一般用来调试理解内核原理。 </p>
</div>
<h3><a id="gdb技巧" name="gdb技巧">gdb技巧</a></h3>
<div 
<div class="li" style="width:700px">
<p>另外有用的命令 ptype, whatis </p>
<p>－－－－ </p>
<p>更多相关技巧： </p>
<p>1. 获取struct page结构的大小 </p>
<pre class="file">(gdb) p mem_map<br>$80 = (struct page *) 0xc1000000<br>(gdb) p mem_map+1<br>$81 = (struct page *) 0xc1000020<br>(gdb) p/x 0xc1000020 - 0xc1000000<br>$82 = 0×20<br></pre>
<p>2. </p>
<p>打印前从指针mem_map所指起的5个page结构体 </p>
<pre class="file">(gdb) p *mem_map@5<br>$83 = {{flags = 1024, _count = {counter = 1}, {_mapcount = {counter = -1}, {inuse = 65535, objects = 65535}}, {{private = 0, mapping = 0×0}, ptl =…<br></pre>
<p>用ddd的图形显示命令是 (gdb) graph display *mem_map@5 </p>
<p>参考 p *array@len </p>
<p>@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中 </p>
<p>3. </p>
<p>每运行一次stepi/next等命令后显示下一步要将要运行的反汇编指令 </p>
<pre class="file">(gdb) display/i $pc<br>6: x/i $pc<br>0xc0144fb6 &lt;init_cgroup_root+22&gt;:    mov    %esp,%ebp<br>(gdb) stepi<br>6: x/i $pc<br>0xc0144fb8 &lt;init_cgroup_root+24&gt;:    mov    %edx,0×44(%eax)<br></pre>
<p>提示：display的管理： </p>
<p>undisplay delete display disable display enable display info display </p>
<p>4.使结构体的显示更漂亮 </p>
<pre class="file">(gdb) show print pretty<br>Prettyprinting of structures is on.<br>(gdb) set print pretty off<br>(gdb) p *init_task-&gt;group_info<br>$12 = {ngroups = 0, usage = {counter = 14}, small_block = {0 &lt;repeats 32 times&gt;}, nblocks = 0, blocks = 0xc0355530}<br>(gdb) set print pretty on<br>(gdb) p *init_task-&gt;group_info<br>$13 = {<br>ngroups = 0,<br>usage = {<br>counter = 14<br>},<br>small_block = {0 &lt;repeats 32 times&gt;},<br>nblocks = 0,<br>blocks = 0xc0355530<br>}<br></pre>
<p>(注：6.7.条来自<a class="urlextern" title="http://techcenter.dicder.com/2006/0906/content_173.html" href="http://techcenter.dicder.com/2006/0906/content_173.html" rel="nofollow"><u><font color="#0000ff">http://techcenter.dicder.com/2006/0906/content_173.html</font></u></a>) </p>
<p>5. 使用自定义命令。 </p>
<pre class="file">(gdb) define nid<br><br>Type commands for definition of “nid”.<br><br>End with a line saying just “end”.<br><br>&gt;ni<br><br>&gt;disassemble $pc $pc+16<br><br>&gt;end<br></pre>
<p>6. 纯gdb的多窗口显示 GUI调试器可以同时打开多个小窗口，分别显示寄存器、汇编和源代码等。在gdb里也可以做到，但同时最多只能显示两个窗口，试了一下也很方便的。基本命令如下： </p>
<p>a) `layout src’ 仅显示源代码窗口。 </p>
<p>b) `layout asm’ 仅显示汇编代码窗口。 </p>
<p>c) `layout split’ 显示源代码和汇编代码窗口。 </p>
<p>d) `layout regs’ 显示寄存器和源代码窗口，或者寄存器和汇编代码窗口。 </p>
<p>e) `layout next` 和 `layout prev’ 切换窗口。 </p>
<p>f) ctrl + L 刷新屏幕。 </p>
<p>g) `C-x 1′ 单窗口模式。 </p>
<p>h) `C-x 2′ 双窗口模式。 </p>
<p>i) `C-x a’ 回到传统模式。 </p>
<p>7. 字符gdb中，如何在每执行一次next命令后都自动显示backtrace的内容 这个问题实际是如何一次执行多条命令。用自定义命令解决 </p>
<pre class="file">(gdb) define nbt<br>Type commands for definition of “nbt”.<br>End with a line saying just “end”.<br>&gt;next<br>&gt;bt<br>&gt;end<br>(gdb) nbt<br>#0  early_cpu_init () at arch/x86/kernel/cpu/common.c:626<br>#1  0xc0384ca9 in setup_arch (cmdline_p=0xc0379fe8)<br>at arch/x86/kernel/setup_32.c:765<br>#2  0xc037f62e in start_kernel () at init/main.c:564<br>#3  0xc037f008 in i386_start_kernel () at arch/x86/kernel/head32.c:13<br>#4  0×00000000 in ?? ()<br>(gdb)<br></pre>
<p>8. gdb在TUI模式下如何把光标焦点炸转移到command窗口，以便能用上下箭头键能快速翻出历史指令？ </p>
<pre class="file">实际是转换“active”窗口。<br>C-x o： ctrl+x,接着放开这两个键，然后在按o（不需要+ctrl）<br>关于TUI更多信息：<br>http://sourceware.org/gdb/current/onlinedocs/gdb_23.html#SEC236<br>还有组合键<br>C-x C-a<br>C-x a<br>C-x A 退出TUI模式<br><br>C-x 1 只用一个窗口<br>C-x 2 用两个窗口，按多次会有不同两个窗口的组合形式<br>C-x o active 窗口转移<br>C-x s 进入和退出TUI SingleKey 模式<br>注：C-x o多次使用相当于依次执行以下命令<br>focus src 转移焦点到源码窗口。<br>focus asm<br>focus regs<br>focus cmd<br><br>TUI模式还有以下专用命令<br>info win<br>layout next<br>layout prev<br>layout src<br>layout asm<br>layout split<br>layout regs<br>focus next<br>refresh<br>tui reg float<br>tui reg general<br>tui reg next<br>tui reg system<br><br><br><br><br><br>update<br>winheight name +count<br>winheight name -count<br>tabset nchars<br></pre>
<p>9. 如何在子函数调用和退出时都暂停运行 watch $ebp </p>
<p>10. 如何获取结构体中特定域的相对偏移量，比如struct stak_struct 中lock_depth的相对偏移量？ </p>
<pre class="file">(gdb) p/x &amp;(*(struct task_struct *)0).lock_depth<br>$7 = 0x14<br></pre>
<p>11. 如何能够交换使用ddd与gdb，也就是说使用ddd调试时，想换回使用纯gdb，同时保证启用gdb后保证“调试上下文”没任何变化？ </p>
<p>只要.gdbinit 文件没包含 c, next..等等能驱动gdb继续调试的命令就可以。 </p>
<p>12. 如何通过函数名确定所在的源文件 </p>
<pre class="file">(gdb) info line vfs_mkdir<br>Line 2131 of "fs/namei.c" starts at address 0xc017c048 &lt;vfs_mkdir&gt; and ends at 0xc017c052 &lt;vfs_mkdir+10&gt;.<br></pre>
<p>13. 由汇编指令地址确定该指令所对应源码的所在行(注：一行c语言一般对应几行汇编指令) </p>
<p>info line *xxxxxxx (xxx是汇编指令地址) </p>
<p>14. 如何快速定位函数中某句C语句对应汇编指令的开始地址。比如以下 [内容太大，准备移到其他位置] </p>
<pre class="file">2130	int vfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)<br>2131	{<br>.......<br>2145		DQUOT_INIT(dir);<br>2146		error = dir-&gt;i_op-&gt;mkdir(dir, dentry, mode);//&lt;-我们想确定这句语句的汇编指令开始地址，注意它在源文件中的行数<br>2147		if (!error)<br>2148			fsnotify_mkdir(dir, dentry);<br>2149		return error;<br>2150	}<br></pre>
<p>首先，通过函数名查询对应的源文件 </p>
<pre class="file">(gdb) info line vfs_mkdir<br>Line 2131 of "fs/namei.c" starts at address 0xc017c048 &lt;vfs_mkdir&gt; and ends at 0xc017c052 &lt;vfs_mkdir+10&gt;.<br></pre>
<p>然后，利用info line 源文件:目标语句的行数 就能查询到 </p>
<pre class="file">(gdb) info line fs/namei.c:2146<br>Line 2146 of "fs/namei.c" starts at address 0xc017c0ee &lt;vfs_mkdir+166&gt; and ends at 0xc017c0fe &lt;vfs_mkdir+182&gt;.<br></pre>
<p>验证一下 </p>
<pre class="file">(gdb) disass 0xc017c0ee<br>Dump of assembler code for function vfs_mkdir:<br>0xc017c048 &lt;vfs_mkdir+0&gt;:	push   %ebp<br>.....<br>0xc017c0e4 &lt;vfs_mkdir+156&gt;:	mov    0x24(%eax),%ecx<br>0xc017c0e7 &lt;vfs_mkdir+159&gt;:	or     $0xffffffff,%edx<br>0xc017c0ea &lt;vfs_mkdir+162&gt;:	mov    %esi,%eax<br>0xc017c0ec &lt;vfs_mkdir+164&gt;:	call   *(%ecx)<br>0xc017c0ee &lt;vfs_mkdir+166&gt;:	mov    0x98(%esi),%ebx  //<br>0xc017c0f4 &lt;vfs_mkdir+172&gt;:	mov    %edi,%edx        //参数 dentry -&gt; %edx<br>0xc017c0f6 &lt;vfs_mkdir+174&gt;:	mov    %esi,%eax        //参数dir -&gt; %eax<br>0xc017c0f8 &lt;vfs_mkdir+176&gt;:	mov    -0x10(%ebp),%ecx //参数mode -&gt; %ecx <br>0xc017c0fb &lt;vfs_mkdir+179&gt;:	call   *0x14(%ebx)      //dir-&gt;i_op-&gt;mkdir(dir, dentry, mode) <br>0xc017c0fe &lt;vfs_mkdir+182&gt;:	test   %eax,%eax        //判断返回值(error = dir-&gt;i_op-&gt;mkdir(dir, dentry, mode);)<br>0xc017c100 &lt;vfs_mkdir+184&gt;:	mov    %eax,%ebx        //保存返回值<br>0xc017c102 &lt;vfs_mkdir+186&gt;:	jne    0xc017c15d &lt;vfs_mkdir+277&gt; //如果返回值 != 0，也就是mkdir失败，跳到最后返回。成功则继续<br>0xc017c104 &lt;vfs_mkdir+188&gt;:	testb  $0x4,0x11c(%esi)           //内联函数fsnotify_mkdir 及子函数-&gt;inode_dir_notify在这里展开<br>                           //static inline void inode_dir_notify(struct inode *inode, unsigned long event)<br>                           //{<br>                           //	if (inode-&gt;i_dnotify_mask &amp; (event)) &lt;-注意这里判断位，刚好对应testb  $0x4,0x11c(%esi)<br><br>0xc017c10b &lt;vfs_mkdir+195&gt;:	je     0xc017c119 &lt;vfs_mkdir+209&gt;<br>.....<br>0xc017c15d &lt;vfs_mkdir+277&gt;:	lea    -0xc(%ebp),%esp<br>0xc017c160 &lt;vfs_mkdir+280&gt;:	mov    %ebx,%eax<br><br></pre>
<p>我们通过mkdir参数个数，及testb 指令基本判定我们的猜测没错。也就是说vfs_mkdir函数中dir→i_op→mkdir的实际调用是在0xc017c0fb &lt;vfs_mkdir+179&gt;: call *0×14(%ebx) </p>
<p>15. 下断点的形式 </p>
<pre class="file">1. b 函数名<br>2. b *指令地址<br>3. b 源码:行数<br>(gdb) b fs/namei.c:2146<br>Breakpoint 9 at 0xc017c0ee: file fs/namei.c, line 2146.<br></pre>
<p>16. 陷入循环语句后，想自动运行到循环语句结束： </p>
<pre class="file">u<br></pre>
<p>17. 重复当前的gdb指令 </p>
<pre class="file">按enter键即可<br></pre>
</div>
<h3><a id="gdb宏" name="gdb宏">gdb宏</a></h3>
<div 
<div class="li" style="width:700px">
<p>本小节意义：为了方便把调试内容复制出来，而又需要一定的功能，本人经常使用的工具是gdb的tui。所以gdb宏的使用更是成了不可缺少的辅助手
段。比如extendinstr宏，能实时显示调用链的情况，相当于实现了ddd的backtrace分窗口。其他宏的作用就不说了。 </p>
</div>
<h4><a id="参考资料" name="参考资料">参考资料</a></h4>
<div 
<div class="li" style="width:700px">
<p>kgdb官方的gdb宏 <a class="urlextern" title="http://kgdb.linsyssoft.com/downloads.htm" href="http://kgdb.linsyssoft.com/downloads.htm" rel="nofollow"><u><font color="#0000ff">http://kgdb.linsyssoft.com/downloads.htm</font></u></a> </p>
<p>“Fun with strace and the GDB Debugger” <a class="urlextern" title="http://www.ibm.com/developerworks/aix/library/au-unix-strace.html" href="http://www.ibm.com/developerworks/aix/library/au-unix-strace.html" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/aix/library/au-unix-strace.html</font></u></a> </p>
<p>“GNU Project Debugger: More fun with GDB” <a class="urlextern" title="http://www.ibm.com/developerworks/aix/library/au-gdb.html" href="http://www.ibm.com/developerworks/aix/library/au-gdb.html" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/aix/library/au-gdb.html</font></u></a> </p>
<p>“14.3.4. Useful Kernel gdb Macros” from “Embedded Linux Primer” <a class="urlextern" title="http://book.opensourceproject.org.cn/embedded/embeddedprime/" href="http://book.opensourceproject.org.cn/embedded/embeddedprime/" rel="nofollow"><u><font color="#0000ff">http://book.opensourceproject.org.cn/embedded/embeddedprime/</font></u></a> </p>
</div>
<h4><a id="gdb宏的使用" name="gdb宏的使用">gdb宏的使用</a></h4>
<div 
<div class="li" style="width:700px">
<p>假设要使用下节的lsmod，该gdb宏能列举内核中的模块。 在内核源码目录下建立一个新文件lsmod,内容见下节。 </p>
<pre class="file">装载宏<br>(gdb) source lsmod <br>查看说明<br>(gdb) help lsmod<br>list module struct's address, text address and their module name<br>使用<br>(gdb) lsmod<br>(gdb) lsmod<br>Address		text		Module<br>0xE014DDA0	0xE014D000	nls_iso8859_1<br>0xE0169AE0	0xE0164000	isofs<br>0xE014BA20	0xE0148000	zlib_inflate<br>0xE0161FE0	0xE0152000	udf<br>.....<br>0xE0012DE0	0xE000B000	processor<br>0xE0008EA0	0xE0008000	fan<br>0xE00223E0	0xE0020000	thermal_sys<br>----end----<br>(gdb) <br><br>(gdb) <br><br>我们查看一下processor模块结构体的内容<br>(gdb) p *(struct module *)0xE0012DE0<br>$10 = {<br>  state = MODULE_STATE_LIVE, <br>  list = {<br>    next = 0xe0008ea4, <br>    prev = 0xe0018984<br>  }, <br>  name = "processor", '\0' &lt;repeats 50 times&gt;, <br>  mkobj = {<br>    kobj = {<br>      name = 0xd5910ba0 "processor", <br>      kref = {<br>        refcount = {<br>          counter = 3<br>        }<br>      }, <br>      entry = {<br>        next = 0xe00189d0, <br>...<br>...<br><br>为了方便查看该结构中指针域所指向的结构体，可在ddd下用以下命令打开数据图形然后展开查看<br>(gdb) graph display *(struct module *)0xE0012DE0<br></pre>
</div>
<h4><a id="实例" name="实例">实例</a></h4>
<div 
<div class="li" style="width:700px">
<p>给出的例子都在2.6.26内核上上测试通过。 </p>
</div>
<h4><a id="链表遍历类" name="链表遍历类">链表遍历类</a></h4>
<div 
<div class="li" style="width:700px">
<p>宏名: lsmod(有小bug,饭后再看) </p>
<p>作用: 列举内核模块的名称及对应模块结构体的地址，以及text段的地址［todo，导出.bss,.data地址］ </p>
<pre class="file">define lsmod<br>        printf "Address\t\ttext\t\tModule\n"<br>        set $m=(struct list_head *)&amp;modules<br>        set $done=0<br>        #获取结构体内特定域的相对偏移，见"gdb技巧"<br>        set $offset=&amp;(*(struct module *)0).list<br>        while ( !$done )<br>                set $mp=(struct module *)((char *)$m-&gt;next - (char *)$offset)<br>                printf "0x%X\t0x%X\t%s\n", $mp, $mp-&gt;module_core,$mp-&gt;name<br>                if ( $mp-&gt;list-&gt;next == &amp;modules)<br>                        set $done=1<br>                end<br>                set $m=$m-&gt;next<br>        end<br>        printf "----end----\n"<br><br> end<br><br>document lsmod<br>list module struct's address, text address and their module name<br>end<br><br></pre>
<p>效果如下 </p>
<pre class="file">(gdb) lsmod<br>Address		text		Module<br>0xE014DDA0	0xE014D000	nls_iso8859_1<br>0xE0169AE0	0xE0164000	isofs<br>0xE014BA20	0xE0148000	zlib_inflate<br>0xE0161FE0	0xE0152000	udf<br>.....<br>0xE001BEA0	0xE001A000	8390<br>0xE017EEC0	0xE016C000	ide_core<br>0xE0018980	0xE0015000	thermal<br>0xE0012DE0	0xE000B000	processor<br>0xE0008EA0	0xE0008000	fan<br>0xE00223E0	0xE0020000	thermal_sys<br>----end----<br><br></pre>
<p>宏名: psusr,pskern </p>
<p>作用: 列举所有task的结构地址，状态，PID，PPID，comm。 </p>
<p>psusr,只列举用户层可见的进程；pskern，列举内核层可见的所有进程。 </p>
<pre class="file">define __show_state<br>        if ($arg0-&gt;state == 0)<br>                printf "running\t\t"<br>                else<br>                if ($arg0-&gt;state == 1)<br>                        printf "sleeping\t"<br>                        else<br>                        if ($arg0-&gt;state == 2)<br>                                printf "disksleep\t"<br>                                else<br>                                if ($arg0-&gt;state == 4)<br>                                        printf "zombie\t"<br>                                        else<br>                                        if ($arg0-&gt;state == 8)<br>                                                printf "stopped\t"<br>                                                else<br>                                                if ($arg0-&gt;state == 16)<br>                                                        printf "wpaging\t"<br>                                                        else<br>                                                                printf "%d\t\t", $arg0-&gt;state<br>                                                        end<br>                                                end<br>                                        end<br>                                end<br>                        end<br>                end<br>end<br>document __show_state<br>internel macro, don't call it by hand<br>end<br><br><br>define psusr<br>        printf "address\t\tstate\t\tuid\tpid\tppid\tcomm\n"<br>        set $init_t = &amp;init_task<br>        set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<br>        set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<br><br>        while ($next_t != $init_t)<br>		set $next_t=(struct task_struct *)$next_t<br>		printf "0x%08X\t", $next_t<br>		__show_state $next_t<br>		printf "%d\t%d\t%d\t%s\n", \<br>			$next_t-&gt;uid, $next_t-&gt;pid, \<br>			$next_t-&gt;parent-&gt;pid, $next_t-&gt;comm<br>		set  $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off <br>        end<br><br>        printf "address\t\tstate\t\tuid\tpid\tppid\tcomm\n"<br>        printf "----end----\n"<br><br>end<br>document psusr<br>print information for all tasks, but not including thread members.<br>This command looks like "ps -aux" in userspace.<br>end<br><br><br>define pskern<br>        printf "address\t\tstate\t\tuid\tpid\tppid\tcomm\n"<br>        set $init_t = &amp;init_task<br>        printf "0x%08X\t", $init_t<br>        __show_state $init_t<br>        printf "%d\t%d\t%d\t%s\n", \<br>                $init_t-&gt;uid, $init_t-&gt;pid, \<br>                $init_t-&gt;parent-&gt;pid, $init_t-&gt;comm<br>	<br>	set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<br>	set $thread_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)<br>	set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<br><br>	while ($next_t != $init_t)<br>		set $next_t=(struct task_struct *)$next_t<br><br>		printf "0x%08X\t", $next_t<br>		__show_state $next_t<br>		printf "%d\t%d\t%d\t%s\n", \<br>			$next_t-&gt;uid, $next_t-&gt;pid, \<br>			$next_t-&gt;parent-&gt;pid, $next_t-&gt;comm<br><br>		set $next_th=(((char *)$next_t-&gt;thread_group.next) - $thread_off)<br><br>		while ($next_th != $next_t)<br>			set $next_th=(struct task_struct *)$next_th<br><br>			printf "0x%08X\t", $next_th<br>			__show_state $next_th<br>			printf "%d\t%d\t%d\t%s\n", \<br>				$next_th-&gt;uid, $next_th-&gt;pid, \<br>				$next_th-&gt;parent-&gt;pid, $next_th-&gt;comm<br><br>			set $next_th=(((char *)$next_th-&gt;thread_group.next) - $thread_off)<br>		end<br><br>		set  $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off<br>        end<br><br>        printf "address\t\tstate\t\tuid\tpid\tppid\tcomm\n"<br>        printf "----end----\n"<br><br>end<br>document pskern<br>print infor for all tasks viewed in kernel, including all thread members<br>and swapper(PID==0).<br>end<br></pre>
<p>效果如下 </p>
<pre class="file">(gdb) source ps<br>(gdb) psusr<br>address		state		uid	pid	ppid	comm<br>0xDC43F8A0	sleeping	0	1	0	init<br>0xDC43F490	sleeping	0	2	0	kthreadd<br>0xDC43F080	sleeping	0	3	2	migration/0<br>0xDC43EC70	sleeping	0	4	2	ksoftirqd/0<br>0xDC43E860	sleeping	0	5	2	watchdog/0<br>.....<br>0xDC44E060	sleeping	0	1707	1	acpid<br>0xD8AE6100	sleeping	104	1716	1	dbus-daemon<br>0xDC46ECD0	sleeping	0	1739	1	cupsd<br>0xDC45E080	sleeping	101	2009	1	exim4<br>0xD5A6C0E0	sleeping	0	2026	1	inetd<br>0xD5A6CD10	sleeping	0	2034	1	dhcdbd<br>0xDBD45160	sleeping	105	2044	1	hald<br>0xDBD45570	sleeping	0	2045	2044	hald-runner<br>....<br>address		state		uid	pid	ppid	comm<br>----end----<br></pre>
<p>宏名： lssp </p>
<p>作用： 列举超级块地址及其s_id域 </p>
<pre class="file">define lssp<br>        printf "address\t\ts_id\n"<br>        set $sb_lh=(struct list_head *)&amp;super_blocks<br>        #获取结构体内特定域的相对偏移，见"gdb技巧"<br>        set $offset=&amp;(*(struct super_block *)0).s_list<br>        set $sbp=(struct super_block *)((char *)$sb_lh-&gt;next - (char *)$offset)<br>        while ( &amp;$sbp-&gt;s_list != $sb_lh )<br>                printf "0x%08X\t%s\n", $sbp, $sbp-&gt;s_id<br>                set $sbp=(struct super_block *)((char *)$sbp-&gt;s_list.next - (char *)$offset)<br>        end<br>        printf "----end----\n"<br><br> end<br><br>document lssp<br>List the super_block and their start addresses<br>end<br><br></pre>
<p>效果 </p>
<pre class="file">(gdb) lssp<br>address		s_id<br>0xDC40DC00	sysfs<br>0xDC40DA00	rootfs<br>0xDC40D800	bdev<br>0xDC40D400	proc<br>0xDC41B200	sockfs<br>0xDC431C00	debugfs<br>0xDC486600	pipefs<br>0xDC486000	anon_inodefs<br>0xD58C5A00	tmpfs<br>0xD58C5200	inotifyfs<br>0xD8C09800	devpts<br>0xD8C09600	hugetlbfs<br>0xD8C09400	mqueue<br>0xD590E000	tmpfs<br>0xD59E4C00	hda1<br>0xD5908A00	tmpfs<br>0xD7753200	tmpfs<br>0xDBD66400	hdc<br>----end----<br><br></pre>
</div>
<h4><a id="功能增强类" name="功能增强类">功能增强类</a></h4>
<div 
<div class="li" style="width:700px">
<p>宏名： eih, lih, ooi </p>
<p>作用： 克服时钟中断干扰与中断无关的目标代码的调试(X86下适用)，解释请看“工程方法” </p>
<p>说明： 使用gdb或ddd时，进入中断后用finish命令的话常常是要么无法返回被中断的原指令处后停住，而是继续运行，要么是会进入到另一个时钟中断中；但是好像在insight下没这个问题。使用这个gdb宏可以解决该问题。 </p>
<pre class="file">define eih<br>b common_interrupt<br>b native_iret<br>end<br><br>document eih<br>eih: early interrupt hacking, break common_interrupt and native_iret<br>end<br><br><br>define lih<br>b apic_timer_interrupt<br>b irq_return<br>end<br><br>document lih<br>lih: late interrupt hacking, break apic_timer_interrupt and irq_return<br>end<br><br><br>define ooi<br>c<br>stepi<br>end<br><br>document ooi<br>ooi: out of interrupt, return to the instruction interrupted by interrupt handler<br>end<br></pre>
<p>宏名： extendinstr </p>
<p>作用： 扩展指令集。配合gdb自带的tui使用，能代替ddd等界面工具的部分功能。 </p>
<p>说明： 指令开头:s→step,si→stepi,n→next,ni→nexti,中间bt→bt,末尾i→info args &amp;&amp; info local </p>
<pre class="file">define inar<br>printf "-----args start----\n"<br>info args<br>end<br><br>define inlo<br>printf "-----local start----\n"<br>info local<br>end<br><br>define btl<br>printf "-------------------\n"<br>bt<br>end<br><br>define sibt<br>stepi<br>btl<br>end<br><br>define sbt<br>step<br>btl<br>end<br><br>define nibt<br>nexti<br>btl<br>end<br><br>define nbt<br>next<br>btl<br>end<br><br><br>define sibti<br>inar<br>inlo<br>stepi<br>btl<br>end<br><br>define sbti<br>inar<br>inlo<br>step<br>btl<br>end<br><br>define nibti<br>inar<br>inlo<br>nexti<br>btl<br>end<br><br>define nbti<br>inar<br>inlo<br>next<br>btl<br>end<br></pre>
<p>效果 </p>
<p>宏名： quick </p>
<p>作用： 超级快捷键。gdb的快捷键并没用用尽所有的按键。我们可以利用空余的按键定义自己的命令。方便起见，我只是利用自定义命令简单的实现该该功能，而不是自定义快捷键。可以根据自己偏好来定义。 </p>
<p>说明： 这个宏是配合前面的宏ooi和宏extendinstr使用的。这样，如果调试时进入了时钟中断，按a＋enter就可以瞬间返回；q＋enter–&gt;sibt; z＋enter–&gt;finish。 </p>
<pre class="file">define a<br>ooi<br>end<br><br>define q<br>sibt<br>end<br><br>define z<br>finish<br>end<br><br></pre>
<p>宏名：bttnobp,btt,psusr,pskern,trapinfo,btpid,dmesg </p>
<p>内核文档gdbmacros.txt 的gdb宏的升级版本,还修正了一个bug,已在2.6.26下测试。 </p>
<p>如果你运行这个脚本有错误，那说明你的内核版本太低了，请运行内核源码中原文件的宏。 </p>
<p>本人这个文件的补丁还在提交的过程中。 </p>
<p>能提供non-running进程的backtrace功能，还实现了dmesg。 </p>
<p>说明bttnobp没在!CONFIG_FRAME_POINTER的配置下测试过，但是估计结果很不可靠， </p>
<p>因为条件判断太宽大了。 </p>
<pre class="file">#<br># This file contains a few gdb macros (user defined commands) to extract<br># useful information from kernel crashdump (kdump) like stack traces of<br># all the processes or a particular process and trapinfo.<br>#<br># These macros can be used by copying this file in .gdbinit (put in home<br># directory or current directory) or by invoking gdb command with<br># --command=&lt;command-file-name&gt; option<br>#<br># Credits:<br># Alexander Nyberg &lt;alexn@telia.com&gt;<br># V Srivatsa &lt;vatsa@in.ibm.com&gt;<br># Maneesh Soni &lt;maneesh@in.ibm.com&gt;<br>#<br><br>define __show_state<br>        if ($arg0-&gt;state == 0)<br>                printf "running\t\t"<br>                else<br>                if ($arg0-&gt;state == 1)<br>                        printf "sleeping\t"<br>                        else<br>                        if ($arg0-&gt;state == 2)<br>                                printf "disksleep\t"<br>                                else<br>                                if ($arg0-&gt;state == 4)<br>                                        printf "zombie\t"<br>                                        else<br>                                        if ($arg0-&gt;state == 8)<br>                                                printf "stopped\t"<br>                                                else<br>                                                if ($arg0-&gt;state == 16)<br>                                                        printf "wpaging\t"<br>                                                        else<br>                                                                printf "%d\t\t", $arg0-&gt;state<br>                                                        end<br>                                                end<br>                                        end<br>                                end<br>                        end<br>                end<br>end<br>document __show_state<br>internel macro, don't call it by hand<br>end<br><br><br>define psusr<br>        printf "address\t\tstate\t\tuid\tpid\tppid\tcomm\n"<br>        set $init_t = &amp;init_task<br>        set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<br>        set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<br><br>        while ($next_t != $init_t)<br>		set $next_t=(struct task_struct *)$next_t<br>		printf "0x%08X\t", $next_t<br>		__show_state $next_t<br>		printf "%d\t%d\t%d\t%s\n", \<br>			$next_t-&gt;uid, $next_t-&gt;pid, \<br>			$next_t-&gt;parent-&gt;pid, $next_t-&gt;comm<br>		set  $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off <br>        end<br><br>        printf "address\t\tstate\t\tuid\tpid\tppid\tcomm\n"<br>        printf "----end----\n"<br><br>end<br>document psusr<br>print information for all tasks, but not including thread members.<br>This command looks like "ps -aux" in userspace.<br>end<br><br><br>define pskern<br>        printf "address\t\tstate\t\tuid\tpid\tppid\tcomm\n"<br>        set $init_t = &amp;init_task<br>        printf "0x%08X\t", $init_t<br>        __show_state $init_t<br>        printf "%d\t%d\t%d\t%s\n", \<br>                $init_t-&gt;uid, $init_t-&gt;pid, \<br>                $init_t-&gt;parent-&gt;pid, $init_t-&gt;comm<br>	<br>	set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<br>	set $thread_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)<br>	set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<br><br>	while ($next_t != $init_t)<br>		set $next_t=(struct task_struct *)$next_t<br><br>		printf "0x%08X\t", $next_t<br>		__show_state $next_t<br>		printf "%d\t%d\t%d\t%s\n", \<br>			$next_t-&gt;uid, $next_t-&gt;pid, \<br>			$next_t-&gt;parent-&gt;pid, $next_t-&gt;comm<br><br>		set $next_th=(((char *)$next_t-&gt;thread_group.next) - $thread_off)<br><br>		while ($next_th != $next_t)<br>			set $next_th=(struct task_struct *)$next_th<br><br>			printf "0x%08X\t", $next_th<br>			__show_state $next_th<br>			printf "%d\t%d\t%d\t%s\n", \<br>				$next_th-&gt;uid, $next_th-&gt;pid, \<br>				$next_th-&gt;parent-&gt;pid, $next_th-&gt;comm<br><br>			set $next_th=(((char *)$next_th-&gt;thread_group.next) - $thread_off)<br>		end<br><br>		set  $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off<br>        end<br><br>        printf "address\t\tstate\t\tuid\tpid\tppid\tcomm\n"<br>        printf "----end----\n"<br><br>end<br>document pskern<br>print infor for all tasks viewed in kernel, including all thread members<br>and swapper(PID==0).<br>end<br><br><br>define __prinfo_nobp<br>        printf "\npid %d; addr:0x%08x; comm %s:\n", \<br>                $arg0.pid, $arg0, $arg0.comm<br>        printf "=====================================\n"<br>        set var $stackp = $arg0.thread.sp<br>        set var $stack_top = ($stackp &amp; ~4095) + 4096<br><br>        while ($stackp &lt; $stack_top)<br>                if (*($stackp) &gt; _stext &amp;&amp; *($stackp) &lt; _sinittext)<br>                        info symbol *($stackp)<br>                end<br>        set $stackp += 4<br>        end<br>end<br>document __prinfo_nobp<br>internal macro, don't call it by hand.<br>end<br><br><br>define bttnobp<br>	set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<br>	set $thread_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)<br>	set $init_t=&amp;init_task<br>	set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<br><br>	while ($next_t != $init_t)<br>		set $next_t=(struct task_struct *)$next_t<br>		__prinfo_nobp $next_t<br>		set $next_th=(((char *)$next_t-&gt;thread_group.next) - $thread_off)<br>		while ($next_th != $next_t)<br>			set $next_th=(struct task_struct *)$next_th<br>			__prinfo_nobp $next_th<br>			set $next_th=(((char *)$next_th-&gt;thread_group.next) - $thread_off)<br>		end<br>		set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off<br>	end<br>end<br>document bttnobp<br>	dump all thread stack traces on a kernel compiled with !CONFIG_FRAME_POINTER<br>end<br><br><br>define __prinfo<br>        printf "\npid %d; addr:0x%08x; comm %s:\n", \<br>                $arg0.pid, $arg0, $arg0.comm<br>        printf "=====================================\n"<br>        set var $stackp = $arg0.thread.sp<br>        set var $stack_top = ($stackp &amp; ~4095) + 4096<br>        set var $stack_bot = ($stackp &amp; ~4095)<br><br>        set $stackp = *($stackp)<br>        while (($stackp &lt; $stack_top) &amp;&amp; ($stackp &gt; $stack_bot))<br>                set var $addr = *($stackp + 4)<br>                info symbol $addr<br>                set $stackp = *($stackp)<br>        end<br>end<br>document __prinfo<br>internal macro, don't call it by hand.<br>end<br><br><br>define btt<br>	set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<br>	set $thread_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)<br>	set $init_t=&amp;init_task<br>	set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<br><br>	while ($next_t != $init_t)<br>		set $next_t=(struct task_struct *)$next_t<br>		__prinfo $next_t<br>		set $next_th=(((char *)$next_t-&gt;thread_group.next) - $thread_off)<br>		while ($next_th != $next_t)<br>			set $next_th=(struct task_struct *)$next_th<br>			__prinfo $next_th	<br>			set $next_th=(((char *)$next_th-&gt;thread_group.next) - $thread_off)<br>		end<br>		set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off<br>	end<br>end<br>document btt<br>	dump all thread stack traces on a kernel compiled with CONFIG_FRAME_POINTER<br>end<br><br>define btpid<br>	set var $pid = $arg0<br>	set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<br>	set $thread_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group)<br>	set $init_t=&amp;init_task<br>	set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<br>	set var $pid_task = 0<br><br>	while ($next_t != $init_t)<br>		set $next_t=(struct task_struct *)$next_t<br><br>		if ($next_t.pid == $pid)<br>			set $pid_task = $next_t<br>		end<br><br>		set $next_th=(((char *)$next_t-&gt;thread_group.next) - $thread_off)<br>		while ($next_th != $next_t)<br>			set $next_th=(struct task_struct *)$next_th<br>			if ($next_th.pid == $pid)<br>				set $pid_task = $next_th<br>			end<br>			set $next_th=(((char *)$next_th-&gt;thread_group.next) - $thread_off)<br>		end<br>		set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off<br>	end<br><br>	__prinfo $pid_task<br><br>end<br>document btpid<br>	backtrace of pid<br>end<br><br><br>define trapinfo<br>	set var $pid = $arg0<br>	set $tasks_off=((size_t)&amp;((struct task_struct *)0)-&gt;tasks)<br>	set $thread_off=((size_t)&amp;((struct task_struct *)0)-&gt;thread_group.next)<br>	set $init_t=&amp;init_task<br>	set $next_t=(((char *)($init_t-&gt;tasks).next) - $tasks_off)<br>	set var $pid_task = 0<br><br>	while ($next_t != $init_t)<br>		set $next_t=(struct task_struct *)$next_t<br><br>		if ($next_t.pid == $pid)<br>			set $pid_task = $next_t<br>		end<br><br>		set $next_th=(((char *)$next_t-&gt;thread_group.next) - $thread_off)<br>		while ($next_th != $next_t)<br>			set $next_th=(struct task_struct *)$next_th<br>			if ($next_th.pid == $pid)<br>				set $pid_task = $next_th<br>			end<br>			set $next_th=(((char *)$next_th-&gt;thread_group.next) - $thread_off)<br>		end<br>		set $next_t=(char *)($next_t-&gt;tasks.next) - $tasks_off<br>	end<br><br>	printf "Trapno %ld, cr2 0x%lx, error_code %ld\n", $pid_task.thread.trap_no, \<br>				$pid_task.thread.cr2, $pid_task.thread.error_code<br><br>end<br>document trapinfo<br>	Run info threads and lookup pid of thread #1<br>	'trapinfo &lt;pid&gt;' will tell you by which trap &amp; possibly<br>	address the kernel panicked.<br>end<br><br><br>define dmesg<br>	set $i = 0<br>	set $end_idx = (log_end - 1) &amp; (log_buf_len - 1)<br><br>	while ($i &lt; logged_chars)<br>		set $idx = (log_end - 1 - logged_chars + $i) &amp; (log_buf_len - 1)<br><br>		if ($idx + 100 &lt;= $end_idx) || \<br>		   ($end_idx &lt;= $idx &amp;&amp; $idx + 100 &lt; log_buf_len)<br>			printf "%.100s", &amp;log_buf[$idx]<br>			set $i = $i + 100<br>		else<br>			printf "%c", log_buf[$idx]<br>			set $i = $i + 1<br>		end<br>	end<br>end<br>document dmesg<br>	print the kernel ring buffer<br>end<br><br></pre>
<p>宏名：vmap, lsvmaps, lsmod, lsmodsects, lsallmodsects </p>
<p>说明：没测试，待更新 </p>
<p>来源 <a class="urlextern" title="http://jeanmarc.saffroy.free.fr/kdump2gdb/" href="http://jeanmarc.saffroy.free.fr/kdump2gdb/" rel="nofollow"><u><font color="#0000ff">http://jeanmarc.saffroy.free.fr/kdump2gdb/</font></u></a> </p>
<pre class="file"># Copyright Jean-Marc Saffroy &lt;saffroy@gmail.com&gt; 2006<br># This program is free software, distributed under the terms of the<br># GNU General Public License version 2.<br><br># a few useful(?) macros for x86-64 VMM hacks<br><br># useful constants<br>set $PAGE_SIZE = (1&lt;&lt;12)<br>set $__PHYSICAL_MASK = (1 &lt;&lt; 46)-1<br>set $PTE_MASK = ~($PAGE_SIZE-1) &amp; $__PHYSICAL_MASK<br>set $__PAGE_OFFSET = 0xffff810000000000<br>set $_PAGE_PSE = 0x80<br><br>define vmap<br>	set $addr = (long)$arg0<br>	# index in each of the 4 levels of page directories<br>	set $pgd = $addr &gt;&gt; 39 &amp; (1&lt;&lt;9)-1<br>	set $pud = $addr &gt;&gt; 30 &amp; (1&lt;&lt;9)-1<br>	set $pmd = $addr &gt;&gt; 21 &amp; (1&lt;&lt;9)-1<br>	set $pte = $addr &gt;&gt; 12 &amp; (1&lt;&lt;9)-1<br>	# offset in page<br>	set $off = $addr &amp; (1&lt;&lt;12)-1<br>	#printf "%03x %03x %03x %03x %03x\n", $pgd, $pud, $pmd, $pte, $off<br><br>	set $pgd_off = (pgd_t *) &amp;init_level4_pgt + $pgd<br>	#printf "pgd_off: %lx pgd: %lx\n", $pgd_off, (long)$pgd_off-&gt;pgd<br>	set $pgd_page = ((long)$pgd_off-&gt;pgd &amp; $PTE_MASK) + $__PAGE_OFFSET<br>	#printf "pgd_page: %lx\n", $pgd_page<br><br>	set $pud_off = ((pud_t *) $pgd_page) + $pud<br>	#printf "pud_off: %lx pud: %lx\n", $pud_off, (long)$pud_off-&gt;pud<br>	set $pud_page = ((long)$pud_off-&gt;pud &amp; $PTE_MASK) + $__PAGE_OFFSET<br>	#printf "pud_page: %lx\n", $pud_page<br><br>	set $pmd_off = ((pmd_t *) $pud_page) + $pmd<br>	#printf "pmd_off: %lx pmd: %lx\n", $pmd_off, (long)$pmd_off-&gt;pmd<br>	set $pmd_page = ((long)$pmd_off-&gt;pmd &amp; $PTE_MASK) + $__PAGE_OFFSET<br>	#printf "pmd_page: %lx\n", $pmd_page<br><br>	if ((long)$pmd_off-&gt;pmd &amp; $_PAGE_PSE) != 0<br>		#printf "PSE page! "<br>		set $paddr = $pmd_page + ($addr &amp; (1&lt;&lt;21)-1)<br>	else<br>		set $pte_off = ((pte_t *) $pmd_page) + $pte<br>		#printf "pte_off: %lx pte: %lx\n", $pte_off, (long)$pte_off-&gt;pte<br>		set $pte_page = ((long)$pte_off-&gt;pte &amp; $PTE_MASK) + $__PAGE_OFFSET<br>		#printf "pte_page: %lx\n", $pte_page<br>		set $paddr = $pte_page + $off<br>	end<br>	#printf "remapped physical addr: %lx\n", $paddr<br>	printf "%lx -&gt; %lx\n", $addr, $paddr<br>end<br><br>document vmap<br>Usage: vmap &lt;address&gt;<br>Convert a kernel remapped virtual address to an identity-mapped address.<br>end<br><br>define lsvmaps<br>	set $map = vmlist<br>	set $gcount = 0<br>	while $map != 0<br>		if $map-&gt;pages != 0<br>			set $vaddr = (long)$map-&gt;addr<br>			set $count = (long)$map-&gt;size / $PAGE_SIZE<br>			set $gcount = $gcount + $count -1<br>			while $count &gt; 1<br>				vmap $vaddr<br>				set $vaddr = $vaddr + $PAGE_SIZE<br>				set $count = $count - 1<br>			end<br>		end<br>		set $map = $map-&gt;next<br>	end<br>	printf "page count: %d\n", $gcount<br>end<br><br>document lsvmaps<br>List all kernel remapped pages (vmalloc regions) and corresponding identity-mapped pages.<br>end<br><br>define lsmod<br>    set $mod = modules.next<br>    printf "struct module        size   name\n"<br>    while $mod != &amp;modules<br>        set $m = (struct module *)((char*)$mod-(char*)(&amp;((struct module*)0)-&gt;list))<br>    	printf "0x%lx % 8d %s\n", $m, $m-&gt;core_size, $m-&gt;name<br>	set $mod = $mod-&gt;next<br>    end<br>end<br><br>document lsmod<br>List loaded kernel modules.<br>end<br><br>define lsmodsects<br>	set $mod = (struct module *)$arg0<br>	printf "add-symbol-file %s.ko 0x%lx ", $mod-&gt;name, $mod-&gt;sect_attrs-&gt;attrs[0].address<br>	set $i = 1<br>	while $mod-&gt;sect_attrs-&gt;grp-&gt;attrs[$i] != 0<br>		printf "-s %s ", (char*)$mod-&gt;sect_attrs-&gt;attrs[$i].name<br>		printf "0x%lx ", $mod-&gt;sect_attrs-&gt;attrs[$i].address<br>		set $i = $i + 1<br>	end<br>	printf "\n"<br>end<br><br>document lsmodsects<br><br>Usage: lsmodsects &lt;address of struct module&gt;<br>Prints "add-symbol-file..." command to load sections of the given module.<br>end<br><br>define lsallmodsects<br>    set $mdl = modules.next<br>    while $mdl != &amp;modules<br>        set $m = (struct module *)((char*)$mdl-(char*)(&amp;((struct module*)0)-&gt;list))<br>	lsmodsects $m<br>	set $mdl = $mdl-&gt;next<br>    end<br>end<br><br>document lsallmodsects<br>Calls lsmodsects on all modules.<br>end<br><br></pre>
</div>
<h2><a id="汇编基础--x86篇" name="汇编基础--x86篇">汇编基础--X86篇</a></h2>
<div 
<div class="li" style="width:700px">
<p>注意：某些内容不具备普遍性。比如给出的反汇编代码，在不同的优化等级下是不同的。但是在熟悉了典型的函数调用链反汇编代码，对于有变化的其他形式也就不难理解了。 </p>
</div>
<h3><a id="用户手册" name="用户手册">用户手册</a></h3>
<div 
<div class="li" style="width:700px">
<p>Intel? 64 and IA-32 Architectures Software Developer’s Manuals </p>
<p><a class="urlextern" title="http://www.intel.com/products/processor/manuals/index.htm" href="http://www.intel.com/products/processor/manuals/index.htm" rel="nofollow"><u><font color="#0000ff">http://www.intel.com/products/processor/manuals/index.htm</font></u></a> </p>
</div>
<h3><a id="at_t汇编格式" name="at_t汇编格式">AT&amp;T汇编格式</a></h3>
<div 
<p>参考 </p>
 style="width:700px">
<p>参考 </p>
<p>“AT&amp;T汇编语言与GCC内嵌汇编简介” <a class="urlextern" title="http://blog.chinaunix.net/u2/73528/showart_1110874.html" href="http://blog.chinaunix.net/u2/73528/showart_1110874.html" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u2/73528/showart_1110874.html</font></u></a> </p>
<p>[杂类文章] </p>
<p>“Linux Assembly and Disassembly an Introduction” <a class="urlextern" title="http://www.milw0rm.com/papers/47" href="http://www.milw0rm.com/papers/47" rel="nofollow"><u><font color="#0000ff">http://www.milw0rm.com/papers/47</font></u></a> </p>
</div>
<h3><a id="内联汇编" name="内联汇编">内联汇编</a></h3>
<div 
<div class="li" style="width:700px">
<p>GCC-Inline-Assembly-HOWTO <a class="urlextern" title="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html" href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html" rel="nofollow"><u><font color="#0000ff">http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</font></u></a> </p>
</div>
<h3><a id="汇编与c函数的相互调用" name="汇编与c函数的相互调用">汇编与C函数的相互调用</a></h3>
<h3><a id="调用链形成和参数传递" name="调用链形成和参数传递">调用链形成和参数传递</a></h3>
<div 
<div class="li" style="width:700px">
<p>参考文章 [多如牛毛] </p>
<p>“Guide: Function Calling Conventions” <a class="urlextern" title="http://www.delorie.com/djgpp/doc/ug/asm/calling.html" href="http://www.delorie.com/djgpp/doc/ug/asm/calling.html" rel="nofollow"><u><font color="#0000ff">http://www.delorie.com/djgpp/doc/ug/asm/calling.html</font></u></a> </p>
<p>“Intel x86 Function-call Conventions - Assembly View” <a class="urlextern" title="http://www.unixwiz.net/techtips/win32-callconv-asm.html" href="http://www.unixwiz.net/techtips/win32-callconv-asm.html" rel="nofollow"><u><font color="#0000ff">http://www.unixwiz.net/techtips/win32-callconv-asm.html</font></u></a> </p>
<p>“C Function Call Conventions and the Stack” <a class="urlextern" title="http://www.cs.umbc.edu/~chang/cs313.s02/stack.shtml" href="http://www.cs.umbc.edu/~chang/cs313.s02/stack.shtml" rel="nofollow"><u><font color="#0000ff">http://www.cs.umbc.edu/~chang/cs313.s02/stack.shtml</font></u></a> </p>
<p>“The C Calling Convention and the 8086: Using the Stack Frame” <a class="urlextern" title="http://www.et.byu.edu/groups/ece425web/stable/labs/StackFrame.html" href="http://www.et.byu.edu/groups/ece425web/stable/labs/StackFrame.html" rel="nofollow"><u><font color="#0000ff">http://www.et.byu.edu/groups/ece425web/stable/labs/StackFrame.html</font></u></a> </p>
<p>“C Function Calling Convention” <a class="urlextern" title="http://adamw-dev.blogspot.com/2007/05/c-function-calling-convention.html" href="http://adamw-dev.blogspot.com/2007/05/c-function-calling-convention.html" rel="nofollow"><u><font color="#0000ff">http://adamw-dev.blogspot.com/2007/05/c-function-calling-convention.html</font></u></a> </p>
<p>“C函数调用在GNU汇编中的实现” <a class="urlextern" title="http://www.unixresources.net/linux/clf/cpu/archive/00/00/59/75/597564.html" href="http://www.unixresources.net/linux/clf/cpu/archive/00/00/59/75/597564.html" rel="nofollow"><u><font color="#0000ff">http://www.unixresources.net/linux/clf/cpu/archive/00/00/59/75/597564.html</font></u></a> </p>
<p>“函数调用的几个概念：_stdcall,_cdecl....” <a class="urlextern" title="http://blog.chinaunix.net/u2/67530/showart_601750.html" href="http://blog.chinaunix.net/u2/67530/showart_601750.html" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u2/67530/showart_601750.html</font></u></a> </p>
<p>“Calling conventions(调用规则)” <a class="urlextern" title="http://www.bobd.cn/itschool/Program/delphi/200612/itschool_12084.html" href="http://www.bobd.cn/itschool/Program/delphi/200612/itschool_12084.html" rel="nofollow"><u><font color="#0000ff">http://www.bobd.cn/itschool/Program/delphi/200612/itschool_12084.html</font></u></a> </p>
<p>[扩展，简要说明原理。并用实例解析] </p>
<p>x86终极参考 </p>
<p>CHAPTER 6 PROCEDURE CALLS, INTERRUPTS, AND EXCEPTIONS of </p>
<p>IA-32 Intel_ Architecture Software Developer’s Manual Volume 1_ Basic Architecture.pdf <a class="urlextern" title="http://download.intel.com/design/processor/manuals/253665.pdf" href="http://download.intel.com/design/processor/manuals/253665.pdf" rel="nofollow"><u><font color="#0000ff">http://download.intel.com/design/processor/manuals/253665.pdf</font></u></a> </p>
</div>
<h4><a id="寄存器的角色与保护" name="寄存器的角色与保护">寄存器的角色与保护</a></h4>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">寄存器的角色</div>
</li>
</ul>
<p>1. %esp: 栈指针 </p>
<p>指向栈的顶端，也就是指向栈的最后一个正在使用的元素。%esp的值隐式地受到几个机器指令的影响，比如push,pop,call,ret等。 </p>
<p>2. %ebp: 基址指针 </p>
<p>指向当前栈的基地址，有时也称为“帧指针”。与%esp不同的是，它必须显式地进行操作才能改变值。 </p>
<p>3. %eip: 指令指针 </p>
<p>保存着下一个被执行机器指令的地址。当CPU执行call指令时，%eip的值自动被保存到栈中。还有，任何一个“jump”跳转指令都会直接地改变%eip </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">两条规则</div>
</li>
</ul>
<p>1. gcc要求在函数调用的前后，寄存器%ebx，%esi，%edi，%ebp，%esp,%ds, %es，%ss的值保持不变。所以被调用函数如果需要修改这些寄存器的值，被调用函数必须负责对它们进行保护。［后三个??］ </p>
<p>2. gcc规定在函数调用的前后，寄存器%eax,%edx,%ecx的值可以改变。所以调用函数如果需要防止子函数破坏这三个寄存器的值，调用者必须在函数调用前自己负责保护它们。 </p>
<p>我们注意到，是保护，不一定是保存。如果确认没用到某寄存器，那么该寄存器就不需要一定要有一个先保存到栈而后再恢复原值的过程。 </p>
<p>这两条规则实际是定义了对系统资源使用的权限和义务。 </p>
<p>第一条规则，是银行和借贷者的关系。有人向银行借了几千万，结果赌博全输光了。还钱的期限到了，银行的行长对借贷者说“没事，你回家吧。几千万而
已，我拿我工资给你垫上”。我想这样的事决不会发生，行长一个电话110过去，借贷者一天后就把钱还清了。所以，这里，调用函数是银行行长，子函数是借贷
者。 </p>
<p>第二条规则，则是老爸和儿子的关系了。儿子对老爸说“老爸，解我100去买球鞋，我明天还你”。结果，第二天，老爸没钱吃饭了，问儿子“还钱”。儿
子说“昨晚逛街碰到一个美女，请了一顿，把钱化光了”。老爸没法子，总不能把儿子绳以正法吧。怪只能怪自己事前没防这招咯。所以，这里，调用函数是老爸，
子函数是儿子你。 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">返回值</div>
</li>
</ul>
<pre class="code">  1. Integers (of any size up to 32 bits) and pointers are returned in the %eax register.<br>  2. Floating point values are returned in the 387 top-of-stack register, st(0).<br>  3. Return values of type long long int are returned in %edx:%eax (the most significant word in %edx and the least significant in %eax).<br>  4. Returning a structure is complicated and rarely useful; try to avoid it. (Note that this is different from returning a pointer to a structure.) <br>  5. If your function returns void (e.g. no value), the contents of these registers are not used.</pre>
</div>
<h4><a id="调用链的形成" name="调用链的形成">调用链的形成</a></h4>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">应用层实例解析</div>
</li>
</ul>
<p>我们回头看看“寄存器的角色”这一小节，很快就能明白调用链的形成的本质。 </p>
<p>调用链包含两方面的内容 </p>
<p>1.返回地址的保存与恢复 </p>
<p>2.旧栈帧的保存与恢复 </p>
<p>因为在普通的调用形式中(call调用)，返回地址的保存与恢复是由处理器机制本身保证的，不需人工维护。调用指令call的执行自动将call指
令之下的指令地址压入栈中，被调用函数返回时，ret指令的执行会重新将返回地址从栈弹出传送到pc中。要求下面分析旧栈帧的保存与恢复。 </p>
<p>旧栈帧的保存与恢复，无非就是要解决两大问题： </p>
<p>1. 建立新栈帧
这一步很简单，栈帧无非有两个头，底端和顶端。%esp指向栈的顶端，而%esp是不需要手工维护的，随着push,pop等指令，它自己就在改变自己。
那么又怎么建立栈帧的底端呢？我们知道，栈底(也就是基址)是由%ebp指定的，在一个栈帧的整个生命周期里，%ebp的值都不变，也就是说，赋个合适的
值给它就完事。怎么赋值就是问题所在了。我们知道，%esp指向栈中最后一个被使用的元素。所以，当我们正在使用(我们认为的)第一个元素时，把%esp
的值赋给%ebp,%ebp不就是指向栈的基址了吗？ </p>
<p>2. 保护旧栈帧的信息
同样的问题，保护旧栈帧的信息，就是保存旧栈帧指向底端和顶端的指针值，也就是旧%ebp,%esbp的值。当函数调用指令刚执行完，马上就要保护作案现
场了。首先，push
%ebp,这句就把旧栈帧的基地址保存在栈的顶端。此时，%esp指向的内存地址中，就放着旧栈帧的基地址的值。但是还不够啊，%esp是个不可靠的东
西，它经常在变化，必须把这个地址放到一个不会隐式变化的寄存器中。于是选择了%ebp。mov %esp
%ebp.这样，%ebp指向的内存地址中，就放着旧栈帧的基地址的值。这就解放了%esp，可以用%esp来动态指向新栈帧的顶端了。按照定
义，%ebp所指向的地址是新栈帧的底端，也就是新栈帧的第一个元素，也就是说新栈帧第一个元素的值是旧栈帧基址。 </p>
<p>但是注意，%ebp指向的地址再加4bytes的地址上，存放的是被调用函数的返回地址。在执行call指令时，call指令后面的那个指令的地址（也就是被调用函数的返回地址）被自动隐式地放到了栈中。 </p>
<p>当子函数返回时，再按照上面文字进行逆操作，就能恢复旧栈帧的信息。 </p>
<pre class="file">#include &lt;stdio.h&gt;<br><br>void func()<br>{}<br><br>void funb()<br>{<br>        func();<br>}<br><br><br>void funa()<br>{<br>        funb();<br>}<br><br>int main()<br>{<br>        funa();<br>}<br>-------<br>08048344 &lt;func&gt;:<br>#include &lt;stdio.h&gt;<br><br>void func()<br>{}<br> 8048344:       55                      push   %ebp<br> 8048345:       89 e5                   mov    %esp,%ebp<br> 8048347:       5d                      pop    %ebp<br> 8048348:       c3                      ret<br><br>08048349 &lt;funb&gt;:<br><br>void funb()<br>{<br> 8048349:       55                      push   %ebp<br> 804834a:       89 e5                   mov    %esp,%ebp<br>        func();<br> 804834c:       e8 f3 ff ff ff          call   8048344 &lt;func&gt;<br>}<br><br><br> 8048351:       5d                      pop    %ebp<br> 8048352:       c3                      ret<br><br>08048353 &lt;funa&gt;:<br><br><br>void funa()<br>{<br> 8048353:       55                      push   %ebp<br> 8048354:       89 e5                   mov    %esp,%ebp<br>        funb();<br> 8048356:       e8 ee ff ff ff          call   8048349 &lt;funb&gt;<br>}<br> 804835b:       5d                      pop    %ebp<br> 804835c:       c3                      ret<br><br><br>0804835d &lt;main&gt;:<br>int main()<br>{<br> 804835d:       8d 4c 24 04             lea    0x4(%esp),%ecx<br> 8048361:       83 e4 f0                and    $0xfffffff0,%esp<br> 8048364:       ff 71 fc                pushl  -0x4(%ecx)<br> 8048367:       55                      push   %ebp<br> 8048368:       89 e5                   mov    %esp,%ebp<br> 804836a:       51                      push   %ecx<br>        funa();<br> 804836b:       e8 e3 ff ff ff          call   8048353 &lt;funa&gt;<br>}<br> 8048370:       59                      pop    %ecx<br> 8048371:       5d                      pop    %ebp<br> 8048372:       8d 61 fc                lea    -0x4(%ecx),%esp<br> 8048375:       c3                      ret<br> 8048376:       90                      nop<br> 8048377:       90                      nop<br> 8048378:       90                      nop<br> 8048379:       90                      nop<br> 804837a:       90                      nop<br> 804837b:       90                      nop<br> 804837c:       90                      nop<br> 804837d:       90                      nop<br> 804837e:       90                      nop<br> 804837f:       90                      nop<br><br><br>func被调用后内存如下<br><br>          |              |                        <br>      |   |              |                       | hight<br>      |   |              |                       |<br>      |   +--------------\                       |<br>      +---+ main's %ebp  |\                      |<br>      +-&gt; +--------------+ --funa's frame        |<br>      |   | ret to funa  | /                     |<br>      |   +--------------+X                      |<br>      +---+ funa's %ebp  | \                     |<br>      +--&gt;+--------------+ ---funb's frame       |<br>      |   | ret to funb  | /                     |<br>      |   +--------------+                       |<br>      +---+ funb's %ebp  |&lt;---func's frame       | low<br>  %esp--&gt; +--------------+&lt;---- %ebp             v <br>          |              |                         <br>          |              |                         <br>          |              |  <br>          |              | <br>          |              | <br>                          <br><br><br></pre>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">内核层实例解析</div>
</li>
</ul>
</div>
<h4><a id="栈帧结构与参数传递" name="栈帧结构与参数传递">栈帧结构与参数传递</a></h4>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">栈元素引用的就近原则</div>
</li>
</ul>
<p>为了说明就近原则，我们先看看典型和全面的栈帧是怎样的。函数caller调用子函数callee所形成的栈帧。 </p>
<p>1. 从被调用的子函数callee来看，获取caller的传递的实参，以及建立自身本地变量时，因为内存地址都靠近栈帧的基址,所以这两种引用都是利用%ebp加上偏移量的形式。 </p>
<p>2. 相反，主函数在调用子函数前，在为子函数准备实参时，因为实参位于栈帧末端，所以对实参的引用都是利用%esp加上偏移量的形式(没画出来) </p>
<pre class="file"> caller's frame pointer                           <br>        |                                         <br>        |     |                   |               <br>        |     |                   |               <br>        |     |                   |               <br>        |     +-------------------+               <br>        |     | caller saved      |               <br>        |     |   registers       |               <br>        |     | %eax,%ecx,%edx    |               <br>        |     |  (as needed)      |               <br>        |     +-------------------+               <br>        |     | argument  #3      | [%ebp+16]     <br>        |     +-------------------+               <br>        |     | argument  #2      | [%ebp+12]     <br>        |     +-------------------+               <br>        |     | argument  #1      | [%ebp+8]      <br>        |     +-------------------+               <br>        |     | return address    |               <br>        |     +-------------------+      -----    <br>        +-----+ caller's %ebp     |&lt;---%ebp   \   <br>              +-------------------+            \   <br>              | local var #1      | [%ebp-4]    \  <br>              +-------------------+             |  <br>              | local var #2      | [%ebp-8]    | <br>              +-------------------+             | <br>              |  temporary        |             | <br>              |   storage         |             | <br>              +-------------------+               <br>              |  callee saved     |           callee stack frame<br>              |    registers      |             | <br>              | %ebx,%esi,%edi    |             | <br>              |   (as needed)     |             | <br>              +-------------------+             | <br>              |                   |             | <br>              |                   |             | <br>              |                   |            /  <br>              |                   |&lt;----%esp  /   <br>              |                                          <br><br>caller:调用者 callee:被调用者<br></pre>
</div>
<h4><a id="完整的调用过程" name="完整的调用过程">完整的调用过程</a></h4>
<div 
<div class="li" style="width:700px">
<p>函数caller调用子函数callee，这是应用层的普通函数调用过程。如果是远调用，跨态调用要考虑的东西更多。但这个例子已经充分展示了调用过程的繁复部分。 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">函数调用前调用者的动作</div>
</li>
</ul>
<p>1.%eax,%edx,%ecx入栈（可选） </p>
<p>2.子函数的参数入栈 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">函数调用 call callee</div>
</li>
</ul>
<p>call机器指令，原子性自动地完成了两种任务. </p>
<p>1.%eip入栈, 保存了callee函数的返回地址 </p>
<p>2.callee的函数地址传递到%eip. </p>
<p>所以下一指令就从callee函数的第一指令开始运行。控制权转移给callee </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">函数调用后被调用者的动作</div>
</li>
</ul>
<p>1.保存caller栈帧基址 push %ebp </p>
<p>2.建立callee栈帧基址 mov %esp，%ebp </p>
<p>3.分配本地变量和临时存储的空间 sub $XXX, %esp </p>
<p>4.本地变量赋值 </p>
<p>5.%ebx,%esi,%edi入栈(可选) </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">调用返回前被调用者的动作</div>
</li>
</ul>
<p>1.%ebx,%esi,%edi还原(出栈,可选) </p>
<p>2.释放本地变量和临时存储的栈空间mov %ebp，%esp </p>
<p>3.还原caller栈帧的基址 pop %ebp </p>
<p>或者2.3.步用一条元语指令完成 leave </p>
<p>4.调用返回 ret </p>
<p>该指令把存放于栈的返回地址取出(出栈)，存放到%eip中。下一指令就从call callee指令的下一指令开始运行。控制权返回给caller </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">调用返回后调用者的动作</div>
</li>
</ul>
<p>1.释放存放callee参数的栈空间 add $XXX, %esp </p>
<p>2.转移%eax的值（子函数的返回值，可选） </p>
<p>3.还原%eax,%edx,%ecx（出栈，可选） </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">应用层实例解析</div>
</li>
</ul>
<p>应用层参数的传入: 用户层参数的传递是利用栈来完成的。函数右边的参数先入栈，位于栈的高地址。反之， 函数左边的参数后入栈，位于栈的低地址。 </p>
<pre class="file">例子请看 “C难点的汇编解释”<br></pre>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">内核层实例解析</div>
</li>
</ul>
<p>内核层参数的传入： 混合使用寄存器和栈来传递参数。当参数个数不多于3个时，参数从左到右依次传递到%eax, %edx,
%ecx.当参数个数多于3时，从第4个起的其余参数通过栈传递。同样，函数右边的参数先入栈，位于栈的高地址。反之，
函数左边的参数后入栈，位于栈的低地址。 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">系统调用实例解析</div>
</li>
</ul>
<p>系统调用的参数传递：[以后再看] </p>
<pre class="file">C库函数<br>       ssize_t read(int fd, void *buf, size_t count);<br><br>000b6a30 &lt;__read&gt;:<br>   b6a30:       65 83 3d 0c 00 00 00    cmpl   $0x0,%gs:0xc<br>   b6a37:       00<br>   b6a38:       75 1d                   jne    b6a57 &lt;__read+0x27&gt;<br>   b6a3a:       53                      push   %ebx<br>   b6a3b:       8b 54 24 10             mov    0x10(%esp),%edx      //count<br>   b6a3f:       8b 4c 24 0c             mov    0xc(%esp),%ecx       //buf<br>   b6a43:       8b 5c 24 08             mov    0x8(%esp),%ebx       //fd<br>   b6a47:       b8 03 00 00 00          mov    $0x3,%eax            //系统调用号<br>   b6a4c:       cd 80                   int    $0x80<br>   b6a4e:       5b                      pop    %ebx<br>   b6a4f:       3d 01 f0 ff ff          cmp    $0xfffff001,%eax<br>   b6a54:       73 2d                   jae    b6a83 &lt;__read+0x53&gt;<br>   b6a56:       c3                      ret<br>   b6a57:       e8 14 ae 01 00          call   d1870 &lt;pthread_exit+0x110&gt;<br>   b6a5c:       50                      push   %eax<br>   b6a5d:       53                      push   %ebx<br>   b6a5e:       8b 54 24 14             mov    0x14(%esp),%edx<br>   b6a62:       8b 4c 24 10             mov    0x10(%esp),%ecx<br>   b6a66:       8b 5c 24 0c             mov    0xc(%esp),%ebx<br>   b6a6a:       b8 03 00 00 00          mov    $0x3,%eax<br>   b6a6f:       cd 80                   int    $0x80<br>   b6a71:       5b                      pop    %ebx<br>   b6a72:       87 04 24                xchg   %eax,(%esp)<br>   b6a75:       e8 c6 ad 01 00          call   d1840 &lt;pthread_exit+0xe0&gt;<br>   b6a7a:       58                      pop    %eax<br>   b6a7b:       3d 01 f0 ff ff          cmp    $0xfffff001,%eax<br>   b6a80:       73 01                   jae    b6a83 &lt;__read+0x53&gt;<br>   b6a82:       c3                      ret<br>   b6a83:       e8 8e 5a 04 00          call   fc516 &lt;__frame_state_for+0xb96&gt;<br>   b6a88:       81 c1 6c e5 07 00       add    $0x7e56c,%ecx<br>   b6a8e:       8b 89 e0 ff ff ff       mov    -0x20(%ecx),%ecx<br>   b6a94:       31 d2                   xor    %edx,%edx<br>   b6a96:       29 c2                   sub    %eax,%edx<br>   b6a98:       65 03 0d 00 00 00 00    add    %gs:0x0,%ecx<br>   b6a9f:       89 11                   mov    %edx,(%ecx)<br>   b6aa1:       83 c8 ff                or     $0xffffffff,%eax<br>   b6aa4:       eb dc                   jmp    b6a82 &lt;__read+0x52&gt;<br>   b6aa6:       90                      nop<br><br>调用号#define __NR_read		  3<br><br>(gdb) disass sys_read<br>Dump of assembler code for function sys_read:<br>0xc017585a &lt;sys_read+0&gt;:	push   %ebp<br>0xc017585b &lt;sys_read+1&gt;:	mov    %esp,%ebp<br>0xc017585d &lt;sys_read+3&gt;:	push   %esi<br>0xc017585e &lt;sys_read+4&gt;:	mov    $0xfffffff7,%esi<br>0xc0175863 &lt;sys_read+9&gt;:	push   %ebx<br>0xc0175864 &lt;sys_read+10&gt;:	sub    $0xc,%esp<br>0xc0175867 &lt;sys_read+13&gt;:	mov    0x8(%ebp),%eax<br>0xc017586a &lt;sys_read+16&gt;:	lea    -0xc(%ebp),%edx<br>0xc017586d &lt;sys_read+19&gt;:	call   0xc0175f65 &lt;fget_light&gt;<br>0xc0175872 &lt;sys_read+24&gt;:	test   %eax,%eax<br>0xc0175874 &lt;sys_read+26&gt;:	mov    %eax,%ebx<br>0xc0175876 &lt;sys_read+28&gt;:	je     0xc01758b1 &lt;sys_read+87&gt;<br>0xc0175878 &lt;sys_read+30&gt;:	mov    0x24(%ebx),%edx<br>0xc017587b &lt;sys_read+33&gt;:	mov    0x20(%eax),%eax<br>0xc017587e &lt;sys_read+36&gt;:	mov    0x10(%ebp),%ecx<br>0xc0175881 &lt;sys_read+39&gt;:	mov    %edx,-0x10(%ebp)<br>0xc0175884 &lt;sys_read+42&gt;:	mov    0xc(%ebp),%edx<br>0xc0175887 &lt;sys_read+45&gt;:	mov    %eax,-0x14(%ebp)<br>0xc017588a &lt;sys_read+48&gt;:	lea    -0x14(%ebp),%eax<br>0xc017588d &lt;sys_read+51&gt;:	push   %eax<br>0xc017588e &lt;sys_read+52&gt;:	mov    %ebx,%eax<br>0xc0175890 &lt;sys_read+54&gt;:	call   0xc01753c1 &lt;vfs_read&gt;<br>0xc0175895 &lt;sys_read+59&gt;:	mov    -0x10(%ebp),%edx<br>0xc0175898 &lt;sys_read+62&gt;:	mov    %eax,%esi<br>0xc017589a &lt;sys_read+64&gt;:	mov    -0x14(%ebp),%eax<br>0xc017589d &lt;sys_read+67&gt;:	mov    %edx,0x24(%ebx)<br>0xc01758a0 &lt;sys_read+70&gt;:	mov    %eax,0x20(%ebx)<br>0xc01758a3 &lt;sys_read+73&gt;:	cmpl   $0x0,-0xc(%ebp)<br>0xc01758a7 &lt;sys_read+77&gt;:	pop    %eax<br>0xc01758a8 &lt;sys_read+78&gt;:	je     0xc01758b1 &lt;sys_read+87&gt;<br>0xc01758aa &lt;sys_read+80&gt;:	mov    %ebx,%eax<br>0xc01758ac &lt;sys_read+82&gt;:	call   0xc0175eae &lt;fput&gt;<br>0xc01758b1 &lt;sys_read+87&gt;:	lea    -0x8(%ebp),%esp<br>0xc01758b4 &lt;sys_read+90&gt;:	mov    %esi,%eax<br>0xc01758b6 &lt;sys_read+92&gt;:	pop    %ebx<br>0xc01758b7 &lt;sys_read+93&gt;:	pop    %esi<br>0xc01758b8 &lt;sys_read+94&gt;:	pop    %ebp<br>0xc01758b9 &lt;sys_read+95&gt;:	ret    <br>End of assembler dump.<br>(gdb) list fget_light<br>313	 * holds a refcnt to that file. That check has to be done at fget() only<br>314	 * and a flag is returned to be passed to the corresponding fput_light().<br>315	 * There must not be a cloning between an fget_light/fput_light pair.<br>316	 */<br>317	struct file *fget_light(unsigned int fd, int *fput_needed)<br><br><br>来自2.6.11<br>378 #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4, \<br>379           type5,arg5,type6,arg6) \<br>380 type name (type1 arg1,type2 arg2,type3 arg3,type4 arg4,type5 arg5,type6 arg6) \<br>381 { \<br>382 long __res; \<br>383 __asm__ volatile ("push %%ebp ; movl %%eax,%%ebp ; movl %1,%%eax ; int $0x80 ; pop %%ebp" \<br>384         : "=a" (__res) \<br>385         : "i" (__NR_##name),"b" ((long)(arg1)),"c" ((long)(arg2)), \<br>386           "d" ((long)(arg3)),"S" ((long)(arg4)),"D" ((long)(arg5)), \<br>387           "0" ((long)(arg6))); \<br>388 __syscall_return(type,__res); \<br>389 }<br><br></pre>
</div>
<h4><a id="调用链回溯的代码实现" name="调用链回溯的代码实现">调用链回溯的代码实现</a></h4>
<div 
<div class="li" style="width:700px">
<p>内核中(x86)对调用链的回溯的代码实现在文件dumpstack_32.c文件中。主要函数是dump_trace和print_context_stack. </p>
<pre class="file">待解释<br></pre>
</div>
<h3><a id="c难点的汇编解释" name="c难点的汇编解释">C难点的汇编解释</a></h3>
<h4><a id="例1" name="例1">例1</a></h4>
<div 
<div class="li" style="width:700px">
<p>if ... else if </p>
<p>这个例子有人看来也许是非常非常地简单，但就这个例子，有的人还真给我考”倒”了。他的回话是“还真没见过这样子的代码”。但是，这样的代码在内核
中比比皆是,比如后面附上的函数代码 do_path_lookup。如果对if ... else if
理解有偏差，对内核代码的逻辑理解根本就是差以千里。 </p>
<pre class="file">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>        int i = 1;<br>        int j = 2;<br><br>        if (i == 1)<br>                printf("i,ok\n");<br>        else if (j == 2)<br>                printf("j,ok\n");<br><br>        return 0;<br>}<br></pre>
<p>这个例子，有人会疑问为什么”j,ok”没打印出来。现在我们分析下它的汇编代码 </p>
<pre class="file">08048374 &lt;main&gt;:<br> 8048374:       8d 4c 24 04             lea    0x4(%esp),%ecx<br> 8048378:       83 e4 f0                and    $0xfffffff0,%esp<br> 804837b:       ff 71 fc                pushl  -0x4(%ecx)<br> 804837e:       55                      push   %ebp<br> 804837f:       89 e5                   mov    %esp,%ebp           //以上汇编码保存旧栈帧信息，建立新栈帧<br> 8048381:       51                      push   %ecx                //%ecx入栈保护<br> 8048382:       83 ec 14                sub    $0x14,%esp          //建立本地变量栈空间，以及子函数实参栈空间<br> 8048385:       c7 45 f8 01 00 00 00    movl   $0x1,-0x8(%ebp)     //变量i赋值，记得本地变量的地址靠近栈帧的基地址，所以用%ebp引用<br> 804838c:       c7 45 f4 02 00 00 00    movl   $0x2,-0xc(%ebp)     //变量j赋值<br> 8048393:       83 7d f8 01             cmpl   $0x1,-0x8(%ebp)     //i和1比较<br> 8048397:       75 0e                   jne    80483a7 &lt;main+0x33&gt; //如果i-1不等0，跳到地址80483a7执行。否则继续执行下面指令<br> 8048399:       c7 04 24 90 84 04 08    movl   $0x8048490,(%esp)   //printf函数第一个参数入栈，它的栈空间之前已经建好。<br>                                                                   //记得子函数的实参空间靠近栈顶，所以引用实参用%esp<br> 80483a0:       e8 2f ff ff ff          call   80482d4 &lt;puts@plt&gt;  //调用printf<br> 80483a5:       eb 12                   jmp    80483b9 &lt;main+0x45&gt; //printf返回后，接着执行这个指令，将跳到地址80483b9继续运行<br> 80483a7:       83 7d f4 02             cmpl   $0x2,-0xc(%ebp)<br> 80483ab:       75 0c                   jne    80483b9 &lt;main+0x45&gt;<br> 80483ad:       c7 04 24 95 84 04 08    movl   $0x8048495,(%esp)<br> 80483b4:       e8 1b ff ff ff          call   80482d4 &lt;puts@plt&gt;   <br> 80483b9:       b8 00 00 00 00          mov    $0x0,%eax           //%eax赋值0,%eax放的也就是main函数返回结果<br> 80483be:       83 c4 14                add    $0x14,%esp          //撤销新栈帧的本地变量栈空间，以及子函数实参栈空间<br> 80483c1:       59                      pop    %ecx                //恢复保存的旧%ecx的值<br> 80483c2:       5d                      pop    %ebp                //以下汇编码都是恢复旧栈帧的信息,main函数返回等<br> 80483c3:       8d 61 fc                lea    -0x4(%ecx),%esp<br> 80483c6:       c3                      ret<br></pre>
<p>经过上面的汇编代码分析，可见c代码块 </p>
<pre class="file">        else if (j == 2)<br>                printf("j,ok\n");<br></pre>
<p>对应的汇编代码是： </p>
<pre class="file"> 80483a7:       83 7d f4 02             cmpl   $0x2,-0xc(%ebp)<br> 80483ab:       75 0c                   jne    80483b9 &lt;main+0x45&gt;<br> 80483ad:       c7 04 24 95 84 04 08    movl   $0x8048495,(%esp)<br> 80483b4:       e8 1b ff ff ff          call   80482d4 &lt;puts@plt&gt;   <br></pre>
<p>上面的代码指令根本就没有机会运行。 </p>
<p>结论，一个if ... else if ..else.. </p>
<pre class="file">if (判断语句1)<br>        代码块1<br>else if (判断语句2)<br>        代码块2;<br>else if ....<br><br>..<br>else 代码块N；<br><br></pre>
<p>语句块1,2..N的运行机会是一种互斥的关系。当然它们的“机会优先级”是不一样的。语句块1,2..N只有一个有被运行的机会，如果没有else甚至可能没有一个语句块能被运行。 </p>
<p>内核代码实例 </p>
<pre class="file">static int do_path_lookup(int dfd, const char *name,<br>				unsigned int flags, struct nameidata *nd)<br>{<br>	int retval = 0;<br>	int fput_needed;<br>	struct file *file;<br>	struct fs_struct *fs = current-&gt;fs;<br><br>	nd-&gt;last_type = LAST_ROOT; /* if there are only slashes... */<br>	nd-&gt;flags = flags;<br>	nd-&gt;depth = 0;<br><br>	if (*name=='/') {<br>		read_lock(&amp;fs-&gt;lock);<br>		if (fs-&gt;altroot.dentry &amp;&amp; !(nd-&gt;flags &amp; LOOKUP_NOALT)) {<br>			nd-&gt;path = fs-&gt;altroot;<br>			path_get(&amp;fs-&gt;altroot);<br>			read_unlock(&amp;fs-&gt;lock);<br>			if (__emul_lookup_dentry(name,nd))<br>				goto out; /* found in altroot */<br>			read_lock(&amp;fs-&gt;lock);<br>		}<br>		nd-&gt;path = fs-&gt;root;<br>		path_get(&amp;fs-&gt;root);<br>		read_unlock(&amp;fs-&gt;lock);<br>	} else if (dfd == AT_FDCWD) {<br>		read_lock(&amp;fs-&gt;lock);<br>		nd-&gt;path = fs-&gt;pwd;<br>		path_get(&amp;fs-&gt;pwd);<br>		read_unlock(&amp;fs-&gt;lock);<br>	} else {<br>		struct dentry *dentry;<br><br>		file = fget_light(dfd, &amp;fput_needed);<br>		retval = -EBADF;<br>		if (!file)<br>			goto out_fail;<br><br>		dentry = file-&gt;f_path.dentry;<br><br>		retval = -ENOTDIR;<br>		if (!S_ISDIR(dentry-&gt;d_inode-&gt;i_mode))<br><br><br><br><br><br>			goto fput_fail;<br><br>		retval = file_permission(file, MAY_EXEC);<br>		if (retval)<br>			goto fput_fail;<br><br>		nd-&gt;path = file-&gt;f_path;<br>		path_get(&amp;file-&gt;f_path);<br><br>		fput_light(file, fput_needed);<br>	}<br><br>	retval = path_walk(name, nd);<br>out:<br>	if (unlikely(!retval &amp;&amp; !audit_dummy_context() &amp;&amp; nd-&gt;path.dentry &amp;&amp;<br>				nd-&gt;path.dentry-&gt;d_inode))<br>		audit_inode(name, nd-&gt;path.dentry);<br>out_fail:<br>	return retval;<br><br>fput_fail:<br>	fput_light(file, fput_needed);<br>	goto out_fail;<br>}<br></pre>
</div>
<h4><a id="例2" name="例2">例2</a></h4>
<div 
<div class="li" style="width:700px">
<p>短路逻辑算法。 </p>
<p>这样的例子在内核代码中也是非常地多，一般用在短的函数或宏中。 </p>
<pre class="file">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>        int a = 1;<br>        int b = 2;<br><br>        if (a || ++b)<br>                printf("%d\n", b);<br><br>        return 0;<br>}<br><br></pre>
<p>这个例子，有人会疑问为什么b的值没有变化，还是为2。现在我们分析下它的汇编代码 </p>
<pre class="file">08048374 &lt;main&gt;:<br> 8048374:       8d 4c 24 04             lea    0x4(%esp),%ecx<br> 8048378:       83 e4 f0                and    $0xfffffff0,%esp<br> 804837b:       ff 71 fc                pushl  -0x4(%ecx)<br> 804837e:       55                      push   %ebp<br> 804837f:       89 e5                   mov    %esp,%ebp            //以上汇编码保存旧栈帧信息，建立新栈帧<br> 8048381:       51                      push   %ecx                 //%ecx入栈保护 <br> 8048382:       83 ec 24                sub    $0x24,%esp           //创建本地变量和子函数实参的栈空间(实际上没全部使用到)<br> 8048385:       c7 45 f8 01 00 00 00    movl   $0x1,-0x8(%ebp)      //变量a赋值，记得本地变量的地址靠近栈帧的基地址，所以用%ebp引用   <br> 804838c:       c7 45 f4 02 00 00 00    movl   $0x2,-0xc(%ebp)      //变量b赋值<br> 8048393:       83 7d f8 00             cmpl   $0x0,-0x8(%ebp)      //变量a和0比较，其实就是判断“表达式 a”是不是为假<br> 8048397:       75 0a                   jne    80483a3 &lt;main+0x2f&gt;  //a-0如果不等0，也就是a为真时就跳到地址80483a3执行。<br>                                                                    //已经知道a==1,表达式a为真，所以将跳到地址80483a3执行<br> 8048399:       83 45 f4 01             addl   $0x1,-0xc(%ebp)<br> 804839d:       83 7d f4 00             cmpl   $0x0,-0xc(%ebp)<br> 80483a1:       74 13                   je     80483b6 &lt;main+0x42&gt;<br> 80483a3:       8b 45 f4                mov    -0xc(%ebp),%eax      //把变量b的值放到临时寄存器%eax<br> 80483a6:       89 44 24 04             mov    %eax,0x4(%esp)       //接着把它作为printf函数第二个实参入栈,<br>                                                                    //记得子函数的实参空间靠近栈顶，所以引用实参用%esp<br> 80483aa:       c7 04 24 90 84 04 08    movl   $0x8048490,(%esp)    //printf函数第一个实参入栈。记得X86下用户层的子函数参数<br>                                                                    //是保存到栈的，而且是从右到左依次入栈   <br> 80483b1:       e8 22 ff ff ff          call   80482d8 &lt;printf@plt&gt; //调用printf函数<br> 80483b6:       b8 00 00 00 00          mov    $0x0,%eax            //%eax赋值0,%eax放的也就是main函数返回结果<br> 80483bb:       83 c4 24                add    $0x24,%esp           //撤销新栈帧的本地变量栈空间，以及子函数实参栈空间<br> 80483be:       59                      pop    %ecx                 //恢复保存的旧%ecx的值 <br> 80483bf:       5d                      pop    %ebp                 //以下汇编码都是恢复旧栈帧的信息，main函数返回等<br> 80483c0:       8d 61 fc                lea    -0x4(%ecx),%esp<br> 80483c3:       c3                      ret<br><br></pre>
<p>分析可见C语句 if (a || ++b)中的++b对应的汇编码是 </p>
<pre class="file"> 8048399:       83 45 f4 01             addl   $0x1,-0xc(%ebp)<br> 804839d:       83 7d f4 00             cmpl   $0x0,-0xc(%ebp)<br> 80483a1:       74 13                   je     80483b6 &lt;main+0x42&gt;<br></pre>
<p>可是因为a==1,表达式a已经为真，++b这个语句，也就是上面的汇编码，根本就没运行。所以变量b的值没有自增，还是保持为2。 </p>
<p>结论 </p>
<pre class="file">表达式 a, b<br>a || b: 如果a为真,b就不管;如果运行到b,a必已是假<br>a &amp;&amp; b: 如果a为假,b就不管;如果运行到b,a必已是真<br></pre>
<p>内核代码实例 </p>
<pre class="file">static struct char_device_struct *<br>__register_chrdev_region(unsigned int major, unsigned int baseminor,<br>			   int minorct, const char *name)<br>{<br>......<br><br>	i = major_to_index(major);<br><br>	for (cp = &amp;chrdevs[i]; *cp; cp = &amp;(*cp)-&gt;next)<br>		if ((*cp)-&gt;major &gt; major ||<br>		    ((*cp)-&gt;major == major &amp;&amp;<br>		     (((*cp)-&gt;baseminor &gt;= baseminor) ||<br>		      ((*cp)-&gt;baseminor + (*cp)-&gt;minorct &gt; baseminor))))<br>			break;<br><br>.....<br>}<br></pre>
</div>
<h4><a id="例3" name="例3">例3</a></h4>
<div 
<div class="li" style="width:700px">
<p>自增自减 </p>
<p>自增自减，以及增减的前后问题。这类代码在内核数不胜数。理解稍有偏差，就会产生“边界问题”，或者在条件判断时理解出错。 </p>
<pre class="file">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>        int i = -1;<br>        if (!i++) {<br>                printf("inner: %d\n", i);<br>        }<br>        printf("outer: %d\n", i);<br><br>        return 0;<br>}<br><br></pre>
<p>汇编代码 </p>
<pre class="file">08048374 &lt;main&gt;:<br> 8048374:       8d 4c 24 04             lea    0x4(%esp),%ecx<br> 8048378:       83 e4 f0                and    $0xfffffff0,%esp<br> 804837b:       ff 71 fc                pushl  -0x4(%ecx)<br> 804837e:       55                      push   %ebp<br> 804837f:       89 e5                   mov    %esp,%ebp<br> 8048381:       51                      push   %ecx<br> 8048382:       83 ec 24                sub    $0x24,%esp<br> 8048385:       c7 45 f8 ff ff ff ff    movl   $0xffffffff,-0x8(%ebp)<br> 804838c:       83 45 f8 01             addl   $0x1,-0x8(%ebp)<br> 8048390:       83 7d f8 01             cmpl   $0x1,-0x8(%ebp)<br> 8048394:       75 13                   jne    80483a9 &lt;main+0x35&gt;<br> 8048396:       8b 45 f8                mov    -0x8(%ebp),%eax<br> 8048399:       89 44 24 04             mov    %eax,0x4(%esp)<br> 804839d:       c7 04 24 90 84 04 08    movl   $0x8048490,(%esp)<br> 80483a4:       e8 2f ff ff ff          call   80482d8 &lt;printf@plt&gt;<br> 80483a9:       8b 45 f8                mov    -0x8(%ebp),%eax<br> 80483ac:       89 44 24 04             mov    %eax,0x4(%esp)<br> 80483b0:       c7 04 24 9b 84 04 08    movl   $0x804849b,(%esp)<br> 80483b7:       e8 1c ff ff ff          call   80482d8 &lt;printf@plt&gt;<br> 80483bc:       b8 00 00 00 00          mov    $0x0,%eax<br> 80483c1:       83 c4 24                add    $0x24,%esp<br> 80483c4:       59                      pop    %ecx<br> 80483c5:       5d                      pop    %ebp<br> 80483c6:       8d 61 fc                lea    -0x4(%ecx),%esp<br> 80483c9:       c3                      ret<br> 80483ca:       90                      nop<br><br></pre>
<p>内核代码实例 </p>
<pre class="file">int platform_add_devices(struct platform_device **devs, int num)<br><br>{<br>	int i, ret = 0;<br><br>	for (i = 0; i &lt; num; i++) {<br>		ret = platform_device_register(devs[i]);<br>		if (ret) {<br>			while (--i &gt;= 0)  /*没错，devs[i]没注册成功的话，从devs[i-1]起反注册*/<br>				platform_device_unregister(devs[i]);<br>			break;<br>		}<br>	}<br><br>	return ret;<br>}<br></pre>
</div>
<h4><a id="例14" name="例14">例14</a></h4>
<div 
<div class="li" style="width:700px">
<p>函数指针 </p>
<p>解释在“穿越交叉索引工具的盲区”→函数指针 </p>
<pre class="file">#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>        int myfunc(int a, int b)<br>        {<br>                int c = a + b;<br>                printf("%d\n", c);<br>                return 0;<br>        }<br>        int (*funa)(int, int) = myfunc;<br>        int (*funb)(int, int) = &amp;myfunc;<br>        int (*func)(int, int) = (int (*)(int, int))myfunc;<br>        int (*fund)(int, int) = (int (*)(int, int))(&amp;myfunc);<br><br>        myfunc(1, 2);<br>        funa(3, 4);<br>        funb(5, 6);<br>        func(7, 8);<br>        fund(9, 10);<br><br>        return 0;<br>}<br><br>编译：<br>$ gcc -g -Wall fuk.c //注意，没任何警告<br><br>int main()<br>{<br> 8048374:       8d 4c 24 04             lea    0x4(%esp),%ecx<br>....省略<br>        int (*funa)(int, int) = myfunc;<br> 8048385:       c7 45 f8 13 84 04 08    movl   $0x8048413,-0x8(%ebp)<br>        int (*funb)(int, int) = &amp;myfunc;<br> 804838c:       c7 45 f4 13 84 04 08    movl   $0x8048413,-0xc(%ebp)<br>        int (*func)(int, int) = (int (*)(int, int))myfunc;<br> 8048393:       c7 45 f0 13 84 04 08    movl   $0x8048413,-0x10(%ebp)<br>        int (*fund)(int, int) = (int (*)(int, int))(&amp;myfunc);<br> 804839a:       c7 45 ec 13 84 04 08    movl   $0x8048413,-0x14(%ebp)<br><br>        myfunc(1, 2);<br>...省略<br>        funa(3, 4);<br> 80483b5:       c7 44 24 04 04 00 00    movl   $0x4,0x4(%esp)<br> 80483bc:       00<br> 80483bd:       c7 04 24 03 00 00 00    movl   $0x3,(%esp)<br> 80483c4:       8b 45 f8                mov    -0x8(%ebp),%eax<br> 80483c7:       ff d0                   call   *%eax<br>        funb(5, 6);<br>....省略，funb, func,fund汇编码和funa完全相同<br><br>        return 0;<br> 8048405:       b8 00 00 00 00          mov    $0x0,%eax<br>}<br> 804840a:       83 c4 24                add    $0x24,%esp<br>...省略<br><br>08048413 &lt;myfunc.1933&gt;:<br>#include &lt;stdio.h&gt;<br>int main()<br>{<br>        int myfunc(int a, int b)<br>        {<br> 8048413:       55                      push   %ebp<br>.....省略<br>        }<br><br><br>xxx@ubuntu:~/dt/test$ gdb a.out<br>GNU gdb 6.8-debian<br>...<br>(gdb) list<br>1	#include &lt;stdio.h&gt;<br><br>......<br>17		funa(3, 4);<br>....<br>20		<br>(gdb) b 17<br>(gdb) r<br>Starting program: /home/xxx/桌面/test/a.out<br>Breakpoint 1, main () at fuck.c:17<br>17		funa(3, 4);<br>(gdb) display/i $pc<br>1: x/i $pc<br>0x80483b5 &lt;main+65&gt;:	movl   $0x4,0x4(%esp)<br>(gdb) stepi<br>0x080483bd	17		funa(3, 4);<br>1: x/i $pc<br>0x80483bd &lt;main+73&gt;:	movl   $0x3,(%esp)<br>(gdb) <br>0x080483c4	17		funa(3, 4);<br>1: x/i $pc<br>0x80483c4 &lt;main+80&gt;:	mov    -0x8(%ebp),%eax<br>(gdb) <br>0x080483c7	17		funa(3, 4);<br>1: x/i $pc<br>0x80483c7 &lt;main+83&gt;:	call   *%eax<br>(gdb) p/x $eax<br>$4 = 0x8048413<br>(gdb) info line  *0x8048413<br>Line 6 of "fuck.c" starts at address 0x8048413 &lt;myfunc&gt; and ends at 0x8048419 &lt;myfunc+6&gt;.<br>(gdb) <br><br><br></pre>
</div>
<h3><a id="优化级别的影响" name="优化级别的影响">优化级别的影响</a></h3>
<div 
<div class="li" style="width:700px">
<p>这部分内容有点偏题，没必要这么钻牛角尖。但是为了说明“调试用的代码和实际运行的代码是不一样”的这个事实以及因为代码优化导致的“非理想状态”的调用链问题(见“内核初窥”)，有必要用观察一个实例，以便有个直观的印象。 </p>
<p>首先应该知道，有没有指定调试选项-g(–debug)，在相同优先级下生成的代码都是一样的。差别只是，指定-g后，多生成了一个调试表。 </p>
</div>
<h4><a id="优化选项" name="优化选项">优化选项</a></h4>
<div 
<div class="li" style="width:700px">
<p>下面文字来自“ARM 系列应用技术完全手册” </p>
<p>使用-Onum选择编译器的优化级别。优化级别分别有 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">-O0: 除一些简单的代码编号外，关闭所有优化，该选项可提供最直接的优化信息。</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">-O1: 关闭严重影响调试效果的优化功能。使用该编译选项，编译器会移除程序中未使用到的内联函数和静态函数。如果于–debug(也就是-g)一起使用，该选项可以在较好的代码密度下，给出最佳调试视图。</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">-O2: 生成充分优化代码。如果与–debug一起使用，调试效果可能不令人满意，因为对目标代码到源代码的映射可能因为代码优化而发生变化。如果不生成调试表，这是默认优化级别。</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">-O3: 最高优化级别。使用该优化级别，使生成的代码在时间和空间上寻求平衡。 </div>
</li>
</ul>
</div>
<h4><a id="例子" name="例子">例子</a></h4>
<div 
<pre class="f style="width:700px">
<pre class="file">#include &lt;stdio.h&gt;<br><br><br>int add(int a, int b)<br>{<br>	return (a + b);<br>}<br><br><br>void funa()<br>{<br>	int a = 3 + 4;<br>	int b;<br>	printf("%d\n", a);<br>        b = add(5,6);<br>	printf("%d\n", b);<br>}<br><br>int main()<br>{<br>	int m = 1 + 2;<br>	printf("%d\n", m);<br>        funa();<br>}<br><br></pre>
<pre class="file">$ gcc -g -O0 src.c (或者不指定优化选项： gcc -g src.c，编译出的机器码一样)<br>$ objdump -d a.out<br><br>得到一个结论：如果指定了-g而没指定优化等级，那么默认优化等级是最低的-O0<br><br>08048374 &lt;add&gt;:<br> 8048374:	55                   	push   %ebp<br> 8048375:	89 e5                	mov    %esp,%ebp<br> 8048377:	8b 45 0c             	mov    0xc(%ebp),%eax<br> 804837a:	03 45 08             	add    0x8(%ebp),%eax<br> 804837d:	5d                   	pop    %ebp<br> 804837e:	c3                   	ret    <br><br>0804837f &lt;funa&gt;:<br> 804837f:	55                   	push   %ebp<br> 8048380:	89 e5                	mov    %esp,%ebp		//保存旧栈帧，建立新栈帧<br> 8048382:	83 ec 18             	sub    $0x18,%esp        	//分配栈帧空间，注意分配了$0x18<br> 8048385:	c7 45 fc 07 00 00 00 	movl   $0x7,-0x4(%ebp)		//-0x4(%ebp)是本地变量a的地址，int a = 3 + 4;<br>                                                                        //注意编译器已经完成了计算<br> 804838c:	8b 45 fc             	mov    -0x4(%ebp),%eax		//a放到临时寄存器%eax<br> 804838f:	89 44 24 04          	mov    %eax,0x4(%esp)		//接着作为printf第二个参数入栈<br> 8048393:	c7 04 24 d0 84 04 08 	movl   $0x80484d0,(%esp)	//printf第一个参数入栈<br> 804839a:	e8 39 ff ff ff       	call   80482d8 &lt;printf@plt&gt;	//printf("%d\n", a);<br> 804839f:	c7 44 24 04 06 00 00 	movl   $0x6,0x4(%esp)		//add(5,6);第二个参数入栈<br> 80483a6:	00 <br> 80483a7:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)		//add(5,6);第一个参数入栈<br> 80483ae:	e8 c1 ff ff ff       	call   8048374 &lt;add&gt;		//调用add<br> 80483b3:	89 45 f8             	mov    %eax,-0x8(%ebp)		//-0x8(%ebp)是本地变量b的地址，b = add(5,6);<br> 80483b6:	8b 45 f8             	mov    -0x8(%ebp),%eax		//b放到临时寄存器%eax<br> 80483b9:	89 44 24 04          	mov    %eax,0x4(%esp)		//接着作为printf第二个参数入栈<br> 80483bd:	c7 04 24 d0 84 04 08 	movl   $0x80484d0,(%esp)	//printf第一个参数入栈<br> 80483c4:	e8 0f ff ff ff       	call   80482d8 &lt;printf@plt&gt;	//printf("%d\n", b);<br> 80483c9:	c9                   	leave  				//撤销新栈帧空间<br> 80483ca:	c3                   	ret    				//funa返回<br><br>080483cb &lt;main&gt;:<br> 80483cb:	8d 4c 24 04          	lea    0x4(%esp),%ecx<br> 80483cf:	83 e4 f0             	and    $0xfffffff0,%esp<br> 80483d2:	ff 71 fc             	pushl  -0x4(%ecx)<br> 80483d5:	55                   	push   %ebp<br> 80483d6:	89 e5                	mov    %esp,%ebp<br> 80483d8:	51                   	push   %ecx<br> 80483d9:	83 ec 24             	sub    $0x24,%esp<br> 80483dc:	c7 45 f8 03 00 00 00 	movl   $0x3,-0x8(%ebp)<br> 80483e3:	8b 45 f8             	mov    -0x8(%ebp),%eax<br> 80483e6:	89 44 24 04          	mov    %eax,0x4(%esp)<br> 80483ea:	c7 04 24 d0 84 04 08 	movl   $0x80484d0,(%esp)<br> 80483f1:	e8 e2 fe ff ff       	call   80482d8 &lt;printf@plt&gt;<br> 80483f6:	e8 84 ff ff ff       	call   804837f &lt;funa&gt;<br> 80483fb:	83 c4 24             	add    $0x24,%esp<br> 80483fe:	59                   	pop    %ecx<br> 80483ff:	5d                   	pop    %ebp<br> 8048400:	8d 61 fc             	lea    -0x4(%ecx),%esp<br> 8048403:	c3                   	ret    <br></pre>
<pre class="file">$ gcc -g -O1 src.c<br>$ objdump -d a.out<br><br><br>08048374 &lt;add&gt;:<br> 8048374:	55                   	push   %ebp<br> 8048375:	89 e5                	mov    %esp,%ebp<br> 8048377:	8b 45 0c             	mov    0xc(%ebp),%eax<br> 804837a:	03 45 08             	add    0x8(%ebp),%eax<br> 804837d:	5d                   	pop    %ebp<br> 804837e:	c3                   	ret    <br><br>0804837f &lt;funa&gt;:							//funa与-O0相比，没有了向本地变量a,b赋值的过程。<br>                                                                        //代码量少了，分配的栈帧空间也小了。<br> 804837f:	55                   	push   %ebp<br> 8048380:	89 e5                	mov    %esp,%ebp<br> 8048382:	83 ec 08             	sub    $0x8,%esp        	//分配栈帧空间，注意分配了$0x8，比－O0下小了<br> 8048385:	c7 44 24 04 07 00 00 	movl   $0x7,0x4(%esp)		//printf("%d\n", a);的第二个参数入栈。<br>                                                                        //注意，与-O0相比，没有向本地变量a赋值的过程。<br> 804838c:	00 <br> 804838d:	c7 04 24 c0 84 04 08 	movl   $0x80484c0,(%esp)<br> 8048394:	e8 3f ff ff ff       	call   80482d8 &lt;printf@plt&gt;	//printf("%d\n", a);<br> 8048399:	c7 44 24 04 06 00 00 	movl   $0x6,0x4(%esp)<br> 80483a0:	00 <br> 80483a1:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)<br> 80483a8:	e8 c7 ff ff ff       	call   8048374 &lt;add&gt;		//add(5,6);<br> 80483ad:	89 44 24 04          	mov    %eax,0x4(%esp)		//add的返回结果作为printf("%d\n", b);的第二个参数入栈。<br>                                                                        //注意，与-O0相比，没有向本地变量b赋值的过程。<br> 80483b1:	c7 04 24 c0 84 04 08 	movl   $0x80484c0,(%esp)<br> 80483b8:	e8 1b ff ff ff       	call   80482d8 &lt;printf@plt&gt;	//printf("%d\n", b);<br> 80483bd:	c9                   	leave  <br> 80483be:	c3                   	ret    <br><br>080483bf &lt;main&gt;:<br> 80483bf:	8d 4c 24 04          	lea    0x4(%esp),%ecx<br> 80483c3:	83 e4 f0             	and    $0xfffffff0,%esp<br> 80483c6:	ff 71 fc             	pushl  -0x4(%ecx)<br> 80483c9:	55                   	push   %ebp<br> 80483ca:	89 e5                	mov    %esp,%ebp<br> 80483cc:	51                   	push   %ecx<br> 80483cd:	83 ec 14             	sub    $0x14,%esp<br> 80483d0:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)<br> 80483d7:	00 <br> 80483d8:	c7 04 24 c0 84 04 08 	movl   $0x80484c0,(%esp)<br> 80483df:	e8 f4 fe ff ff       	call   80482d8 &lt;printf@plt&gt;<br> 80483e4:	e8 96 ff ff ff       	call   804837f &lt;funa&gt;<br> 80483e9:	83 c4 14             	add    $0x14,%esp<br> 80483ec:	59                   	pop    %ecx<br> 80483ed:	5d                   	pop    %ebp<br> 80483ee:	8d 61 fc             	lea    -0x4(%ecx),%esp<br> 80483f1:	c3                   	ret    <br></pre>
<pre class="file">$ gcc -g -O2 src.c<br>$ objdump -d a.out<br><br>我们应该知道，如果没有指定-g和优化选项，那么默认的优化等级就是-O2<br><br><br>08048380 &lt;add&gt;:<br> 8048380:	55                   	push   %ebp<br> 8048381:	89 e5                	mov    %esp,%ebp<br> 8048383:	8b 45 0c             	mov    0xc(%ebp),%eax<br> 8048386:	03 45 08             	add    0x8(%ebp),%eax<br> 8048389:	5d                   	pop    %ebp<br> 804838a:	c3                   	ret    <br> 804838b:	90                   	nop    <br> 804838c:	8d 74 26 00          	lea    0x0(%esi),%esi<br><br>08048390 &lt;funa&gt;:<br> 8048390:	55                   	push   %ebp<br> 8048391:	89 e5                	mov    %esp,%ebp<br> 8048393:	83 ec 08             	sub    $0x8,%esp<br> 8048396:	c7 44 24 04 07 00 00 	movl   $0x7,0x4(%esp)<br> 804839d:	00 <br> 804839e:	c7 04 24 d0 84 04 08 	movl   $0x80484d0,(%esp)<br> 80483a5:	e8 2e ff ff ff       	call   80482d8 &lt;printf@plt&gt;<br> 80483aa:	c7 44 24 04 06 00 00 	movl   $0x6,0x4(%esp)<br> 80483b1:	00 <br> 80483b2:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)<br> 80483b9:	e8 c2 ff ff ff       	call   8048380 &lt;add&gt;<br> 80483be:	c7 04 24 d0 84 04 08 	movl   $0x80484d0,(%esp)	//第二个参数入栈<br> 80483c5:	89 44 24 04          	mov    %eax,0x4(%esp)		//第一个参数入栈。注意和-O1相比，参数在栈帧空间的位置没变，<br>                                                                        //但是入栈指令的执行顺序有变。<br> 80483c9:	e8 0a ff ff ff       	call   80482d8 &lt;printf@plt&gt;	//printf("%d\n", b);<br> 80483ce:	c9                   	leave  <br> 80483cf:	c3                   	ret    <br><br>080483d0 &lt;main&gt;:<br> 80483d0:	8d 4c 24 04          	lea    0x4(%esp),%ecx<br> 80483d4:	83 e4 f0             	and    $0xfffffff0,%esp<br> 80483d7:	ff 71 fc             	pushl  -0x4(%ecx)<br> 80483da:	55                   	push   %ebp<br> 80483db:	89 e5                	mov    %esp,%ebp<br> 80483dd:	51                   	push   %ecx<br> 80483de:	83 ec 14             	sub    $0x14,%esp<br> 80483e1:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)<br> 80483e8:	00 <br> 80483e9:	c7 04 24 d0 84 04 08 	movl   $0x80484d0,(%esp)<br> 80483f0:	e8 e3 fe ff ff       	call   80482d8 &lt;printf@plt&gt;<br> 80483f5:	e8 96 ff ff ff       	call   8048390 &lt;funa&gt;<br> 80483fa:	83 c4 14             	add    $0x14,%esp<br> 80483fd:	59                   	pop    %ecx<br> 80483fe:	5d                   	pop    %ebp<br> 80483ff:	8d 61 fc             	lea    -0x4(%ecx),%esp<br><br><br><br> 8048402:	c3                   	ret   <br></pre>
<pre class="file">$ gcc -g -O3 src.c<br>$ objdump -d a.out<br><br><br>048380 &lt;add&gt;:<br> 8048380:	55                   	push   %ebp<br> 8048381:	89 e5                	mov    %esp,%ebp<br> 8048383:	8b 45 0c             	mov    0xc(%ebp),%eax<br> 8048386:	03 45 08             	add    0x8(%ebp),%eax<br> 8048389:	5d                   	pop    %ebp<br> 804838a:	c3                   	ret    <br> 804838b:	90                   	nop    <br> 804838c:	8d 74 26 00          	lea    0x0(%esi),%esi<br><br>08048390 &lt;funa&gt;:							//与-O2相比，对函数add()的调用被编译器优化消失<br> 8048390:	55                   	push   %ebp<br> 8048391:	89 e5                	mov    %esp,%ebp<br> 8048393:	83 ec 08             	sub    $0x8,%esp<br> 8048396:	c7 44 24 04 07 00 00 	movl   $0x7,0x4(%esp)<br> 804839d:	00 <br> 804839e:	c7 04 24 e0 84 04 08 	movl   $0x80484e0,(%esp)<br> 80483a5:	e8 2e ff ff ff       	call   80482d8 &lt;printf@plt&gt;<br> 80483aa:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)		//注意，与-O2相比，b = add(5,6);被优化掉了。<br>                                                                        //之前应该有个优化为内联函数的过程，但因为add函数<br>                                                                        //太简单，被直接计算了结果。(猜想)<br>                                                                        //编译器直接计算出它的结果$0xb,也就是11<br> 80483b1:	00 <br> 80483b2:	c7 04 24 e0 84 04 08 	movl   $0x80484e0,(%esp)<br> 80483b9:	e8 1a ff ff ff       	call   80482d8 &lt;printf@plt&gt;	//printf("%d\n", b);<br> 80483be:	c9                   	leave  <br> 80483bf:	c3                   	ret    <br><br>080483c0 &lt;main&gt;:<br> 80483c0:	8d 4c 24 04          	lea    0x4(%esp),%ecx<br> 80483c4:	83 e4 f0             	and    $0xfffffff0,%esp<br> 80483c7:	ff 71 fc             	pushl  -0x4(%ecx)<br> 80483ca:	55                   	push   %ebp<br> 80483cb:	89 e5                	mov    %esp,%ebp<br> 80483cd:	51                   	push   %ecx<br> 80483ce:	83 ec 14             	sub    $0x14,%esp<br> 80483d1:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)<br> 80483d8:	00 <br> 80483d9:	c7 04 24 e0 84 04 08 	movl   $0x80484e0,(%esp)<br> 80483e0:	e8 f3 fe ff ff       	call   80482d8 &lt;printf@plt&gt;<br> 80483e5:	c7 44 24 04 07 00 00 	movl   $0x7,0x4(%esp)<br> 80483ec:	00 <br> 80483ed:	c7 04 24 e0 84 04 08 	movl   $0x80484e0,(%esp)<br> 80483f4:	e8 df fe ff ff       	call   80482d8 &lt;printf@plt&gt;<br> 80483f9:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)<br> 8048400:	00 <br> 8048401:	c7 04 24 e0 84 04 08 	movl   $0x80484e0,(%esp)<br> 8048408:	e8 cb fe ff ff       	call   80482d8 &lt;printf@plt&gt;<br> 804840d:	83 c4 14             	add    $0x14,%esp<br> 8048410:	59                   	pop    %ecx<br> 8048411:	5d                   	pop    %ebp<br> 8048412:	8d 61 fc             	lea    -0x4(%ecx),%esp<br> 8048415:	c3                   	ret    <br></pre>
</div>
<h2><a id="汇编基础--arm篇" name="汇编基础--arm篇">汇编基础--ARM篇</a></h2>
<div 
<div class="li" style="width:700px">
<p>说明： </p>
<p>1. 部分内容和X86的重复，重复部分请参考X86的内容。 </p>
<p>2. 某些内容不具备普遍性。比如给出的反汇编代码，在不同的优化等级下是不同的。但是在熟悉了典型的函数调用链反汇编代码，对于有变化的其他形式也就不难理解了。 </p>
</div>
<h3><a id="用户手册1" name="用户手册1">用户手册</a></h3>
<div 
<div class="li" style="width:700px">
<p>ARM7TDMI Technical Reference Manual </p>
<p>ARM920T Technical Reference Manual </p>
<p><a class="urlextern" title="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.home/index.html" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.home/index.html" rel="nofollow"><u><font color="#0000ff">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.home/index.html</font></u></a> </p>
<p>指令速查 <a class="urlextern" title="http://www.arm.com/pdfs/QRC0001H_rvct_v2.1_arm.pdf" href="http://www.arm.com/pdfs/QRC0001H_rvct_v2.1_arm.pdf" rel="nofollow"><u><font color="#0000ff">http://www.arm.com/pdfs/QRC0001H_rvct_v2.1_arm.pdf</font></u></a> </p>
</div>
<h3><a id="调用链形成和参数传递1" name="调用链形成和参数传递1">调用链形成和参数传递</a></h3>
<div 
<div class="li" style="width:700px">
<p>注意：arm体系过程调用的文字说明部分，都是依据AAPCS标准。 </p>
</div>
<h4><a id="壮观的标准" name="壮观的标准">壮观的标准</a></h4>
<div 
<div class="li" style="width:700px">
<p>参考： </p>
<p>AAPCS </p>
<p>Procedure Call Standard for the ARM Architecture </p>
<p><a class="urlextern" title="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042b/IHI0042B_aapcs.pdf" href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042b/IHI0042B_aapcs.pdf" rel="nofollow"><u><font color="#0000ff">http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042b/IHI0042B_aapcs.pdf</font></u></a> </p>
<p>终于在“ARM Procedure Call Standard”中找到了答案 </p>
<pre class="file">PCS      Procedure Call Standard.<br>AAPCS    Procedure Call Standard for the ARM Architecture (this standard).<br>APCS     ARM Procedure Call Standard (obsolete).<br>TPCS     Thumb Procedure Call Standard (obsolete).<br>ATPCS    ARM-Thumb Procedure Call Standard (precursor to this standard).<br>PIC, PID Position-independent code, position-independent data.<br></pre>
<p>下面的标准已过时 </p>
<p>APCS </p>
<p>ARM Procedure Call Standard <a class="urlextern" title="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/BGBGFIDA.html" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/BGBGFIDA.html" rel="nofollow"><u><font color="#0000ff">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/BGBGFIDA.html</font></u></a> </p>
<p>Using the ARM Procedure Call Standard <a class="urlextern" title="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0040d/Chdbceig.html" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0040d/Chdbceig.html" rel="nofollow"><u><font color="#0000ff">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0040d/Chdbceig.html</font></u></a> </p>
<p>APCS 简介<a class="urlextern" title="http://www.bsdmap.com/UNIX_html/ARM/apcsintro.html#01" href="http://www.bsdmap.com/UNIX_html/ARM/apcsintro.html#01" rel="nofollow"><u><font color="#0000ff">http://www.bsdmap.com/UNIX_html/ARM/apcsintro.html#01</font></u></a> </p>
<p>TPCS </p>
<p>Thumb Procedure Call Standard <a class="urlextern" title="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/BCEEAHAF.html" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/BCEEAHAF.html" rel="nofollow"><u><font color="#0000ff">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0041c/BCEEAHAF.html</font></u></a> </p>
<p>Using the Thumb Procedure Call Standard <a class="urlextern" title="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0040d/Cihdbchi.html" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0040d/Cihdbchi.html" rel="nofollow"><u><font color="#0000ff">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0040d/Cihdbchi.html</font></u></a> </p>
<p>ATPCS </p>
<p>About the ARM-Thumb Procedure Call Standard <a class="urlextern" title="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcffcieh.html" href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcffcieh.html" rel="nofollow"><u><font color="#0000ff">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0056d/Bcffcieh.html</font></u></a> </p>
</div>
<h4><a id="别名的烦恼" name="别名的烦恼">别名的烦恼</a></h4>
<div 
<div class="li" style="width:700px">
<p>arm体系的函数调用标准换了好几个版本，对寄存器的别名也是不一样。不同的调试器，或者它在不同的选项下，对同一个寄存器可能就有多种称呼。又或者你在调试器下看到的名称和书籍上的不一样。所以，又必要知道这些寄存器各自都有哪些别名。 </p>
<p>我们运行下命令 </p>
<pre class="file">$ arm-linux-gnueabi-objdump --help<br>....省略<br>The following ARM specific disassembler options are supported for use with<br>the -M switch:<br>  reg-names-special-atpcs  Select special register names used in the ATPCS<br>  reg-names-atpcs          Select register names used in the ATPCS<br>  reg-names-apcs           Select register names used in the APCS<br>  reg-names-std            Select register names used in ARM's ISA documentation<br>  reg-names-gcc            Select register names used by GCC<br>  reg-names-raw            Select raw register names<br>  force-thumb              Assume all insns are Thumb insns<br>  no-force-thumb           Examine preceeding label to determine an insn's type<br></pre>
<p>我们下载它的源码打开看看 </p>
<p>$ sudo apt-get source binutils-arm-linux-gnueabi </p>
<p>完成后，在下载目录下多了几个东东，其中有一个文件夹binutils-2.18.1~cvs20080103，这是debian对官方binutils进行过修改的源码。在里面搜索文件arm-dis.c，该文件中有以下这个数组。 </p>
<p>就是不同标准下各个寄存器的不同别名。 </p>
<pre class="file">static const arm_regname regnames[] =<br>{<br>  { "raw" , "Select raw register names",<br>    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"}},<br>  { "gcc",  "Select register names used by GCC",<br>    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},<br>  { "std",  "Select register names used in ARM's ISA documentation",<br>    { "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "r8", "r9", "r10", "r11", "r12", "sp",  "lr",  "pc" }},<br>  { "apcs", "Select register names used in the APCS",<br>    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "sl",  "fp",  "ip",  "sp",  "lr",  "pc" }},<br>  { "atpcs", "Select register names used in the ATPCS",<br>    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "v4", "v5", "v6", "v7",  "v8",  "IP",  "SP",  "LR",  "PC" }},<br>  { "special-atpcs", "Select special register names used in the ATPCS",<br>    { "a1", "a2", "a3", "a4", "v1", "v2", "v3", "WR", "v5", "SB", "SL",  "FP",  "IP",  "SP",  "LR",  "PC" }},<br>};<br><br>但是可以看到，该列表并没有包含AAPCS标准，AAPCS标准对 r9 又引入了一个别名 TR，这样AAPCS下，r9使用了三个别名v6， SB， TR。选用哪个<br>别名，是依赖于不同平台的选择。<br></pre>
<p>[扩展，简要说明原理。并用实例解析] </p>
</div>
<h4><a id="寄存器的角色与保护1" name="寄存器的角色与保护1">寄存器的角色与保护</a></h4>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">寄存器的角色(AAPCS标准)</div>
</li>
</ul>
<table class="inline">
<tbody>
<tr>
<th class="leftalign">寄存器 </th>
<th class="leftalign">可选寄存器名 </th>
<th class="leftalign">特殊寄存器名 </th>
<th class="leftalign">在函数调用中的角色 </th>
</tr>
<tr>
<td class="leftalign">r15 </td>
<td class="rightalign"><br></td>
<td class="leftalign">PC </td>
<td class="leftalign">The Program Counter. </td>
</tr>
<tr>
<td class="leftalign">r14 </td>
<td class="rightalign"><br></td>
<td class="leftalign">LR </td>
<td class="leftalign">The Link Register. </td>
</tr>
<tr>
<td class="leftalign">r13 </td>
<td class="rightalign"><br></td>
<td class="leftalign">SP </td>
<td class="leftalign">The Stack Pointer. </td>
</tr>
<tr>
<td class="leftalign">r12 </td>
<td class="rightalign"><br></td>
<td class="leftalign">IP </td>
<td>The Intra-Procedure-call scratch register.</td>
</tr>
<tr>
<td class="leftalign">r11 </td>
<td class="leftalign">v8 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Variable-register 8. </td>
</tr>
<tr>
<td class="leftalign">r10 </td>
<td class="leftalign">v7 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Variable-register 7. </td>
</tr>
<tr>
<td class="leftalign">r9 </td>
<td class="rightalign"><br></td>
<td class="leftalign">v6/SB/TR </td>
<td>Platform register. The meaning of this register is defined by the platform standard</td>
</tr>
<tr>
<td class="leftalign">r8 </td>
<td class="leftalign">v5 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Variable-register 5. </td>
</tr>
<tr>
<td class="leftalign">r7 </td>
<td class="leftalign">v4 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Variable register 4. </td>
</tr>
<tr>
<td class="leftalign">r6 </td>
<td class="leftalign">v3 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Variable register 3. </td>
</tr>
<tr>
<td class="leftalign">r5 </td>
<td class="leftalign">v2 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Variable register 2. </td>
</tr>
<tr>
<td class="leftalign">r4 </td>
<td class="leftalign">v1 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Variable register 1. </td>
</tr>
<tr>
<td class="leftalign">r3 </td>
<td class="leftalign">a4 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Argument / scratch register 4. </td>
</tr>
<tr>
<td class="leftalign">r2 </td>
<td class="leftalign">a3 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Argument / scratch register 3. </td>
</tr>
<tr>
<td class="leftalign">r1 </td>
<td class="leftalign">a2 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Argument / result / scratch register 2. </td>
</tr>
<tr>
<td class="leftalign">r0 </td>
<td class="leftalign">a1 </td>
<td class="rightalign"><br></td>
<td class="leftalign">Argument / result / scratch register 1. </td>
</tr>
</tbody>
</table>
<p>前四个寄存器r0-r3 (a1-a4)用于传递参数给子函数或从函数中返回结果值。他们也可用于在一个函数中保存寄存器的值（但是，一般只用在子函数调用中）。 </p>
<p>寄存器r12 (IP) 可在函数以及该函数调用的任何子函数中被链接器用作临时寄存器。它也可以在函数调用中用于保存寄存器的值。 </p>
<p>寄存器r9的角色是平台相关的。虚拟系统可能赋予该寄存器任何角色，因此必须说明它的用法。比如，在位置无关数据模型中它可以指定为static
base(SB)，或者在带有本地线程存储的环境中指定它为thread
register(TR)。该寄存器的使用可能要求在所有调用过程前后，它保存的值必须不变。在一个不需要这样特殊寄存器的虚拟平台上，r9可以指定为新
增的callee-saved variable register,v6. </p>
<p>通常，寄存器r4-r8, r10 和 r11 (v1-v5, v7 和 v8)用于保存函数的本地变量。这些寄存器中，只有v1-v4能被整个thumb指令集一致地使用，但是AAPCS并没有规定Thumb代码只能使用这些寄存器。 </p>
<p>子函数必须保护寄存器r4-r8, r10, r11 和 SP(还有r9,如果在函数调用过程中r6被指定为v6的话)的值。 </p>
<p>在所有的函数调用标准中，寄存器r12-r15都扮演特殊的角色。依据这些角色，它们被标注为IP, SP, LR 和 PC。 </p>
<p>寄存器CPSR的属性（省） </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">寄存器保护规则</div>
</li>
</ul>
<p>子函数必须保护寄存器r4-r8, r10, r11 和 SP(还有r9,如果在函数调用过程中r6被指定为v6的话)的值。 子函数调用 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">子函数调用</div>
</li>
</ul>
<p>ARM 和 Thumb 指令集都有一个函数调用指令元语，BL,它执行branch-with-link
操作。BL的执行效果是把紧跟程序计数器的下一个值－－也就是返回地址－－传送到链接寄存器(LR)，然后把目标地址传送到程序寄存器(PC)中。如果
BL指令是在Thumb状态下执行的，链接寄存器的Bit
0就设置为1;如果是在ARM状态下执行的，则设置为0。执行的结果是，把控制权转给目标地址，并把存放在LR中的返回地址作为附加的参数传递给了被调用
的函数。 </p>
<p>当返回地址装载到PC时，控制就返回给跟随BL后面的指令。 </p>
<p>子函数调用可以由具有下面效果的任何指令序列完成： </p>
<pre class="file">       	LR[31:1] ← 返回地址<br>       	LR[0] ← 返回地址的代码类型 (0 ARM, 1 Thumb)<br>       	PC ← 子函数地址<br>	...<br>返回地址:<br></pre>
<p>例如，在ARM状态中，调用由r4指定了地址的子函数 </p>
<pre class="file">do:<br>	MOV LR, PC<br>	BX  r4<br>	...<br></pre>
<p>注意，相同的指令序列在Thumb状态中将不能工作，因为设置LR的指令并没有拷贝Thumb 状态标志位到LR[0]中。 </p>
<p>在ARM V5架构中，ARM 和 Thumb指令集都提供了BLX指令，它将调用由一个寄存器指定了地址的子函数，并正确地设置返回地址为程序计数器的下一个值。 </p>
</div>
<h4><a id="条件执行" name="条件执行">条件执行</a></h4>
<div 
<table class= style="width:700px">
<table class="inline">
<tbody>
<tr>
<th class="leftalign">操作码［31:28］ </th>
<th class="centeralign">助记符扩展 </th>
<th class="leftalign">解释 </th>
<th class="leftalign">用于执行的标志位状态 </th>
</tr>
<tr>
<td class="leftalign">0000 </td>
<td class="centeralign">EQ </td>
<td class="leftalign">相等/等于0 </td>
<td class="leftalign">Z置位 </td>
</tr>
<tr>
<td class="leftalign">0001 </td>
<td class="centeralign">NE </td>
<td class="leftalign">不等 </td>
<td class="leftalign">Z清0 </td>
</tr>
<tr>
<td class="leftalign">0010 </td>
<td class="centeralign">CS/HS </td>
<td class="leftalign">进位/无符号数高于或等于 </td>
<td class="leftalign">C置位 </td>
</tr>
<tr>
<td class="leftalign">0011 </td>
<td class="centeralign">CC/LO </td>
<td class="leftalign">无进位/无符号数小于 </td>
<td class="leftalign">C清0 </td>
</tr>
<tr>
<td class="leftalign">0100 </td>
<td class="centeralign">MI </td>
<td class="leftalign">负数 </td>
<td class="leftalign">N置位 </td>
</tr>
<tr>
<td class="leftalign">0101 </td>
<td class="centeralign">PL </td>
<td class="leftalign">正数或0 </td>
<td class="leftalign">N清0 </td>
</tr>
<tr>
<td class="leftalign">0110 </td>
<td class="centeralign">VS </td>
<td class="leftalign">溢出 </td>
<td class="leftalign">V置位 </td>
</tr>
<tr>
<td class="leftalign">0111 </td>
<td class="centeralign">VC </td>
<td class="leftalign">未溢出 </td>
<td class="leftalign">V清0 </td>
</tr>
<tr>
<td class="leftalign">1000 </td>
<td class="centeralign">HI </td>
<td class="leftalign">无符号数高于 </td>
<td class="leftalign">C置位，Z清0 </td>
</tr>
<tr>
<td class="leftalign">1001 </td>
<td class="centeralign">LS </td>
<td class="leftalign">无符号数小于或等于 </td>
<td class="leftalign">C清0,Z置位 </td>
</tr>
<tr>
<td class="leftalign">1010 </td>
<td class="centeralign">GE </td>
<td class="leftalign">有符号数大于或等于 </td>
<td class="leftalign">N等于V </td>
</tr>
<tr>
<td class="leftalign">1011 </td>
<td class="centeralign">LT </td>
<td class="leftalign">有符号数小于 </td>
<td class="leftalign">N不等于V </td>
</tr>
<tr>
<td class="leftalign">1100 </td>
<td class="centeralign">GT </td>
<td class="leftalign">有符号数大于 </td>
<td class="leftalign">Z清0且N等于V </td>
</tr>
<tr>
<td class="leftalign">1101 </td>
<td class="centeralign">LE </td>
<td class="leftalign">有符号数小于或等于 </td>
<td class="leftalign">Z置位且N不等于V </td>
</tr>
<tr>
<td class="leftalign">1110 </td>
<td class="centeralign">AL </td>
<td class="leftalign">总是 </td>
<td class="leftalign">任何状态 </td>
</tr>
<tr>
<td class="leftalign">1111 </td>
<td class="centeralign">NV </td>
<td class="leftalign">从不(未使用） </td>
<td class="leftalign">无 </td>
</tr>
</tbody>
</table>
</div>
<h4><a id="调用链的形成1" name="调用链的形成1">调用链的形成</a></h4>
<div 
<div class="li" style="width:700px">
<p>注意对比ARM和X86在调用链形成的类似和区别之处。 </p>
<p>区别，首先在寄存器的名称和角色的差异。 </p>
<p>1.
X86中寄存器%eip指向的是下一个将要执行的指令。在ARM中也有个类似别名的寄存器ip。但这个寄存器ip的作用并不是指向的是下一个将要执行的指
令。在ARM中，寄存器pc才是起着X86中寄存器%eip的角色，也就是包含下一个将要执行指令的地址。而ARM中的ip寄存器，作用比较自由，类似干
杂工的人，一般用于临时寄存器。[扩展，引用权威手册的话] </p>
<p>2.
X86中，返回地址是直接保存在栈中的。但是ARM不一样了，它寄存器比X86多得多，财大气粗，所以，返回地址保存在了专用的寄存器lr(link
register)中。但是，不要以为把返回地址放到专用的寄存器中会省事，其实反而多事了。因为，在调用函数刚执行完调用语句之时，lr保存的是子函数
的返回地址，而指令控制权转移到了子函数后，子函数照样可能调用自己的子函数，依次需要使用lr。所以自然也就有了lr的值的保存与恢复的问题，解决方法
还是要靠压栈解决。（参考下面的内容） </p>
<p>3. 我们知道，描述栈帧就是描述栈帧的基地址和顶端地址。在X86中，用专用的寄存器%ebp保存栈基址，也就是base
pointer；%esp保存栈顶端地址，也就是stack pointer。在ARM中，也有专用的寄存器保存栈顶端地址，就是SP(stack
pointer的简称)。但是，在保存栈基址这方面，依据最新的AAPCS标准，ARM就很吝啬了，没有一个保存栈基址的专用寄存器。又不过呢，在
APCS和ATPCS标准中，有fp寄存器用于保存帧指针(frame pointer，也就是X86的base
pointer)。在现在的编译器，可以看到，还是依照惯例把fp用于保存帧指针。既然如此，当然也有个入栈保存恢复的问题。 </p>
<p>调用链包含两方面的内容，和X86类似 </p>
<p>1.返回地址的保存与恢复 </p>
<p>由调用函数在执行调用指令时把子函数的返回地址传送进连接寄存器lr中，指令控制权转交给子函数后，再由子函数负责把上层函数的lr(也就是子函数
的返回地址)保存到栈中。然后子函数在返回前的最后时刻，再负责把lr的保存值从栈弹回到lr中，从而恢复了上层函数的lr。这时还没完事，子函数在执行
返回指令时，由返回指令把lr的值传送到寄存器pc(Program
Counter)，从而导致接下来的指令是从子函数的返回地址开始运行。这样，指令控制权就返回给了调用函数。 </p>
<p>我们应当注意到，ARM中调用指令也是多种多样的。有b,bl,bx,bxl。如果调用指令是不带连接的指令，比如b,bx,这时就要人工给lr赋
值。不过为了简便，我不再区分这两类指令，而把实现跳转和连接以及可能的换态这些功能的整个指令序列为“调用指令”，相关区别参考指令手册。在ARM中，
返回指令和调用指令都是同一套的。而X86，调用用call,返回用ret。 </p>
<p>2.旧栈帧的保存与恢复 </p>
<p>对比X86栈帧的保存与恢复的方式，ARM的更加简单直接。就是直接把上一栈帧的帧指针（frame
pointer，也就是栈帧基地址）以及栈顶端指针sp(stack
pointer)压入栈中。子函数返回时，在执行返回指令之前的最后关头才从栈弹出fp和sp的值，从而恢复旧栈帧。这个过程真的没有遗漏了吗？我们看
下，上面的步骤保证了调用函数的栈帧不被破坏，但是子函数自己的栈帧却没有建立起来呢。首先是帧指针需要人赋值。这个情形和X86非常相似。子函数在使用
栈帧之前，把上层函数的栈顶端指针sp赋给一个临时寄存器ip，然后在旧fp的值被压栈保存之后，把ip的值减去4，再赋给帧指针寄存器fp，此时，fp
就指向了新栈帧的基址。这是因为，新栈帧基地址刚好位于旧栈帧栈顶之下，地址低了4字节。其次，子函数栈帧的栈顶指针sp也是要考虑的，根据压栈指令的不
同，sp可能不需要人工维护，也可能需要人工维护［有疑问...????］。 </p>
<p>我们还注意到，在X86中，子函数的栈帧的底端（也就是%ebp所指的内存位置)存放着上一层栈帧的基址指针(旧%ebp)的值，一层层下去，这样
就形成回溯的链条。那么，在ARM之下，也是靠子函数的栈帧的底端提供回溯的能力的吗？当然不是。实际上子函数的栈帧的基址位置存放的是什么，这无所谓
的。 </p>
<p>［疑问？？？如果旧fp保存在新栈帧中的位置不是固定的，那么调试器是如何做到栈帧回溯的呢？］ </p>
<p>根据AAPCS标准的规定，子函数必须保护寄存器r4-r8, r10, r11 和 SP(还有r9,如果在函数调用过程中r6被指定为v6的话)的值。注意，它用的字眼是“保护”，而不是“保存”。 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">应用层实例解析</div>
</li>
</ul>
<pre class="file">#include &lt;stdio.h&gt;<br><br>void func()<br>{}<br><br>void funb()<br>{<br>        func();<br>}<br><br><br>void funa()<br>{<br>        funb();<br>}<br><br><br>int main()<br>{<br>        funa();<br>}<br>-----------<br>000083b0 &lt;func&gt;:<br>#include &lt;stdio.h&gt;<br><br>void func()<br>{}<br>    83b0:       e1a0c00d        mov     ip, sp<br>    83b4:       e92dd800        push    {fp, ip, lr, pc}<br>    83b8:       e24cb004        sub     fp, ip, #4      ; 0x4<br>    83bc:       e24bd00c        sub     sp, fp, #12     ; 0xc<br>    83c0:       e89d6800        ldm     sp, {fp, sp, lr}<br><br>    83c4:       e12fff1e        bx      lr<br><br>000083c8 &lt;funb&gt;:<br><br>void funb()<br>{<br>    83c8:       e1a0c00d        mov     ip, sp<br>    83cc:       e92dd800        push    {fp, ip, lr, pc}<br>    83d0:       e24cb004        sub     fp, ip, #4      ; 0x4<br>        func();<br>    83d4:       ebfffff5        bl      83b0 &lt;func&gt;<br>}<br>    83d8:       e24bd00c        sub     sp, fp, #12     ; 0xc<br>    83dc:       e89d6800        ldm     sp, {fp, sp, lr}<br>    83e0:       e12fff1e        bx      lr<br><br>000083e4 &lt;funa&gt;:<br><br><br>void funa()<br>{<br><br>    83e4:       e1a0c00d        mov     ip, sp<br>    83e8:       e92dd800        push    {fp, ip, lr, pc}<br>    83ec:       e24cb004        sub     fp, ip, #4      ; 0x4<br>        funb();<br>    83f0:       ebfffff4        bl      83c8 &lt;funb&gt;<br>}<br>    83f4:       e24bd00c        sub     sp, fp, #12     ; 0xc<br>    83f8:       e89d6800        ldm     sp, {fp, sp, lr}<br>    83fc:       e12fff1e        bx      lr<br>00008400 &lt;main&gt;:<br><br>int main()<br>{<br>    8400:       e1a0c00d        mov     ip, sp<br>    8404:       e92dd800        push    {fp, ip, lr, pc}<br>    8408:       e24cb004        sub     fp, ip, #4      ; 0x4<br>        funa();<br>    840c:       ebfffff4        bl      83e4 &lt;funa&gt;<br>}<br>    8410:       e24bd00c        sub     sp, fp, #12     ; 0xc<br>    8414:       e89d6800        ldm     sp, {fp, sp, lr}<br>    8418:       e12fff1e        bx      lr<br><br></pre>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">内核层实例解析</div>
</li>
</ul>
</div>
<h4><a id="栈帧结构与参数传递1" name="栈帧结构与参数传递1">栈帧结构与参数传递</a></h4>
<div 
<div class="li" style="width:700px">
<p>[1.栈:栈对齐，栈限制。2.参数传递：variadic函数，nonvariadic函数。3.结果的返回 4.互交代码(ARM-Thumb interworking)] </p>
<p>栈帧示意图 </p>
<pre class="file">                        +------------------------------ + ---------<br>                        |  Register Save Area           |        | <br>                        +------------------------------ +        | <br>                        | Locals and Temporaries        |        | <br>                        +------------------------------ +          <br>                        |     alloca() Locals           |     Caller's Frame<br>                        +------------------------------ +          <br>                        | Incoming Args Past Four Words |        | <br>                        +------------------------------ + ---------<br>                        | First Four Words Of Args      |        | <br>       Frame Pointer--&gt; +------------------------------ +        |<br>                        |  Register Save Area           |        | <br>                        +------------------------------ +      Current Frame<br>                        | Locals and Temporaries        |         <br>                        +------------------------------ +        |   <br>                        |   alloca() Locals             |        | <br>                        +------------------------------ +        | <br>                        | Outgoing Args Past Four Words |        | <br>      Stack Pointer---&gt; +------------------------------ + ---------<br></pre>
</div>
<h4><a id="完整的调用过程1" name="完整的调用过程1">完整的调用过程</a></h4>
<div 
<div class="li" style="width:700px">
<p>函数caller调用子函数callee，这是应用层的普通函数调用过程。如果是远调用，跨态调用要考虑的东西更多。但这个例子已经充分展示了调用过程的繁复部分。 </p>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">函数调用前调用者的动作</div>
</li>
</ul>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">函数调用 call callee</div>
</li>
</ul>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">函数调用后被调用者的动作</div>
</li>
</ul>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">调用返回前被调用者的动作</div>
</li>
</ul>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">调用返回后调用者的动作</div>
</li>
</ul>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">应用层实例解析</div>
</li>
</ul>
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">内核层实例解析</div>
</li>
</ul>
</div>
<h4><a id="调用链回溯的实现" name="调用链回溯的实现">调用链回溯的实现</a></h4>
<div 
<div class="li" style="width:700px">
<p>arm体系对调用链的回溯的代码实现主要在 </p>
<pre class="file">arch/arm/kernel/traps.c 和arch/arm/lib/backtrace.S.其中核心函数是backtrace.S中的__backtrace函数。<br><br>待解释<br>---/*<br> *  linux/arch/arm/lib/backtrace.S<br> *<br> *  Copyright (C) 1995, 1996 Russell King<br> *<br> * This program is free software; you can redistribute it and/or modify<br> * it under the terms of the GNU General Public License version 2 as<br> * published by the Free Software Foundation.<br> *<br> * 27/03/03 Ian Molton Clean up CONFIG_CPU<br> *<br> */<br>#include &lt;linux/linkage.h&gt;<br>#include &lt;asm/assembler.h&gt;<br>		.text<br><br>@ fp is 0 or stack frame<br><br>#define frame	r4<br>#define sv_fp	r5<br>#define sv_pc	r6<br>#define mask	r7<br>#define offset	r8<br><br>ENTRY(__backtrace)<br>		mov	r1, #0x10<br>		mov	r0, fp<br><br>ENTRY(c_backtrace)<br><br>#if !defined(CONFIG_FRAME_POINTER) || !defined(CONFIG_PRINTK)<br>		mov	pc, lr<br>ENDPROC(__backtrace)<br>ENDPROC(c_backtrace)<br>#else<br>		stmfd	sp!, {r4 - r8, lr}	@ Save an extra register so we have a location...<br>		movs	frame, r0		@ if frame pointer is zero<br>		beq	no_frame		@ we have no stack frames<br><br>		tst	r1, #0x10		@ 26 or 32-bit mode?<br>		moveq	mask, #0xfc000003	@ mask for 26-bit<br>		movne	mask, #0		@ mask for 32-bit<br><br>1:		stmfd	sp!, {pc}		@ calculate offset of PC stored<br>		ldr	r0, [sp], #4		@ by stmfd for this CPU<br>		adr	r1, 1b<br>		sub	offset, r0, r1<br><br>/*<br> * Stack frame layout:<br> *             optionally saved caller registers (r4 - r10)<br> *             saved fp<br> *             saved sp<br> *             saved lr<br> *    frame =&gt; saved pc<br> *             optionally saved arguments (r0 - r3)<br> * saved sp =&gt; &lt;next word&gt;<br> *<br> * Functions start with the following code sequence:<br> *                  mov   ip, sp<br> *                  stmfd sp!, {r0 - r3} (optional)<br> * corrected pc =&gt;  stmfd sp!, {..., fp, ip, lr, pc}<br> */<br>for_each_frame:	tst	frame, mask		@ Check for address exceptions<br>		bne	no_frame<br><br>1001:		ldr	sv_pc, [frame, #0]	@ get saved pc<br>1002:		ldr	sv_fp, [frame, #-12]	@ get saved fp<br><br>		sub	sv_pc, sv_pc, offset	@ Correct PC for prefetching<br>		bic	sv_pc, sv_pc, mask	@ mask PC/LR for the mode<br><br>1003:		ldr	r2, [sv_pc, #-4]	@ if stmfd sp!, {args} exists,<br>		ldr	r3, .Ldsi+4		@ adjust saved 'pc' back one<br>		teq	r3, r2, lsr #10		@ instruction<br>		subne	r0, sv_pc, #4		@ allow for mov<br>		subeq	r0, sv_pc, #8		@ allow for mov + stmia<br><br>		ldr	r1, [frame, #-4]	@ get saved lr<br>		mov	r2, frame<br>		bic	r1, r1, mask		@ mask PC/LR for the mode<br>		bl	dump_backtrace_entry<br><br>		ldr	r1, [sv_pc, #-4]	@ if stmfd sp!, {args} exists,<br>		ldr	r3, .Ldsi+4<br>		teq	r3, r1, lsr #10<br>		ldreq	r0, [frame, #-8]	@ get sp<br>		subeq	r0, r0, #4		@ point at the last arg<br>		bleq	.Ldumpstm		@ dump saved registers<br><br>1004:		ldr	r1, [sv_pc, #0]		@ if stmfd sp!, {..., fp, ip, lr, pc}<br>		ldr	r3, .Ldsi		@ instruction exists,<br>		teq	r3, r1, lsr #10<br>		subeq	r0, frame, #16<br>		bleq	.Ldumpstm		@ dump saved registers<br><br>		teq	sv_fp, #0		@ zero saved fp means<br>		beq	no_frame		@ no further frames<br><br>		cmp	sv_fp, frame		@ next frame must be<br>		mov	frame, sv_fp		@ above the current frame<br>		bhi	for_each_frame<br><br>1006:		adr	r0, .Lbad<br>		mov	r1, frame<br>		bl	printk<br>no_frame:	ldmfd	sp!, {r4 - r8, pc}<br>ENDPROC(__backtrace)<br>ENDPROC(c_backtrace)<br>		<br>		.section __ex_table,"a"<br>		.align	3<br>		.long	1001b, 1006b<br>		.long	1002b, 1006b<br>		.long	1003b, 1006b<br>		.long	1004b, 1006b<br>		.previous<br><br>#define instr r4<br>#define reg   r5<br>#define stack r6<br><br>.Ldumpstm:	stmfd	sp!, {instr, reg, stack, r7, lr}<br>		mov	stack, r0<br>		mov	instr, r1<br>		mov	reg, #10<br>		mov	r7, #0<br>1:		mov	r3, #1<br>		tst	instr, r3, lsl reg<br>		beq	2f<br>		add	r7, r7, #1<br>		teq	r7, #6<br>		moveq	r7, #1<br>		moveq	r1, #'\n'<br>		movne	r1, #' '<br>		ldr	r3, [stack], #-4<br>		mov	r2, reg<br>		adr	r0, .Lfp<br>		bl	printk<br>2:		subs	reg, reg, #1<br>		bpl	1b<br>		teq	r7, #0<br>		adrne	r0, .Lcr<br>		blne	printk<br>		ldmfd	sp!, {instr, reg, stack, r7, pc}<br><br>.Lfp:		.asciz	"%cr%d:%08x"<br>.Lcr:		.asciz	"\n"<br>.Lbad:		.asciz	"Backtrace aborted due to bad frame pointer &lt;%p&gt;\n"<br>		.align<br>.Ldsi:		.word	0xe92dd800 &gt;&gt; 10	@ stmfd sp!, {... fp, ip, lr, pc}<br>		.word	0xe92d0000 &gt;&gt; 10	@ stmfd sp!, {}<br><br>#endif<br><br><br></pre>
</div>
<h2><a id="源码浏览工具" name="源码浏览工具">源码浏览工具</a></h2>
<div 
<div class="li" style="width:700px">
<p>本节意义： 内核源码的代码量越来越大，不借助源码交叉索引工具根本是无法阅读了。一定要熟练灵活掌握此类工具的使用 </p>
</div>
<h3><a id="调用图生成工具" name="调用图生成工具">调用图生成工具</a></h3>
<div 
<div class="li" style="width:700px">
<p>1.CodeViz </p>
<p>官网： </p>
<p><a class="urlextern" title="http://www.csn.ul.ie/~mel/projects/codeviz/" href="http://www.csn.ul.ie/~mel/projects/codeviz/" rel="nofollow"><u><font color="#0000ff">http://www.csn.ul.ie/~mel/projects/codeviz/</font></u></a> </p>
<p>安装使用： </p>
<p>CodeViz —— 一款分析C_C++源代码中函数调用关系的调用图生成工具.pdf </p>
<p><a class="urlextern" title="http://linux.chinaunix.net/bbs/thread-1031921-1-1.html" href="http://linux.chinaunix.net/bbs/thread-1031921-1-1.html" rel="nofollow"><u><font color="#0000ff">http://linux.chinaunix.net/bbs/thread-1031921-1-1.html</font></u></a> </p>
<p>用CodeViz产生函数调用图 </p>
<p><a class="urlextern" title="http://barry-popy.blog.sohu.com/31629163.html" href="http://barry-popy.blog.sohu.com/31629163.html" rel="nofollow"><u><font color="#0000ff">http://barry-popy.blog.sohu.com/31629163.html</font></u></a> </p>
<p>分析函数调用关系图(call graph)的几种方法 </p>
<p><a class="urlextern" title="http://blog.csdn.net/Solstice/archive/2005/09/24/488865.aspx" href="http://blog.csdn.net/Solstice/archive/2005/09/24/488865.aspx" rel="nofollow"><u><font color="#0000ff">http://blog.csdn.net/Solstice/archive/2005/09/24/488865.aspx</font></u></a> </p>
<p>用CodeViz绘制函数调用关系图(call graph) </p>
<p><a class="urlextern" title="http://blog.csdn.net/Solstice/archive/2005/09/22/486788.aspx" href="http://blog.csdn.net/Solstice/archive/2005/09/22/486788.aspx" rel="nofollow"><u><font color="#0000ff">http://blog.csdn.net/Solstice/archive/2005/09/22/486788.aspx</font></u></a> </p>
<p>2.ncc </p>
</div>
<h3><a id="find_grep" name="find_grep">find + grep</a></h3>
<div 
<div class="li" style="width:700px">
<p>对于源码的阅读工具，一般是选取后面提到的某种源码索引工具，再和find以及grep“高低搭配”一起来使用。 </p>
<p>1.命令选项 </p>
<p>2.正则表达式 </p>
<p>Regular Expression HOWTO： <a class="urlextern" title="http://www.amk.ca/python/howto/regex/" href="http://www.amk.ca/python/howto/regex/" rel="nofollow"><u><font color="#0000ff">http://www.amk.ca/python/howto/regex/</font></u></a> </p>
<p>正则表达式之道： <a class="urlextern" title="http://net.pku.edu.cn/~yhf/tao_regexps_zh.html" href="http://net.pku.edu.cn/~yhf/tao_regexps_zh.html" rel="nofollow"><u><font color="#0000ff">http://net.pku.edu.cn/~yhf/tao_regexps_zh.html</font></u></a> </p>
</div>
<h3><a id="wine_si" name="wine_si">wine + SI</a></h3>
<div 
<div class="li" style="width:700px">
<p>wine + source insight </p>
</div>
<h4><a id="优缺点" name="优缺点">优缺点</a></h4>
<div 
<div class="li" style="width:700px">
<p>优点： SI的特点是有图形界面，操作和浏览特别方便快捷。特别是它的“函数调用树”的图形显示功能，以及分窗口自动显示函数，变量等定义的功能。 </p>
<p>缺点： 不能解析汇编源文件。 </p>
</div>
<h4><a id="安装wine" name="安装wine">安装wine</a></h4>
<div 
<div class="li" style="width:700px">
<p>在ubuntu/debian下用以下命令就能在线安装wine </p>
<pre class="file">$ sudo apt-get install wine<br></pre>
<p>安装好后，就能看到wine的快捷菜单被添加到了任务栏的“应用程序”中。 </p>
</div>
<h4><a id="安装si" name="安装si">安装SI</a></h4>
<div 
<div class="li" style="width:700px">
<p>wine安装好后，就可以像在windows一样去安装使用SI了。安装完成后，SI的快捷菜单被添加到“应用程序”→“wine”→“programs”→“source insight3”中。以后用快捷菜单就能启动SI </p>
</div>
<h4><a id="si的使用" name="si的使用">SI的使用</a></h4>
<div 
<div class="li" style="width:700px">
<p>可以乱点乱试一下，它能提供很多的功能。其中一些经常要到的功能有 查找符号；函数调用的函数，被调用的函数；以及调用关系的多层展开显示；字符串搜索等。 </p>
</div>
<h3><a id="global" name="global">global</a></h3>
<div 
<div class="li" style="width:700px">
<p>[待玩] <a class="urlextern" title="http://www.gnu.org/software/global/" href="http://www.gnu.org/software/global/" rel="nofollow"><u><font color="#0000ff">http://www.gnu.org/software/global/</font></u></a> </p>
</div>
<h3><a id="source-navigator" name="source-navigator">Source-Navigator</a></h3>
<div 
<div class="li" style="width:700px">
<p>[待玩] <a class="urlextern" title="http://sourcenav.sourceforge.net/" href="http://sourcenav.sourceforge.net/" rel="nofollow"><u><font color="#0000ff">http://sourcenav.sourceforge.net/</font></u></a> </p>
<p>安装： </p>
<p>在ubuntu下可以在线安装 </p>
<pre class="file">$ sudo apt-get install sourcenav<br></pre>
<p>运行： </p>
<pre class="file">$ snavigator<br></pre>
</div>
<h3><a id="vim_cscopectags" name="vim_cscopectags">vim + cscope/ctags</a></h3>
<div 
<div class="li" style="width:700px">
<p>参考： </p>
<p>cscope的官方教程 “The Vim/Cscope tutorial”： </p>
<p><a class="urlextern" title="http://cscope.sourceforge.net/cscope_vim_tutorial.html" href="http://cscope.sourceforge.net/cscope_vim_tutorial.html" rel="nofollow"><u><font color="#0000ff">http://cscope.sourceforge.net/cscope_vim_tutorial.html</font></u></a> </p>
<p>对应的中文翻译： <a class="urlextern" title="http://www.gracecode.com/Archive/Display/316" href="http://www.gracecode.com/Archive/Display/316" rel="nofollow"><u><font color="#0000ff">http://www.gracecode.com/Archive/Display/316</font></u></a> </p>
<p><a class="urlextern" title="http://www.lupaworld.com/?uid-151392-action-viewspace-itemid-106656" href="http://www.lupaworld.com/?uid-151392-action-viewspace-itemid-106656" rel="nofollow"><u><font color="#0000ff">http://www.lupaworld.com/?uid-151392-action-viewspace-itemid-106656</font></u></a> </p>
<p><a class="urlextern" title="http://dev.21tx.com/2007/02/21/10252.html" href="http://dev.21tx.com/2007/02/21/10252.html" rel="nofollow"><u><font color="#0000ff">http://dev.21tx.com/2007/02/21/10252.html</font></u></a> </p>
</div>
<h4><a id="优缺点1" name="优缺点1">优缺点</a></h4>
<div 
<div class="li" style="width:700px">
<p>优点： 本人感觉在终端下看源码比较舒服。 </p>
<p>缺点： 没有一个实时显示函数/变量定义的分窗口。也不能直接显示“调用树”，但有其他小工具可以实现该功能。也许vim高手能解决这些问题。 </p>
</div>
<h4><a id="安装cscopectags" name="安装cscopectags">安装cscope/ctags</a></h4>
<div 
<div class="li" style="width:700px">
<p>ubuntu/debian下用以下命令就能在线安装 </p>
<pre class="file">$ sudo apt-get install cscope ctags<br></pre>
</div>
<h4><a id="命令选项" name="命令选项">命令选项</a></h4>
<div 
<div class="li" style="width:700px">
<p>在终端下可以用 man info –help等形式查看cscope/ctags的手册 </p>
<p>在vim下查看手册的方式是 </p>
<pre class="file">:help cscope<br>和<br>:help ctags<br></pre>
<p>1. 以下是cscope建立索引文件用到的一些选项 </p>
<pre class="file">-R: 在生成索引文件时，搜索子目录树中的代码<br><br>-b: 只生成索引文件，不进入cscope的界面<br><br>-q: 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度<br><br>-k: 在生成索引文件时，不搜索/usr/include目录<br><br>-i: 如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用“-”，表示由标准输入获得文件列表。<br><br>-I dir: 在-I选项指出的目录中查找头文件<br><br>-u: 扫描所有文件，重新生成交叉索引文件<br><br>-C: 在搜索时忽略大小写<br><br>-P path: 在以相对路径表示的文件前加上的path，这样，你不用切换到你数据库文件所在的目录也可以使用它了。<br></pre>
<p>2. 在vim下利用:cscope find &lt;关键字&gt; 命令的选项有 </p>
<pre class="file">s: 查找C语言符号，即查找函数名、宏、枚举值等出现的地方<br><br>g: 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能<br><br>d: 查找本函数调用的函数<br><br>c: 查找调用本函数的函数<br><br>t: 查找指定的字符串<br><br>e: 查找egrep模式，相当于egrep功能，但查找速度快多了<br><br>f: 查找并打开文件，类似vim的find功能<br><br>i: 查找包含本文件的文<br></pre>
</div>
<h4><a id="使用" name="使用">使用</a></h4>
<h5><a id="建立索引" name="建立索引">建立索引</a></h5>
<div 
<div class="li" style="width:700px">
<p>[可能要修改] </p>
<p>用以下命令先产生一个文件列表，然后让cscope为这个列表中的每个文件都生成索引。在这里，我们只关注.h, .c,
.S文件，所以只对他们进行索引。可以根据自己需求进行更改。接着我们用-bq选项利用cscope生成索引。选项意义见上节。同时也生成ctags索
引。 </p>
<pre class="file">#!/bin/sh<br>find . -name "*.h" -o -name "*.c" -o -name "*.S" &gt; cscope.files<br>cscope -bkq -i cscope.files<br>ctags -R<br></pre>
</div>
<h5><a id="利用vim浏览源码" name="利用vim浏览源码">利用vim浏览源码</a></h5>
<div 
<div class="li" style="width:700px">
<p>切换到内核源码的目录上，运行vim，然后在vim下导入索引 </p>
<pre class="file">$vim<br>:cscope add cscope.out<br></pre>
<p>然后就可以在vim下调用“:cscope find &lt;关键字&gt;”来查找函数的定义，函数调用的函数以及被调用函数等 </p>
<p>“:cscope find &lt;关键字&gt;” 可以缩写为 “:cs f &lt;关键字&gt;” </p>
<p>比如以下命令用来查找sys_read的定义 </p>
<pre class="file">:cs f g sys_read<br></pre>
<p>“cs f”的其他命令选项请看上节 </p>
</div>
<h5><a id="快捷键的使用" name="快捷键的使用">快捷键的使用</a></h5>
<div 
<pre class="f style="width:700px">
<pre class="file">ctrl + t : 退回<br>ctrl + ] : 进入光标处的变量/函数的定义处<br></pre>
</div>
<h3><a id="kscope" name="kscope">kscope</a></h3>
<div 
<div class="li" style="width:700px">
<p>kscope是cscope的图形前端工具。在ubuntu下可以在线安装。它的界面上和操作上与source
insight都比较类似。但是目前它对cpu的占用很大，不是很好。但是它和cscope相比，有一个很大的优点是：可以图形显示“函数调用树”，甚至
这个功能比SI还强大。 </p>
<pre class="file">$sudo apt-get install kscope<br></pre>
</div>
<h3><a id="lxr" name="lxr">lxr</a></h3>
<div 
<div class="li" style="width:700px">
<p>1. 优缺点 </p>
<p>优点：本身好像没什么特别的优点。但是有专门提供这种服务的网站，上面有很多不同系统的不同版本源码 </p>
<p>缺点：在本机上配置运行的话，配置麻烦。如果是浏览lxr站点的方式，速度比较慢。 </p>
<p>2. lxr官方： <a class="urlextern" title="http://lxr.linux.no/" href="http://lxr.linux.no/" rel="nofollow"><u><font color="#0000ff">http://lxr.linux.no/</font></u></a> </p>
<p>特点是可以浏览历史上linux所有版本的源码，可以看到它的演化过程。 </p>
<p>3. 其他系统的源码 <a class="urlextern" title="http://fxr.watson.org/" href="http://fxr.watson.org/" rel="nofollow"><u><font color="#0000ff">http://fxr.watson.org/</font></u></a> </p>
<p>估计超一流的内核开发人员，可能会经常访问此类站点。因为他需要借鉴其他系统的设计思想。 </p>
</div>
<h3><a id="si等与gdb的特点" name="si等与gdb的特点">SI等与gdb的特点</a></h3>
<div 
<div class="li" style="width:700px">
<p>在源码阅读的功能上： </p>
<p>1. SI等适合“面读”，也就是读一个代码段，并且提供更舒适的阅读辅助手段。SI适合分析函数全面的逻辑。 </p>
<p>2. gdb适合“线读”，也就是以追踪调用链的方式深入阅读，并且提供了数据分析的调试功能。适合分析特定情况下的函数逻辑表现。 </p>
</div>
<h2><a id="调用链、调用树和调用图" name="调用链、调用树和调用图">调用链、调用树和调用图</a></h2>
<div 
<div class="li" style="width:700px">
<p>为了能使用调试器，必须理解函数调用链在调试器级别的表现形式。但是，因为存在内嵌函数和代码优化等原因，调试器的表现形式和源码浏览器下的表现形式是不一样的。它们两者的信息显示可能存在“错位”的现象。本节的目的就是为了磨合调试器和交叉索引工具之间的代沟。 </p>
<p>为了简化问题的描述，在实际分析前，先将知识点分解介绍一下。 </p>
</div>
<h3><a id="理想调用链" name="理想调用链">理想调用链</a></h3>
<div 
<div class="li" style="width:700px">
<p>下面我给出一个处于“理想状态”的经典backtrace(backtrace的意思是“回溯”，依照它的作用来说，也就是本人说的调用链)。所谓
“理想状态的”的backtrace是指，可以利用内核源码交叉索引工具，依据gdb给出的这个backtrace，从frame
0开始一级级往后最追溯，能够一直追溯到最前面的frame
N，而且追溯的过程中，没有出现多出来的连接frameN和frame(N-1)的“过渡”frame. </p>
<p>注意其中的两个条件：1.能够 2.不多出。但是，在现实的世界里，往往没这么美好。源码浏览工具往往要么“不能”，要么“多出”。造成前者的原因在于源码浏览工具的局限性，造成后者的是内嵌函数以及代码优化。详细情况可看下节的分析。 </p>
<p>追溯的方法对于source insight来说就是：打开”relation window”→选中要被追溯的函数→右键→选“view relation”→选“referenced by functions”,这样就能显示出调用了被选函数的函数来。 </p>
<p>我们拿下面这个“理想状态”的backtrace分析一下 </p>
<pre class="file">(gdb) bt<br>#0  kref_init (kref=0xdc40abe4) at lib/kref.c:33<br>#1  0xc01de8be in kobject_init_internal (kobj=0xdc40abe0) at lib/kobject.c:149<br>#2  0xc01de928 in kobject_init (kobj=0xdc40abe0, ktype=0xc035b9dc) at lib/kobject.c:282<br>#3  0xc01de972 in kobject_create () at lib/kobject.c:619<br>#4  0xc01def53 in kobject_create_and_add (name=0xdc40abe4 "", parent=0xc035b9dc) at lib/kobject.c:641<br>#5  0xc0393b04 in mnt_init () at fs/namespace.c:2333<br>#6  0xc039382b in vfs_caches_init (mempages=108676) at fs/dcache.c:2212<br>#7  0xc037f868 in start_kernel () at init/main.c:666<br>#8  0xc037f008 in i386_start_kernel () at arch/x86/kernel/head32.c:13<br>#9  0x00000000 in ?? ()<br></pre>
<p>理想状态下的backtrace各个域的含义是(注意，在非理想状态的backtrace中，这些含义往往对不上号) </p>
<pre class="file">#frameN的编号 frame(N-1)的返回地址(注：fram0没有这项) in frameN所处的函数(该函数的参数...) at 该函数所处的源文件 : frameN函数内对frame(N-1)函数的调用语句在源文件中所处的行数 <br></pre>
<p>我们看下 </p>
<pre class="file">#0  kref_init (kref=0xdc40abe4) at lib/kref.c:33<br></pre>
<p>它说明frame0时，kref_init正要运行。传入的参数是0xdc40abe4。函数kref_init从源文件lib/kref.c第33行开始。 在gdb下调用shell来查看源文件 </p>
<pre class="file">(gdb) shell vi lib/kref.c<br></pre>
<p>vi 出来后打命令:set nu可看到 </p>
<pre class="file"> 31  */<br> 32 void kref_init(struct kref *kref)<br> 33 {<br> 34         kref_set(kref, 1);<br> 35 }<br> 36 <br></pre>
<p>我们再看看frame0这一瞬间是不是“kref_init正要运行”。应该知道，“正要运行”和“正要被调用”是两个不同的概念。前者来说，到了下一个指令，代码的控制权就会交给了被调用的函数；而后者，到了下一个指令，代码的控制权还在调用者手里， </p>
<pre class="file">(gdb) f 0<br>#0  kref_init (kref=0xdc40abe4) at lib/kref.c:33<br>33	{<br>(gdb) info registers <br>....<br>edi            0x0	0<br>eip            0xc01df520	0xc01df520 &lt;kref_init&gt; //&lt;-注意eip是下一个将要运行的指令地址<br>eflags         0x282	[ SF IF ]<br>....<br>(gdb) disass kref_init<br>Dump of assembler code for function kref_init:<br>0xc01df520 &lt;kref_init+0&gt;:	push   %ebp  //对比上面，eip指向这里<br>0xc01df521 &lt;kref_init+1&gt;:	mov    %esp,%ebp<br>...<br>0xc01df52f &lt;kref_init+15&gt;:	ret    <br>End of assembler dump.<br>(gdb) <br></pre>
<p>可见，kobject_init_internal的调用指令call已经执行完毕，到了frame0时，下一个指令“将要运行”函数kref_init。 </p>
<p>再看看 </p>
<pre class="file">#1  0xc01de8be in kobject_init_internal (kobj=0xdc40abe0) at lib/kobject.c:149<br></pre>
<p>frameN与frame(N-1)之间是调用的关系，前者调用了后者。也就是说，frame1的kobject_init_internal调用
frame0的kref_init，并且kref_init函数返回后，将返回到地址0xc01de8be继续执行。0xc01de8be就在
kobject_init_internal的体内，函数kobject_init_internal中调用kref_init的C语句位于
lib/kobject.c的149行。 </p>
<p>查看一下kobject_init_internal的反汇编码 </p>
<pre class="file">(gdb) disass kobject_init_internal<br>Dump of assembler code for function kobject_init_internal:<br>0xc01de8ac &lt;kobject_init_internal+0&gt;:	push   %ebp<br>0xc01de8ad &lt;kobject_init_internal+1&gt;:	test   %eax,%eax<br>0xc01de8af &lt;kobject_init_internal+3&gt;:	mov    %esp,%ebp<br>0xc01de8b1 &lt;kobject_init_internal+5&gt;:	push   %ebx<br>0xc01de8b2 &lt;kobject_init_internal+6&gt;:	mov    %eax,%ebx<br>0xc01de8b4 &lt;kobject_init_internal+8&gt;:	je     0xc01de8d3 &lt;kobject_init_internal+39&gt;<br>0xc01de8b6 &lt;kobject_init_internal+10&gt;:	lea    0x4(%eax),%eax<br>0xc01de8b9 &lt;kobject_init_internal+13&gt;:	call   0xc01df520 &lt;kref_init&gt;<br>0xc01de8be &lt;kobject_init_internal+18&gt;:	lea    0x8(%ebx),%eax  //注意这个地址0xc01de8be是kref_init的返回地址<br>0xc01de8c1 &lt;kobject_init_internal+21&gt;:	mov    %eax,0x8(%ebx)<br><br></pre>
<p>再看看lib/kobject.c，看看最后的那个行数的意义 </p>
<pre class="file">145 static void kobject_init_internal(struct kobject *kobj)<br>146 {<br>147         if (!kobj)<br>148                 return;<br>149         kref_init(&amp;kobj-&gt;kref);   //注意kobject_init_internal调用子函数kref_init的C语句位于行数149<br>150         INIT_LIST_HEAD(&amp;kobj-&gt;entry);<br>151         kobj-&gt;state_in_sysfs = 0;<br>152         kobj-&gt;state_add_uevent_sent = 0;<br>153         kobj-&gt;state_remove_uevent_sent = 0;<br>154         kobj-&gt;state_initialized = 1;<br>155 }<br><br></pre>
<p>在验证一下 </p>
<pre class="file">#2  0xc01de928 in kobject_init (kobj=0xdc40abe0, ktype=0xc035b9dc) at lib/kobject.c:282<br></pre>
<p>看看kobject_init的反汇编码 </p>
<pre class="file">(gdb) disass kobject_init<br>Dump of assembler code for function kobject_init:<br>0xc01de8f3 &lt;kobject_init+0&gt;:	push   %ebp<br>........<br>0xc01de923 &lt;kobject_init+48&gt;:	call   0xc01de8ac &lt;kobject_init_internal&gt;<br>0xc01de928 &lt;kobject_init+53&gt;:	mov    %esi,0x18(%ebx)     //注意这个地址0xc01de928是kobject_init_internal的返回地址<br>......<br>0xc01de94b &lt;kobject_init+88&gt;:	pop    %ebp<br>0xc01de94c &lt;kobject_init+89&gt;:	ret    <br>End of assembler dump.<br><br></pre>
<p>看看看看lib/kobject.c，看看最后的那个行数的意义 </p>
<pre class="file">263 void kobject_init(struct kobject *kobj, struct kobj_type *ktype)<br>264 {<br>265         char *err_str;<br>.......<br>282         kobject_init_internal(kobj);    ////注意kobject_init调用子函数kobject_init_internal的C语句位于行数282<br>283         kobj-&gt;ktype = ktype;<br>......<br>287         printk(KERN_ERR "kobject (%p): %s\n", kobj, err_str);<br>288         dump_stack<br></pre>
<p>通过这两个例子，可见最初的猜想是正确的。 </p>
</div>
<h3><a id="函数指针调用" name="函数指针调用">函数指针调用</a></h3>
<div 
<div class="li" style="width:700px">
<p>本小节意义： 在利用SI等工具查看函数调用链时，遇到的一个最多的问题是函数指针的调用。所以把该小节内容移到这里来，为下小节的叙述作铺垫。SI等交叉索引工具不能在父函数内部解析出这种调用关系。 </p>
<p>我们经常碰到这种情况：如果内核中函数A是通过函数指针调用函数B，那么源码交叉索引工具(如source insight,
kscope等)就无法通过函数B的名称回溯到上层函数A。这是因为在函数A内部对函数B的调用并不是通过函数B的名称，而是利用指向函数B代码块的指针
(函数指针)。 </p>
<p>要想解决这个问题，方法有两种： </p>
<p>1. 利用字符串搜索功能： </p>
<p>搜索函数指针的变量名。如果已经知道的是子函数，想找出通过指针调用它的所有上层父函数：利用子函数的函数名进行搜索，就能找到所有相应的函数指针
变量赋值的语句。然后搜索该函数指针变量就能得到所有可能调用该函数的上层父函数。相反，如果是已经知道父函数，想知道该父函数体内的一个函数指针可能会
调用哪些子函数，可以搜索该函数指针变量(一般在该变量名前加个点号“.”)，这样可以搜索出所有给该函数指针变量赋值的语句，从而找出所有可能的子函
数。 </p>
<p>当然，既然是字符串搜索，搜索结果中会夹带其他没用的信息，这需要进一步的筛选。这个方法能搜索出依赖某函数指针变量的所有调用关系。 </p>
<p>2. 利用调试工具： </p>
<p>在目标函数处下断点。调试器器会实时拦截该函数的调用，然后用bt命令就能看到整个调用链。 </p>
<p>这个方法得到的只是一个特定的具体调用关系。可能还有其他很多的潜在调用路径。 </p>
<p>然而，我们研究的目标并不满足于知道调用链。下面我们观察函数究竟是怎样利用函数指针调用子函数的。[待整理] </p>
<pre class="file">2130 int vfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)<br>2131 {<br>2132         int error = may_create(dir, dentry, NULL);<br>2133 <br>2134         if (error)<br>2135                 return error;<br>2136 <br>2137         if (!dir-&gt;i_op || !dir-&gt;i_op-&gt;mkdir)<br>2138                 return -EPERM;<br>2139 <br>2140         mode &amp;= (S_IRWXUGO|S_ISVTX);<br>2141         error = security_inode_mkdir(dir, dentry, mode);<br>2142         if (error)<br>2143                 return error;<br>2144 <br>2145         DQUOT_INIT(dir);<br>2146         error = dir-&gt;i_op-&gt;mkdir(dir, dentry, mode);<br>2147         if (!error)<br>2148                 fsnotify_mkdir(dir, dentry);<br>2149         return error;<br>2150 }<br><br>对源码文件下断点<br><br>(gdb) b fs/namei.c:2146<br>Breakpoint 9 at 0xc017c0ee: file fs/namei.c, line 2146.<br><br>问题一：<br><br>动态分析call   *0x14(%ebx)是怎么回事，函数指针<br><br>-------------------------<br>┌──Register group: general───────────────────────────────────────────────────────────────────────────────────────────────────┐<br>│eax            0xdc20b0a8       -601837400                    ecx            0x1ed    493                                   │<br>│edx            0xdb9526c0       -610982208                    ebx            0xe01c87d4       -535001132                    │<br>│esp            0xd8c5bf1c       0xd8c5bf1c                    ebp            0xd8c5bf34       0xd8c5bf34                    │<br>│esi            0xdc20b0a8       -601837400                    edi            0xdb9526c0       -610982208                    │<br>│eip            0xc017c0fb       0xc017c0fb &lt;vfs_mkdir+179&gt;    eflags         0x200246 [ PF ZF IF ID ]                       │<br>│cs             0x60     96                                    ss             0x68     104                                   │<br>│ds             0x7b     123                                   es             0x7b     123                                   │<br>│fs             0xd8     216                                   gs             0x33     51                                    │<br>│                                                                                                                            │<br>│                                                                                                                            │<br>│                                                                                                                            │<br>│                                                                                                                            │<br>│                                                                                                                            │<br>│                                                                                                                            │<br>   ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐<br>   │0xc017c0ea &lt;vfs_mkdir+162&gt;      mov    %esi,%eax                                                                         │<br>   │0xc017c0ec &lt;vfs_mkdir+164&gt;      call   *(%ecx)                                                                           │<br>B+ │0xc017c0ee &lt;vfs_mkdir+166&gt;      mov    0x98(%esi),%ebx                                                                   │<br>   │0xc017c0f4 &lt;vfs_mkdir+172&gt;      mov    %edi,%edx                                                                         │<br>   │0xc017c0f6 &lt;vfs_mkdir+174&gt;      mov    %esi,%eax                                                                         │<br>   │0xc017c0f8 &lt;vfs_mkdir+176&gt;      mov    -0x10(%ebp),%ecx                                                                  │<br>  &gt;│0xc017c0fb &lt;vfs_mkdir+179&gt;      call   *0x14(%ebx)                                                                       │<br>   │0xc017c0fe &lt;vfs_mkdir+182&gt;      test   %eax,%eax                                                                         │<br>   │0xc017c100 &lt;vfs_mkdir+184&gt;      mov    %eax,%ebx                                                                         │<br>   │0xc017c102 &lt;vfs_mkdir+186&gt;      jne    0xc017c15d &lt;vfs_mkdir+277&gt;                                                        │<br>   │0xc017c104 &lt;vfs_mkdir+188&gt;      testb  $0x4,0x11c(%esi)                                                                  │<br>   │0xc017c10b &lt;vfs_mkdir+195&gt;      je     0xc017c119 &lt;vfs_mkdir+209&gt;                                                        │<br>   │0xc017c10d &lt;vfs_mkdir+197&gt;      mov    $0x4,%edx                                                                         │<br>   │0xc017c112 &lt;vfs_mkdir+202&gt;      mov    %esi,%eax                                                                         │<br>   └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>remote Thread 42000 In: vfs_mkdir                                                                   Line: 2146 PC: 0xc017c0fb <br>  i_state = 1, <br>  dirtied_when = 0, <br>  i_flags = 0, <br>  i_writecount = {<br>    counter = 0<br>  }, <br>  i_security = 0x0, <br>  i_private = 0x0<br>}<br>(gdb) p/x $ebx<br>$20 = 0xe01c87d4<br>(gdb) p/x $ebx+0x14<br>$21 = 0xe01c87e8<br><br><br>(gdb) p &amp;sfs_dir_inode_ops<br>$13 = (struct inode_operations *) 0xe01c87d4<br><br>(gdb) p/x *(int * )0xe01c87d4@10<br>$18 = {0xe01c75b1, 0xe01c7677, 0xc018d3f0, 0xc018cc91, 0xe01c75dd, 0xe01c75c0, 0xc018d441, 0xe01c7510, 0xc018d474, 0x0}<br><br><br>(gdb) disass sfs_mkdir<br>Dump of assembler code for function sfs_mkdir:<br>0xe01c75c0 &lt;sfs_mkdir+0&gt;:	push   %ebp          //&lt;-<br>0xe01c75c1 &lt;sfs_mkdir+1&gt;:	or     $0x40,%ch<br>0xe01c75c4 &lt;sfs_mkdir+4&gt;:	mov    %esp,%ebp<br>0xe01c75c6 &lt;sfs_mkdir+6&gt;:	push   %ebx<br>0xe01c75c7 &lt;sfs_mkdir+7&gt;:	mov    %eax,%ebx<br>0xe01c75c9 &lt;sfs_mkdir+9&gt;:	push   $0x0<br>0xe01c75cb &lt;sfs_mkdir+11&gt;:	call   0xe01c7510 &lt;sfs_mknod&gt;<br>0xe01c75d0 &lt;sfs_mkdir+16&gt;:	pop    %edx<br>0xe01c75d1 &lt;sfs_mkdir+17&gt;:	test   %eax,%eax<br>0xe01c75d3 &lt;sfs_mkdir+19&gt;:	jne    0xe01c75d8 &lt;sfs_mkdir+24&gt;<br>0xe01c75d5 &lt;sfs_mkdir+21&gt;:	incl   0x28(%ebx)<br>0xe01c75d8 &lt;sfs_mkdir+24&gt;:	mov    -0x4(%ebp),%ebx<br>0xe01c75db &lt;sfs_mkdir+27&gt;:	leave  <br>0xe01c75dc &lt;sfs_mkdir+28&gt;:	ret    <br>End of assembler dump.<br>(gdb) p/x *0xe01c87e8<br>$9 = 0xe01c75c0   // &lt;-sfs_mkdir的地址<br>(gdb) <br><br>struct inode_operations {<br>	int (*create) (struct inode *,struct dentry *,int, struct nameidata *);<br>	struct dentry * (*lookup) (struct inode *,struct dentry *, struct nameidata *);<br>	int (*link) (struct dentry *,struct inode *,struct dentry *);<br>	int (*unlink) (struct inode *,struct dentry *);<br>	int (*symlink) (struct inode *,struct dentry *,const char *);<br>	int (*mkdir) (struct inode *,struct dentry *,int);<br>......<br>};<br><br>struct inode_operations sfs_dir_inode_ops = {<br>...<br>	.mkdir          = sfs_mkdir,<br>...<br>};<br><br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>0xc017c0fb &lt;vfs_mkdir+179&gt;      call   *0x14(%ebx)  为什么要加 * ?<br><br>call *0x14(%ebx) ==<br>push %eip<br>mov 0x14(%ebx) %eip   <br><br>注意call与mov指令语义的区别<br><br>mov 0x14(%ebx) %eax; 把存放在地址0x14(%ebx)中的32位数据拷贝到%eax<br>mov %eax 0x14(%ebx); 把%eax的值拷贝到地址0x14(%ebx)指向的内存中<br>call 0x14(%ebx)    : 结果是跳到地址0x14(%ebx)继续执行(当然对于本例来说，该地址指向的并不是目标代码段)<br>call *0x14(%ebx)   : 取出存放在地址0x14(%ebx)中的32位数据，把该数据作为目标地址，跳到该地址继续执行。<br><br>mov $0xe01c75c9 %eax ; 0xe01c75c9被认为是立即数，前面有$。没有mov 0xe01c75c9 %eax这种形式<br>call 0xe01c75c9 ;0xe01c75c9被认为是地址。没有call $0xe01c75c9这种形式。<br>注意，也没有call %eax等形式(假设%eax放着目标地址)。需用 call *%eax，同样，*%eax表示从%eax获取地址值<br><br> <br>                                                                                                           <br>                           |      -             |                  |    --         |            <br>                           |      -             |                  |    --         |                   4. call sfs_mkdir == call 0xe01c75c0<br>                           |      -             |                  |    --         |                     <br>                           +--------------------+    &lt;-------&gt;     |    --         |                   3. 0xe01c75c0 == fetch from 0xe01c87e8 <br>                           |      ---           |                  |    --         |                                        *0x14(%ebx)<br>                           +--------------------+                  +---------------+                      <br>                           |  init (*mkdir)(..) +--+               |  0xe01c75c0   |   2. 0xe01c87e8  ==  calculate 0x14(%ebx)<br>            0x14(%ebx)---&gt; +--------------------+  |               +---------------+                        <br>                           |      ...           |  |               |  0xe01c75dd   |                                            <br>                           +--------------------+  |               +---------------+                                            <br>                           |      ...           |  |               |  0xc018cc91   |                        <br>                           +--------------------+  |               +---------------+                        <br>                           |      ...           |  |               |  0xc018d3f0   |                        <br>                           +--------------------+  |               +---------------+                     1. 0xe01c87d4 == fetch from %ebx<br>                           |      ...           |  |               |  0xe01c7677   |                        <br>                           +--------------------+  |               +---------------+                        +------------+<br>                           |  int (*create)(..) |  |               |  0xe01c75b1   |       0xe01c87d4       | 0xe01c87d4 |<br>              %ebx-------&gt; +--------------------+  |               +---------------+                        +------------+<br>                          struct inode_operations  |                  contents              address         register %ebx <br>                             sfs_dir_inode_ops     |                                                      <br>                                                   |                                                   call   *0x14(%ebx) 的过程<br>                                                   |  <br>                                                   +-----------------------------+   <br>                                                                                 |   <br>                                                      static int sfs_mkdir(..)   |   <br>                                                      0xe01c75c0 &lt;sfs_mkdir+0&gt;:  +-&gt;  push   %ebp          <br>                                                      0xe01c75c1 &lt;sfs_mkdir+1&gt;:       or     $0x40,%ch<br>                                                      0xe01c75c4 &lt;sfs_mkdir+4&gt;:       mov    %esp,%ebp<br>                                                      0xe01c75c6 &lt;sfs_mkdir+6&gt;:       push   %ebx<br>                                                      0xe01c75c7 &lt;sfs_mkdir+7&gt;:       mov    %eax,%ebx<br>                                                      0xe01c75c9 &lt;sfs_mkdir+9&gt;:       push   $0x0<br>                                                      0xe01c75cb &lt;sfs_mkdir+11&gt;:      call   0xe01c7510 &lt;sfs_mknod&gt;<br>                                                      0xe01c75d0 &lt;sfs_mkdir+16&gt;:      pop    %edx<br>                                                      0xe01c75d1 &lt;sfs_mkdir+17&gt;:      test   %eax,%eax<br>                                                      0xe01c75d3 &lt;sfs_mkdir+19&gt;:      jne    0xe01c75d8 &lt;sfs_mkdir+24&gt;<br><br>                                                      0xe01c75d5 &lt;sfs_mkdir+21&gt;:      incl   0x28(%ebx)<br>                                                      0xe01c75d8 &lt;sfs_mkdir+24&gt;:      mov    -0x4(%ebp),%ebx<br>						      0xe01c75db &lt;sfs_mkdir+27&gt;:      leave  <br>                                                      0xe01c75dc &lt;sfs_mkdir+28&gt;:      ret    <br>                                                                                                                                                 <br>                                                            address                        contents<br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>问题二：<br><br>下面的dir-&gt;i_op-&gt;mkdir()，为什么不是dir.i_op.mkidr. . 和 -&gt; 有什么区别<br><br>static int sfs_mkdir(struct inode * dir, struct dentry * dentry, int mode)<br>{<br>....<br>}<br><br>2130 int vfs_mkdir(struct inode *dir, struct dentry *dentry, int mode)<br>2131 {<br>....<br>2146         error = dir-&gt;i_op-&gt;mkdir(dir, dentry, mode);<br>...<br>2150 }<br><br>struct inode {<br>...<br>const struct inode_operations	*i_op;<br>...<br>};<br><br>struct inode_operations {<br>...<br>	int (*mkdir) (struct inode *,struct dentry *,int);<br>...<br>};<br><br>dir: 取得(struct inode *)dir<br>dir-&gt;i_op: 取得(const struct inode_operations	*)i_op<br>dir-&gt;i_op-&gt;mkdir: 取得(int (*) (struct inode *,struct dentry *,int))mkdir<br><br>dir-&gt;i_op-&gt;mkdir(dir, dentry, mode)也就是  函数指针变量名(参数...)<br><br>函数指针是一个指针，它向目标函数的代码块的第一个指令。<br><br>函数名的值等于该函数第一条指令的地址。<br><br>(gdb) p sfs_mkdir<br>$20 = {int (struct inode *, struct dentry *, int)} 0xe01c75c0 &lt;sfs_mkdir&gt;<br>(gdb) p &amp;sfs_mkdir<br>$21 = (int (*)(struct inode *, struct dentry *, int)) 0xe01c75c0 &lt;sfs_mkdir&gt;<br>(gdb) p dir-&gt;i_op-&gt;mkdir<br>$18 = (int (*)(struct inode *, struct dentry *, int)) 0xe01c75c0 &lt;sfs_mkdir&gt;<br>前者指明变量名/函数名的类型，后者是它的值<br><br>struct inode_operations sfs_dir_inode_ops = {<br>...<br>	.mkdir          = sfs_mkdir,<br>...<br>};<br><br><br>函数的两种调用形式： 函数指针变量名(参数...)  函数名(参数...)<br>严格地说，从C语言的形式看来，前者通过函数指针变量名调用函数，后者通过函数名调用，是不同的。<br>但从汇编级代码看来，都是转化为指令call 函数地址。是一样的。<br>引入了函数指针变量后，这个变量就可以动态地赋值，从而指向不同的函数体，实现某些特殊的功能。<br><br>我们再看下函数指针的赋值.mkdir          = sfs_mkdir,<br>严格地说，mkdir和sfs_mkdir是类型不同的东西，但在编译时自动经过了类型转换。所以下面这些写法效果都一样<br>.mkdir          = sfs_mkdir,<br>.mkdir          = &amp;sfs_mkdir,<br>.mkdir          = (int (*)(struct inode *, struct dentry *, int))sfs_mkdir,<br>.mkdir          = (int (*)(struct inode *, struct dentry *, int))(&amp;sfs_mkdir),<br>---<br>例子<br>#include &lt;stdio.h&gt;<br><br>int main()<br>{<br>        int myfunc(int a)<br>        {<br>                printf("%d\n", a);<br>                return 0;<br>        }<br>        int (*funa)(int) = myfunc;<br>        int (*funb)(int) = &amp;myfunc;<br>        int (*func)(int) = (int (*)(int))myfunc;<br>        int (*fund)(int) = (int (*)(int))(&amp;myfunc);<br><br>        myfunc(1);<br>        funa(2);<br>        funb(3);<br>        func(4);<br>        fund(5);<br><br>        return 0;<br>}<br><br><br></pre>
</div>
<h3><a id="调用链的层次" name="调用链的层次">调用链的层次</a></h3>
<div 
<div class="li" style="width:700px">
<p>1. 人观念层次 </p>
<p>2. 交叉解析器层次 </p>
<p>2. c调用层次 </p>
<p>3. 编译器(机器码静态)层次 </p>
<p>4. 运行时(机器码动态)层次，也叫调试器层次 </p>
<p>很明显，前面所讲的“理想状态”的backtrace就是指在交叉解析器层次下和在调试器层次下的表现相同的调用链。 </p>
</div>
<h3><a id="非理想调用链" name="非理想调用链">非理想调用链</a></h3>
<div 
<div class="li" style="width:700px">
<p>任务： </p>
<p>从一个断点开始，从后向前推导，分析出ramfs注册函数的调用过程。同时，观察调试器的优点和局限性。 </p>
<p>ramfs文件系统的注册函数是register_filesystem(&amp;ramfs_fs_type)。为了更快定位，在上层函数init_ramfs_fs下断点。而后在gdb下得到的调用链是 </p>
<pre class="file">(gdb) bt<br>#0  register_filesystem (fs=0xc03595cc) at fs/filesystems.c:68<br>#1  0xc0394594 in init_ramfs_fs () at fs/ramfs/inode.c:213<br>#2  0xc037f473 in kernel_init (unused=&lt;value optimized out&gt;) at init/main.c:708<br>#3  0xc010463f in kernel_thread_helper () at arch/x86/kernel/entry_32.S:1013<br></pre>
<p>我们注意到： </p>
<p>1. 这个backtrace包含的函数只有4个，实际上并非如此。经过分析，它实际上（用C的观点看）调用链如下所示，这是为什么呢？ </p>
<p>start_kernel→rest_init→kernel_thread→kernel_thread_helper→call %ebx
(即call kernel_init)→do_basic_setup→do_initcalls→do_one_initcall→result =
fn() (即call init_ramfs_fs)→register_filesystem </p>
<p>2. backtrace推溯到kernel_thread_helper后就再没下文了。又是什么使得调试器变成了瞎子，无法看得再远了呢？ </p>
<p>欲见其详，且听下回分解 </p>
<p>[下面准备材料] </p>
<p>kernel_init对do_basic_setup的调用被优化成内联函数 </p>
<p>do_basic_setup对do_initcalls的调用被优化成内联函数 </p>
<p>do_initcalls对do_one_initcall的调用被优化成内联函数 </p>
<p>有三层的非内联函数都被被优化成内联函数，整个代码被优化的乱七八糟。 </p>
<pre class="file">838 static int __init kernel_init(void * unused)<br>839 {<br>.....<br>864         cpuset_init_smp();<br>865 <br>866         do_basic_setup();<br>867 <br>.......<br>887         return 0;<br>888 }<br>                                               <br><br>static void __init do_basic_setup(void)<br>{<br>	/* drivers will send hotplug events */<br>	init_workqueues();<br>	usermodehelper_init();<br>	driver_init();<br>	init_irq_proc();<br>	do_initcalls();<br>}<br><br>741 static void __init do_initcalls(void)<br>742 {<br>743         initcall_t *call;<br>744 <br>745         for (call = __initcall_start; call &lt; __initcall_end; call++)<br>746                 do_one_initcall(*call);<br>747 <br>748         /* Make sure there is no pending stuff from the initcall sequence */<br>749         flush_scheduled_work();<br>750 }<br><br>static void __init do_one_initcall(initcall_t fn)<br>{<br>	int count = preempt_count();<br>	ktime_t t0, t1, delta;<br>	char msgbuf[64];<br>	int result;<br><br>	if (initcall_debug) {<br>		print_fn_descriptor_symbol("calling  %s\n", fn);<br>		t0 = ktime_get();<br>	}<br><br>	result = fn();<br><br>	if (initcall_debug) {<br>....<br>}<br><br>static inline void print_fn_descriptor_symbol(const char *fmt, void *addr)<br>{<br>#if defined(CONFIG_IA64) || defined(CONFIG_PPC64)<br>	addr = *(void **)addr;<br>#endif<br>	print_symbol(fmt, (unsigned long)addr);<br>}<br><br><br>(gdb) disass kernel_init<br>Dump of assembler code for function kernel_init:<br>0xc037f349 &lt;kernel_init+0&gt;:	push   %ebp<br>0xc037f34a &lt;kernel_init+1&gt;:	mov    %esp,%ebp<br>0xc037f34c &lt;kernel_init+3&gt;:	push   %edi<br>0xc037f34d &lt;kernel_init+4&gt;:	push   %esi<br>......<br>0xc037f413 &lt;kernel_init+202&gt;:	call   0xc0391454 &lt;cpuset_init_smp&gt;<br>0xc037f418 &lt;kernel_init+207&gt;:	call   0xc0390081 &lt;init_workqueues&gt;  //&lt;-do_basic_setup被优化成内联函数，在这里开始展开<br>0xc037f41d &lt;kernel_init+212&gt;:	call   0xc039004e &lt;usermodehelper_init&gt;<br>0xc037f422 &lt;kernel_init+217&gt;:	call   0xc039b7d1 &lt;driver_init&gt;<br>0xc037f427 &lt;kernel_init+222&gt;:	call   0xc0153e18 &lt;init_irq_proc&gt;<br>0xc037f42c &lt;kernel_init+227&gt;:	movl   $0xc03aa470,-0x5c(%ebp)  //do_initcalls被优化成内联函数，在这里开始展开<br>0xc037f433 &lt;kernel_init+234&gt;:	pop    %eax<br>0xc037f434 &lt;kernel_init+235&gt;:	pop    %edx<br>0xc037f435 &lt;kernel_init+236&gt;:	jmp    0xc037f559 &lt;kernel_init+528&gt;<br>0xc037f43a &lt;kernel_init+241&gt;:	mov    -0x5c(%ebp),%eax  //do_one_initcall被优化成内联函数，在这里开始展开<br>0xc037f43d &lt;kernel_init+244&gt;:	mov    (%eax),%eax<br>0xc037f43f &lt;kernel_init+246&gt;:	mov    %eax,-0x58(%ebp)<br>0xc037f442 &lt;kernel_init+249&gt;:	mov    %esp,%eax<br>0xc037f444 &lt;kernel_init+251&gt;:	and    $0xffffe000,%eax<br>0xc037f449 &lt;kernel_init+256&gt;:	mov    0x14(%eax),%eax<br>0xc037f44c &lt;kernel_init+259&gt;:	cmpl   $0x0,0xc03a1820<br>0xc037f453 &lt;kernel_init+266&gt;:	mov    %eax,-0x54(%ebp)<br>0xc037f456 &lt;kernel_init+269&gt;:	je     0xc037f470 &lt;kernel_init+295&gt;<br>0xc037f458 &lt;kernel_init+271&gt;:	mov    -0x58(%ebp),%edx  //内联函数print_fn_descriptor_symbol在这里开始展开<br>0xc037f45b &lt;kernel_init+274&gt;:	mov    $0xc030d1be,%eax<br>0xc037f460 &lt;kernel_init+279&gt;:	call   0xc013f598 &lt;__print_symbol&gt;//内联函数print_fn_descriptor_symbo的展开结束<br>0xc037f465 &lt;kernel_init+284&gt;:	call   0xc013352f &lt;ktime_get&gt;<br>0xc037f46a &lt;kernel_init+289&gt;:	mov    %eax,-0x64(%ebp)<br>0xc037f46d &lt;kernel_init+292&gt;:	mov    %edx,-0x60(%ebp)<br>0xc037f470 &lt;kernel_init+295&gt;:	call   *-0x58(%ebp)  //do_one_initcall中的调用语句result = fn();<br><br>.....<br>0xc037f553 &lt;kernel_init+522&gt;:	pop    %edi<br>0xc037f554 &lt;kernel_init+523&gt;:	pop    %eax<br>0xc037f555 &lt;kernel_init+524&gt;:	addl   $0x4,-0x5c(%ebp)<br>0xc037f559 &lt;kernel_init+528&gt;:	cmpl   $0xc03aa804,-0x5c(%ebp) //<br>0xc037f560 &lt;kernel_init+535&gt;:	jb     0xc037f43a &lt;kernel_init+241&gt; //<br><br></pre>
<p>如何在汇编码中定位内联（或被优化掉的非内联）函数 </p>
<pre class="file">1.利用前后相关函数的提示<br>2.函数的前戏码定位函数的开始<br>3.注意跳转语句<br>4.利用调试器辅助定位(见gdb技巧)<br></pre>
</div>
<h3><a id="调用树与调用图" name="调用树与调用图">调用树与调用图</a></h3>
<div 
<div class="li" style="width:700px">
<p>[待充实] </p>
</div>
<h4><a id="调用树的定义" name="调用树的定义">调用树的定义</a></h4>
<div 
<div class="li" style="width:700px">
<p>一个复杂的函数调用一定是调用了多个子函数，同时这些子函数又会调用若干“孙”函数，这样依次调用并依次返回到最初的父函数后，就形成了树状的调用关系，我们称之为“调用树”。 </p>
</div>
<h4><a id="调用树的作用" name="调用树的作用">调用树的作用</a></h4>
<div 
<div class="li" style="width:700px">
<p>函数调用树是比函数调用链更为复杂的观察对象。如果能够显示调用树，就可以对调用的整个过程有个直观的了解。 </p>
</div>
<h4><a id="调用树的分类" name="调用树的分类">调用树的分类</a></h4>
<div 
<div class="li" style="width:700px">
<p>函数调用树有两类： </p>
<p>1. 抽象调用树 </p>
<p>也叫虚拟调用树。比如在源码中，父函数调用了子函数a, b,
c。那么对这三个函数的调用逻辑都考虑进去，这就是“抽象调用”。抽象调用树能全面的描述了父函数的逻辑和代码开发员的意图。但是，在实际的环境中，这三
个函数未必就全部会调用到。把在实际的具体情况下未调用的“潜在”调用关系去掉后，剩下的调用树就称为“具体调用树”。明显，具体调用树不能全面显示代码
开发员的意图，只是放映具体环境下函数的调用关系。 </p>
<p>2. 具体调用树 </p>
<p>也叫实时调用树。解释见上。 </p>
</div>
<h4><a id="调用树的显示" name="调用树的显示">调用树的显示</a></h4>
<div 
<div class="li" style="width:700px">
<p>1. 抽象调用树的显示 </p>
<p>借助source insight等工具可以图形显示抽象调用树。 </p>
<p>1. 具体调用树的显示 </p>
<p>据本人的了解，目前gdb没有一个类似”bt”那样的能显示函数调用树的命令，但是借助gdb宏也许能够实现显示调用树的功能，这有待研究。不过，目前已经有个现成的调试工具可以显示调用树，它就是 systemtap. </p>
<p>效果如下： </p>
<pre class="file">[...]<br>     0 klogd(1391):-&gt;sys_read<br>    14 klogd(1391): -&gt;fget_light<br>    22 klogd(1391): &lt;-fget_light<br>    27 klogd(1391): -&gt;vfs_read<br>    35 klogd(1391):  -&gt;rw_verify_area<br>    43 klogd(1391):  &lt;-rw_verify_area<br>    49 klogd(1391):  -&gt;kmsg_read<br>     0 sendmail(1696):-&gt;sys_read<br>    17 sendmail(1696): -&gt;fget_light<br>    26 sendmail(1696): &lt;-fget_light<br>    34 sendmail(1696): -&gt;vfs_read<br>    44 sendmail(1696):  -&gt;rw_verify_area<br>    52 sendmail(1696):  &lt;-rw_verify_area<br>    58 sendmail(1696):  -&gt;proc_file_read<br>    70 sendmail(1696):   -&gt;loadavg_read_proc<br>    84 sendmail(1696):    -&gt;proc_calc_metrics<br>    92 sendmail(1696):    &lt;-proc_calc_metrics<br>    95 sendmail(1696):   &lt;-loadavg_read_proc<br>   101 sendmail(1696):  &lt;-proc_file_read<br>   106 sendmail(1696):  -&gt;dnotify_parent<br>   115 sendmail(1696):  &lt;-dnotify_parent<br>   119 sendmail(1696):  -&gt;inotify_dentry_parent_queue_event<br>   127 sendmail(1696):  &lt;-inotify_dentry_parent_queue_event<br>   133 sendmail(1696):  -&gt;inotify_inode_queue_event<br>   141 sendmail(1696):  &lt;-inotify_inode_queue_event<br>   146 sendmail(1696): &lt;-vfs_read<br>   151 sendmail(1696):&lt;-sys_read<br>[...]<br><br></pre>
<p>见于 </p>
<p><a class="urlextern" title="http://sourceware.org/systemtap/wiki/WSCallGraph?highlight=" href="http://sourceware.org/systemtap/wiki/WSCallGraph?highlight=" rel="nofollow"><font color="#0000ff"><u>http://sourceware.org/systemtap/wiki/WSCallGraph?highlight=</u></font></a><a class="fn_top" id="fnt__1" onmouseover="fnt(&#39;1&#39;, this, event);" href="http://wiki.zh-kernel.org/sniper#fn__1" name="fnt__1"><u><font color="#800080">1)</font></u></a> </p>
</div>
<h4><a id="调用树的拼接" name="调用树的拼接">调用树的拼接</a></h4>
<div 
<div class="li" style="width:700px">
<p>对于一个更刁的函数调用来说，利用工具显示的抽象调用树和具体调用调用树可能是不完整的。比如，对于抽象调用树来说，它的显示工具是source
insight。但是如果这个函数对某个子函数或在更下层的函数对下下层的函数调用是通过函数指针来调用的，那么source
insight显示的调用树中就会漏掉通过函数指针调用的子函数，以及以子函数为根的子调用树。这是因为函数指针变量的赋值是发生在代码动态运行时的。
source
insight无法利用静态的源码就捕捉到未来才出现东西，甚至它也无法在形式上解析出“那里存在一个利用函数指针的调用”。这就要通过阅读源码来找出这
种调用关系。同时，可以利用调试器实时找出具体情况下是通过那个函数指针调用了哪个特定的下层函数。这样就能把漏掉的子调用树拼接到父调用树中。 </p>
<p>可见，这些内容又回归到了调用链的内容。具体看前面。 </p>
</div>
<h4><a id="调用图" name="调用图">调用图</a></h4>
<div 
<div class="li" style="width:700px">
<p>各函数间的像蜘蛛网一样的调用关系的图形表示就是调用图了，显然它比调用树更复杂。 </p>
</div>
<h2><a id="穿越盲区" name="穿越盲区">穿越盲区</a></h2>
<div 
<div class="li" style="width:700px">
<p>本节意义：经过上面章节的叙述，利用源码交叉索引工具＋调试器已经能解决大部分问题，但是因为调试器和交叉索引工具的各自局限性，依然会存在一些问题。本节尝试如何联合交叉索引工具以及调试器再加上人脑来解决各自的缺点。 </p>
<p>[观察积累中，待扩展] </p>
</div>
<h3><a id="穿越gdb的盲区" name="穿越gdb的盲区">穿越gdb的盲区</a></h3>
<h4><a id="进程切换" name="进程切换">进程切换</a></h4>
<h4><a id="中断异常" name="中断异常">中断异常</a></h4>
<h4><a id="系统调用" name="系统调用">系统调用</a></h4>
<h3><a id="穿越交叉索引工具的盲区" name="穿越交叉索引工具的盲区">穿越交叉索引工具的盲区</a></h3>
<h4><a id="函数指针" name="函数指针">函数指针</a></h4>
<div 
<div class="li" style="width:700px">
<p>该小节内容移到了： 调用链的状态→函数指针调用 </p>
</div>
<h4><a id="查看函数的参数" name="查看函数的参数">查看函数的参数</a></h4>
<div 
<div class="li" style="width:700px">
<p>我们知道，一个函数的计算结果并不都是通过它的返回值返回的，有时会通过函数的参数返回真正感兴趣的数据。看内核源码的时候，如果调用链过长，涉及内容和数据结构过多的话，往往是看到最后都记不住函数的参数哪些是已经“初始化的”。 </p>
<p>这也是交叉索引工具无法克服的先天弱点。它能动态索引源码，却无法动态查看数据。此时，可以利用gdb给目标函数下断点，而后可以用命令info args查看参数，另外命令info local可查看本地变量。当然在ddd下查看效果会更好。 </p>
<p>内容简单，不展开了。 </p>
</div>
<h3><a id="工程方法" name="工程方法">工程方法</a></h3>
<h4><a id="二叉断点" name="二叉断点">二叉断点</a></h4>
<div 
<div class="li" style="width:700px">
<p>实例 “什么/proc下无法创建目录？” </p>
</div>
<h4><a id="给调用指令下断点" name="给调用指令下断点">给调用指令下断点</a></h4>
<div 
<div class="li" style="width:700px">
<p>如果对目标函数下断点后，受到很多骚扰，那么就转为在上层函数内对目标函数的调用指令处下断点。如果你已经进入了上层函数，对调用指令下断点，是更为精确的断点方法。 </p>
</div>
<h4><a id="绕过时钟中断的干扰" name="绕过时钟中断的干扰">绕过时钟中断的干扰</a></h4>
<div 
<div class="li" style="width:700px">
<p>有时我们调试的程序与中断无关的，但是由于时钟中断的异步到来，在调试过程中经常会自动进入时钟中断处理例程中，这严重干扰了我们的工作。用下面的方法可绕过时钟中断的干扰。 </p>
<p>注： </p>
<p>使用GDB与QEMU调试内核时的问题分析： <a class="urlextern" title="http://www.chinaitlab.com/linux/kernel/356774.html" href="http://www.chinaitlab.com/linux/kernel/356774.html" rel="nofollow"><u><font color="#0000ff">http://www.chinaitlab.com/linux/kernel/356774.html</font></u></a> </p>
<p>关于qemu在单步指令时进入时钟中断的问题，上面给出链接给出了比较“深入”地探讨。这个问题涉及虚拟机本身，有人说是虚拟机相对于真机的固有缺
陷，似乎很深奥，我没那个能力也没那个时间研究。但是我们应该知道，如果问题足够的复杂，以至于解决它要花费太高的代价，那么绕过这个问题是个更明智的解
决方法。 </p>
<p>解决方法(手工) </p>
<p>1. 内核启动早期 </p>
<p>事先下两个断点 </p>
<pre class="file">b common_interrupt<br>b native_iret<br></pre>
<p>自定义返回命令 </p>
<pre class="file">(gdb) define ooi<br>Type commands for definition of "ooi".<br>End with a line saying just "end".<br>&gt;c<br>&gt;stepi<br>&gt;end<br></pre>
<p>一旦时钟中断产生，就会拦截在中断处理的通用入口common_interrupt，然后运行返回指令，就会“回到”被时钟中断打断的原指令处 </p>
<pre class="file">ooi<br></pre>
<p>2. 内核启动完毕 </p>
<p>事先下两个断点 </p>
<pre class="file">b apic_timer_interrupt<br>b irq_return<br></pre>
<p>一旦时钟中断产生，就会拦截在中断处理例程apic_timer_interrupt，然后运行返回指令，就会“回到”被时钟中断打断的原指令处 </p>
<pre class="file">ooi<br></pre>
<pre class="file" style="width:700px">分析记录，待整理<br>提示，分析异常和中断的处理过程比分析C代码更直观，因为源码本身是汇编码。<br>   ┌──arch/x86/kernel/entry_32.S─────────────────────────────────────────────────────────────────────────────────────────────┐<br>   │614             SAVE_ALL                                                                                                 │<br>   │615             TRACE_IRQS_OFF                                                                                           │<br>   │616             movl %esp,%eax                                                                                           │<br>   │617             call do_IRQ                                                                                              │<br>  &gt;│618             jmp ret_from_intr                                                                                        │<br>   │619     ENDPROC(common_interrupt)                                                                                        │<br>   │620             CFI_ENDPROC                                                                                              │<br>   │621                                                                                                                      │<br>   │622     #define BUILD_INTERRUPT(name, nr)       \                                                                        │<br>   │623     ENTRY(name)                             \                                                                        │<br>   │624             RING0_INT_FRAME;                \                                                                        │<br>   │625             pushl $~(nr);                   \                                                                        │<br>   │626             CFI_ADJUST_CFA_OFFSET 4;        \                                                                        │<br>   │627             SAVE_ALL;                       \                                                                        │<br>   └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>   │0xc01043e1 &lt;common_interrupt+17&gt;        mov    %edx,%ds                                                                  │<br>   │0xc01043e3 &lt;common_interrupt+19&gt;        mov    %edx,%es                                                                  │<br>   │0xc01043e5 &lt;common_interrupt+21&gt;        mov    $0xd8,%edx                                                                │<br>   │0xc01043ea &lt;common_interrupt+26&gt;        mov    %edx,%fs                                                                  │<br>   │0xc01043ec &lt;common_interrupt+28&gt;        mov    %esp,%eax                                                                 │<br>   │0xc01043ee &lt;common_interrupt+30&gt;        call   0xc0106151 &lt;do_IRQ&gt;                                                       │<br>  &gt;│0xc01043f3 &lt;common_interrupt+35&gt;        jmp    0xc01038dc &lt;ret_from_exception&gt;                                           │<br>   │0xc01043f8 &lt;reschedule_interrupt&gt;       push   $0xffffff03                                                               │<br>   │0xc01043fd &lt;reschedule_interrupt+5&gt;     cld                                                                              │<br>   │0xc01043fe &lt;reschedule_interrupt+6&gt;     push   %fs                                                                       │<br>   │0xc0104400 &lt;reschedule_interrupt+8&gt;     push   %es                                                                       │<br>   │0xc0104401 &lt;reschedule_interrupt+9&gt;     push   %ds                                                                       │<br>   │0xc0104402 &lt;reschedule_interrupt+10&gt;    push   %eax                                                                      │<br>   │0xc0104403 &lt;reschedule_interrupt+11&gt;    push   %ebp                                                                      │<br>   └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>remote Thread 42000 In: common_interrupt                                                            Line: 618  PC: 0xc01043f3 <br>(gdb)  <br>(gdb)   <br>(gdb) bt<br>#0  common_interrupt () at arch/x86/kernel/entry_32.S:618<br>#1  0x00000292 in ?? ()<br>#2  0xc01880db in alloc_vfsmnt (name=0xc031dcf3 "rootfs") at include/linux/slab.h:266<br>#3  0xc0176919 in vfs_kern_mount (type=0xc0359678, flags=0, name=0xc031dcf3 "rootfs", data=0x0) at fs/super.c:896<br>#4  0xc0176a2f in do_kern_mount (fstype=0xc031dcf3 "rootfs", flags=0, name=0xc031dcf3 "rootfs", data=0x0) at fs/super.c:968<br>#5  0xc0393b33 in mnt_init () at fs/namespace.c:2285<br>#6  0xc039382b in vfs_caches_init (mempages=108676) at fs/dcache.c:2212<br>#7  0xc037f868 in start_kernel () at init/main.c:666<br>#8  0xc037f008 in i386_start_kernel () at arch/x86/kernel/head32.c:13<br>#9  0x00000000 in ?? ()<br>(gdb) disass<br>(gdb) <br>----<br>   ┌──arch/x86/kernel/entry_32.S─────────────────────────────────────────────────────────────────────────────────────────────┐<br>   │401             cmpl $((SEGMENT_LDT &lt;&lt; 8) | USER_RPL), %eax                                                              │<br>   │402             CFI_REMEMBER_STATE                                                                                       │<br>   │403             je ldt_ss                       # returning to user-space with LDT SS                                    │<br>   │404     restore_nocheck:                                                                                                 │<br>   │405             TRACE_IRQS_IRET                                                                                          │<br>   │406     restore_nocheck_notrace:                                                                                         │<br>   │407             RESTORE_REGS                                                                                             │<br>   │408             addl $4, %esp                   # skip orig_eax/error_code                                               │<br>   │409             CFI_ADJUST_CFA_OFFSET -4                                                                                 │<br>   │410     irq_return:                                                                                                      │<br>  &gt;│411             INTERRUPT_RETURN                                                                                         │<br>   │412     .section .fixup,"ax"                                                                                             │<br>   │413     ENTRY(iret_exc)                                                                                                  │<br>   │414             pushl $0                        # no error code                                                          │<br>   ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐<br>   │0xc0103a61 &lt;restore_nocheck_notrace&gt;    pop    %ebx                                                                      │<br>   │0xc0103a62 &lt;restore_nocheck_notrace+1&gt;  pop    %ecx                                                                      │<br>   │0xc0103a63 &lt;restore_nocheck_notrace+2&gt;  pop    %edx                                                                      │<br>   │0xc0103a64 &lt;restore_nocheck_notrace+3&gt;  pop    %esi                                                                      │<br>   │0xc0103a65 &lt;restore_nocheck_notrace+4&gt;  pop    %edi                                                                      │<br>   │0xc0103a66 &lt;restore_nocheck_notrace+5&gt;  pop    %ebp                                                                      │<br>   │0xc0103a67 &lt;restore_nocheck_notrace+6&gt;  pop    %eax                                                                      │<br>   │0xc0103a68 &lt;restore_nocheck_notrace+7&gt;  pop    %ds                                                                       │<br>   │0xc0103a69 &lt;restore_nocheck_notrace+8&gt;  pop    %es                                                                       │<br>   │0xc0103a6a &lt;restore_nocheck_notrace+9&gt;  pop    %fs                                                                       │<br>   │0xc0103a6c &lt;restore_nocheck_notrace+11&gt; add    $0x4,%esp                                                                 │<br>  &gt;│0xc0103a6f &lt;irq_return&gt;                 jmp    *%cs:0xc0353b54                                                           │<br>   │0xc0103a76 &lt;ldt_ss&gt;                     lar    0x3c(%esp),%eax                                                           │<br>   │0xc0103a7b &lt;ldt_ss+5&gt;                   jne    0xc0103a61 &lt;restore_nocheck_notrace&gt;                                      │<br>   └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>remote Thread 42000 In: irq_return                                                                  Line: 411  PC: 0xc0103a6f <br>(gdb) stepi<br>0xc0103a64 in restore_nocheck_notrace () at arch/x86/kernel/entry_32.S:407<br>0xc0103a65 in restore_nocheck_notrace () at arch/x86/kernel/entry_32.S:407<br>0xc0103a66 in restore_nocheck_notrace () at arch/x86/kernel/entry_32.S:407<br>Watchpoint 3: $ebp<br><br>Old value = (void *) 0xc0378000<br>New value = (void *) 0xc0379f4c<br>0xc0103a67 in restore_nocheck_notrace () at arch/x86/kernel/entry_32.S:407<br>0xc0103a68 in restore_nocheck_notrace () at arch/x86/kernel/entry_32.S:407<br>0xc0103a69 in restore_nocheck_notrace () at arch/x86/kernel/entry_32.S:407<br>0xc0103a6a in restore_nocheck_notrace () at arch/x86/kernel/entry_32.S:407<br>restore_nocheck_notrace () at arch/x86/kernel/entry_32.S:408<br>irq_return () at arch/x86/kernel/entry_32.S:411<br>(gdb) <br>------------<br>   ┌──arch/x86/kernel/entry_32.S─────────────────────────────────────────────────────────────────────────────────────────────┐<br>   │864             jmp irq_return                                                                                           │<br>   │865             CFI_ENDPROC                                                                                              │<br>   │866     KPROBE_END(nmi)                                                                                                  │<br>   │867                                                                                                                      │<br>   │868     #ifdef CONFIG_PARAVIRT                                                                                           │<br>   │869     ENTRY(native_iret)                                                                                               │<br>  &gt;│870             iret                                                                                                     │<br>   │871     .section __ex_table,"a"                                                                                          │<br>   │872             .align 4                                                                                                 │<br>   │873             .long native_iret, iret_exc                                                                              │<br>   │874     .previous                                                                                                        │<br>   │875     END(native_iret)                                                                                                 │<br>   │876                                                                                                                      │<br>   │877     ENTRY(native_irq_enable_syscall_ret)                                                                             │<br>   ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐<br>  &gt;│0xc01045a8 &lt;native_iret&gt;                        iret                                                                     │<br>   │0xc01045a9                                      lea    0x0(%esi),%esi                                                    │<br>   │0xc01045ac &lt;native_irq_enable_syscall_ret&gt;      sti                                                                      │<br>   │0xc01045ad &lt;native_irq_enable_syscall_ret+1&gt;    sysexit                                                                  │<br>   │0xc01045af                                      nop                                                                      │<br>   │0xc01045b0 &lt;overflow&gt;                           push   $0x0                                                              │<br>   │0xc01045b2 &lt;overflow+2&gt;                         push   $0xc0105030                                                       │<br>   │0xc01045b7 &lt;overflow+7&gt;                         jmp    0xc02bfb80 &lt;page_fault+8&gt;                                         │<br>   │0xc01045bc &lt;bounds&gt;                             push   $0x0                                                              │<br>   │0xc01045be &lt;bounds+2&gt;                           push   $0xc0104fe3                                                       │<br>   │0xc01045c3 &lt;bounds+7&gt;                           jmp    0xc02bfb80 &lt;page_fault+8&gt;                                         │<br>   │0xc01045c8 &lt;invalid_op&gt;                         push   $0x0                                                              │<br>   │0xc01045ca &lt;invalid_op+2&gt;                       push   $0xc0104f6d                                                       │<br>   │0xc01045cf &lt;invalid_op+7&gt;                       jmp    0xc02bfb80 &lt;page_fault+8&gt;                                         │<br>   └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>remote Thread 42000 In: native_iret                                                                 Line: 870  PC: 0xc01045a8 <br>#9  0x00000000 in ?? ()<br>(gdb) stepi<br>native_iret () at arch/x86/kernel/entry_32.S:870<br>(gdb) bt<br>#0  native_iret () at arch/x86/kernel/entry_32.S:870<br>#1  0xc0172198 in kmem_cache_alloc (cachep=0xdc404ec0, flags=&lt;value optimized out&gt;) at include/asm/string_32.h:183<br>#2  0xc01880db in alloc_vfsmnt (name=0xc031dcf3 "rootfs") at include/linux/slab.h:266<br>#3  0xc0176919 in vfs_kern_mount (type=0xc0359678, flags=0, name=0xc031dcf3 "rootfs", data=0x0) at fs/super.c:896<br>#4  0xc0176a2f in do_kern_mount (fstype=0xc031dcf3 "rootfs", flags=0, name=0xc031dcf3 "rootfs", data=0x0) at fs/super.c:968<br>#5  0xc0393b33 in mnt_init () at fs/namespace.c:2285<br>#6  0xc039382b in vfs_caches_init (mempages=108676) at fs/dcache.c:2212<br>#7  0xc037f868 in start_kernel () at init/main.c:666<br>#8  0xc037f008 in i386_start_kernel () at arch/x86/kernel/head32.c:13<br>#9  0x00000000 in ?? ()<br>(gdb) <br>－－－－－－－－－－－－－－－－－－－－－－－－－－－－－<br>   ┌──mm/slab.c──────────────────────────────────────────────────────────────────────────────────────────────────────────────┐<br>   │3478            if (unlikely((flags &amp; __GFP_ZERO) &amp;&amp; objp))                                                              │<br>   │3479                    memset(objp, 0, obj_size(cachep));                                                               │<br>   │3480                                                                                                                     │<br>   │3481            return objp;                                                                                             │<br>   │3482    }                                                                                                                │<br>   │3483                                                                                                                     │<br>   │3484    /*                                                                                                               │<br>   │3485     * Caller needs to acquire correct kmem_list's list_lock                                                         │<br>   │3486     */                                                                                                              │<br>   │3487    static void free_block(struct kmem_cache *cachep, void **objpp, int nr_objects,                                  │<br>   │3488                           int node)                                                                                 │<br>   │3489    {                                                                                                                │<br>   │3490            int i;                                                                                                   │<br>   │3491            struct kmem_list3 *l3;                                                                                   │<br>   ┌─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐<br>   │0xc0172183 &lt;kmem_cache_alloc+100&gt;       cmpw   $0x0,-0x14(%ebp)                                                          │<br>   │0xc0172188 &lt;kmem_cache_alloc+105&gt;       jns    0xc01721a7 &lt;kmem_cache_alloc+136&gt;                                         │<br>   │0xc017218a &lt;kmem_cache_alloc+107&gt;       test   %edi,%edi                                                                 │<br>   │0xc017218c &lt;kmem_cache_alloc+109&gt;       je     0xc01721a7 &lt;kmem_cache_alloc+136&gt;                                         │<br>   │0xc017218e &lt;kmem_cache_alloc+111&gt;       mov    0x2c(%esi),%edx                                                           │<br>   │0xc0172191 &lt;kmem_cache_alloc+114&gt;       xor    %eax,%eax                                                                 │<br>   │0xc0172193 &lt;kmem_cache_alloc+116&gt;       mov    %edx,%ecx                                                                 │<br>   │0xc0172195 &lt;kmem_cache_alloc+118&gt;       shr    $0x2,%ecx                                                                 │<br>  &gt;│0xc0172198 &lt;kmem_cache_alloc+121&gt;       rep stos %eax,%es:(%edi)                                                         │<br>   │0xc017219a &lt;kmem_cache_alloc+123&gt;       test   $0x2,%dl                                                                  │<br>   │0xc017219d &lt;kmem_cache_alloc+126&gt;       je     0xc01721a1 &lt;kmem_cache_alloc+130&gt;                                         │<br>   │0xc017219f &lt;kmem_cache_alloc+128&gt;       stos   %ax,%es:(%edi)                                                            │<br>   │0xc01721a1 &lt;kmem_cache_alloc+130&gt;       test   $0x1,%dl                                                                  │<br>   │0xc01721a4 &lt;kmem_cache_alloc+133&gt;       je     0xc01721a7 &lt;kmem_cache_alloc+136&gt;                                         │<br>   └─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘<br>remote Thread 42000 In: kmem_cache_alloc                                                            Line: 183  PC: 0xc0172198 <br>#7  0xc037f008 in i386_start_kernel () at arch/x86/kernel/head32.c:13<br>#8  0x00000000 in ?? ()<br>(gdb) bt<br>#0  0xc0172198 in kmem_cache_alloc (cachep=0xdc404ec0, flags=&lt;value optimized out&gt;) at include/asm/string_32.h:183<br>#1  0xc01880db in alloc_vfsmnt (name=0xc031dcf3 "rootfs") at include/linux/slab.h:266<br>#2  0xc0176919 in vfs_kern_mount (type=0xc0359678, flags=0, name=0xc031dcf3 "rootfs", data=0x0) at fs/super.c:896<br>#3  0xc0176a2f in do_kern_mount (fstype=0xc031dcf3 "rootfs", flags=0, name=0xc031dcf3 "rootfs", data=0x0) at fs/super.c:968<br>#4  0xc0393b33 in mnt_init () at fs/namespace.c:2285<br>#5  0xc039382b in vfs_caches_init (mempages=108676) at fs/dcache.c:2212<br>#6  0xc037f868 in start_kernel () at init/main.c:666<br>#7  0xc037f008 in i386_start_kernel () at arch/x86/kernel/head32.c:13<br>#8  0x00000000 in ?? ()<br>(gdb) list<br>(gdb) disass<br>(gdb)  <br><br></pre>
</div>
<h2><a id="bug_与_oops" name="bug_与_oops">bug 与 OOPS</a></h2>
<div 
<div class="li" style="width:700px">
<p>［主要研究定位bug的技巧，找出是哪条指令引发了panic似乎很容易。但要找出错误产生的源头似乎是门艺术了］ </p>
<p>经过上面章节的叙述，本小节问题的解决已不成问题了。不再展开叙述。可以参考下面链接。 </p>
<p>参考手册 </p>
<p>“Using kgdb and the kgdb Internals” <a class="urlextern" title="http://www.kernel.org/pub/linux/kernel/people/jwessel/kgdb/index.html" href="http://www.kernel.org/pub/linux/kernel/people/jwessel/kgdb/index.html" rel="nofollow"><u><font color="#0000ff">http://www.kernel.org/pub/linux/kernel/people/jwessel/kgdb/index.html</font></u></a> </p>
<p>kgdb官网 <a class="urlextern" title="http://kgdb.linsyssoft.com/" href="http://kgdb.linsyssoft.com/" rel="nofollow"><u><font color="#0000ff">http://kgdb.linsyssoft.com/</font></u></a> </p>
<p>参考书籍（freeebsd） </p>
<p>“Debugging Kernel Problems” <a class="urlextern" title="http://www.google.cn/search?q=Debugging+Kernel+Problems&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=com.ubuntu:zh-CN:unofficial&amp;client=firefox-a" href="http://www.google.cn/search?q=Debugging+Kernel+Problems&ie=utf-8&oe=utf-8&aq=t&rls=com.ubuntu:zh-CN:unofficial&client=firefox-a" rel="nofollow"><u><font color="#0000ff">http://www.google.cn/search?q=Debugging+Kernel+Problems&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=com.ubuntu:zh-CN:unofficial&amp;client=firefox-a</font></u></a> </p>
<p>“Chapter 10 Kernel Debugging” <a class="urlextern" title="http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook/kerneldebug.html" href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook/kerneldebug.html" rel="nofollow"><u><font color="#0000ff">http://www.freebsd.org/doc/en_US.ISO8859-1/books/developers-handbook/kerneldebug.html</font></u></a> </p>
<p>参考书籍(linux) </p>
<p>Chapter 14. Kernel Debugging Techniques of “Embedded Linux Primer: A Practical, Real-World Approach” </p>
<p><a class="urlextern" title="http://book.opensourceproject.org.cn/embedded/embeddedprime/" href="http://book.opensourceproject.org.cn/embedded/embeddedprime/" rel="nofollow"><u><font color="#0000ff">http://book.opensourceproject.org.cn/embedded/embeddedprime/</font></u></a> </p>
<p>参考文章 </p>
<p>“掌握 Linux 调试技术” <a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/sdk/l-debug/index.html" href="http://www.ibm.com/developerworks/cn/linux/sdk/l-debug/index.html" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/sdk/l-debug/index.html</font></u></a> </p>
<p>“定位Oops的具体代码行” <a class="urlextern" title="http://blog.chinaunix.net/u/12592/showart_1092733.html" href="http://blog.chinaunix.net/u/12592/showart_1092733.html" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u/12592/showart_1092733.html</font></u></a> </p>
<p>“跟踪内核 oops” <a class="urlextern" title="http://wiki.zh-kernel.org/doc/oops-tracing.txt" href="http://wiki.zh-kernel.org/doc/oops-tracing.txt" rel="nofollow"><u><font color="#0000ff">http://wiki.zh-kernel.org/doc/oops-tracing.txt</font></u></a> </p>
<p>“例解Linux Kernel Debug” <a class="urlextern" title="http://blog.chinaunix.net/u/2108/showart_164703.html" href="http://blog.chinaunix.net/u/2108/showart_164703.html" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u/2108/showart_164703.html</font></u></a> </p>
<p>“kernel debug的一些小手段” <a class="urlextern" title="http://blog.chinaunix.net/u/12592/showart_499502.html" href="http://blog.chinaunix.net/u/12592/showart_499502.html" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u/12592/showart_499502.html</font></u></a> </p>
<p>“Kernel Debugging Techniques” <a class="urlextern" title="http://www.linuxjournal.com/article/9252" href="http://www.linuxjournal.com/article/9252" rel="nofollow"><u><font color="#0000ff">http://www.linuxjournal.com/article/9252</font></u></a> </p>
<p>［参考文章］有的已过时，而且深度不够。 </p>
</div>
<h4><a id="网站" name="网站">网站</a></h4>
<div 
<div class="li" style="width:700px">
<p><a class="urlextern" title="http://bugzilla.kernel.org/" href="http://bugzilla.kernel.org/" rel="nofollow"><u><font color="#0000ff">http://bugzilla.kernel.org/</font></u></a> </p>
<p><a class="urlextern" title="http://www.kerneloops.org/" href="http://www.kerneloops.org/" rel="nofollow"><u><font color="#0000ff">http://www.kerneloops.org/</font></u></a> </p>
<p><a class="urlextern" title="http://www.lkml.org/" href="http://www.lkml.org/" rel="nofollow"><u><font color="#0000ff">http://www.lkml.org/</font></u></a> 搜索bug </p>
</div>
<h2><a id="第二部分：内核分析" name="第二部分：内核分析">***第二部分：内核分析***</a></h2>
<div 
<div class="li" style="width:700px">
<p>这部分的内容侧重于内核原理分析，其中涉及gdb调试器的内容不是很多，但它起的作用很关键，主要用于观察内核数据的生成及变化，在对源码理解有困
惑时用于验证自己的猜想。另外，gdb一个很重要的功能是，拦截通过函数指针调用的函数，从而追溯整个调用链，交叉索引工具无法做到这点。 </p>
<p>另外，调试内核时，利用gdb的“list 函数名”命令看到的C代码都是当前处理器当前配置下内核实际运行的函数版本:”disass
函数名”看到的都是处理器实际运行时的机器代码，也就是说define语句和inline函数已经被编译器处理了，而且编译器也完成了优化。所以，gdb
本身就是一种不可替代的源码浏览工具，它能筛选掉出实际运行的函数版本，又能呈现出实际运行的机器码。 </p>
</div>
<h2><a id="调试相关子系统" name="调试相关子系统">调试相关子系统</a></h2>
<h3><a id="kgdb源码分析" name="kgdb源码分析">kgdb源码分析</a></h3>
<div 
<div class="li" style="width:700px">
<p>gdb远程串口协议 </p>
<p><a class="urlextern" title="http://sourceware.org/gdb/current/onlinedocs/gdb_34.html#SEC706" href="http://sourceware.org/gdb/current/onlinedocs/gdb_34.html#SEC706" rel="nofollow"><u><font color="#0000ff">http://sourceware.org/gdb/current/onlinedocs/gdb_34.html#SEC706</font></u></a> </p>
<p><a class="urlextern" title="http://www.huihoo.org/mirrors/pub/embed/document/debugger/ew_GDB_RSP.pdf" href="http://www.huihoo.org/mirrors/pub/embed/document/debugger/ew_GDB_RSP.pdf" rel="nofollow"><u><font color="#0000ff">http://www.huihoo.org/mirrors/pub/embed/document/debugger/ew_GDB_RSP.pdf</font></u></a> </p>
<p>Jason Wessel的linux-2.6-kgdb.git </p>
<p><a class="urlextern" title="http://git.kernel.org/?p=linux/kernel/git/jwessel/linux-2.6-kgdb.git;a=summary" href="http://git.kernel.org/?p=linux/kernel/git/jwessel/linux-2.6-kgdb.git;a=summary" rel="nofollow"><u><font color="#0000ff">http://git.kernel.org/?p=linux/kernel/git/jwessel/linux-2.6-kgdb.git;a=summary</font></u></a> </p>
<p>gdb调试模式 </p>
<pre class="file">(gdb) set debug serial 1<br>(gdb) set debug remote 1<br></pre>
</div>
<h3><a id="sysrq" name="sysrq">sysrq</a></h3>
<h3><a id="oprofile" name="oprofile">oprofile</a></h3>
<h3><a id="kprobes" name="kprobes">kprobes</a></h3>
<h2><a id="驱动分析" name="驱动分析">驱动分析</a></h2>
<div 
<div class="li" style="width:700px">
<p>［分析一个简单的驱动，观察函数调用流程。重点观察驱动与驱动模型，以及和系统内核的交互过程。比如，中断的整个生命周期。］ </p>
<p>参考： </p>
<p>“Debugging kernel modules” <a class="urlextern" title="http://lwn.net/Articles/90913/" href="http://lwn.net/Articles/90913/" rel="nofollow"><u><font color="#0000ff">http://lwn.net/Articles/90913/</font></u></a> </p>
<p>“Linux 系统内核的调试” <a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-kdb/" href="http://www.ibm.com/developerworks/cn/linux/l-kdb/" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-kdb/</font></u></a> </p>
<p>“Linux 可加载内核模块剖析” <a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-lkm/" href="http://www.ibm.com/developerworks/cn/linux/l-lkm/" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-lkm/</font></u></a> </p>
<p>“使用 KGDB 调试 Linux 内核” <a class="urlextern" title="http://blog.chinaunix.net/u/8057/showart_1087126.html" href="http://blog.chinaunix.net/u/8057/showart_1087126.html" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u/8057/showart_1087126.html</font></u></a> </p>
<p>“使用 /proc 文件系统来访问 Linux 内核的内容” <a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-proc.html" href="http://www.ibm.com/developerworks/cn/linux/l-proc.html" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-proc.html</font></u></a> </p>
<p>如何查找出当前系统所安装模块驱动对应的源码，从而对其做些修改等实验？ </p>
<p>提示： </p>
<p>1. lsmod 列出模块名 </p>
<p>2. modinfo 模块名， 查看模块信息 </p>
<p>3. 模块名，模块信息中的别名，模块的参数说明文字都可结合source
insight查找该模块的源码文件；模块信息中的模块路径也可用来定位对应源码的路径以及相关的kconfig文件，从而获取更多相关信息。一般源码文
件的名称就是模块名或在模块名的基础上加上某些后缀，用模块名的方法查找不出时再利用其他信息查找。 </p>
<p>4.
如果利用以上方法还找不到源文件，或者一个模块对应着几个源文件，可使用最后的必杀绝招。比如lsmod后得到一个sr_mod。我们用modinfo
sr_mod的得到它的已编译文件的路径是
/lib/modules/2.6.24-19-generic/kernel/drivers/scsi/sr_mod.ko
；把它拷贝出来，并用命令objdump -d sr_mod.ko
查看它的机器码，就可以知道它使用了哪些函数，利用这些函数名就可以结合source insight搜索出源码了。 </p>
</div>
<h3><a id="载入模块符号" name="载入模块符号">载入模块符号</a></h3>
<div 
<div class="li" style="width:700px">
<p>首先，在虚拟系统上装入目标模块foo，然后到/sys/module/foo/sections/下查看目标模块的section偏移地址信息. </p>
<p>实例 </p>
<pre class="file">debian:/sys/module/smplefs/sections# cat .text .data .bss<br>0xe01c7000<br>0xe01c864c<br>0xe01c8b20<br></pre>
<p>然后，到真机的gdb下用add-symbol-file命令装载目标模块的符号信息 格式如下 </p>
<pre class="file">    add-symbol-file /path/to/module 0xe01c7000 \  # .text<br> 		-s .data 0xe01c864c \<br>		-s .bss  0xe01c8b20<br><br></pre>
<p>实例 </p>
<pre class="file">(gdb) add-symbol-file  test/day11/samplefs.ko 0xe01c7000 -s .data 0xe01c864c -s .bss 0xe01c8b20<br>add symbol table from file "test/day11/samplefs.ko" at<br>	.text_addr = 0xe01c7000<br>	.data_addr = 0xe01c864c<br>	.bss_addr = 0xe01c8b20<br>(y or n) y<br>Reading symbols from /storage/myqemu/new/linux-2.6.26/test/day11/samplefs.ko...done.<br>(gdb) <br><br></pre>
<p>然后，余下的对模块的调试就类似对内核的调试了。 </p>
</div>
<h3><a id="seq_file.c的分析" name="seq_file.c的分析">seq_file.c的分析</a></h3>
<h3><a id="module.c的分析" name="module.c的分析">module.c的分析</a></h3>
<h3><a id="中断处理过程" name="中断处理过程">中断处理过程</a></h3>
<h2><a id="s3c24xx内存初始化分析" name="s3c24xx内存初始化分析">s3c24xx内存初始化分析</a></h2>
<div 
<div class="li" style="width:700px">
<p>[从这节开始，侧重于利用kgdb和source insight理解内核原理] ［网上好像没这个内容。只看源码的话，因为source insight不能解析汇编源文件，在汇编源码中定位到初始化的源头好像很难，利用调试器很容易做到这点］ </p>
</div>
<h2><a id="虚拟地址空间" name="虚拟地址空间">虚拟地址空间</a></h2>
<h3><a id="用户层的观察窗" name="用户层的观察窗">用户层的观察窗</a></h3>
<div 
<div class="li" style="width:700px">
<p>[待充实] </p>
<pre class="file">3G~4G虚拟地址空间的用途。（来自于qemu虚拟机的dmesg启动信息,500m物理内存）<br>&lt;4&gt;Zone PFN ranges:<br>&lt;4&gt;  DMA             0 -&gt;     4096<br>&lt;4&gt;  Normal       4096 -&gt;   127984<br>&lt;4&gt;  HighMem    127984 -&gt;   127984<br><br>&lt;6&gt;virtual kernel memory layout:<br>&lt;4&gt;    fixmap  : 0xfff4c000 - 0xfffff000   ( 716 kB)<br>&lt;4&gt;    pkmap   : 0xff800000 - 0xffc00000   (4096 kB)<br>&lt;4&gt;    vmalloc : 0xe0000000 - 0xff7fe000   ( 503 MB)<br>&lt;4&gt;    lowmem  : 0xc0000000 - 0xdf3f0000   ( 499 MB)<br>&lt;4&gt;      .init : 0xc037f000 - 0xc03bb000   ( 240 kB)<br>&lt;4&gt;      .data : 0xc02c0875 - 0xc03773ac   ( 730 kB)<br>&lt;4&gt;      .text : 0xc0100000 - 0xc02c0875   (1794 kB)<br><br>3G~4G虚拟地址空间的用途。（来自于qemu虚拟机的dmesg启动信息,897m物理内存）<br>&lt;4&gt;Zone PFN ranges:<br>&lt;4&gt;  DMA             0 -&gt;     4096<br>&lt;4&gt;  Normal       4096 -&gt;   229376<br>&lt;4&gt;  HighMem    229376 -&gt;   229616<br><br>&lt;6&gt;virtual kernel memory layout:<br>&lt;4&gt;    fixmap  : 0xfff4c000 - 0xfffff000   ( 716 kB)<br>&lt;4&gt;    pkmap   : 0xff800000 - 0xffc00000   (4096 kB)<br>&lt;4&gt;    vmalloc : 0xf8800000 - 0xff7fe000   ( 111 MB)<br>&lt;4&gt;    lowmem  : 0xc0000000 - 0xf8000000   ( 896 MB)<br>&lt;4&gt;      .init : 0xc037f000 - 0xc03bb000   ( 240 kB)<br>&lt;4&gt;      .data : 0xc02c0875 - 0xc03773ac   ( 730 kB)<br>&lt;4&gt;      .text : 0xc0100000 - 0xc02c0875   (1794 kB)<br><br>3G~4G虚拟地址空间的用途。（来自真机的dmesg启动信息,3G物理内存）<br>[    0.000000] Zone PFN ranges:<br>[    0.000000]   DMA             0 -&gt;     4096<br>[    0.000000]   Normal       4096 -&gt;   229376<br>[    0.000000]   HighMem    229376 -&gt;   786416<br><br>[   33.262853] virtual kernel memory layout:<br>[   33.262854]     fixmap  : 0xfff4b000 - 0xfffff000   ( 720 kB)<br>[   33.262855]     pkmap   : 0xff800000 - 0xffc00000   (4096 kB)<br>[   33.262856]     vmalloc : 0xf8800000 - 0xff7fe000   ( 111 MB)<br>[   33.262857]     lowmem  : 0xc0000000 - 0xf8000000   ( 896 MB)<br>[   33.262858]       .init : 0xc0421000 - 0xc047d000   ( 368 kB)<br>[   33.262859]       .data : 0xc03204c4 - 0xc041bdc4   (1006 kB)<br>[   33.262861]       .text : 0xc0100000 - 0xc03204c4   (2177 kB)<br><br><br><br>    top, 4G ---&gt;+-------------------+<br>                |                   |<br>                | malloc()'ed memory|<br>                |   interrupt stack | kernel<br>                |       data        |<br>                |       text        |<br>  kernel, 3G---&gt;+-------------------+<br>                |                   |<br>                |     argv,envp     |<br>                |     user stack    |<br>                |         |         |<br>                |         |         |<br>                |         v         |<br>                |                   | user process<br>                |         ^         |<br>                |         |         |<br>                |         |         |<br>                |        heap       |<br>                |        data       |<br>                |        text       |<br>   user, 0G---&gt; +-------------------+<br><br>          Layout of virtual address space<br><br></pre>
<p>我们验证一下用户空间的内容(上图的下部分)［未完，待续］ 引用于<a class="urlextern" title="http://linux.chinaunix.net/bbs/viewthread.php?tid=978491" href="http://linux.chinaunix.net/bbs/viewthread.php?tid=978491" rel="nofollow"><u><font color="#0000ff">http://linux.chinaunix.net/bbs/viewthread.php?tid=978491</font></u></a> </p>
<pre class="file">查看进程的虚拟地址空间是如何使用的。<br>该文件有6列，分别为：<br>地址：库在进程里地址范围<br>权限：虚拟内存的权限，r=读，w=写,x=,s=共享,p=私有；<br>偏移量：库在进程里地址范围<br>设备：映像文件的主设备号和次设备号；<br>节点：映像文件的节点号；<br>路径: 映像文件的路径<br>每项都与一个vm_area_struct结构成员对应，<br>－－－－<br>struct vm_area_struct {<br>	struct mm_struct * vm_mm;	/* The address space we belong to. */<br>	unsigned long vm_start;		/* Our start address within vm_mm. */<br>	unsigned long vm_end;		/* The first byte after our end address<br>					   within vm_mm. */<br><br>	/* linked list of VM areas per task, sorted by address */<br>	struct vm_area_struct *vm_next;<br><br>	pgprot_t vm_page_prot;		/* Access permissions of this VMA. */<br>	unsigned long vm_flags;		/* Flags, listed below. */<br><br>	struct rb_node vm_rb;<br><br>	/*<br>	 * For areas with an address space and backing store,<br>	 * linkage into the address_space-&gt;i_mmap prio tree, or<br>	 * linkage to the list of like vmas hanging off its node, or<br>	 * linkage of vma in the address_space-&gt;i_mmap_nonlinear list.<br>	 */<br>	union {<br>		struct {<br>			struct list_head list;<br>			void *parent;	/* aligns with prio_tree_node parent */<br>			struct vm_area_struct *head;<br>		} vm_set;<br><br>		struct raw_prio_tree_node prio_tree_node;<br>	} shared;<br><br>	/*<br>	 * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma<br>	 * list, after a COW of one of the file pages.	A MAP_SHARED vma<br>	 * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack<br>	 * or brk vma (with NULL file) can only be in an anon_vma list.<br>	 */<br>	struct list_head anon_vma_node;	/* Serialized by anon_vma-&gt;lock */<br>	struct anon_vma *anon_vma;	/* Serialized by page_table_lock */<br><br>	/* Function pointers to deal with this struct. */<br>	struct vm_operations_struct * vm_ops;<br><br>	/* Information about our backing store: */<br>	unsigned long vm_pgoff;		/* Offset (within vm_file) in PAGE_SIZE<br>					   units, *not* PAGE_CACHE_SIZE */<br>	struct file * vm_file;		/* File we map to (can be NULL). */<br>	void * vm_private_data;		/* was vm_pte (shared mem) */<br>	unsigned long vm_truncate_count;/* truncate_count or restart_addr */<br><br>#ifndef CONFIG_MMU<br>	atomic_t vm_usage;		/* refcount (VMAs shared if !MMU) */<br>#endif<br>#ifdef CONFIG_NUMA<br>	struct mempolicy *vm_policy;	/* NUMA policy for the VMA */<br>#endif<br><br></pre>
<pre class="file">[todo 换个简单的程序]<br>$ ps -aux | grep firefox<br>Warning: bad ps syntax, perhaps a bogus '-'? See http://procps.sf.net/faq.html<br>fqh       8230  4.7  2.5 205872 80024 ?        Tl   14:54   0:19 /usr/lib/firefox-3.0.1/firefox<br>fqh       8313  0.0  0.0   3220   764 pts/1    R+   15:01   0:00 grep firefox<br><br><br>(gdb) attach 8230<br>...<br>.....<br>Loaded symbols for /usr/lib/libflashsupport.so<br>Reading symbols from /usr/lib/libpulse.so.0...(no debugging symbols found)...done.<br>Loaded symbols for /usr/lib/libpulse.so.0<br>Reading symbols from /lib/libcap.so.1...(no debugging symbols found)...done.<br>Loaded symbols for /lib/libcap.so.1<br><br><br>(no debugging symbols found)<br>0xb7f24410 in __kernel_vsyscall ()<br>(gdb) bt<br>#0  0xb7f24410 in __kernel_vsyscall ()<br>#1  0xb7d46c07 in poll () from /lib/tls/i686/cmov/libc.so.6<br>#2  0xb6b4e1c6 in ?? () from /usr/lib/libglib-2.0.so.0<br>#3  0xb6b4e74e in g_main_context_iteration () from /usr/lib/libglib-2.0.so.0<br>#4  0xb77ba87c in ?? () from /usr/lib/xulrunner-1.9.0.1/libxul.so<br>#5  0xb77cf624 in ?? () from /usr/lib/xulrunner-1.9.0.1/libxul.so<br>#6  0xb77cfa6f in ?? () from /usr/lib/xulrunner-1.9.0.1/libxul.so<br>#7  0xb787ecd6 in ?? () from /usr/lib/xulrunner-1.9.0.1/libxul.so<br>#8  0xb784e31f in ?? () from /usr/lib/xulrunner-1.9.0.1/libxul.so<br>#9  0xb77cf75e in ?? () from /usr/lib/xulrunner-1.9.0.1/libxul.so<br>#10 0xb765f122 in ?? () from /usr/lib/xulrunner-1.9.0.1/libxul.so<br>#11 0xb70b3a88 in XRE_main () from /usr/lib/xulrunner-1.9.0.1/libxul.so<br>#12 0x08049033 in ?? ()<br>#13 0xb7c90450 in __libc_start_main () from /lib/tls/i686/cmov/libc.so.6<br>#14 0x08048cc1 in ?? ()<br>(gdb) <br><br><br>$ cat /proc/8230/maps<br>08048000-0804f000 r-xp 00000000 08:01 7022914    /usr/lib/firefox-3.0.1/firefox  &lt;-text,注意标志 可读可执行不可写私有<br>0804f000-08050000 rw-p 00006000 08:01 7022914    /usr/lib/firefox-3.0.1/firefox  &lt;-data,注意标志 可读可写不可执行<br>08050000-0abd4000 rw-p 08050000 00:00 0          [heap]                          &lt;-heap，一共45.5多MB［todo:验证向上增长］可读可写不可执行<br>ae060000-ae063000 r-xp 00000000 08:01 6941098    /usr/lib/libflashsupport.so     &lt;-libflashsupport.so 共享库的代码段， 可读可执行不可写<br>ae063000-ae064000 rw-p 00002000 08:01 6941098    /usr/lib/libflashsupport.so     &lt;-libflashsupport.so 共享库的数据段， 可读可写不可执行<br>.....<br>..<br>b7f20000-b7f21000 rw-p 00001000 08:01 6942869    /usr/lib/libplds4.so.0d<br>b7f21000-b7f22000 r--p 00000000 08:01 6966184    /usr/lib/locale/zh_CN.utf8/LC_IDENTIFICATION<br>b7f22000-b7f24000 rw-p b7f22000 00:00 0 <br>b7f24000-b7f25000 r-xp b7f24000 00:00 0          [vdso]<br>b7f25000-b7f3f000 r-xp 00000000 08:01 2326545    /lib/ld-2.7.so<br>b7f3f000-b7f41000 rw-p 00019000 08:01 2326545    /lib/ld-2.7.so<br>bfbcd000-bfc0a000 rw-p bffc3000 00:00 0          [stack]                         &lt;-stack，不到0.24MB，可读可执行不可写［todo:验证向下增长］<br>                                                                                 ［todo:验证argv,envp］ <br>$<br></pre>
</div>
<h3><a id="交互，从内核层分析" name="交互，从内核层分析">交互，从内核层分析</a></h3>
<div 
<div class="li" style="width:700px">
<p>[扩展] </p>
</div>
<h2><a id="理解设备模型" name="理解设备模型">理解设备模型</a></h2>
<div 
<div class="li" style="width:700px">
<p>［结合source insight分析一个内核子系统的原理。源码分析工具虽好，但却是个死的东西，不能实时观察数据的生成和变化。如果在内核运行的时候，搭配调试器来分析，这个过程一定很形象和有趣］ </p>
</div>
<h3><a id="面向对象的实现" name="面向对象的实现">面向对象的实现</a></h3>
<h3><a id="设备模型的分层" name="设备模型的分层">设备模型的分层</a></h3>
<h3><a id="外围支持机制" name="外围支持机制">外围支持机制</a></h3>
<h4><a id="sysfs" name="sysfs">sysfs</a></h4>
<h4><a id="hotplug" name="hotplug">hotplug</a></h4>
<h2><a id="文件系统" name="文件系统">文件系统</a></h2>
<div 
<div class="li" style="width:700px">
<p>参考书籍： </p>
<p>UNIX Filesystems Evolution, Design, and Implementation.pdf : </p>
<p><a class="urlextern" title="http://www.google.cn/search?q=UNIX+Filesystems+Evolution%2C+Design%2C+and+Implementation&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=com.ubuntu:zh-CN:unofficial&amp;client=firefox-a" href="http://www.google.cn/search?q=UNIX+Filesystems+Evolution%2C+Design%2C+and+Implementation&ie=utf-8&oe=utf-8&aq=t&rls=com.ubuntu:zh-CN:unofficial&client=firefox-a" rel="nofollow"><u><font color="#0000ff">http://www.google.cn/search?q=UNIX+Filesystems+Evolution%2C+Design%2C+and+Implementation&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=com.ubuntu:zh-CN:unofficial&amp;client=firefox-a</font></u></a> </p>
<p>站点： </p>
<p>Ext4 (and Ext2/Ext3) Wiki: <a class="urlextern" title="http://ext4.wiki.kernel.org/index.php/Main_Page" href="http://ext4.wiki.kernel.org/index.php/Main_Page" rel="nofollow"><u><font color="#0000ff">http://ext4.wiki.kernel.org/index.php/Main_Page</font></u></a> </p>
<p>Ext4 Development project: <a class="urlextern" title="http://www.bullopensource.org/ext4/" href="http://www.bullopensource.org/ext4/" rel="nofollow"><u><font color="#0000ff">http://www.bullopensource.org/ext4/</font></u></a> </p>
<p>ext2-devel maillist archive: <a class="urlextern" title="http://sourceforge.net/mailarchive/forum.php?forum=ext2-devel" href="http://sourceforge.net/mailarchive/forum.php?forum=ext2-devel" rel="nofollow"><u><font color="#0000ff">http://sourceforge.net/mailarchive/forum.php?forum=ext2-devel</font></u></a> </p>
<p>参考文章： </p>
<p>“Linux Filesystems in 21 days 45 minutes” <a class="urlextern" title="http://us1.samba.org/samba/ftp/cifs-cvs/ols2006-fs-tutorial-smf.pdf" href="http://us1.samba.org/samba/ftp/cifs-cvs/ols2006-fs-tutorial-smf.pdf" rel="nofollow"><u><font color="#0000ff">http://us1.samba.org/samba/ftp/cifs-cvs/ols2006-fs-tutorial-smf.pdf</font></u></a> </p>
</div>
<h2><a id="第三部分：其他工具" name="第三部分：其他工具">***第三部分：其他工具***</a></h2>
<h2><a id="strace" name="strace">strace</a></h2>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">作用: strace能拦截和记录应用程序发起的系统调用和它收到的信号。主要用于观察应用层和内核层的交互。</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">命令选项: 查看，$strace –help 或$man strace 或 $info strace</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">实例</div>
</li>
</ul>
</div>
<h2><a id="ltrace" name="ltrace">ltrace</a></h2>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">作用: ltrace用于监控程序发起的库函数调用以及程序收到的信号。</div>
</li>
</ul>
</div>
<h2><a id="systemtap" name="systemtap">SystemTap</a></h2>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">动态收集Linux内核信息和性能数据</div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">官方 <a class="urlextern" title="http://sourceware.org/systemtap/" href="http://sourceware.org/systemtap/" rel="nofollow"><u><font color="#0000ff">http://sourceware.org/systemtap/</font></u></a></div>
</li>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">参考文章 </div>
</li>
</ul>
<p><a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-cn-systemtap3/index.html" href="http://www.ibm.com/developerworks/cn/linux/l-cn-systemtap3/index.html" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-cn-systemtap3/index.html</font></u></a> </p>
<p><a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-systemtap/index.html" href="http://www.ibm.com/developerworks/cn/linux/l-systemtap/index.html" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-systemtap/index.html</font></u></a> </p>
<p><a class="urlextern" title="http://sourceware.org/systemtap/tutorial/" href="http://sourceware.org/systemtap/tutorial/" rel="nofollow"><u><font color="#0000ff">http://sourceware.org/systemtap/tutorial/</font></u></a> </p>
<p><a class="urlextern" title="http://sourceware.org/systemtap/wiki" href="http://sourceware.org/systemtap/wiki" rel="nofollow"><u><font color="#0000ff">http://sourceware.org/systemtap/wiki</font></u></a> </p>
<p>ubuntu下的配置安装： <a class="urlextern" title="http://sourceware.org/systemtap/wiki/SystemtapOnUbuntu" href="http://sourceware.org/systemtap/wiki/SystemtapOnUbuntu" rel="nofollow"><u><font color="#0000ff">http://sourceware.org/systemtap/wiki/SystemtapOnUbuntu</font></u></a> </p>
</div>
<h2><a id="memwatch" name="memwatch">MEMWATCH</a></h2>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">作用: 跟踪程序中的内存泄漏和错误</div>
</li>
</ul>
</div>
<h2><a id="yamd" name="yamd">YAMD</a></h2>
<div 
<ul>
<li clas style="width:700px">
<ul>
<li 
<div class="li" style="width:700px">
<div class="li" style="width:700px">作用: 查找 C 和 C++ 中动态的、与内存分配有关的问题</div>
</li>
</ul>
</div>
<h2><a id="magic_sysrq" name="magic_sysrq">Magic SysRq</a></h2>
<div 
<div class="li" style="width:700px">
<p>内核文档 sysrq.txt </p>
<p><a class="urlextern" title="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;f=Documentation/sysrq.txt;h=10a0263ebb3f01e832c7827cc75d7fe54b341a6f;hb=f8d56f1771e4867acc461146764b4feeb5245669" href="http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;f=Documentation/sysrq.txt;h=10a0263ebb3f01e832c7827cc75d7fe54b341a6f;hb=f8d56f1771e4867acc461146764b4feeb5245669" rel="nofollow"><u><font color="#0000ff">http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blob;f=Documentation/sysrq.txt;h=10a0263ebb3f01e832c7827cc75d7fe54b341a6f;hb=f8d56f1771e4867acc461146764b4feeb5245669</font></u></a> </p>
<p>linux内核测试指南 相关章节 </p>
<p><a class="urlextern" title="http://wiki.zh-kernel.org/#%E6%96%87%E7%AB%A0" href="http://wiki.zh-kernel.org/#%E6%96%87%E7%AB%A0" rel="nofollow"><u><font color="#800080">http://wiki.zh-kernel.org/#%E6%96%87%E7%AB%A0</font></u></a> </p>
</div>
<h2><a id="附录：社区交流相关" name="附录：社区交流相关">附录：社区交流相关</a></h2>
<h3><a id="补丁提交相关文档" name="补丁提交相关文档">补丁提交相关文档</a></h3>
<div 
<div class="li" style="width:700px">
<p>如何参与 Linux 内核开发 </p>
<p><a class="urlextern" title="http://wiki.zh-kernel.org/doc/howto" href="http://wiki.zh-kernel.org/doc/howto" rel="nofollow"><u><font color="#0000ff">http://wiki.zh-kernel.org/doc/howto</font></u></a> </p>
<p>Linux内核代码风格 </p>
<p><a class="urlextern" title="http://wiki.zh-kernel.org/doc/codingstyle" href="http://wiki.zh-kernel.org/doc/codingstyle" rel="nofollow"><u><font color="#0000ff">http://wiki.zh-kernel.org/doc/codingstyle</font></u></a> </p>
<p>Linux内核开发邮件客户端资料 </p>
<p><a class="urlextern" title="http://wiki.zh-kernel.org/doc/email-clients.txt" href="http://wiki.zh-kernel.org/doc/email-clients.txt" rel="nofollow"><u><font color="#0000ff">http://wiki.zh-kernel.org/doc/email-clients.txt</font></u></a> </p>
<p>Linux内核补丁提交注意事项 </p>
<p><a class="urlextern" title="http://wiki.zh-kernel.org/doc/linux%E5%86%85%E6%A0%B8%E8%A1%A5%E4%B8%81%E6%8F%90%E4%BA%A4%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" href="http://wiki.zh-kernel.org/doc/linux%E5%86%85%E6%A0%B8%E8%A1%A5%E4%B8%81%E6%8F%90%E4%BA%A4%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow"><u><font color="#0000ff">http://wiki.zh-kernel.org/doc/linux%E5%86%85%E6%A0%B8%E8%A1%A5%E4%B8%81%E6%8F%90%E4%BA%A4%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9</font></u></a> </p>
<p>基于git的Gentoo中文文档开发流程 </p>
<p><a class="urlextern" title="http://www.gentoo-cn.org/doc/zh_cn/git-howto.xml" href="http://www.gentoo-cn.org/doc/zh_cn/git-howto.xml" rel="nofollow"><u><font color="#0000ff">http://www.gentoo-cn.org/doc/zh_cn/git-howto.xml</font></u></a> </p>
<p>mutt配置使用 </p>
<p><a class="urlextern" title="http://hi.baidu.com/springtty/blog/item/e6b25ddbb52f51ddb7fd4805.html" href="http://hi.baidu.com/springtty/blog/item/e6b25ddbb52f51ddb7fd4805.html" rel="nofollow"><u><font color="#0000ff">http://hi.baidu.com/springtty/blog/item/e6b25ddbb52f51ddb7fd4805.html</font></u></a> </p>
<p><a class="urlextern" title="http://www.kongove.cn/blog/?p=149" href="http://www.kongove.cn/blog/?p=149" rel="nofollow"><u><font color="#0000ff">http://www.kongove.cn/blog/?p=149</font></u></a> </p>
<p><a class="urlextern" title="http://www.kongove.cn/blog/?p=229" href="http://www.kongove.cn/blog/?p=229" rel="nofollow"><u><font color="#0000ff">http://www.kongove.cn/blog/?p=229</font></u></a> </p>
<p><a class="urlextern" title="http://www.kongove.cn/blog/?p=225" href="http://www.kongove.cn/blog/?p=225" rel="nofollow"><u><font color="#0000ff">http://www.kongove.cn/blog/?p=225</font></u></a> </p>
</div>
<h3><a id="补丁制作与提交示范" name="补丁制作与提交示范">补丁制作与提交示范</a></h3>
<div 
<div class="li" style="width:700px">
<p>说明：这个补丁本是用web-gmail发的。后来发现web-gmail遇到一行字数很长的补丁时，会导致补丁格式错误。本人决定以后使用
claws，看的是它有线索成组的功能和草稿上有字数的标尺。内核社区中使用的邮件客户端大多数是mutt（并不是专指发补丁）。发补丁的所用工具也多种
多样，有用各种邮件客户端的(mutt,claws,kmail...)，有使用git-send-email的，还有使用quilt的，真是打开眼界。
</p>
<p>另外本人感觉claws比Sylpheed要快上几十倍。claws本来是Sylpheed的实验版，后来独立出来了。 </p>
<p>补丁的任务 </p>
<pre class="file">mm/oom_kill.c:badness（）函数<br><br>/**<br> * badness - calculate a numeric value for how bad this task has been<br> * @p: task struct of which task we should calculate<br> * @uptime: current uptime in seconds<br> * @mem: target memory controller//&lt;-Li Zefan大侠上次提交了一个补丁，去掉了badness()的这个参数，<br>                                   但是忘了删除该参数的说明了。现在的任务是提交补丁把它删除掉<br> *<br>...省略<br> */<br><br>unsigned long badness(struct task_struct *p, unsigned long uptime)<br>{<br></pre>
<p>过程 </p>
<pre class="file">1. 进入git树<br>XXX@ubuntu:~$ cd /storage/linus-git/linux-2.6/<br>XXX@ubuntu:/storage/linus-git/linux-2.6$ <br><br>2. 更新git树<br>XXX@ubuntu:/storage/linus-git/linux-2.6$ git-pull<br>Already up-to-date.<br><br>3. 修改目标源码<br>XXX@ubuntu:/storage/linus-git/linux-2.6$ vi mm/oom_kill.c <br>删除掉那个参数说明后结束vi,返回到shell下<br><br>4. 制作补丁<br>XXX@ubuntu:/storage/linus-git/linux-2.6$ git-diff &gt; ../oom_kill.patch<br><br>5. 还原git树<br>XXX@ubuntu:/storage/linus-git/linux-2.6$ patch -p1 &lt; ../oom_kill.patch -R<br>patching file mm/oom_kill.c<br><br>还原的方法或者采用下面方式<br>XXX@ubuntu:/storage/linus-git/linux-2.6$ git-gui<br>界面出来后，点击Branch-&gt;reset<br><br>6.点击compose新建邮件<br><br>7. 点击insert file 载入补丁文件<br>diff --git a/mm/oom_kill.c b/mm/oom_kill.c<br>index 64e5b4b..460f90e 100644<br>--- a/mm/oom_kill.c<br>+++ b/mm/oom_kill.c<br>@@ -38,7 +38,6 @@ static DEFINE_SPINLOCK(zone_scan_mutex);<br>  * badness - calculate a numeric value for how bad this task has been<br>  * @p: task struct of which task we should calculate<br>  * @uptime: current uptime in seconds<br>- * @mem: target memory controller<br>  *<br>  * The formula used is relatively simple and documented inline in the<br>  * function. The main rationale is that we want to select a good task<br><br>8. 补全其他信息，比如 标题，to, cc等，还有信件内容<br>本例是：<br>标题起为：[PATCH]mm/oom_kill.c: cleanup kerneldoc of badness() <br>         //为讨好Randy.Dunlap，特意写了字眼kerneldoc，因为他是主管内核文档的<br><br>to "Randy.Dunlap" &lt;rdunlap@xenotime.net&gt; <br>//收件人是谁得根据补丁的性质查看内核源码中的MAINTAINERS文件，<br>//难以确认是谁时，可以到linus-git的web-git下参看你修改文件的历史记录，看别人是发给谁的<br>cc linux-kernel@vger.kernel.org, //这个一定要有<br>linux-mm@kvack.org               //修改文件所在的子系统的邮件列表，当收件人写错时，<br>                                 //子系统的头目们可能会注意到和接受你的补丁  <br><br>邮件本身处理后变成下面的格式<br>Paramter @mem has been removed since v2.6.26, now delete it's comment. //补丁的作用<br><br>Signed-off-by: your-name &lt;your-address@gmail.com&gt;                //你的签收<br>---              //三个'-'，表示下面的内容是补丁了。应用补丁的工具会根据这个标志提取补丁。<br>diff --git a/mm/oom_kill.c b/mm/oom_kill.c<br>index 64e5b4b..460f90e 100644<br>--- a/mm/oom_kill.c<br>+++ b/mm/oom_kill.c<br>@@ -38,7 +38,6 @@ static DEFINE_SPINLOCK(zone_scan_mutex);<br>  * badness - calculate a numeric value for how bad this task has been<br>  * @p: task struct of which task we should calculate<br>  * @uptime: current uptime in seconds<br>- * @mem: target memory controller<br>  *<br>  * The formula used is relatively simple and documented inline in the<br>  * function. The main rationale is that we want to select a good task<br><br>9. 然后发信<br><br>10. 等待回复<br>Randy Dunla果然勤快，两个小时不到就收到了他的信件<br>Acked-by: Randy Dunlap &lt;rdunlap@xenotime.net&gt;<br>Thanks.<br><br>说明：<br>Acked-by表示他认为补丁正确，但并不自己接收。 维护者回复applied才算是接受了。<br>当然如果得到比较有威望的人acked-by，被接受的可能性就大大的提高了。--Li Yang大牛<br><br>看来，我把补丁的维护人搞错了，因为Randy Dunlap并没领我的情:(<br><br>注意，这个不能急。有的补丁或许是因为太微小，对方都没回复你，其实他已经收录了你的补丁。<br>到子系统树向linus的git树合并时就会看到你的补丁(通常会在LKML中有个集体通告，说明<br>这批补丁中包含了哪些内容。)。等一个多星期无妨。<br><br>后记：过了三四天后，收到了一封信如下。这是mm树的邮件系统发来的。可见Randy Dunlap<br>把这个补丁提交给mm树了。在mm树经过验证补丁正确后就会再汇合到linus的主线树中。这是<br>补丁接受的一种方式。当然，我遇到的情况有，子系统维护人回复你applied to xx(树)，<br>然后该负责人就要求linus merge他的树，这样就收不到mm树的通知信。甚至有时子系统维护<br>人接受补丁了都不吭一声，然后补丁又是直接merge到主线树中。补丁接受的流程大概就这样了。<br><br>From: akpm@linux-foundation.org<br>To: mm-commits@vger.kernel.org<br>Cc: qhfeng.kernel@gmail.com, rdunlap@xenotime.net<br>Subject: + mm-oom_killc-fix-badness-kerneldoc.patch added to -mm tree<br>Date: Thu, 30 Oct 2008 14:47:53 -0700<br><br><br>The patch titled<br>     mm/oom_kill.c: fix badness() kerneldoc<br>has been added to the -mm tree.  Its filename is<br>     mm-oom_killc-fix-badness-kerneldoc.patch<br>....省略<br><br>The current -mm tree may be found at http://userweb.kernel.org/~akpm/mmotm/<br><br>------------------------------------------------------<br>Subject: mm/oom_kill.c: fix badness() kerneldoc<br>From: Qinghuang Feng &lt;qhfeng.kernel@gmail.com&gt;<br><br>Paramter @mem has been removed since v2.6.26, now delete it's comment.<br><br>Signed-off-by: Qinghuang Feng &lt;qhfeng.kernel@gmail.com&gt;<br>Acked-by: Randy Dunlap &lt;rdunlap@xenotime.net&gt;<br>Signed-off-by: Andrew Morton &lt;akpm@linux-foundation.org&gt;<br>---<br><br>...补丁内容省略<br>_<br><br>Patches currently in -mm which might be from qhfeng.kernel@gmail.com are<br><br>origin.patch<br>mm-oom_killc-fix-badness-kerneldoc.patch<br>linux-next.patch<br><br></pre>
</div>
<h3><a id="git使用" name="git使用">git使用</a></h3>
<div 
<div class="li" style="width:700px">
<p>Git 中文教程 </p>
<p><a class="urlextern" title="http://www.linuxsir.org/main/doc/git/gittutorcn.htm" href="http://www.linuxsir.org/main/doc/git/gittutorcn.htm" rel="nofollow"><u><font color="#0000ff">http://www.linuxsir.org/main/doc/git/gittutorcn.htm</font></u></a> </p>
<p>git使用小结 </p>
<p><a class="urlextern" title="http://wangcong.org/blog/?p=307" href="http://wangcong.org/blog/?p=307" rel="nofollow"><u><font color="#0000ff">http://wangcong.org/blog/?p=307</font></u></a> </p>
<p>学习 Git </p>
<p><a class="urlextern" title="http://www.zeuux.org/science/learning-git.cn.html" href="http://www.zeuux.org/science/learning-git.cn.html" rel="nofollow"><u><font color="#0000ff">http://www.zeuux.org/science/learning-git.cn.html</font></u></a> </p>
</div>
<h2><a id="附录：内核参考书籍文章" name="附录：内核参考书籍文章">附录：内核参考书籍文章</a></h2>
<div 
<div class="li" style="width:700px">
<p>内核git库： </p>
<p><a class="urlextern" title="http://git.kernel.org/?p=linux/kernel/git" href="http://git.kernel.org/?p=linux/kernel/git" rel="nofollow"><u><font color="#0000ff">http://git.kernel.org/?p=linux/kernel/git</font></u></a> </p>
<p>综合类： </p>
<p>“understanding the linux kernel” </p>
<p>”linux kernel development“ </p>
<p>“linux源代码情景分析” </p>
<p>“Embedded.Linux.Primer.A.Practical.Real.World.Approach.” </p>
<p>“The_Linux_Kernel_Primer_A_Top_Down_Approach_For_x86_and_PowerPC_Architectures” </p>
<p>子系统类： </p>
<p>文件系统： </p>
<p>“UNIX Filesystems Evolution, Design, and Implementation” </p>
<p>“File System Forensic Analysis” </p>
<p>“Windows NT File System Internals” </p>
<p>内存管理： </p>
<p>“Understanding The Linux Virtual Memory Manager” </p>
<p>网络系统： </p>
<p>“The Linux? Networking Architecture: Design and Implementation of Network Protocols in the Linux Kernel” </p>
<p>“Understanding.Linux.Network.Internals” </p>
<p>驱动开发: </p>
<p>“linux device drivers” </p>
<p>“Essential.Linux.Device.Drivers” </p>
<p>源码本身及附带文档 </p>
<p>参考文章: </p>
<p>IBM-Linux 相关专题 <a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/" href="http://www.ibm.com/developerworks/cn/linux/" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/</font></u></a> “Debugging Kernel Modules with User Mode Linux” </p>
<p><a class="urlextern" title="http://www.linuxjournal.com/article/5749" href="http://www.linuxjournal.com/article/5749" rel="nofollow"><u><font color="#0000ff">http://www.linuxjournal.com/article/5749</font></u></a> </p>
<p>“Debugging Memory on Linux” <a class="urlextern" title="http://www.linuxjournal.com/article/4681" href="http://www.linuxjournal.com/article/4681" rel="nofollow"><u><font color="#0000ff">http://www.linuxjournal.com/article/4681</font></u></a> </p>
<p>“DDD—Data Display Debugger” <a class="urlextern" title="http://www.linuxjournal.com/article/2315" href="http://www.linuxjournal.com/article/2315" rel="nofollow"><u><font color="#0000ff">http://www.linuxjournal.com/article/2315</font></u></a> </p>
<p>“Linux 系统内核的调试” <a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-kdb/" href="http://www.ibm.com/developerworks/cn/linux/l-kdb/" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-kdb/</font></u></a> </p>
<p>System Dump和Core Dump的区别 <a class="urlextern" title="http://hi.baidu.com/iruler/blog/item/c203de3522ff398ea61e122c.html" href="http://hi.baidu.com/iruler/blog/item/c203de3522ff398ea61e122c.html" rel="nofollow"><u><font color="#0000ff">http://hi.baidu.com/iruler/blog/item/c203de3522ff398ea61e122c.html</font></u></a> </p>
<p><a class="urlextern" title="http://www.linuxjournal.com/user/800887/track" href="http://www.linuxjournal.com/user/800887/track" rel="nofollow"><u><font color="#0000ff">http://www.linuxjournal.com/user/800887/track</font></u></a> </p>
<p><a class="urlextern" title="http://www.linuxjournal.com/" href="http://www.linuxjournal.com/" rel="nofollow"><u><font color="#0000ff">http://www.linuxjournal.com/</font></u></a> <a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html" href="http://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-devmapper/index.html</font></u></a> </p>
<p>read 系统调用剖析 <a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-cn-read/index.html" href="http://www.ibm.com/developerworks/cn/linux/l-cn-read/index.html" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-cn-read/index.html</font></u></a> </p>
<p><a class="urlextern" title="http://blog.chinaunix.net/u/4206/showart_501237.html" href="http://blog.chinaunix.net/u/4206/showart_501237.html" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u/4206/showart_501237.html</font></u></a> </p>
<p><a class="urlextern" title="http://hi.baidu.com/linux%5Fkernel/blog/category/pci%C9%E8%B1%B8%C7%FD%B6%AF" href="http://hi.baidu.com/linux_kernel/blog/category/pci%C9%E8%B1%B8%C7%FD%B6%AF" rel="nofollow"><u><font color="#0000ff">http://hi.baidu.com/linux%5Fkernel/blog/category/pci%C9%E8%B1%B8%C7%FD%B6%AF</font></u></a> </p>
<p><a class="urlextern" title="http://wiki.jk2410.org/wiki/Main_Page" href="http://wiki.jk2410.org/wiki/Main_Page" rel="nofollow"><u><font color="#0000ff">http://wiki.jk2410.org/wiki/Main_Page</font></u></a> </p>
<p><a class="urlextern" title="http://www.ibm.com/developerworks/cn/linux/l-cn-clocks/index.html" href="http://www.ibm.com/developerworks/cn/linux/l-cn-clocks/index.html" rel="nofollow"><u><font color="#0000ff">http://www.ibm.com/developerworks/cn/linux/l-cn-clocks/index.html</font></u></a> </p>
<p>利用Vmware5.5.1 和 kgdb调试 x86平台的kernel </p>
<p><a class="urlextern" title="http://blog.chinaunix.net/u/22617/showart_338509.html" href="http://blog.chinaunix.net/u/22617/showart_338509.html" rel="nofollow"><u><font color="#0000ff">http://blog.chinaunix.net/u/22617/showart_338509.html</font></u></a> </p>
<p>Welcome to Linux From Scratch </p>
<p><a class="urlextern" title="http://www.linuxfromscratch.org/" href="http://www.linuxfromscratch.org/" rel="nofollow"><u><font color="#0000ff">http://www.linuxfromscratch.org/</font></u></a> </p>
<p>Unreliable Guide To Locking </p>
<p><a class="urlextern" title="http://www.kernel.org/pub/linux/kernel/people/rusty/kernel-locking/index.html" href="http://www.kernel.org/pub/linux/kernel/people/rusty/kernel-locking/index.html" rel="nofollow"><u><font color="#0000ff">http://www.kernel.org/pub/linux/kernel/people/rusty/kernel-locking/index.html</font></u></a> </p>
<p>How do I printk &lt;type&gt; correctly? </p>
<p><a class="urlextern" title="http://lkml.org/lkml/2008/10/23/132" href="http://lkml.org/lkml/2008/10/23/132" rel="nofollow"><u><font color="#0000ff">http://lkml.org/lkml/2008/10/23/132</font></u></a> </p>
<p>KernelJanitors/Todo </p>
<p><a class="urlextern" title="http://kernelnewbies.org/KernelJanitors/Todo" href="http://kernelnewbies.org/KernelJanitors/Todo" rel="nofollow"><u><font color="#800080">http://kernelnewbies.org/KernelJanitors/Todo</font></u></a> </p>
<p>Coccinelle - a Framework for Linux Device Driver Evolution </p>
<p><a class="urlextern" title="http://www.emn.fr/x-info/coccinelle/" href="http://www.emn.fr/x-info/coccinelle/" rel="nofollow"><u><font color="#0000ff">http://www.emn.fr/x-info/coccinelle/</font></u></a> </p>
<p>linux论文 <a class="urlextern" title="http://www.linuxsymposium.org" href="http://www.linuxsymposium.org/" rel="nofollow"><u><font color="#0000ff">http://www.linuxsymposium.org</font></u></a> </p>
<p><a class="urlextern" title="http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf" href="http://www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf" rel="nofollow"><u><font color="#0000ff">www.linuxsymposium.org/2006/linuxsymposium_procv2.pdf</font></u></a> </p>
<p><a class="urlextern" title="http://www.linuxsymposium.org/2006/linuxsymposium_procv1.pdf" href="http://www.linuxsymposium.org/2006/linuxsymposium_procv1.pdf" rel="nofollow"><u><font color="#0000ff">www.linuxsymposium.org/2006/linuxsymposium_procv1.pdf</font></u></a> </p>
<p>understanding the linux kernel 在线文档 </p>
<p><a class="urlextern" title="http://www.linux-security.cn/ebooks/ulk3-html/" href="http://www.linux-security.cn/ebooks/ulk3-html/" rel="nofollow"><u><font color="#0000ff">http://www.linux-security.cn/ebooks/ulk3-html/</font></u></a> </p>
<p>Data Structures and Algorithms with Object-Oriented Design Patterns in C++/Java/C#/Python/Ruby/Lua/<acronym title="Practical Extraction and Report Language">Perl</acronym>/<acronym title="Hypertext Preprocessor">PHP</acronym> </p>
<p><a class="urlextern" title="http://www.brpreiss.com/books/opus4/" href="http://www.brpreiss.com/books/opus4/" rel="nofollow"><u><font color="#0000ff">http://www.brpreiss.com/books/opus4/</font></u></a> </p>
<p><a class="urlextern" title="ftp://ftp.akaedu.org/../1.html" href="ftp://ftp.akaedu.org/1.html" rel="nofollow"><u><font color="#0000ff">ftp://ftp.akaedu.org/../1.html</font></u></a> </p>
</div>
<h2><a id="私人备忘" name="私人备忘">私人备忘</a></h2>
<div 
<div class="li" style="width:700px">
<pre class="file">cpan设置<br>Going to read /home/fqh/.cpan/sources/modules/02packages.details.txt.gz<br>Warning: Your /home/fqh/.cpan/sources/modules/02packages.details.txt.gz does not contain a Line-Count header.<br>是选取站点不可用造成的。<br>http://tech.foolpig.com/2008/10/22/cpan-error-modulelist/<br>1.删除掉.cpan<br>2.perl -MCPAN -e shell<br>或1,2步骤换为o conf init命令<br>3.选了africa下的三个站点<br>4.cpan设置完后，reload index即可<br>5.列举模块m<br>6.查询 d /模块/<br>－－－<br><br>__attribute__((context(x,0,1))) means "you need not hold x before, but<br>you will hold one more of x after".<br>__attribute__((context(x,1,0))) means "you must already hold x, and you<br>will no longer hold x after".<br>__attribute__((context(x,1,1))) means "you must already hold x, and you<br>will continue to hold x".<br><br></pre>
</div>
<div class="footnotes">
<div class="fn"><a class="fn_bot" id="fn__1" href="http://wiki.zh-kernel.org/sniper#fnt__1" name="fn__1"><u><font color="#800080">1)</font></u></a> WarStories</div>
</div>
<br></td></tr></tbody></table>
</span>
<table>
<tbody><tr>
<td>
</td>
</tr>
</tbody></table>
</td>
</tr>
<tr><td><div class="lf360 list" style=" text-align:left; font-size:14px;"><div id="lastart"><div class="shangyp">上一篇：<a href="http://www.360doc.com/content/10/1215/15/1378815_78370674.shtml" target="_blank" onclick="wzhit(35);">Linux slab</a></div></div>
<div id="nextart">下一篇：<a href="http://www.360doc.com/content/10/1230/21/1378815_82757146.shtml" target="_blank" onclick="wzhit(36);">LINUX动态链接库高级应用(etc/ld.so.conf)共享动态链接库</a></div></div></td></tr>
<tr><td style="height:29px;">
<div style=" padding-top:20px;"><table style="  width:100%; " cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td width="31%"></td>    
<td>
<table cellpadding="0" cellspacing="0" style=" margin:0px auto; ">
<tbody>
<tr>
<td><div class=" lf360" style="cursor:pointer"><a href="javascript:void(0);" onclick="wzhit(22);SaveArt();"><img src="./Linux内核调试指南_files/tb11.gif"></a></div>    
<div class=" lf360 xianhua" id="sendFlowerToUser" style="cursor:pointer" onclick="Showflowerlayer(&quot;sendedLayer1&quot;);">献花(<span id="articleflowernum">0</span>)<div id="flowernumadd" class="addtionone">+1</div></div>


</td>
</tr></tbody>
</table>
</td> 
</tr>
</tbody>
</table>

</div>
</td></tr>

<tr><td>
<div class="xiantao" style=" padding-top:5px;">

</div>
</td></tr>
<tr><td class="xgiambox" style=" vertical-align:top; height:30px;padding-top:10px;"><div class="rt360">(本文系<span class="name"><a target="_blank" href="http://www.360doc.com/userhome/1378815">danydany_ok...</a></span>首藏<span id="docsource">&nbsp;&nbsp;<a href="http://blog.csdn.net/Hunnad/archive/2008/11/07/3242097.aspx" target="_blank">源文网址</a></span>)</div></td></tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody>
</table>
</div>

</body></html>